{"version":3,"file":"vendors-node_modules_storybook_nextjs_node_modules_babel_runtime_helpers_esm_slicedToArray_js-cca622.iframe.bundle.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACJA;AACA;AACA;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1BA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;ACxCA;;;;;;;;;;ACAA;;;;;;;;;;ACEA;;;;;;;;;;ACCA;;;;;;;;;;ACHA;;;;;;;;;;ACAA;;;;;;;;;;ACAA","sources":["webpack://next-app/../../node_modules/@storybook/nextjs/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack://next-app/../../node_modules/@storybook/nextjs/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack://next-app/../../node_modules/@storybook/nextjs/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack://next-app/../../node_modules/@storybook/nextjs/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack://next-app/../../node_modules/@storybook/nextjs/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack://next-app/../../node_modules/@storybook/nextjs/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack://next-app/../../node_modules/@tamagui/lucide-icons/dist/esm/icons/chevron-left.mjs","webpack://next-app/../src/index.ts","webpack://next-app/../../src/middleware/context.web.tsx","webpack://next-app/../../src/middleware/provider.tsx","webpack://next-app/../../src/params/index.tsx","webpack://next-app/../../src/params/router.web.ts","webpack://next-app/../../src/params/use-route.web.ts","webpack://next-app/../../src/params/use-router.web.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import { jsx } from \"react/jsx-runtime\";\nimport { memo } from \"react\";\nimport {\n  Polyline,\n  Svg\n} from \"react-native-svg\";\nimport { themed } from \"../themed\";\nconst Icon = (props) => {\n  const { color = \"black\", size = 24, ...otherProps } = props;\n  return /* @__PURE__ */ jsx(\n    Svg,\n    {\n      width: size,\n      height: size,\n      viewBox: \"0 0 24 24\",\n      fill: \"none\",\n      stroke: `${color}`,\n      strokeWidth: \"2\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\",\n      ...otherProps,\n      children: /* @__PURE__ */ jsx(\n        Polyline,\n        {\n          points: \"15 18 9 12 15 6\",\n          fill: \"none\",\n          stroke: `${color}`,\n          strokeWidth: \"2\",\n          strokeLinecap: \"round\",\n          strokeLinejoin: \"round\"\n        }\n      )\n    }\n  );\n};\nIcon.displayName = \"ChevronLeft\";\nconst ChevronLeft = memo(themed(Icon));\nexport {\n  ChevronLeft\n};\n//# sourceMappingURL=chevron-left.mjs.map\n","export * from './types/solito-page'\nexport * from './middleware/provider'\nexport * from './params'\n","import { createContext } from 'react'\n\nimport { MiddlewareContextType } from './types'\n\nfunction error() {\n  throw new Error(\n    '[solito] useLinkTo should not be called on Web. Is next/router defined?'\n  )\n}\n\nexport const MiddlewareContext = createContext<MiddlewareContextType>({\n  useLinkTo() {\n    return error\n  },\n})\n","import React from 'react'\n\nimport { MiddlewareContext } from './context'\nimport { MiddlewareContextType } from './types'\n\ntype Props = {\n  middleware: MiddlewareContextType\n}\n\nexport function SolitoProvider({\n  children,\n  middleware,\n}: { children: React.ReactNode } & Props) {\n  return (\n    <MiddlewareContext.Provider value={middleware}>\n      {children}\n    </MiddlewareContext.Provider>\n  )\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\n// From https://gist.github.com/nandorojo/052887f99bb61b54845474f324aa41cc\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { Platform } from 'react-native'\n\nimport { useNavigation } from '../router/use-navigation'\nimport Router from './router'\nimport { useRoute } from './use-route'\nimport { useRouter } from './use-router'\n\nfunction useStable<T>(value: T) {\n  const ref = useRef(value)\n  useEffect(() => {\n    ref.current = value\n  }, [value])\n\n  return ref\n}\n\nfunction useStableCallback<T extends (...args: any[]) => any>(\n  callback: T | undefined\n): T {\n  const callbackRef = useRef(callback)\n\n  useEffect(() => {\n    callbackRef.current = callback\n  })\n\n  // https://github.com/facebook/react/issues/19240\n  return useMemo(() => ((...args) => callbackRef.current?.(...args)) as T, [])\n}\n\ntype Config<\n  Props extends Record<string, unknown>,\n  Required extends boolean,\n  ParsedType,\n  InitialValue\n> = (Required extends false\n  ? {\n      parse?: (value?: string | string[]) => ParsedType\n    }\n  : {\n      parse: (value?: string | string[]) => ParsedType\n    }) & {\n  stringify?: (value: ParsedType) => string\n  initial: InitialValue\n  paramsToClearOnSetState?: (keyof Props)[]\n}\n\ntype Params<\n  Props extends Record<string, unknown> = Record<string, string>,\n  Name extends keyof Props = keyof Props,\n  NullableUnparsedParsedType extends Props[Name] | undefined =\n    | Props[Name]\n    | undefined,\n  ParseFunction extends\n    | undefined\n    | ((\n        value?: string | string[]\n      ) => NonNullable<NullableUnparsedParsedType>) = (\n    value?: string | string[]\n  ) => NonNullable<NullableUnparsedParsedType>,\n  InitialValue = NullableUnparsedParsedType | undefined,\n  ParsedType = InitialValue extends undefined\n    ? NullableUnparsedParsedType\n    : ParseFunction extends undefined\n    ? NullableUnparsedParsedType\n    : NonNullable<NullableUnparsedParsedType>\n> = NonNullable<ParsedType> extends string\n  ?\n      | [name: Name, config: Config<Props, false, ParsedType, InitialValue>]\n      | [name: Name]\n  : [name: Name, config: Config<Props, true, ParsedType, InitialValue>]\n\ntype Returns<\n  Props extends Record<string, unknown> = Record<string, string>,\n  Name extends keyof Props = keyof Props,\n  NullableUnparsedParsedType extends Props[Name] | undefined =\n    | Props[Name]\n    | undefined,\n  ParseFunction extends\n    | undefined\n    | ((\n        value?: string | string[]\n      ) => NonNullable<NullableUnparsedParsedType>) = (\n    value?: string | string[]\n  ) => NonNullable<NullableUnparsedParsedType>,\n  InitialValue = NullableUnparsedParsedType | undefined,\n  ParsedType = InitialValue extends undefined\n    ? NullableUnparsedParsedType\n    : ParseFunction extends undefined\n    ? NullableUnparsedParsedType\n    : NonNullable<NullableUnparsedParsedType>\n> = readonly [\n  state: ParsedType | InitialValue,\n  setState: (value: ParsedType, options?: SetStateOptions) => void\n]\n\ntype SetStateOptions = {\n  /**\n   * Override whether this function calls `Router.push` or `Router.replace`.\n   *\n   * By default, `Router.push` is called if the query parameter already exists in the URL.\n   */\n  webBehavior?: 'push' | 'replace'\n}\n\nexport function createParam<\n  Props extends Record<string, unknown> = Record<string, string>\n>() {\n  function useParam<\n    Name extends keyof Props,\n    NullableUnparsedParsedType extends Props[Name] | undefined =\n      | Props[Name]\n      | undefined,\n    ParseFunction extends\n      | undefined\n      | ((\n          value?: string | string[]\n        ) => NonNullable<NullableUnparsedParsedType>) = (\n      value?: string | string[]\n    ) => NonNullable<NullableUnparsedParsedType>,\n    InitialValue = NullableUnparsedParsedType | undefined,\n    ParsedType = InitialValue extends undefined\n      ? NullableUnparsedParsedType\n      : ParseFunction extends undefined\n      ? NullableUnparsedParsedType\n      : NonNullable<NullableUnparsedParsedType>\n  >(\n    ...[name, maybeConfig]: Params<\n      Props,\n      Name,\n      NullableUnparsedParsedType,\n      ParseFunction,\n      InitialValue,\n      ParsedType\n    >\n  ): Returns<\n    Props,\n    Name,\n    NullableUnparsedParsedType,\n    ParseFunction,\n    InitialValue,\n    ParsedType\n  > {\n    const {\n      parse = (value?: string | string[]) => value,\n      initial,\n      stringify = (value: ParsedType) => `${value}`,\n      paramsToClearOnSetState,\n    } = maybeConfig || {}\n    const nextRouter = useRouter()\n    const nativeRoute = useRoute()\n    const nativeNavigation = useNavigation()\n    const nativeStateFromParams = (nativeRoute?.params as any)?.[\n      name\n    ] as ParsedType\n\n    const [nativeStateFromReact, setNativeStateFromReact] = useState<\n      ParsedType | InitialValue\n    >(() => nativeStateFromParams ?? (initial as InitialValue))\n\n    const setNativeStateFromParams = useCallback((value: ParsedType) => {\n      nativeNavigation?.setParams({\n        [name]: value,\n      })\n    }, [])\n\n    const nativeState = nativeRoute\n      ? nativeStateFromParams\n      : nativeStateFromReact\n    const setNativeState = nativeRoute\n      ? setNativeStateFromParams\n      : setNativeStateFromReact\n\n    const stableStringify = useStableCallback(stringify)\n    const stableParse = useStableCallback(parse)\n    const stableParamsToClear = useStable(paramsToClearOnSetState)\n\n    const initialValue = useRef(initial)\n    const hasSetState = useRef(false)\n\n    const setState = useCallback(\n      (value: ParsedType, options?: SetStateOptions) => {\n        hasSetState.current = true\n        const { pathname, query } = Router\n        const newQuery = { ...query }\n        if (value != null && (value as any) !== '') {\n          newQuery[name as string] = stableStringify(value)\n        } else {\n          delete newQuery[name as string]\n        }\n\n        if (stableParamsToClear.current) {\n          for (const paramKey of stableParamsToClear.current) {\n            delete newQuery[paramKey as string]\n          }\n        }\n\n        const willChangeExistingParam =\n          query[name as string] && newQuery[name as string]\n\n        let action = willChangeExistingParam ? Router.replace : Router.push\n\n        if (options?.webBehavior) {\n          action = Router[options.webBehavior]\n        }\n\n        action(\n          {\n            pathname,\n            query: newQuery,\n          },\n          undefined,\n          {\n            shallow: true,\n          }\n        )\n      },\n      [name, stableStringify, stableParamsToClear]\n    )\n\n    const webParam = nextRouter?.query?.[name as string]\n\n    const state = useMemo<ParsedType>(() => {\n      let state: ParsedType\n      if (webParam === undefined && !hasSetState.current) {\n        state = initialValue.current as any\n      } else {\n        state = stableParse(webParam) as ParsedType\n      }\n      return state\n    }, [stableParse, webParam])\n\n    if (Platform.OS !== 'web') {\n      if (!nativeRoute) {\n        console.error(\n          `[solito] useParam('${\n            name as string\n          }') called when there is no React Navigation route available. In a future version, this will throw an error. Please fix this by only calling useParam() inside of a React Navigation route. For now, Solito will fallback to using React state.`\n        )\n      }\n      return [nativeState, setNativeState]\n    }\n\n    return [state, setState]\n  }\n\n  type UpdateOptions = {\n    web?: {\n      replace?: boolean\n    }\n  }\n\n  function useUpdateParams(): (\n    props: Partial<Props>,\n    options?: UpdateOptions\n  ) => void {\n    const nativeNavigation = useNavigation()\n\n    const setNativeStateFromParams = useCallback((value: Partial<Props>) => {\n      nativeNavigation?.setParams(value)\n    }, [])\n\n    const setWebState = useCallback(\n      (value: Partial<Props>, options?: UpdateOptions) => {\n        const { pathname, query } = Router\n        const newQuery = { ...query, ...value }\n        for (const key in value) {\n          if (value[key] == null || value[key] === '') {\n            delete newQuery[key]\n          }\n        }\n\n        const action = options?.web?.replace ? Router.replace : Router.push\n\n        action(\n          {\n            pathname,\n            query: newQuery,\n          },\n          undefined,\n          {\n            shallow: true,\n          }\n        )\n      },\n      []\n    )\n\n    return Platform.select({\n      web: setWebState,\n      default: setNativeStateFromParams,\n    })\n  }\n\n  function useParams(): {\n    params: Props\n    setParams: (value: Partial<Props>, options?: SetStateOptions) => void\n  } {\n    if (Platform.OS !== 'web') {\n      const nativeRoute = useRoute()\n      const nativeNavigation = useNavigation()\n\n      return {\n        params: nativeRoute?.params as Props,\n        setParams: useCallback(\n          (params) => nativeNavigation?.setParams(params),\n          [nativeNavigation]\n        ),\n      }\n    }\n    const nextRouter = useRouter()\n\n    return {\n      params: nextRouter?.query as Props,\n      setParams: useCallback((params, options) => {\n        const { pathname, query } = Router\n        const newQuery = { ...query, ...params }\n        for (const key in params) {\n          if (params[key] == null || params[key] === '') {\n            delete newQuery[key]\n          }\n        }\n\n        const action = Router[options?.webBehavior ?? 'push']\n\n        action(\n          {\n            pathname,\n            query: newQuery,\n          },\n          undefined,\n          {\n            shallow: true,\n          }\n        )\n      }, []),\n    }\n  }\n\n  return {\n    useParam,\n    useUpdateParams,\n    useParams,\n  }\n}\n","export { default } from 'next/router'\n","export const useRoute = () => undefined\n","import { useRouter as _useRouter } from 'next/router';\n\nexport const useRouter = () => _useRouter();"],"names":[],"sourceRoot":""}