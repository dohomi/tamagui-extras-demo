{"version":3,"file":"vendors-node_modules_tamagui_lucide-icons_dist_esm_themed_mjs-node_modules_react-native-svg_l-609481.iframe.bundle.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC3BA;AACA;AACA;AACA;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5lCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1pBA;AACA;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtCA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;;;;;;;;;;;;;;;;;;;;AClEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AASA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC5SA;AACA;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;;;;;;;;;;;;;;;;;;;;;;ACpHA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;;;;;;;;;;;;;;;;;;;;;;ACtPA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;;;;;;;;;;;;;;;;;;;;;AClHA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;;;;;;;;;;;;;;;;;;;;;;ACpSA;AACA;;;;;;;;;;;;;;;;;;ACDA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxmBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AAIA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;AC5NA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;;;;;;;;;;;;;;;;;AC/CA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;;;;;;;;;;;;;;;;;;;;;ACtDA;AACA;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;;;;;;;;;;;;;;;;;;;;;AC1OA;AACA;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLA;AAGA;AACA;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;AChDA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;;;;;;;;;;;;;;;;;AC1IA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChMA;AACA;;;;;;;;;;;;;;;;;;;;;ACDA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzWA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AAMA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACzSA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;;;;;;;;;;;;;;;;;;;;;AC3JA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;ACzWA;AACA;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;ACXA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;AClBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC/cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;AAgBA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;AChCA;AACA;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;;;;;;;;;;;;;;;;;;;;;ACroBA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;AChFA;AACA;AACA;AAKA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrEA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjGA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;;;;;;;;;;;;;;;;;;;;;ACrQA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;AC3UA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACLA;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;ACrEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;ACzDA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;ACxTA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AAWA;AACA;AACA;AACA;AAQA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;ACdA;AACA;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;;;;;;;;;;;;;;;;;AC5DA;AACA;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;;;;;;;;;;;;;;;ACjBA;AAGA;AACA;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;ACxBA;AACA;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9JA;;;;;;;;;;ACAA;;;;;;;;;;ACCA;;;;;;;;;;ACDA;;;;;;;;;;ACCA;;;;;;;;;;ACDA;;;;;;;;;;ACIA;;;;;;;;;;ACJA;;;;;;;;;;ACAA;;;;;;;;;;ACCA;;;;;;;;;;ACDA;;;;;;;;;;ACAA;;;;;;;;;;ACEA;;;;;;;;;;ACFA;;;;;;;;;;ACEA;;;;;;;;;;ACFA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACCA;;;;;;;;;;ACDA;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5NA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5pDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC1IA;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/FA;AACA;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAcA;;;;;;;;;;;;;;;;;;;ACpQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC1cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AAuDA;AACA;;;;;;;;;;;;;;;;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;ACvBA;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AClDA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpKA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://next-app/../../node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack://next-app/../../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack://next-app/../../node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack://next-app/../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js","webpack://next-app/../../node_modules/@babel/runtime/helpers/slicedToArray.js","webpack://next-app/../../node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs","webpack://next-app/../../node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js","webpack://next-app/../../node_modules/@radix-ui/react-use-previous/dist/index.module.js","webpack://next-app/../../node_modules/@swc/helpers/lib/_async_to_generator.js","webpack://next-app/../../node_modules/@tamagui/adapt/dist/esm/Adapt.mjs","webpack://next-app/../../node_modules/@tamagui/adapt/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/alert-dialog/dist/esm/AlertDialog.mjs","webpack://next-app/../../node_modules/@tamagui/alert-dialog/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/animate-presence/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/avatar/dist/esm/Avatar.mjs","webpack://next-app/../../node_modules/@tamagui/avatar/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/button/dist/esm/Button.mjs","webpack://next-app/../../node_modules/@tamagui/button/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/card/dist/esm/Card.mjs","webpack://next-app/../../node_modules/@tamagui/card/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/checkbox/dist/esm/Checkbox.mjs","webpack://next-app/../../node_modules/@tamagui/checkbox/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/create-context/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/dialog/dist/esm/Dialog.mjs","webpack://next-app/../../node_modules/@tamagui/dialog/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/floating/dist/esm/Floating.mjs","webpack://next-app/../../node_modules/@tamagui/floating/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/floating/dist/esm/useFloating.mjs","webpack://next-app/../../node_modules/@tamagui/focus-scope/dist/esm/FocusScope.mjs","webpack://next-app/../../node_modules/@tamagui/focus-scope/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/focusable/dist/esm/focusableInputHOC.mjs","webpack://next-app/../../node_modules/@tamagui/focusable/dist/esm/registerFocusable.mjs","webpack://next-app/../../node_modules/@tamagui/font-size/dist/esm/getFontSize.mjs","webpack://next-app/../../node_modules/@tamagui/font-size/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/form/dist/esm/Form.mjs","webpack://next-app/../../node_modules/@tamagui/form/dist/esm/index.js","webpack://next-app/../../node_modules/@tamagui/get-button-sized/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/get-size/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/group/dist/esm/Group.mjs","webpack://next-app/../../node_modules/@tamagui/group/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/helpers-tamagui/dist/esm/getSpace.mjs","webpack://next-app/../../node_modules/@tamagui/helpers-tamagui/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/helpers-tamagui/dist/esm/prevent.mjs","webpack://next-app/../../node_modules/@tamagui/helpers-tamagui/dist/esm/useCurrentColor.mjs","webpack://next-app/../../node_modules/@tamagui/helpers-tamagui/dist/esm/useGetThemedIcon.mjs","webpack://next-app/../../node_modules/@tamagui/image/dist/esm/Image.mjs","webpack://next-app/../../node_modules/@tamagui/image/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/label/dist/esm/Label.mjs","webpack://next-app/../../node_modules/@tamagui/label/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/list-item/dist/esm/ListItem.mjs","webpack://next-app/../../node_modules/@tamagui/list-item/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/lucide-icons/dist/esm/themed.mjs","webpack://next-app/../../node_modules/@tamagui/popover/dist/esm/Popover.mjs","webpack://next-app/../../node_modules/@tamagui/popover/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/popover/dist/esm/useFloatingContext.mjs","webpack://next-app/../../node_modules/@tamagui/popper/dist/esm/Popper.mjs","webpack://next-app/../../node_modules/@tamagui/popper/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/progress/dist/esm/Progress.mjs","webpack://next-app/../../node_modules/@tamagui/progress/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/radio-group/dist/esm/RadioGroup.mjs","webpack://next-app/../../node_modules/@tamagui/radio-group/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/remove-scroll/dist/esm/RemoveScroll.mjs","webpack://next-app/../../node_modules/@tamagui/remove-scroll/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/roving-focus/dist/esm/RovingFocusGroup.mjs","webpack://next-app/../../node_modules/@tamagui/scroll-view/dist/esm/ScrollView.mjs","webpack://next-app/../../node_modules/@tamagui/scroll-view/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/select/dist/esm/Select.mjs","webpack://next-app/../../node_modules/@tamagui/select/dist/esm/SelectContent.mjs","webpack://next-app/../../node_modules/@tamagui/select/dist/esm/SelectImpl.mjs","webpack://next-app/../../node_modules/@tamagui/select/dist/esm/SelectScrollButton.mjs","webpack://next-app/../../node_modules/@tamagui/select/dist/esm/SelectViewport.mjs","webpack://next-app/../../node_modules/@tamagui/select/dist/esm/constants.mjs","webpack://next-app/../../node_modules/@tamagui/select/dist/esm/context.mjs","webpack://next-app/../../node_modules/@tamagui/select/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/select/dist/esm/useSelectBreakpointActive.mjs","webpack://next-app/../../node_modules/@tamagui/separator/dist/esm/Separator.mjs","webpack://next-app/../../node_modules/@tamagui/separator/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/shapes/dist/esm/Circle.mjs","webpack://next-app/../../node_modules/@tamagui/shapes/dist/esm/Square.mjs","webpack://next-app/../../node_modules/@tamagui/shapes/dist/esm/getShapeSize.mjs","webpack://next-app/../../node_modules/@tamagui/shapes/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/sheet/dist/esm/Sheet.mjs","webpack://next-app/../../node_modules/@tamagui/sheet/dist/esm/SheetContext.mjs","webpack://next-app/../../node_modules/@tamagui/sheet/dist/esm/SheetScrollView.mjs","webpack://next-app/../../node_modules/@tamagui/sheet/dist/esm/constants.mjs","webpack://next-app/../../node_modules/@tamagui/sheet/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/slider/dist/esm/Slider.mjs","webpack://next-app/../../node_modules/@tamagui/slider/dist/esm/SliderImpl.mjs","webpack://next-app/../../node_modules/@tamagui/slider/dist/esm/constants.mjs","webpack://next-app/../../node_modules/@tamagui/slider/dist/esm/helpers.mjs","webpack://next-app/../../node_modules/@tamagui/slider/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/stacks/dist/esm/SizableStack.js","webpack://next-app/../../node_modules/@tamagui/stacks/dist/esm/Stacks.mjs","webpack://next-app/../../node_modules/@tamagui/stacks/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/stacks/dist/esm/variants.mjs","webpack://next-app/../../node_modules/@tamagui/switch/dist/esm/Switch.mjs","webpack://next-app/../../node_modules/@tamagui/switch/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/tabs/dist/esm/Tabs.mjs","webpack://next-app/../../node_modules/@tamagui/tabs/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/text/dist/esm/Headings.mjs","webpack://next-app/../../node_modules/@tamagui/text/dist/esm/Paragraph.mjs","webpack://next-app/../../node_modules/@tamagui/text/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/text/dist/esm/types.mjs","webpack://next-app/../../node_modules/@tamagui/text/dist/esm/wrapChildrenInText.mjs","webpack://next-app/../../node_modules/@tamagui/theme/dist/esm/addTheme.js","webpack://next-app/../../node_modules/@tamagui/theme/dist/esm/addTheme.mjs","webpack://next-app/../../node_modules/@tamagui/theme/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/theme/dist/esm/updateTheme.mjs","webpack://next-app/../../node_modules/@tamagui/toggle-group/dist/esm/Toggle.mjs","webpack://next-app/../../node_modules/@tamagui/toggle-group/dist/esm/ToggleGroup.mjs","webpack://next-app/../../node_modules/@tamagui/toggle-group/dist/esm/index.js","webpack://next-app/../../node_modules/@tamagui/tooltip/dist/esm/Tooltip.mjs","webpack://next-app/../../node_modules/@tamagui/tooltip/dist/esm/TooltipSimple.mjs","webpack://next-app/../../node_modules/@tamagui/tooltip/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/use-constant/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/use-controllable-state/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/use-debounce/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/use-direction/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/use-direction/dist/esm/useDirection.mjs","webpack://next-app/../../node_modules/@tamagui/use-keyboard-visible/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/use-keyboard-visible/dist/esm/useKeyboardVisible.mjs","webpack://next-app/../../node_modules/@tamagui/use-window-dimensions/dist/esm/index.mjs","webpack://next-app/../../node_modules/@tamagui/visually-hidden/dist/esm/index.mjs","webpack://next-app/../../node_modules/aria-hidden/dist/es2015/index.js","webpack://next-app/../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js","webpack://next-app/../../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js","webpack://next-app/ReactNativeSVG.web.ts","webpack://next-app/index.ts","webpack://next-app/SvgTouchableMixin.ts","webpack://next-app/resolve.ts","webpack://next-app/../../src/link/core.tsx","webpack://next-app/../../src/link/index.tsx","webpack://next-app/../../src/link/link.tsx","webpack://next-app/../../src/link/linking.web.ts","webpack://next-app/../../src/link/next-link.web.tsx","webpack://next-app/../../src/link/text-link.tsx","webpack://next-app/../../src/link/use-custom-link.tsx","webpack://next-app/../../src/router/index.ts","webpack://next-app/../../src/router/parse-next-path.ts","webpack://next-app/../../src/router/replace-helpers.web.ts","webpack://next-app/../../src/router/use-link-to.web.ts","webpack://next-app/../../src/router/use-navigation.web.ts","webpack://next-app/../../src/router/use-next-router.web.ts","webpack://next-app/../../src/router/use-router.ts","webpack://next-app/../../node_modules/solito/link/index.js","webpack://next-app/../../node_modules/get-nonce/dist/es2015/index.js","webpack://next-app/../../node_modules/next/dist/client/add-base-path.js","webpack://next-app/../../node_modules/next/dist/client/add-locale.js","webpack://next-app/../../node_modules/next/dist/client/detect-domain-locale.js","webpack://next-app/../../node_modules/next/dist/client/get-domain-locale.js","webpack://next-app/../../node_modules/next/dist/client/has-base-path.js","webpack://next-app/../../node_modules/next/dist/client/link.js","webpack://next-app/../../node_modules/next/dist/client/normalize-locale-path.js","webpack://next-app/../../node_modules/next/dist/client/remove-base-path.js","webpack://next-app/../../node_modules/next/dist/client/remove-locale.js","webpack://next-app/../../node_modules/next/dist/client/route-loader.js","webpack://next-app/../../node_modules/next/dist/client/router.js","webpack://next-app/../../node_modules/next/dist/client/script.js","webpack://next-app/../../node_modules/next/dist/client/trusted-types.js","webpack://next-app/../../node_modules/next/dist/client/with-router.js","webpack://next-app/../../node_modules/next/dist/compiled/path-to-regexp/index.js","webpack://next-app/../../node_modules/next/dist/compiled/react-is/cjs/react-is.development.js","webpack://next-app/../../node_modules/next/dist/compiled/react-is/index.js","webpack://next-app/../../node_modules/next/dist/lib/is-api-route.js","webpack://next-app/../../node_modules/next/dist/lib/is-error.js","webpack://next-app/../../node_modules/next/dist/shared/lib/bloom-filter/base-filter.js","webpack://next-app/../../node_modules/next/dist/shared/lib/bloom-filter/base64-arraybuffer.js","webpack://next-app/../../node_modules/next/dist/shared/lib/bloom-filter/bit-set.js","webpack://next-app/../../node_modules/next/dist/shared/lib/bloom-filter/formulas.js","webpack://next-app/../../node_modules/next/dist/shared/lib/bloom-filter/hashing.js","webpack://next-app/../../node_modules/next/dist/shared/lib/bloom-filter/index.js","webpack://next-app/../../node_modules/next/dist/shared/lib/bloom-filter/utils.js","webpack://next-app/../../node_modules/next/dist/shared/lib/escape-regexp.js","webpack://next-app/../../node_modules/next/dist/shared/lib/fnv1a.js","webpack://next-app/../../node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js","webpack://next-app/../../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js","webpack://next-app/../../node_modules/next/dist/shared/lib/is-plain-object.js","webpack://next-app/../../node_modules/next/dist/shared/lib/mitt.js","webpack://next-app/../../node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js","webpack://next-app/../../node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/router.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/add-locale.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/compare-states.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/format-url.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/index.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/is-bot.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/is-local-url.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/omit.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/parse-url.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/path-match.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/prepare-destination.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/querystring.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/resolve-href.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/route-matcher.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/route-regex.js","webpack://next-app/../../node_modules/next/dist/shared/lib/router/utils/sorted-routes.js","webpack://next-app/../../node_modules/next/dist/shared/lib/utils.js","webpack://next-app/../../node_modules/next/link.js","webpack://next-app/../../node_modules/next/router.js","webpack://next-app/../../node_modules/performant-array-to-tree/build/arrayToTree.min.js","webpack://next-app/../../node_modules/react-remove-scroll-bar/dist/es2015/component.js","webpack://next-app/../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js","webpack://next-app/../../node_modules/react-remove-scroll-bar/dist/es2015/index.js","webpack://next-app/../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js","webpack://next-app/../../node_modules/react-remove-scroll/dist/es2015/Combination.js","webpack://next-app/../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js","webpack://next-app/../../node_modules/react-remove-scroll/dist/es2015/UI.js","webpack://next-app/../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js","webpack://next-app/../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js","webpack://next-app/../../node_modules/react-remove-scroll/dist/es2015/medium.js","webpack://next-app/../../node_modules/react-remove-scroll/dist/es2015/sidecar.js","webpack://next-app/../../node_modules/react-style-singleton/dist/es2015/component.js","webpack://next-app/../../node_modules/react-style-singleton/dist/es2015/hook.js","webpack://next-app/../../node_modules/react-style-singleton/dist/es2015/index.js","webpack://next-app/../../node_modules/react-style-singleton/dist/es2015/singleton.js","webpack://next-app/../../node_modules/reforest/dist/esm/index.js","webpack://next-app/../../node_modules/tabbable/dist/index.esm.js","webpack://next-app/../../node_modules/tamagui/dist/esm/helpers/inputHelpers.mjs","webpack://next-app/../../node_modules/tamagui/dist/esm/index.mjs","webpack://next-app/../../node_modules/tamagui/dist/esm/setup.mjs","webpack://next-app/../../node_modules/tamagui/dist/esm/viewTypes.mjs","webpack://next-app/../../node_modules/tamagui/dist/esm/views/Anchor.mjs","webpack://next-app/../../node_modules/tamagui/dist/esm/views/EnsureFlexed.mjs","webpack://next-app/../../node_modules/tamagui/dist/esm/views/Fieldset.mjs","webpack://next-app/../../node_modules/tamagui/dist/esm/views/Grid.mjs","webpack://next-app/../../node_modules/tamagui/dist/esm/views/Input.mjs","webpack://next-app/../../node_modules/tamagui/dist/esm/views/Layouts.mjs","webpack://next-app/../../node_modules/tamagui/dist/esm/views/Spinner.mjs","webpack://next-app/../../node_modules/tamagui/dist/esm/views/TextArea.mjs","webpack://next-app/../../node_modules/tslib/tslib.es6.js","webpack://next-app/../../node_modules/use-callback-ref/dist/es2015/assignRef.js","webpack://next-app/../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js","webpack://next-app/../../node_modules/use-callback-ref/dist/es2015/useRef.js","webpack://next-app/../../node_modules/use-sidecar/dist/es2015/exports.js","webpack://next-app/../../node_modules/use-sidecar/dist/es2015/medium.js","webpack://next-app/../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js","webpack://next-app/../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js","webpack://next-app/../../node_modules/use-sync-external-store/shim/index.js","webpack://next-app/../../node_modules/use-sync-external-store/shim/with-selector.js","webpack://next-app/../../node_modules/zustand/esm/index.mjs","webpack://next-app/../../node_modules/zustand/esm/vanilla.mjs"],"sourcesContent":["function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose.js\");\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayWithHoles = require(\"./arrayWithHoles.js\");\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit.js\");\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\nvar nonIterableRest = require(\"./nonIterableRest.js\");\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n    if (validMiddleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement` middleware', 'detected. This will lead to an infinite loop. Ensure only one of', 'either has been passed to the `middleware` array.'].join(' '));\n    }\n    if (!reference || !floating) {\n      console.error(['Floating UI: The reference and/or floating element was not defined', 'when `computePosition()` was called. Ensure that both elements have', 'been created and can be measured.'].join(' '));\n    }\n  }\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    {\n      if (resetCount > 50) {\n        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));\n      }\n    }\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = options || {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = state;\n    if (element == null) {\n      {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n      return {};\n    }\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n});\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[main], overflow[cross]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = options;\n      const {\n        rects\n      } = state;\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || [];\n      const paddingObject = getSideObjectFromPadding(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nasync function convertValueToCoords(state, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(state) : value;\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n  return {\n    name: 'offset',\n    options: value,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset(state) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const axis = getMainAxisFromPlacement(placement);\n      const isXAxis = axis === 'x';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isXAxis) {\n        availableWidth = min(\n        // Maximum clipping viewport width\n        width - overflow.right - overflow.left, overflowAvailableWidth);\n      } else {\n        availableHeight = min(\n        // Maximum clipping viewport height\n        height - overflow.bottom - overflow.top, overflowAvailableHeight);\n      }\n      if (!state.middlewareData.shift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isXAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  let width = parseFloat(css.width);\n  let height = parseFloat(css.height);\n  const offsetWidth = element.offsetWidth;\n  const offsetHeight = element.offsetHeight;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    fallback: shouldFallback\n  };\n}\n\nfunction getNodeName(node) {\n  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';\n}\n\nlet uaString;\nfunction getUAString() {\n  if (uaString) {\n    return uaString;\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    uaString = uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n    return uaString;\n  }\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try to use feature detection here instead.\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element);\n  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;\n\n  // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => {\n    // Add type check for old browsers.\n    const contain = css.contain;\n    return contain != null ? contain.includes(value) : false;\n  });\n}\n\n/**\n * Determines whether or not `.getBoundingClientRect()` is affected by visual\n * viewport offsets. In Safari, the `x`/`y` offsets are values relative to the\n * visual viewport, while in other engines, they are values relative to the\n * layout viewport.\n */\nfunction isClientRectVisualViewportBased() {\n  // TODO: Try to use feature detection here instead. Feature detection for\n  // this can fail in various ways, making the userAgent check the most\n  // reliable:\n  // • Always-visible scrollbar or not\n  // • Width of <html>\n\n  // Is Safari.\n  return /^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nconst FALLBACK_SCALE = {\n  x: 1,\n  y: 1\n};\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return FALLBACK_SCALE;\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    fallback\n  } = getCssDimensions(domElement);\n  let x = (fallback ? round(rect.width) : rect.width) / width;\n  let y = (fallback ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  var _win$visualViewport, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = FALLBACK_SCALE;\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const win = domElement ? getWindow(domElement) : window;\n  const addVisualOffsets = isClientRectVisualViewportBased() && isFixedStrategy;\n  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;\n  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += iframeRect.x;\n      y += iframeRect.y;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = {\n    x: 1,\n    y: 1\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // `getParentNode` will never return a `Document` due to the fallback\n    // check, so it's either the <html> or <body> element.\n    return parentNode.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isClientRectVisualViewportBased();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : {\n    x: 1,\n    y: 1\n  };\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const mutableRect = {\n      ...clippingAncestor\n    };\n    if (isClientRectVisualViewportBased()) {\n      var _win$visualViewport, _win$visualViewport2;\n      const win = getWindow(element);\n      mutableRect.x -= ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0;\n      mutableRect.y -= ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0;\n    }\n    rect = mutableRect;\n  }\n  return rectToClientRect(rect);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const containingBlock = isContainingBlock(currentNode);\n    const shouldIgnoreCurrentNode = computedStyle.position === 'fixed';\n    if (shouldIgnoreCurrentNode) {\n      currentContainingBlockComputedStyle = null;\n    } else {\n      const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);\n      if (shouldDropCurrentNode) {\n        // Drop non-containing blocks.\n        result = result.filter(ancestor => ancestor !== currentNode);\n      } else {\n        // Record last containing block for next iteration.\n        currentContainingBlockComputedStyle = computedStyle;\n      }\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return getCssDimensions(element);\n  }\n  return element.getBoundingClientRect();\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getScale,\n  async getElementRects(_ref) {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await getDimensionsFn(floating))\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    if (!isElement(reference) && reference.contextElement && !animationFrame) {\n      observer.observe(reference.contextElement);\n    }\n    observer.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _observer;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, getOverflowAncestors, platform };\n","import*as e from\"react\";export function usePrevious(r){const u=e.useRef({value:r,previous:r});return e.useMemo((()=>(u.current.value!==r&&(u.current.previous=u.current.value,u.current.value=r),u.current.previous)),[r])}\n//# sourceMappingURL=index.module.js.map\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return _asyncToGenerator;\n    }\n});\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\n","import { jsx } from \"react/jsx-runtime\";\nimport {\n  isTouchable,\n  isWeb,\n  useIsomorphicLayoutEffect,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { createContext, createElement, useContext, useMemo, useState } from \"react\";\nconst AdaptParentContext = createContext(null);\nconst AdaptContents = (props) => {\n  const context = useContext(AdaptParentContext);\n  if (!(context == null ? void 0 : context.Contents)) {\n    throw new Error(\"Adapt not supported by this component\");\n  }\n  return createElement(context.Contents, props);\n};\nAdaptContents[\"shouldForwardSpace\"] = true;\nconst useAdaptParent = ({\n  Contents\n}) => {\n  const [when, setWhen] = useState(null);\n  const AdaptProvider = useMemo(() => {\n    const context = {\n      Contents,\n      setWhen\n    };\n    function AdaptProviderView(props) {\n      return /* @__PURE__ */ jsx(AdaptParentContext.Provider, { value: context, children: props.children });\n    }\n    return AdaptProviderView;\n  }, [Contents]);\n  return {\n    AdaptProvider,\n    when\n  };\n};\nconst Adapt = withStaticProperties(\n  function Adapt2({ platform, when, children }) {\n    const context = useContext(AdaptParentContext);\n    let enabled = !platform;\n    if (platform === \"touch\")\n      enabled = isTouchable;\n    if (platform === \"native\")\n      enabled = !isWeb;\n    if (platform === \"web\")\n      enabled = isWeb;\n    useIsomorphicLayoutEffect(() => {\n      if (!enabled)\n        return;\n      context == null ? void 0 : context.setWhen(when || enabled);\n    }, [when, context, enabled]);\n    if (!enabled) {\n      return null;\n    }\n    return children;\n  },\n  {\n    Contents: AdaptContents\n  }\n);\nexport {\n  Adapt,\n  AdaptContents,\n  AdaptParentContext,\n  useAdaptParent\n};\n//# sourceMappingURL=Adapt.mjs.map\n","export * from \"./Adapt\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx, jsxs } from \"react/jsx-runtime\";\nimport { useComposedRefs } from \"@tamagui/compose-refs\";\nimport {\n  Slottable,\n  composeEventHandlers,\n  isTamaguiElement,\n  isWeb,\n  styled,\n  useIsomorphicLayoutEffect,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogOverlay,\n  DialogOverlayFrame,\n  DialogPortal,\n  DialogTitle,\n  DialogTrigger,\n  DialogWarningProvider,\n  createDialogScope\n} from \"@tamagui/dialog\";\nimport { YStack } from \"@tamagui/stacks\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport * as React from \"react\";\nimport { Alert } from \"react-native\";\nconst ROOT_NAME = \"AlertDialog\";\nconst [createAlertDialogContext, createAlertDialogScope] = createContextScope(ROOT_NAME, [\n  createDialogScope\n]);\nconst useDialogScope = createDialogScope();\nconst TRIGGER_NAME = \"AlertDialogTrigger\";\nconst NativeAlertDialogTriggerFrame = styled(YStack, {\n  name: \"DialogTrigger\"\n});\nconst AlertDialogTrigger = React.forwardRef(\n  (props, forwardedRef) => {\n    if (props[\"__native\"]) {\n      const { __native, onPress, __onPress, ...rest } = props;\n      return /* @__PURE__ */ jsx(\n        NativeAlertDialogTriggerFrame,\n        {\n          ...rest,\n          onPress: composeEventHandlers(onPress, __onPress)\n        }\n      );\n    }\n    const { __scopeAlertDialog, ...triggerProps } = props;\n    const dialogScope = useDialogScope(__scopeAlertDialog);\n    return /* @__PURE__ */ jsx(DialogTrigger, { ...dialogScope, ...triggerProps, ref: forwardedRef });\n  }\n);\nAlertDialogTrigger.displayName = TRIGGER_NAME;\nconst PORTAL_NAME = \"AlertDialogPortal\";\nconst AlertDialogPortal = (props) => {\n  const { __scopeAlertDialog, ...portalProps } = props;\n  const dialogScope = useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ jsx(DialogPortal, { ...dialogScope, ...portalProps });\n};\nAlertDialogPortal.displayName = PORTAL_NAME;\nconst OVERLAY_NAME = \"AlertDialogOverlay\";\nconst AlertDialogOverlayFrame = styled(DialogOverlayFrame, {\n  name: OVERLAY_NAME\n});\nconst AlertDialogOverlay = AlertDialogOverlayFrame.extractable(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const { __scopeAlertDialog, ...overlayProps } = props;\n      const dialogScope = useDialogScope(__scopeAlertDialog);\n      return /* @__PURE__ */ jsx(DialogOverlay, { ...dialogScope, ...overlayProps, ref: forwardedRef });\n    }\n  )\n);\nAlertDialogOverlay.displayName = OVERLAY_NAME;\nconst CONTENT_NAME = \"AlertDialogContent\";\nconst [AlertDialogContentProvider, useAlertDialogContentContext] = createAlertDialogContext(CONTENT_NAME);\nconst AlertDialogContent = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeAlertDialog, children, ...contentProps } = props;\n    const dialogScope = useDialogScope(__scopeAlertDialog);\n    const contentRef = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef);\n    const cancelRef = React.useRef(null);\n    return /* @__PURE__ */ jsx(\n      DialogWarningProvider,\n      {\n        contentName: CONTENT_NAME,\n        titleName: TITLE_NAME,\n        docsSlug: \"alert-dialog\",\n        children: /* @__PURE__ */ jsx(AlertDialogContentProvider, { scope: __scopeAlertDialog, cancelRef, children: /* @__PURE__ */ jsxs(\n          DialogContent,\n          {\n            role: \"alertdialog\",\n            ...dialogScope,\n            ...contentProps,\n            ref: composedRefs,\n            onOpenAutoFocus: composeEventHandlers(\n              contentProps.onOpenAutoFocus,\n              (event) => {\n                var _a;\n                event.preventDefault();\n                if (isWeb) {\n                  (_a = cancelRef.current) == null ? void 0 : _a.focus({ preventScroll: true });\n                }\n              }\n            ),\n            onPointerDownOutside: (event) => event.preventDefault(),\n            onInteractOutside: (event) => event.preventDefault(),\n            children: [\n              /* @__PURE__ */ jsx(Slottable, { children }),\n              process.env.NODE_ENV === \"development\" && /* @__PURE__ */ jsx(DescriptionWarning, { contentRef })\n            ]\n          }\n        ) })\n      }\n    );\n  }\n);\nAlertDialogContent.displayName = CONTENT_NAME;\nconst TITLE_NAME = \"AlertDialogTitle\";\nconst AlertDialogTitle = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeAlertDialog, ...titleProps } = props;\n    const dialogScope = useDialogScope(__scopeAlertDialog);\n    return /* @__PURE__ */ jsx(DialogTitle, { ...dialogScope, ...titleProps, ref: forwardedRef });\n  }\n);\nAlertDialogTitle.displayName = TITLE_NAME;\nconst DESCRIPTION_NAME = \"AlertDialogDescription\";\nconst AlertDialogDescription = React.forwardRef((props, forwardedRef) => {\n  const { __scopeAlertDialog, ...descriptionProps } = props;\n  const dialogScope = useDialogScope(__scopeAlertDialog);\n  return /* @__PURE__ */ jsx(DialogDescription, { ...dialogScope, ...descriptionProps, ref: forwardedRef });\n});\nAlertDialogDescription.displayName = DESCRIPTION_NAME;\nconst ACTION_NAME = \"AlertDialogAction\";\nconst AlertDialogAction = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeAlertDialog, ...actionProps } = props;\n    const dialogScope = useDialogScope(__scopeAlertDialog);\n    return /* @__PURE__ */ jsx(DialogClose, { ...dialogScope, ...actionProps, ref: forwardedRef });\n  }\n);\nAlertDialogAction.displayName = ACTION_NAME;\nconst CANCEL_NAME = \"AlertDialogCancel\";\nconst AlertDialogCancel = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeAlertDialog, ...cancelProps } = props;\n    const { cancelRef } = useAlertDialogContentContext(CANCEL_NAME, __scopeAlertDialog);\n    const dialogScope = useDialogScope(__scopeAlertDialog);\n    const ref = useComposedRefs(forwardedRef, cancelRef);\n    return /* @__PURE__ */ jsx(DialogClose, { ...dialogScope, ...cancelProps, ref });\n  }\n);\nAlertDialogCancel.displayName = CANCEL_NAME;\nconst DescriptionWarning = ({ contentRef }) => {\n  if (process.env.NODE_ENV === \"development\") {\n    React.useEffect(() => {\n      var _a;\n      if (!isWeb)\n        return;\n      const hasDescription = document.getElementById(\n        // @ts-ignore\n        // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n        (_a = contentRef.current) == null ? void 0 : _a.getAttribute(\"aria-describedby\")\n      );\n      if (!hasDescription) {\n        console.warn(`\\`${CONTENT_NAME}\\` requires a description for the component to be accessible for screen reader users.\n  \n        You can add a description to the \\`${CONTENT_NAME}\\` by passing a \\`${DESCRIPTION_NAME}\\` component as a child, which also benefits sighted users by adding visible context to the dialog.\n        \n        Alternatively, you can use your own component as a description by assigning it an \\`id\\` and passing the same value to the \\`aria-describedby\\` prop in \\`${CONTENT_NAME}\\`. If the description is confusing or duplicative for sighted users, you can use the \\`@radix-ui/react-visually-hidden\\` primitive as a wrapper around your description component.\n        \n        For more information, see https://tamagui.dev/docs/components/alert-dialog`);\n      }\n    }, [contentRef]);\n  }\n  return null;\n};\nconst AlertDialogInner = (props) => {\n  const { __scopeAlertDialog, native, ...alertDialogProps } = props;\n  const dialogScope = useDialogScope(__scopeAlertDialog);\n  if (process.env.TAMAGUI_TARGET === \"native\") {\n    const [open, setOpen] = useControllableState({\n      prop: props.open,\n      defaultProp: props.defaultOpen || false,\n      onChange: props.onOpenChange,\n      transition: true\n    });\n    let triggerElement = null;\n    let title = \"\";\n    let description = \"\";\n    const buttons = [];\n    forEachChildDeep(React.Children.toArray(props.children), (child) => {\n      if (!React.isValidElement(child))\n        return false;\n      const name = isTamaguiElement(child) ? child.type.staticConfig.componentName : child.type[\"displayName\"];\n      switch (name) {\n        case TRIGGER_NAME: {\n          triggerElement = React.cloneElement(child, {\n            __native: true\n          });\n          return false;\n        }\n        case TITLE_NAME: {\n          title = getStringChildren(child);\n          return false;\n        }\n        case DESCRIPTION_NAME: {\n          description = getStringChildren(child);\n          return false;\n        }\n        case ACTION_NAME:\n        case CANCEL_NAME: {\n          const style = name === ACTION_NAME ? \"default\" : \"cancel\";\n          const text = getStringChildren(child);\n          const onPress = () => {\n            var _a;\n            const childProps = child.props;\n            (_a = childProps == null ? void 0 : childProps.onPress) == null ? void 0 : _a.call(childProps, { native: true });\n            setOpen(false);\n          };\n          buttons.push({\n            style,\n            text,\n            // @ts-ignore\n            onPress\n          });\n          return false;\n        }\n        default: {\n          return true;\n        }\n      }\n    });\n    useIsomorphicLayoutEffect(() => {\n      if (!open || !native)\n        return;\n      if (title || description) {\n        Alert.alert(title, description, buttons);\n      }\n    }, [native, open]);\n    if (native) {\n      return React.cloneElement(triggerElement, {\n        __onPress: () => {\n          setOpen(true);\n        }\n      });\n    }\n  }\n  return /* @__PURE__ */ jsx(Dialog, { ...dialogScope, ...alertDialogProps, modal: true });\n};\nfunction forEachChildDeep(children, onChild) {\n  for (const child of children) {\n    if (!React.isValidElement(child))\n      continue;\n    if (!onChild(child))\n      continue;\n    if (child.props.children) {\n      forEachChildDeep(React.Children.toArray(child.props.children), onChild);\n    }\n  }\n}\nfunction getStringChildren(child) {\n  let string = \"\";\n  forEachChildDeep(React.Children.toArray(child), (child2) => {\n    if (typeof child2.props.children === \"string\") {\n      string = child2.props.children;\n      return false;\n    }\n    return true;\n  });\n  return string;\n}\nconst AlertDialog = withStaticProperties(AlertDialogInner, {\n  Trigger: AlertDialogTrigger,\n  Portal: AlertDialogPortal,\n  Overlay: AlertDialogOverlay,\n  Content: AlertDialogContent,\n  Action: AlertDialogAction,\n  Cancel: AlertDialogCancel,\n  Title: AlertDialogTitle,\n  Description: AlertDialogDescription\n});\nAlertDialog.displayName = ROOT_NAME;\nexport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogOverlay,\n  AlertDialogPortal,\n  AlertDialogTitle,\n  AlertDialogTrigger,\n  createAlertDialogScope\n};\n//# sourceMappingURL=AlertDialog.mjs.map\n","export * from \"./AlertDialog\";\n//# sourceMappingURL=index.mjs.map\n","export * from \"./AnimatePresence\";\nexport * from \"@tamagui/use-presence\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport {\n  getVariableValue,\n  getVariantExtras,\n  styled,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport { Image } from \"@tamagui/image\";\nimport { Square, getShapeSize } from \"@tamagui/shapes\";\nimport { YStack } from \"@tamagui/stacks\";\nimport * as React from \"react\";\nconst AVATAR_NAME = \"Avatar\";\nconst [createAvatarContext, createAvatarScope] = createContextScope(AVATAR_NAME);\nconst [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME);\nconst IMAGE_NAME = \"AvatarImage\";\nconst AvatarImage = React.forwardRef(\n  (props, forwardedRef) => {\n    var _a;\n    const { __scopeAvatar, src, onLoadingStatusChange = () => {\n    }, ...imageProps } = props;\n    const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);\n    const [status, setStatus] = React.useState(\"idle\");\n    const extras = getVariantExtras(props);\n    const shapeSize = getVariableValue(\n      (_a = getShapeSize(context.size, extras)) == null ? void 0 : _a.width\n    );\n    React.useEffect(() => {\n      setStatus(\"idle\");\n    }, [JSON.stringify(src)]);\n    React.useEffect(() => {\n      onLoadingStatusChange(status);\n      context.onImageLoadingStatusChange(status);\n    }, [status]);\n    return /* @__PURE__ */ jsx(YStack, { fullscreen: true, zIndex: 1, children: /* @__PURE__ */ jsx(\n      Image,\n      {\n        fullscreen: true,\n        ...typeof shapeSize === \"number\" && !isNaN(shapeSize) && {\n          width: shapeSize,\n          height: shapeSize\n        },\n        ...imageProps,\n        ref: forwardedRef,\n        src,\n        onError: () => {\n          setStatus(\"error\");\n        },\n        onLoad: () => {\n          setStatus(\"loaded\");\n        }\n      }\n    ) });\n  }\n);\nAvatarImage.displayName = IMAGE_NAME;\nconst FALLBACK_NAME = \"AvatarFallback\";\nconst AvatarFallbackFrame = styled(YStack, {\n  name: FALLBACK_NAME,\n  position: \"absolute\",\n  fullscreen: true,\n  zIndex: 0\n});\nconst AvatarFallback = AvatarFallbackFrame.extractable(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const { __scopeAvatar, delayMs, ...fallbackProps } = props;\n      const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);\n      const [canRender, setCanRender] = React.useState(delayMs === void 0);\n      React.useEffect(() => {\n        if (delayMs !== void 0) {\n          const timerId = setTimeout(() => setCanRender(true), delayMs);\n          return () => clearTimeout(timerId);\n        }\n      }, [delayMs]);\n      return canRender && context.imageLoadingStatus !== \"loaded\" ? /* @__PURE__ */ jsx(AvatarFallbackFrame, { ...fallbackProps, ref: forwardedRef }) : null;\n    }\n  )\n);\nAvatarFallback.displayName = FALLBACK_NAME;\nconst AvatarFrame = styled(Square, {\n  name: AVATAR_NAME,\n  position: \"relative\",\n  overflow: \"hidden\"\n});\nconst Avatar = withStaticProperties(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const { __scopeAvatar, size = \"$true\", ...avatarProps } = props;\n      const [imageLoadingStatus, setImageLoadingStatus] = React.useState(\"idle\");\n      return /* @__PURE__ */ jsx(\n        AvatarProvider,\n        {\n          size,\n          scope: __scopeAvatar,\n          imageLoadingStatus,\n          onImageLoadingStatusChange: setImageLoadingStatus,\n          children: /* @__PURE__ */ jsx(AvatarFrame, { size, ...avatarProps, ref: forwardedRef })\n        }\n      );\n    }\n  ),\n  {\n    Image: AvatarImage,\n    Fallback: AvatarFallback\n  }\n);\nAvatar.displayName = AVATAR_NAME;\nexport {\n  Avatar,\n  AvatarFallback,\n  AvatarFallbackFrame,\n  AvatarFrame,\n  AvatarImage,\n  createAvatarScope\n};\n//# sourceMappingURL=Avatar.mjs.map\n","export * from \"./Avatar\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport { getFontSize } from \"@tamagui/font-size\";\nimport { getButtonSized } from \"@tamagui/get-button-sized\";\nimport { useGetThemedIcon } from \"@tamagui/helpers-tamagui\";\nimport { ThemeableStack } from \"@tamagui/stacks\";\nimport { SizableText, wrapChildrenInText } from \"@tamagui/text\";\nimport {\n  ButtonNestingContext,\n  getVariableValue,\n  isRSC,\n  spacedChildren,\n  styled,\n  themeable,\n  useMediaPropsActive,\n  withStaticProperties\n} from \"@tamagui/web\";\nimport {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useState\n} from \"react\";\nconst BUTTON_NAME = \"Button\";\nconst ButtonFrame = styled(ThemeableStack, {\n  name: BUTTON_NAME,\n  tag: \"button\",\n  variants: {\n    unstyled: {\n      false: {\n        size: \"$true\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        flexWrap: \"nowrap\",\n        flexDirection: \"row\",\n        cursor: \"pointer\",\n        focusable: true,\n        hoverTheme: true,\n        pressTheme: true,\n        backgrounded: true,\n        borderWidth: 1,\n        borderColor: \"transparent\",\n        pressStyle: {\n          borderColor: \"transparent\"\n        },\n        hoverStyle: {\n          borderColor: \"transparent\"\n        },\n        focusStyle: {\n          borderColor: \"$borderColorFocus\",\n          outlineColor: \"$borderColorFocus\",\n          outlineStyle: \"solid\",\n          outlineWidth: 2\n        }\n      }\n    },\n    size: {\n      \"...size\": getButtonSized\n    },\n    active: {\n      true: {\n        hoverStyle: {\n          backgroundColor: \"$background\"\n        }\n      }\n    },\n    disabled: {\n      true: {\n        pointerEvents: \"none\"\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst BUTTON_TEXT_NAME = \"ButtonText\";\nconst ButtonTextFrame = styled(SizableText, {\n  name: BUTTON_TEXT_NAME,\n  variants: {\n    unstyled: {\n      false: {\n        userSelect: \"none\",\n        cursor: \"pointer\",\n        // flexGrow 1 leads to inconsistent native style where text pushes to start of view\n        flexGrow: 0,\n        flexShrink: 1,\n        ellipse: true,\n        color: \"$color\"\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst [createButtonContext, createButtonScope] = createContextScope(\"Button\");\nconst [ButtonProvider, useButtonContext] = createButtonContext(\"Button\");\nconst ButtonTextComponent = ButtonTextFrame.extractable(\n  forwardRef(\n    (props, ref) => {\n      const context = useButtonContext(BUTTON_TEXT_NAME, props.__scopeButton);\n      useEffect(() => {\n        const unregister = context.registerButtonText();\n        return () => unregister();\n      }, [context.registerButtonText]);\n      return /* @__PURE__ */ jsx(ButtonTextFrame, { size: props.size ?? context.size, ...props, ref });\n    }\n  )\n);\nconst BUTTON_ICON_NAME = \"ButtonIcon\";\nconst ButtonIcon = (props) => {\n  const { children, scaleIcon = 1 } = props;\n  const context = useButtonContext(BUTTON_ICON_NAME, props.__scopeButton);\n  const size = context.size;\n  const color = context.color;\n  const iconSize = (typeof size === \"number\" ? size * 0.5 : getFontSize(size)) * scaleIcon;\n  const getThemedIcon = useGetThemedIcon({ size: iconSize, color });\n  return getThemedIcon(children);\n};\nconst ButtonComponent = forwardRef(\n  function Button(props, ref) {\n    const { props: buttonProps } = useButton(props);\n    const [buttonTextCount, setButtonTextCount] = useState(0);\n    const registerButtonText = useCallback(() => {\n      setButtonTextCount((prev) => prev + 1);\n      return () => setButtonTextCount((prev) => prev - 1);\n    }, [setButtonTextCount]);\n    const hasTextComponent = buttonTextCount > 0;\n    return /* @__PURE__ */ jsx(\n      ButtonProvider,\n      {\n        scope: props.__scopeButton,\n        color: props.color,\n        hasTextComponent,\n        size: props.size ?? \"$true\",\n        registerButtonText,\n        children: /* @__PURE__ */ jsx(ButtonFrame, { ...hasTextComponent ? props : buttonProps, ref })\n      }\n    );\n  }\n);\nconst buttonStaticConfig = {\n  inlineProps: /* @__PURE__ */ new Set([\n    // text props go here (can't really optimize them, but we never fully extract button anyway)\n    // may be able to remove this entirely, as the compiler / runtime have gotten better\n    \"color\",\n    \"fontWeight\",\n    \"fontSize\",\n    \"fontFamily\",\n    \"fontStyle\",\n    \"letterSpacing\",\n    \"textAlign\",\n    \"unstyled\"\n  ])\n};\nconst Button2 = withStaticProperties(\n  ButtonFrame.extractable(\n    themeable(ButtonComponent, ButtonFrame.staticConfig),\n    buttonStaticConfig\n  ),\n  {\n    Text: ButtonTextComponent,\n    Icon: ButtonIcon\n  }\n);\nfunction useButton(propsIn, { Text = ButtonTextFrame } = { Text: ButtonTextFrame }) {\n  const {\n    children,\n    icon,\n    iconAfter,\n    noTextWrap,\n    theme: themeName,\n    space,\n    spaceFlex,\n    scaleIcon = 1,\n    scaleSpace = 0.66,\n    separator,\n    // text props\n    color,\n    fontWeight,\n    letterSpacing,\n    fontSize,\n    fontFamily,\n    fontStyle,\n    textAlign,\n    unstyled = false,\n    textProps,\n    ...rest\n  } = propsIn;\n  const isNested = isRSC ? false : useContext(ButtonNestingContext);\n  const propsActive = useMediaPropsActive(propsIn);\n  const size = propsActive.size || \"$true\";\n  const iconSize = (typeof size === \"number\" ? size * 0.5 : getFontSize(size)) * scaleIcon;\n  const getThemedIcon = useGetThemedIcon({ size: iconSize, color });\n  const [themedIcon, themedIconAfter] = [icon, iconAfter].map(getThemedIcon);\n  const spaceSize = propsActive.space ?? getVariableValue(iconSize) * scaleSpace;\n  const contents = wrapChildrenInText(\n    Text,\n    propsActive,\n    Text === ButtonTextFrame ? {\n      unstyled\n    } : void 0\n  );\n  const inner = spacedChildren({\n    // a bit arbitrary but scaling to font size is necessary so long as button does\n    space: spaceSize,\n    spaceFlex,\n    separator,\n    direction: propsActive.flexDirection === \"column\" || propsActive.flexDirection === \"column-reverse\" ? \"vertical\" : \"horizontal\",\n    children: [themedIcon, ...contents, themedIconAfter]\n  });\n  const tag = isNested ? \"span\" : (\n    // defaults to <a /> when accessibilityRole = link\n    // see https://github.com/tamagui/tamagui/issues/505\n    propsIn.accessibilityRole === \"link\" ? \"a\" : void 0\n  );\n  const props = {\n    ...propsActive.disabled && {\n      // in rnw - false still has keyboard tabIndex, undefined = not actually focusable\n      focusable: void 0,\n      // even with tabIndex unset, it will keep focusStyle on web so disable it here\n      focusStyle: {\n        borderColor: \"$background\"\n      }\n    },\n    unstyled,\n    tag,\n    ...rest,\n    children: isRSC ? inner : /* @__PURE__ */ jsx(ButtonNestingContext.Provider, { value: true, children: inner })\n  };\n  return {\n    spaceSize,\n    isNested,\n    props\n  };\n}\nexport {\n  Button2 as Button,\n  ButtonFrame,\n  ButtonTextFrame as ButtonText,\n  buttonStaticConfig,\n  createButtonScope,\n  useButton\n};\n//# sourceMappingURL=Button.mjs.map\n","export * from \"./Button\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { ThemeableStack } from \"@tamagui/stacks\";\nimport {\n  isTamaguiElement,\n  styled,\n  withStaticProperties\n} from \"@tamagui/web\";\nimport React, { cloneElement, forwardRef } from \"react\";\nconst CardFrame = styled(ThemeableStack, {\n  name: \"Card\",\n  variants: {\n    unstyled: {\n      false: {\n        size: \"$true\",\n        backgroundColor: \"$background\",\n        position: \"relative\",\n        overflow: \"hidden\"\n      }\n    },\n    size: {\n      \"...size\": (val, { tokens }) => {\n        return {\n          borderRadius: tokens.radius[val] ?? val\n        };\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst CardHeader = styled(ThemeableStack, {\n  name: \"CardHeader\",\n  variants: {\n    unstyled: {\n      false: {\n        zIndex: 10,\n        backgroundColor: \"transparent\",\n        marginBottom: \"auto\"\n      }\n    },\n    size: {\n      \"...size\": (val, { tokens }) => {\n        return {\n          padding: tokens.space[val] ?? val\n        };\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst CardFooter = styled(CardHeader, {\n  name: \"CardFooter\",\n  variants: {\n    unstyled: {\n      false: {\n        zIndex: 5,\n        flexDirection: \"row\",\n        marginTop: \"auto\",\n        marginBottom: 0\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst CardBackground = styled(ThemeableStack, {\n  name: \"CardBackground\",\n  variants: {\n    unstyled: {\n      false: {\n        zIndex: 0,\n        fullscreen: true,\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        padding: 0\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst Card = withStaticProperties(\n  CardFrame.extractable(\n    forwardRef(\n      ({ size, __scopeCard, children, ...props }, ref) => {\n        return /* @__PURE__ */ jsx(CardFrame, { ref, ...props, children: React.Children.map(children, (child) => {\n          if (isTamaguiElement(child) && !child.props.size) {\n            return cloneElement(child, {\n              size\n            });\n          }\n          return child;\n        }) });\n      }\n    )\n  ),\n  {\n    Header: CardHeader,\n    Footer: CardFooter,\n    Background: CardBackground\n  }\n);\nexport {\n  Card,\n  CardBackground,\n  CardFooter,\n  CardFrame,\n  CardHeader\n};\n//# sourceMappingURL=Card.mjs.map\n","export * from \"./Card\";\n//# sourceMappingURL=index.mjs.map\n","import { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nimport { usePrevious } from \"@radix-ui/react-use-previous\";\nimport {\n  composeEventHandlers,\n  getVariableValue,\n  isWeb,\n  styled,\n  useComposedRefs,\n  useMediaPropsActive,\n  useTheme,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport { registerFocusable } from \"@tamagui/focusable\";\nimport { getFontSize } from \"@tamagui/font-size\";\nimport { getSize, stepTokenUpOrDown } from \"@tamagui/get-size\";\nimport { useGetThemedIcon } from \"@tamagui/helpers-tamagui\";\nimport { useLabelContext } from \"@tamagui/label\";\nimport { ThemeableStack } from \"@tamagui/stacks\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport * as React from \"react\";\nfunction isIndeterminate(checked) {\n  return checked === \"indeterminate\";\n}\nfunction getState(checked) {\n  return isIndeterminate(checked) ? \"indeterminate\" : checked ? \"checked\" : \"unchecked\";\n}\nconst BubbleInput = (props) => {\n  const { checked, bubbles = true, control, isHidden, ...inputProps } = props;\n  const ref = React.useRef(null);\n  const prevChecked = usePrevious(checked);\n  React.useEffect(() => {\n    const input = ref.current;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(\n      inputProto,\n      \"checked\"\n    );\n    const setChecked = descriptor.set;\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event(\"click\", { bubbles });\n      input.indeterminate = isIndeterminate(checked);\n      setChecked.call(input, isIndeterminate(checked) ? false : checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n  return /* @__PURE__ */ jsx(\n    \"input\",\n    {\n      type: \"checkbox\",\n      defaultChecked: isIndeterminate(checked) ? false : checked,\n      ...inputProps,\n      tabIndex: -1,\n      ref,\n      \"aria-hidden\": isHidden,\n      style: {\n        ...isHidden ? {\n          // ...controlSize,\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        } : {\n          appearance: \"auto\",\n          accentColor: \"var(--color6)\"\n        },\n        ...props.style\n      }\n    }\n  );\n};\nconst INDICATOR_NAME = \"CheckboxIndicator\";\nconst CheckboxIndicatorFrame = styled(ThemeableStack, {\n  // use Checkbox for easier themes\n  name: INDICATOR_NAME\n});\nconst CheckboxIndicator = CheckboxIndicatorFrame.extractable(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const {\n        __scopeCheckbox,\n        children: childrenProp,\n        forceMount,\n        disablePassStyles,\n        ...indicatorProps\n      } = props;\n      const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);\n      const iconSize = (typeof context.size === \"number\" ? context.size * 0.65 : getFontSize(context.size)) * context.scaleIcon;\n      const theme = useTheme();\n      const getThemedIcon = useGetThemedIcon({ size: iconSize, color: theme.color });\n      const childrens = React.Children.toArray(childrenProp);\n      const children = childrens.map((child) => {\n        if (disablePassStyles || !React.isValidElement(child)) {\n          return child;\n        }\n        return getThemedIcon(child);\n      });\n      if (forceMount || isIndeterminate(context.state) || context.state === true)\n        return /* @__PURE__ */ jsx(\n          CheckboxIndicatorFrame,\n          {\n            \"data-state\": getState(context.state),\n            \"data-disabled\": context.disabled ? \"\" : void 0,\n            pointerEvents: \"none\",\n            ...indicatorProps,\n            ref: forwardedRef,\n            children\n          }\n        );\n      return null;\n    }\n  )\n);\nCheckboxIndicator.displayName = INDICATOR_NAME;\nconst CHECKBOX_NAME = \"Checkbox\";\nconst CheckboxFrame = styled(ThemeableStack, {\n  name: CHECKBOX_NAME,\n  tag: \"button\",\n  variants: {\n    unstyled: {\n      false: {\n        size: \"$true\",\n        backgroundColor: \"$background\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        pressTheme: true,\n        focusable: true,\n        borderWidth: 1,\n        borderColor: \"$borderColor\",\n        hoverStyle: {\n          borderColor: \"$borderColorHover\"\n        },\n        focusStyle: {\n          borderColor: \"$borderColorFocus\"\n        }\n      }\n    },\n    size: {\n      \"...size\": (val, { tokens }) => {\n        const radiusToken = getVariableValue(getSize(val)) / 8;\n        return {\n          borderRadius: radiusToken\n        };\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);\nconst [CheckboxProvider, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);\nconst Checkbox = withStaticProperties(\n  CheckboxFrame.extractable(\n    React.forwardRef(\n      (props, forwardedRef) => {\n        const {\n          __scopeCheckbox,\n          labelledBy: ariaLabelledby,\n          name,\n          checked: checkedProp,\n          defaultChecked,\n          required,\n          scaleIcon = 1,\n          scaleSize = 0.45,\n          sizeAdjust = 0,\n          disabled,\n          value = \"on\",\n          onCheckedChange,\n          native,\n          ...checkboxProps\n        } = props;\n        const [button, setButton] = React.useState(null);\n        const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));\n        const hasConsumerStoppedPropagationRef = React.useRef(false);\n        const propsActive = useMediaPropsActive(props);\n        const isFormControl = isWeb ? button ? Boolean(button.closest(\"form\")) : true : false;\n        const [checked = false, setChecked] = useControllableState({\n          prop: checkedProp,\n          defaultProp: defaultChecked,\n          onChange: onCheckedChange\n        });\n        const adjustedSize = getVariableValue(\n          stepTokenUpOrDown(\"size\", propsActive.size, sizeAdjust)\n        );\n        const size = scaleSize ? Math.round(adjustedSize * scaleSize) : adjustedSize;\n        const labelId = useLabelContext(button);\n        const labelledBy = ariaLabelledby || labelId;\n        if (process.env.TAMAGUI_TARGET === \"native\") {\n          React.useEffect(() => {\n            if (!props.id)\n              return;\n            return registerFocusable(props.id, {\n              focusAndSelect: () => {\n                setChecked((x) => !x);\n              },\n              focus: () => {\n              }\n            });\n          }, [props.id, setChecked]);\n        }\n        return /* @__PURE__ */ jsx(\n          CheckboxProvider,\n          {\n            scope: __scopeCheckbox,\n            state: checked,\n            disabled,\n            size,\n            scaleIcon,\n            children: isWeb && native ? /* @__PURE__ */ jsx(\n              BubbleInput,\n              {\n                control: button,\n                bubbles: !hasConsumerStoppedPropagationRef.current,\n                name,\n                value,\n                checked,\n                required,\n                disabled,\n                id: props.id\n              }\n            ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n              /* @__PURE__ */ jsx(\n                CheckboxFrame,\n                {\n                  width: size,\n                  height: size,\n                  tag: \"button\",\n                  role: \"checkbox\",\n                  \"aria-labelledby\": labelledBy,\n                  \"aria-checked\": isIndeterminate(checked) ? \"mixed\" : checked,\n                  \"aria-required\": required,\n                  \"data-state\": getState(checked),\n                  \"data-disabled\": disabled ? \"\" : void 0,\n                  disabled,\n                  ...checkboxProps,\n                  ref: composedRefs,\n                  ...isWeb && {\n                    type: \"button\",\n                    value,\n                    onKeyDown: composeEventHandlers(\n                      props.onKeyDown,\n                      (event) => {\n                        if (event.key === \"Enter\")\n                          event.preventDefault();\n                      }\n                    )\n                  },\n                  onPress: composeEventHandlers(props.onPress, (event) => {\n                    setChecked(\n                      (prevChecked) => isIndeterminate(prevChecked) ? true : !prevChecked\n                    );\n                    if (isFormControl) {\n                      hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n                      if (!hasConsumerStoppedPropagationRef.current)\n                        event.stopPropagation();\n                    }\n                  })\n                }\n              ),\n              isWeb && isFormControl ? /* @__PURE__ */ jsx(\n                BubbleInput,\n                {\n                  isHidden: true,\n                  control: button,\n                  bubbles: !hasConsumerStoppedPropagationRef.current,\n                  name,\n                  value,\n                  checked,\n                  required,\n                  disabled\n                }\n              ) : null\n            ] })\n          }\n        );\n      }\n    )\n  ),\n  {\n    Indicator: CheckboxIndicator\n  }\n);\nCheckbox.displayName = CHECKBOX_NAME;\nexport {\n  BubbleInput,\n  Checkbox,\n  CheckboxFrame,\n  createCheckboxScope,\n  getState,\n  isIndeterminate\n};\n//# sourceMappingURL=Checkbox.mjs.map\n","export * from \"./Checkbox\";\n//# sourceMappingURL=index.mjs.map\n","export * from \"./create-context\";\n//# sourceMappingURL=index.mjs.map\n","import { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nimport { Adapt, useAdaptParent } from \"@tamagui/adapt\";\nimport { AnimatePresence } from \"@tamagui/animate-presence\";\nimport { hideOthers } from \"@tamagui/aria-hidden\";\nimport { useComposedRefs } from \"@tamagui/compose-refs\";\nimport {\n  Theme,\n  composeEventHandlers,\n  isWeb,\n  spacedChildren,\n  styled,\n  useGet,\n  useMedia,\n  useThemeName,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { createContext, createContextScope } from \"@tamagui/create-context\";\nimport { Dismissable } from \"@tamagui/dismissable\";\nimport { FocusScope } from \"@tamagui/focus-scope\";\nimport { PortalHost, PortalItem } from \"@tamagui/portal\";\nimport { RemoveScroll } from \"@tamagui/remove-scroll\";\nimport { ControlledSheet, SheetController, SheetOverlayFrame } from \"@tamagui/sheet\";\nimport { ThemeableStack, YStack } from \"@tamagui/stacks\";\nimport { H2, Paragraph } from \"@tamagui/text\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport * as React from \"react\";\nconst DIALOG_NAME = \"Dialog\";\nconst [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);\nconst [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);\nconst TRIGGER_NAME = \"DialogTrigger\";\nconst DialogTriggerFrame = styled(YStack, {\n  name: TRIGGER_NAME\n});\nconst DialogTrigger = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeDialog, ...triggerProps } = props;\n    const context = useDialogContext(TRIGGER_NAME, __scopeDialog);\n    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n    return /* @__PURE__ */ jsx(\n      DialogTriggerFrame,\n      {\n        tag: \"button\",\n        \"aria-haspopup\": \"dialog\",\n        \"aria-expanded\": context.open,\n        \"aria-controls\": context.contentId,\n        \"data-state\": getState(context.open),\n        ...triggerProps,\n        ref: composedTriggerRef,\n        onPress: composeEventHandlers(props.onPress, context.onOpenToggle)\n      }\n    );\n  }\n);\nDialogTrigger.displayName = TRIGGER_NAME;\nconst PORTAL_NAME = \"DialogPortal\";\nconst [PortalProvider, usePortalContext] = createDialogContext(\n  PORTAL_NAME,\n  {\n    forceMount: void 0\n  }\n);\nconst DialogPortalFrame = styled(YStack, {\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  fullscreen: true,\n  zIndex: 100,\n  ...isWeb && {\n    maxHeight: \"100vh\",\n    position: \"fixed\"\n  }\n});\nconst DialogPortalItem = (props) => {\n  const themeName = useThemeName();\n  const context = useDialogContext(PORTAL_NAME, props.__scopeDialog);\n  return /* @__PURE__ */ jsx(PortalItem, { hostName: props.hostName, children: /* @__PURE__ */ jsx(DialogPortalItemContent, { ...props, themeName, context }) });\n};\nfunction DialogPortalItemContent(props) {\n  const {\n    __scopeDialog,\n    children,\n    context,\n    themeName,\n    space,\n    spaceDirection,\n    separator\n  } = props;\n  let childrenSpaced = children;\n  if (space || separator) {\n    childrenSpaced = spacedChildren({\n      children,\n      separator,\n      space,\n      direction: spaceDirection\n    });\n  }\n  return /* @__PURE__ */ jsx(DialogProvider, { scope: __scopeDialog, ...context, children: /* @__PURE__ */ jsx(Theme, { name: themeName, children: childrenSpaced }) });\n}\nconst DialogPortal = (props) => {\n  const { __scopeDialog, forceMount, children, ...frameProps } = props;\n  const context = useDialogContext(PORTAL_NAME, __scopeDialog);\n  const isShowing = forceMount || context.open;\n  const [isFullyHidden, setIsFullyHidden] = React.useState(!isShowing);\n  if (isShowing && isFullyHidden) {\n    setIsFullyHidden(false);\n  }\n  const contents = /* @__PURE__ */ jsx(\n    AnimatePresence,\n    {\n      onExitComplete: () => {\n        setIsFullyHidden(true);\n      },\n      children: isShowing ? children : null\n    }\n  );\n  const isSheet = useShowDialogSheet(context);\n  if (isSheet) {\n    return children;\n  }\n  if (context.modal) {\n    if (isFullyHidden) {\n      return null;\n    }\n    return /* @__PURE__ */ jsx(DialogPortalItem, { __scopeDialog, children: /* @__PURE__ */ jsx(PortalProvider, { scope: __scopeDialog, forceMount, children: /* @__PURE__ */ jsx(DialogPortalFrame, { pointerEvents: isShowing ? \"auto\" : \"none\", ...frameProps, children: contents }) }) });\n  }\n  return contents;\n};\nDialogPortal.displayName = PORTAL_NAME;\nconst OVERLAY_NAME = \"DialogOverlay\";\nconst DialogOverlayFrame = styled(SheetOverlayFrame, {\n  name: OVERLAY_NAME\n});\nconst DialogOverlay = DialogOverlayFrame.extractable(\n  React.forwardRef(\n    ({ __scopeDialog, ...props }, forwardedRef) => {\n      const portalContext = usePortalContext(OVERLAY_NAME, __scopeDialog);\n      const { forceMount = portalContext.forceMount, ...overlayProps } = props;\n      const context = useDialogContext(OVERLAY_NAME, __scopeDialog);\n      const showSheet = useShowDialogSheet(context);\n      if (!forceMount) {\n        if (!context.modal || showSheet) {\n          return null;\n        }\n      }\n      return /* @__PURE__ */ jsx(DialogOverlayImpl, { context, ...overlayProps, ref: forwardedRef });\n    }\n  )\n);\nDialogOverlay.displayName = OVERLAY_NAME;\nconst DialogOverlayImpl = React.forwardRef(\n  (props, forwardedRef) => {\n    const { context, ...overlayProps } = props;\n    return (\n      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`\n      // ie. when `Overlay` and `Content` are siblings\n      /* @__PURE__ */ jsx(\n        DialogOverlayFrame,\n        {\n          \"data-state\": getState(context.open),\n          pointerEvents: context.open ? \"auto\" : \"none\",\n          ...overlayProps,\n          ref: forwardedRef\n        }\n      )\n    );\n  }\n);\nconst CONTENT_NAME = \"DialogContent\";\nconst DialogContentFrame = styled(ThemeableStack, {\n  name: CONTENT_NAME,\n  tag: \"dialog\",\n  position: \"relative\",\n  backgrounded: true,\n  padded: true,\n  radiused: true,\n  elevate: true,\n  variants: {\n    size: {\n      \"...size\": (val, extras) => {\n        return {};\n      }\n    }\n  },\n  defaultVariants: {\n    size: \"$true\"\n  }\n});\nconst DialogContent = DialogContentFrame.extractable(\n  React.forwardRef(\n    ({ __scopeDialog, ...props }, forwardedRef) => {\n      const portalContext = usePortalContext(CONTENT_NAME, __scopeDialog);\n      const { forceMount = portalContext.forceMount, ...contentProps } = props;\n      const context = useDialogContext(CONTENT_NAME, __scopeDialog);\n      const contents = context.modal ? /* @__PURE__ */ jsx(DialogContentModal, { context, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsx(DialogContentNonModal, { context, ...contentProps, ref: forwardedRef });\n      if (!isWeb || context.disableRemoveScroll) {\n        return contents;\n      }\n      return /* @__PURE__ */ jsx(\n        RemoveScroll,\n        {\n          forwardProps: true,\n          enabled: context.open,\n          allowPinchZoom: context.allowPinchZoom,\n          shards: [context.contentRef],\n          removeScrollBar: false,\n          children: /* @__PURE__ */ jsx(\"div\", { className: \"_dsp_contents\", children: contents })\n        }\n      );\n    }\n  )\n);\nDialogContent.displayName = CONTENT_NAME;\nconst DialogContentModal = React.forwardRef(\n  ({ children, context, ...props }, forwardedRef) => {\n    const contentRef = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);\n    if (isWeb) {\n      React.useEffect(() => {\n        if (!context.open)\n          return;\n        const content = contentRef.current;\n        if (content)\n          return hideOthers(content);\n      }, [context.open]);\n    }\n    return /* @__PURE__ */ jsx(\n      DialogContentImpl,\n      {\n        ...props,\n        context,\n        ref: composedRefs,\n        disableOutsidePointerEvents: true,\n        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {\n          var _a;\n          event.preventDefault();\n          (_a = context.triggerRef.current) == null ? void 0 : _a.focus();\n        }),\n        onPointerDownOutside: composeEventHandlers(\n          props.onPointerDownOutside,\n          (event) => {\n            const originalEvent = event[\"detail\"].originalEvent;\n            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n            if (isRightClick)\n              event.preventDefault();\n          }\n        ),\n        onFocusOutside: composeEventHandlers(\n          props.onFocusOutside,\n          (event) => event.preventDefault()\n        ),\n        children\n      }\n    );\n  }\n);\nconst DialogContentNonModal = React.forwardRef(\n  (props, forwardedRef) => {\n    const hasInteractedOutsideRef = React.useRef(false);\n    return /* @__PURE__ */ jsx(\n      DialogContentImpl,\n      {\n        ...props,\n        ref: forwardedRef,\n        trapFocus: false,\n        disableOutsidePointerEvents: false,\n        onCloseAutoFocus: (event) => {\n          var _a, _b;\n          (_a = props.onCloseAutoFocus) == null ? void 0 : _a.call(props, event);\n          if (!event.defaultPrevented) {\n            if (!hasInteractedOutsideRef.current) {\n              (_b = props.context.triggerRef.current) == null ? void 0 : _b.focus();\n            }\n            event.preventDefault();\n          }\n          hasInteractedOutsideRef.current = false;\n        },\n        onInteractOutside: (event) => {\n          var _a;\n          (_a = props.onInteractOutside) == null ? void 0 : _a.call(props, event);\n          if (!event.defaultPrevented)\n            hasInteractedOutsideRef.current = true;\n          const target = event.target;\n          const trigger = props.context.triggerRef.current;\n          if (!(trigger instanceof HTMLElement))\n            return;\n          const targetIsTrigger = trigger.contains(target);\n          if (targetIsTrigger)\n            event.preventDefault();\n        }\n      }\n    );\n  }\n);\nconst DialogContentImpl = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeDialog,\n      trapFocus,\n      onOpenAutoFocus,\n      onCloseAutoFocus,\n      disableOutsidePointerEvents,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      context,\n      ...contentProps\n    } = props;\n    const contentRef = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef);\n    const showSheet = useShowDialogSheet(context);\n    const contents = /* @__PURE__ */ jsx(\n      DialogContentFrame,\n      {\n        id: context.contentId,\n        \"aria-describedby\": context.descriptionId,\n        \"aria-labelledby\": context.titleId,\n        \"data-state\": getState(context.open),\n        ...contentProps\n      }\n    );\n    if (showSheet) {\n      return /* @__PURE__ */ jsx(DialogPortalItem, { hostName: getSheetContentsName(context), children: contentProps.children });\n    }\n    if (!isWeb) {\n      return contents;\n    }\n    return /* @__PURE__ */ jsxs(Fragment, { children: [\n      /* @__PURE__ */ jsx(\n        FocusScope,\n        {\n          loop: true,\n          trapped: trapFocus,\n          onMountAutoFocus: onOpenAutoFocus,\n          forceUnmount: !context.open,\n          onUnmountAutoFocus: onCloseAutoFocus,\n          children: /* @__PURE__ */ jsx(\n            Dismissable,\n            {\n              disableOutsidePointerEvents: context.open && disableOutsidePointerEvents,\n              forceUnmount: !context.open,\n              onEscapeKeyDown,\n              onPointerDownOutside,\n              onFocusOutside,\n              onInteractOutside,\n              ref: composedRefs,\n              onDismiss: () => context.onOpenChange(false),\n              children: contents\n            }\n          )\n        }\n      ),\n      process.env.NODE_ENV === \"development\" && /* @__PURE__ */ jsxs(Fragment, { children: [\n        /* @__PURE__ */ jsx(TitleWarning, { titleId: context.titleId }),\n        /* @__PURE__ */ jsx(\n          DescriptionWarning,\n          {\n            contentRef,\n            descriptionId: context.descriptionId\n          }\n        )\n      ] })\n    ] });\n  }\n);\nconst TITLE_NAME = \"DialogTitle\";\nconst DialogTitleFrame = styled(H2, {\n  name: TITLE_NAME\n});\nconst DialogTitle = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeDialog, ...titleProps } = props;\n    const context = useDialogContext(TITLE_NAME, __scopeDialog);\n    return /* @__PURE__ */ jsx(DialogTitleFrame, { id: context.titleId, ...titleProps, ref: forwardedRef });\n  }\n);\nDialogTitle.displayName = TITLE_NAME;\nconst DialogDescriptionFrame = styled(Paragraph, {\n  name: \"DialogDescription\"\n});\nconst DESCRIPTION_NAME = \"DialogDescription\";\nconst DialogDescription = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeDialog, ...descriptionProps } = props;\n    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);\n    return /* @__PURE__ */ jsx(\n      DialogDescriptionFrame,\n      {\n        id: context.descriptionId,\n        ...descriptionProps,\n        ref: forwardedRef\n      }\n    );\n  }\n);\nDialogDescription.displayName = DESCRIPTION_NAME;\nconst CLOSE_NAME = \"DialogClose\";\nconst DialogClose = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeDialog, displayWhenAdapted, ...closeProps } = props;\n    const context = useDialogContext(CLOSE_NAME, __scopeDialog, {\n      warn: false,\n      fallback: {}\n    });\n    const isSheet = useShowDialogSheet(context);\n    if (isSheet && !displayWhenAdapted) {\n      return null;\n    }\n    return /* @__PURE__ */ jsx(\n      YStack,\n      {\n        tag: \"button\",\n        accessibilityLabel: \"Dialog Close\",\n        ...closeProps,\n        ref: forwardedRef,\n        onPress: composeEventHandlers(\n          props.onPress,\n          () => context.onOpenChange(false)\n        )\n      }\n    );\n  }\n);\nDialogClose.displayName = CLOSE_NAME;\nfunction getState(open) {\n  return open ? \"open\" : \"closed\";\n}\nconst TITLE_WARNING_NAME = \"DialogTitleWarning\";\nconst [DialogWarningProvider, useWarningContext] = createContext(TITLE_WARNING_NAME, {\n  contentName: CONTENT_NAME,\n  titleName: TITLE_NAME,\n  docsSlug: \"dialog\"\n});\nconst TitleWarning = ({ titleId }) => {\n  if (process.env.NODE_ENV === \"development\") {\n    const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);\n    const MESSAGE = `\\`${titleWarningContext.contentName}\\` requires a \\`${titleWarningContext.titleName}\\` for the component to be accessible for screen reader users.\n\nIf you want to hide the \\`${titleWarningContext.titleName}\\`, you can wrap it with our VisuallyHidden component.`;\n    React.useEffect(() => {\n      if (!isWeb)\n        return;\n      if (titleId) {\n        const hasTitle = document.getElementById(titleId);\n        if (!hasTitle) {\n          console.warn(MESSAGE);\n        }\n      }\n    }, [MESSAGE, titleId]);\n  }\n  return null;\n};\nconst DESCRIPTION_WARNING_NAME = \"DialogDescriptionWarning\";\nconst DescriptionWarning = ({\n  contentRef,\n  descriptionId\n}) => {\n  if (process.env.NODE_ENV === \"development\") {\n    const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);\n    const MESSAGE = `Warning: Missing \\`Description\\` or \\`aria-describedby={undefined}\\` for {${descriptionWarningContext.contentName}}.`;\n    React.useEffect(() => {\n      if (!isWeb)\n        return;\n      const contentNode = contentRef.current;\n      if (!(contentNode instanceof HTMLElement)) {\n        return;\n      }\n      const describedById = contentNode.getAttribute(\"aria-describedby\");\n      if (descriptionId && describedById) {\n        const hasDescription = document.getElementById(descriptionId);\n        if (!hasDescription) {\n          console.warn(MESSAGE);\n        }\n      }\n    }, [MESSAGE, contentRef, descriptionId]);\n  }\n  return null;\n};\nconst Dialog = withStaticProperties(\n  React.forwardRef(function Dialog2(props, ref) {\n    const {\n      __scopeDialog,\n      children,\n      open: openProp,\n      defaultOpen = false,\n      onOpenChange,\n      modal = true,\n      allowPinchZoom = false,\n      disableRemoveScroll = false\n    } = props;\n    const baseId = React.useId();\n    const scopeId = `scope-${baseId}`;\n    const contentId = `content-${baseId}`;\n    const titleId = `title-${baseId}`;\n    const descriptionId = `description-${baseId}`;\n    const scopeKey = __scopeDialog ? Object.keys(__scopeDialog)[0] : scopeId;\n    const sheetContentsName = getSheetContentsName({ scopeKey, contentId });\n    const triggerRef = React.useRef(null);\n    const contentRef = React.useRef(null);\n    const [open, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen,\n      onChange: onOpenChange\n    });\n    const onOpenToggle = React.useCallback(() => {\n      setOpen((prevOpen) => !prevOpen);\n    }, [setOpen]);\n    const context = {\n      scope: __scopeDialog,\n      scopeKey,\n      triggerRef,\n      contentRef,\n      contentId,\n      titleId,\n      descriptionId,\n      open,\n      onOpenChange: setOpen,\n      onOpenToggle,\n      modal,\n      allowPinchZoom\n    };\n    const { when, AdaptProvider } = useAdaptParent({\n      Contents: React.useCallback(\n        (props2) => {\n          return /* @__PURE__ */ jsx(PortalHost, { forwardProps: props2, name: sheetContentsName });\n        },\n        [sheetContentsName]\n      )\n    });\n    React.useImperativeHandle(\n      ref,\n      () => ({\n        open: setOpen\n      }),\n      [setOpen]\n    );\n    return /* @__PURE__ */ jsx(AdaptProvider, { children: /* @__PURE__ */ jsx(\n      DialogProvider,\n      {\n        ...context,\n        sheetBreakpoint: when,\n        disableRemoveScroll,\n        children: /* @__PURE__ */ jsx(DialogSheetController, { onOpenChange: setOpen, __scopeDialog, children })\n      }\n    ) });\n  }),\n  {\n    Trigger: DialogTrigger,\n    Portal: DialogPortal,\n    Overlay: DialogOverlay,\n    Content: DialogContent,\n    Title: DialogTitle,\n    Description: DialogDescription,\n    Close: DialogClose,\n    Sheet: ControlledSheet,\n    Adapt\n  }\n);\nconst SHEET_CONTENTS_NAME = \"DialogSheetContents\";\nconst DialogSheetContents = ({\n  name,\n  ...props\n}) => {\n  return /* @__PURE__ */ jsx(PortalHost, { forwardProps: props, name });\n};\nDialogSheetContents.displayName = SHEET_CONTENTS_NAME;\nconst getSheetContentsName = ({\n  scopeKey,\n  contentId\n}) => `${scopeKey || contentId}SheetContents`;\nconst DialogSheetController = (props) => {\n  const context = useDialogContext(\"DialogSheetController\", props.__scopeDialog);\n  const showSheet = useShowDialogSheet(context);\n  const breakpointActive = useSheetBreakpointActive(context);\n  const getShowSheet = useGet(showSheet);\n  return /* @__PURE__ */ jsx(\n    SheetController,\n    {\n      onOpenChange: (val) => {\n        if (getShowSheet()) {\n          props.onOpenChange(val);\n        }\n      },\n      open: context.open,\n      hidden: breakpointActive === false,\n      children: props.children\n    }\n  );\n};\nconst useSheetBreakpointActive = (context) => {\n  const media = useMedia();\n  if (!context.sheetBreakpoint)\n    return false;\n  if (context.sheetBreakpoint === true)\n    return true;\n  return media[context.sheetBreakpoint];\n};\nconst useShowDialogSheet = (context) => {\n  const breakpointActive = useSheetBreakpointActive(context);\n  return context.open === false ? false : breakpointActive;\n};\nexport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogOverlay,\n  DialogOverlayFrame,\n  DialogPortal,\n  DialogPortalFrame,\n  DialogSheetContents,\n  DialogTitle,\n  DialogTrigger,\n  DialogWarningProvider,\n  createDialogScope\n};\n//# sourceMappingURL=Dialog.mjs.map\n","export * from \"./Dialog\";\n//# sourceMappingURL=index.mjs.map\n","export * from \"@floating-ui/react-dom\";\n//# sourceMappingURL=Floating.mjs.map\n","export * from \"./Floating\";\nimport {\n  useFloating,\n  FloatingOverrideContext\n} from \"./useFloating\";\nexport {\n  FloatingOverrideContext,\n  useFloating\n};\n//# sourceMappingURL=index.mjs.map\n","import { useContext, createContext } from \"react\";\nimport * as Floating from \"./Floating\";\nconst FloatingOverrideContext = createContext(null);\nconst useFloating = (props) => {\n  var _a;\n  const context = useContext(FloatingOverrideContext);\n  return (_a = context || Floating.useFloating) == null ? void 0 : _a(props);\n};\nexport {\n  FloatingOverrideContext,\n  useFloating\n};\n//# sourceMappingURL=useFloating.mjs.map\n","import { useComposedRefs } from \"@tamagui/compose-refs\";\nimport { useEvent } from \"@tamagui/use-event\";\nimport * as React from \"react\";\nconst AUTOFOCUS_ON_MOUNT = \"focusScope.autoFocusOnMount\";\nconst AUTOFOCUS_ON_UNMOUNT = \"focusScope.autoFocusOnUnmount\";\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\nconst FOCUS_SCOPE_NAME = \"FocusScope\";\nconst FocusScope = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      loop = false,\n      trapped = false,\n      onMountAutoFocus: onMountAutoFocusProp,\n      onUnmountAutoFocus: onUnmountAutoFocusProp,\n      children,\n      forceUnmount,\n      ...scopeProps\n    } = props;\n    const [container, setContainer] = React.useState(null);\n    const onMountAutoFocus = useEvent(onMountAutoFocusProp);\n    const onUnmountAutoFocus = useEvent(onUnmountAutoFocusProp);\n    const lastFocusedElementRef = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n    const focusScope = React.useRef({\n      paused: false,\n      pause() {\n        this.paused = true;\n      },\n      resume() {\n        this.paused = false;\n      }\n    }).current;\n    React.useEffect(() => {\n      if (!trapped)\n        return;\n      function handleFocusIn(event) {\n        if (focusScope.paused || !container)\n          return;\n        const target = event.target;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n      function handleFocusOut(event) {\n        if (focusScope.paused || !container)\n          return;\n        if (!container.contains(event.relatedTarget)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n      document.addEventListener(\"focusin\", handleFocusIn);\n      document.addEventListener(\"focusout\", handleFocusOut);\n      return () => {\n        document.removeEventListener(\"focusin\", handleFocusIn);\n        document.removeEventListener(\"focusout\", handleFocusOut);\n      };\n    }, [trapped, forceUnmount, container, focusScope.paused]);\n    React.useEffect(() => {\n      if (!container)\n        return;\n      if (forceUnmount)\n        return;\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n        container.dispatchEvent(unmountEvent);\n        if (!unmountEvent.defaultPrevented) {\n          focus(previouslyFocusedElement ?? document.body, { select: true });\n        }\n        container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n        focusScopesStack.remove(focusScope);\n      };\n    }, [container, forceUnmount, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n    const handleKeyDown = React.useCallback(\n      (event) => {\n        if (!(loop || trapped))\n          return;\n        if (focusScope.paused)\n          return;\n        const isTabKey = event.key === \"Tab\" && !event.altKey && !event.ctrlKey && !event.metaKey;\n        const focusedElement = document.activeElement;\n        if (isTabKey && focusedElement) {\n          const container2 = event.currentTarget;\n          const [first, last] = getTabbableEdges(container2);\n          const hasTabbableElementsInside = first && last;\n          if (!hasTabbableElementsInside) {\n            if (focusedElement === container2)\n              event.preventDefault();\n          } else {\n            if (!event.shiftKey && focusedElement === last) {\n              event.preventDefault();\n              if (loop)\n                focus(first, { select: true });\n            } else if (event.shiftKey && focusedElement === first) {\n              event.preventDefault();\n              if (loop)\n                focus(last, { select: true });\n            }\n          }\n        }\n      },\n      [loop, trapped, focusScope.paused]\n    );\n    const child = React.Children.only(children);\n    return React.cloneElement(child, {\n      tabIndex: -1,\n      ...scopeProps,\n      ref: composedRefs,\n      onKeyDown: handleKeyDown\n    });\n  }\n);\nFocusScope.displayName = FOCUS_SCOPE_NAME;\nfunction focusFirst(candidates, { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement)\n      return;\n  }\n}\nfunction getTabbableEdges(container) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last];\n}\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node) => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode())\n    nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction findVisible(elements, container) {\n  for (const element of elements) {\n    if (!isHidden(element, { upTo: container }))\n      return element;\n  }\n}\nfunction isHidden(node, { upTo }) {\n  if (getComputedStyle(node).visibility === \"hidden\")\n    return true;\n  while (node) {\n    if (upTo !== void 0 && node === upTo)\n      return false;\n    if (getComputedStyle(node).display === \"none\")\n      return true;\n    node = node.parentElement;\n  }\n  return false;\n}\nfunction isSelectableInput(element) {\n  return element instanceof HTMLInputElement && \"select\" in element;\n}\nfunction focus(element, { select = false } = {}) {\n  if (element == null ? void 0 : element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    element.focus({ preventScroll: true });\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\nconst focusScopesStack = createFocusScopesStack();\nfunction createFocusScopesStack() {\n  let stack = [];\n  return {\n    add(focusScope) {\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope == null ? void 0 : activeFocusScope.pause();\n      }\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n    remove(focusScope) {\n      var _a;\n      stack = arrayRemove(stack, focusScope);\n      (_a = stack[0]) == null ? void 0 : _a.resume();\n    }\n  };\n}\nfunction arrayRemove(array, item) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\nfunction removeLinks(items) {\n  return items.filter((item) => item.tagName !== \"A\");\n}\nexport {\n  FocusScope\n};\n//# sourceMappingURL=FocusScope.mjs.map\n","export * from \"./FocusScope\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { composeRefs } from \"@tamagui/compose-refs\";\nimport { isTamaguiComponent, useEvent } from \"@tamagui/web\";\nimport { forwardRef, useCallback, useEffect, useRef } from \"react\";\nimport { registerFocusable } from \"./registerFocusable\";\nfunction focusableInputHOC(Component) {\n  const component = Component.extractable(\n    forwardRef(\n      (props, ref) => {\n        const isInput = isTamaguiComponent(Component) && Component.staticConfig.isInput;\n        const inputValue = useRef(props.value || props.defaultValue || \"\");\n        const unregisterFocusable = useRef();\n        const inputRef = useCallback(\n          (input) => {\n            var _a;\n            if (!props.id)\n              return;\n            if (!input)\n              return;\n            (_a = unregisterFocusable.current) == null ? void 0 : _a.call(unregisterFocusable);\n            unregisterFocusable.current = registerFocusable(props.id, {\n              focus: input.focus,\n              ...isInput && {\n                // react-native doesn't support programmatic .select()\n                focusAndSelect() {\n                  input.focus();\n                  if (input.setSelection && typeof inputValue.current === \"string\") {\n                    input.setSelection(0, inputValue.current.length);\n                  }\n                }\n              }\n            });\n          },\n          [isInput, props.id]\n        );\n        const combinedRefs = composeRefs(ref, inputRef);\n        useEffect(() => {\n          return () => {\n            var _a;\n            (_a = unregisterFocusable.current) == null ? void 0 : _a.call(unregisterFocusable);\n          };\n        }, []);\n        const onChangeText = useEvent((value) => {\n          var _a;\n          inputValue.current = value;\n          (_a = props.onChangeText) == null ? void 0 : _a.call(props, value);\n        });\n        const finalProps = isInput ? {\n          ...props,\n          onChangeText\n        } : props;\n        return /* @__PURE__ */ jsx(Component, { ref: combinedRefs, ...finalProps });\n      }\n    )\n  );\n  return component;\n}\nexport {\n  focusableInputHOC\n};\n//# sourceMappingURL=focusableInputHOC.mjs.map\n","const registerFocusable = (id, input) => () => {\n};\nconst unregisterFocusable = (id) => {\n};\nconst focusFocusable = (id) => {\n};\nexport {\n  focusFocusable,\n  registerFocusable,\n  unregisterFocusable\n};\n//# sourceMappingURL=registerFocusable.mjs.map\n","import { getConfig, isVariable } from \"@tamagui/core\";\nconst getFontSize = (inSize, opts) => {\n  const res = getFontSizeVariable(inSize, opts);\n  if (isVariable(res)) {\n    return +res.val;\n  }\n  return res ? +res : 16;\n};\nconst getFontSizeVariable = (inSize, opts) => {\n  const token = getFontSizeToken(inSize, opts);\n  if (!token) {\n    return inSize;\n  }\n  const conf = getConfig();\n  return conf.fontsParsed[(opts == null ? void 0 : opts.font) || \"$body\"].size[token];\n};\nconst getFontSizeToken = (inSize, opts) => {\n  if (typeof inSize === \"number\") {\n    return null;\n  }\n  const relativeSize = (opts == null ? void 0 : opts.relativeSize) || 0;\n  const conf = getConfig();\n  const fontSize = conf.fontsParsed[(opts == null ? void 0 : opts.font) || \"$body\"].size;\n  const size = inSize || (\"$true\" in fontSize ? \"$true\" : \"$4\");\n  const sizeTokens = Object.keys(fontSize);\n  let foundIndex = sizeTokens.indexOf(size);\n  if (foundIndex === -1) {\n    if (size.endsWith(\".5\")) {\n      foundIndex = sizeTokens.indexOf(size.replace(\".5\", \"\"));\n    }\n  }\n  if (process.env.NODE_ENV === \"development\") {\n    if (foundIndex === -1) {\n      console.warn(\"No font size found\", size, opts, \"in size tokens\", sizeTokens);\n    }\n  }\n  const tokenIndex = Math.min(\n    Math.max(0, foundIndex + relativeSize),\n    sizeTokens.length - 1\n  );\n  return sizeTokens[tokenIndex] ?? size;\n};\nexport {\n  getFontSize,\n  getFontSizeToken,\n  getFontSizeVariable\n};\n//# sourceMappingURL=getFontSize.mjs.map\n","export * from \"./getFontSize\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport {\n  Stack,\n  composeEventHandlers,\n  styled,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport { cloneElement, forwardRef } from \"react\";\nconst FORM_NAME = \"Form\";\nconst FormFrame = styled(Stack, {\n  name: FORM_NAME,\n  tag: \"form\"\n});\nconst [createFormContext] = createContextScope(FORM_NAME);\nconst [FormProvider, useFormContext] = createFormContext(FORM_NAME);\nconst TRIGGER_NAME = \"FormTrigger\";\nconst FormTriggerFrame = styled(Stack, {\n  name: TRIGGER_NAME\n});\nconst FormTrigger = FormTriggerFrame.extractable(\n  forwardRef(\n    (props, forwardedRef) => {\n      const { __scopeForm, children, ...triggerProps } = props;\n      const context = useFormContext(TRIGGER_NAME, __scopeForm);\n      return /* @__PURE__ */ jsx(\n        FormTriggerFrame,\n        {\n          tag: \"button\",\n          ...triggerProps,\n          children: triggerProps.asChild ? cloneElement(children, { disabled: triggerProps.disabled }) : children,\n          ref: forwardedRef,\n          onPress: composeEventHandlers(props.onPress, context.onSubmit)\n        }\n      );\n    }\n  )\n);\nfunction FormComponent({\n  onSubmit,\n  ...props\n}) {\n  return /* @__PURE__ */ jsx(FormProvider, { scope: props.__scopeForm, onSubmit, children: /* @__PURE__ */ jsx(FormFrame, { ...props, onSubmit: (e) => e.preventDefault() }) });\n}\nconst Form = withStaticProperties(FormFrame.extractable(FormComponent), {\n  Trigger: FormTrigger\n});\nexport {\n  Form,\n  FormFrame,\n  FormProvider,\n  FormTrigger,\n  useFormContext\n};\n//# sourceMappingURL=Form.mjs.map\n","export * from \"./Form\";\n//# sourceMappingURL=index.js.map\n","import { getSize, stepTokenUpOrDown } from \"@tamagui/get-size\";\nconst getButtonSized = (val, { tokens }) => {\n  if (typeof val === \"number\") {\n    return {\n      paddingHorizontal: val * 0.25,\n      height: val,\n      borderRadius: val * 0.2\n    };\n  }\n  const ySize = getSize(val, 0);\n  const xSize = stepTokenUpOrDown(\"space\", val);\n  const radiusToken = tokens.radius[val] ?? tokens.radius[\"$true\"];\n  return {\n    paddingHorizontal: xSize,\n    height: ySize,\n    borderRadius: radiusToken\n  };\n};\nexport {\n  getButtonSized\n};\n//# sourceMappingURL=index.mjs.map\n","import { getTokens, tokensKeysOrdered } from \"@tamagui/core\";\nconst getSize = (size, shift = 0, bounds = [0]) => {\n  return stepTokenUpOrDown(\"size\", size, shift, bounds);\n};\nconst stepTokenUpOrDown = (type, name = \"$true\", shift = 0, bounds = [0]) => {\n  const tokens = getTokens({ prefixed: true })[type];\n  const maybeTokenizedKeysOrdered = tokensKeysOrdered.get(tokens) || Object.keys(tokens);\n  const keysOrdered = maybeTokenizedKeysOrdered.map((maybeTokenizedKey) => maybeTokenizedKey.charAt(0) === \"$\" ? maybeTokenizedKey : `$${maybeTokenizedKey}`);\n  const min = bounds[0] ?? 0;\n  const max = bounds[1] ?? keysOrdered.length - 1;\n  const currentIndex = keysOrdered.indexOf(name);\n  if (name === \"$true\") {\n    shift += shift === 0 ? 0 : shift > 0 ? 1 : -1;\n  }\n  const index = Math.min(max, Math.max(min, currentIndex + shift));\n  const key = keysOrdered[index];\n  return tokens[key] || tokens[\"$true\"];\n};\nexport {\n  getSize,\n  stepTokenUpOrDown\n};\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport {\n  getConfig,\n  getExpandedShorthands,\n  getTokens,\n  getVariableValue,\n  isTamaguiElement,\n  mergeProps,\n  spacedChildren,\n  styled,\n  useMediaPropsActive,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport { ThemeableStack } from \"@tamagui/stacks\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport React, { Children, forwardRef, isValidElement } from \"react\";\nimport { ScrollView } from \"react-native\";\nimport { useIndex, useIndexedChildren } from \"reforest\";\nconst GROUP_NAME = \"Group\";\nconst [createGroupContext, createGroupScope] = createContextScope(GROUP_NAME);\nconst [GroupProvider, useGroupContext] = createGroupContext(GROUP_NAME);\nconst GroupFrame = styled(ThemeableStack, {\n  name: \"GroupFrame\",\n  variants: {\n    unstyled: {\n      false: {\n        size: \"$true\",\n        y: 0,\n        backgroundColor: \"$background\"\n      }\n    },\n    size: (val, { tokens }) => {\n      const borderRadius = tokens.radius[val] ?? val ?? tokens.radius[\"$true\"];\n      return {\n        borderRadius\n      };\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nfunction createGroup(verticalDefault) {\n  return withStaticProperties(\n    forwardRef((props, ref) => {\n      const activeProps = useMediaPropsActive(props);\n      const {\n        __scopeGroup,\n        children: childrenProp,\n        space,\n        size = \"$true\",\n        spaceDirection,\n        separator,\n        scrollable,\n        axis = verticalDefault ? \"vertical\" : \"horizontal\",\n        orientation = axis,\n        disabled: disabledProp,\n        disablePassBorderRadius: disablePassBorderRadiusProp,\n        borderRadius,\n        forceUseItem,\n        ...restProps\n      } = getExpandedShorthands(activeProps);\n      const vertical = orientation === \"vertical\";\n      const [itemChildrenCount, setItemChildrenCount] = useControllableState({\n        defaultProp: forceUseItem ? 1 : 0\n      });\n      const isUsingItems = true;\n      const radius = borderRadius ?? (size ? getVariableValue(getTokens().radius[size]) - 1 : void 0);\n      const hasRadius = radius !== void 0;\n      const disablePassBorderRadius = disablePassBorderRadiusProp ?? !hasRadius;\n      if (!isUsingItems)\n        console.log(\"screw up!\");\n      const childrenArray = Children.toArray(childrenProp);\n      const children = isUsingItems ? childrenProp : childrenArray.map((child, i) => {\n        if (!isValidElement(child)) {\n          return child;\n        }\n        const disabled = child.props.disabled ?? disabledProp;\n        const isFirst = i === 0;\n        const isLast = i === childrenArray.length - 1;\n        const radiusStyles = disablePassBorderRadius === true ? null : getBorderRadius({\n          isFirst,\n          isLast,\n          radius,\n          vertical,\n          disable: disablePassBorderRadius\n        });\n        const props2 = {\n          disabled,\n          ...isTamaguiElement(child) ? radiusStyles : { style: radiusStyles }\n        };\n        return cloneElementWithPropOrder(child, props2);\n      });\n      const indexedChildren = useIndexedChildren(\n        spacedChildren({\n          direction: spaceDirection,\n          separator,\n          space,\n          children\n        })\n      );\n      const onItemMount = React.useCallback(\n        () => setItemChildrenCount((prev) => prev + 1),\n        []\n      );\n      const onItemUnmount = React.useCallback(\n        () => setItemChildrenCount((prev) => prev - 1),\n        []\n      );\n      return /* @__PURE__ */ jsx(\n        GroupProvider,\n        {\n          disablePassBorderRadius,\n          vertical: orientation === \"vertical\",\n          radius,\n          disabled: disabledProp,\n          onItemMount,\n          onItemUnmount,\n          scope: __scopeGroup,\n          children: /* @__PURE__ */ jsx(\n            GroupFrame,\n            {\n              ref,\n              size,\n              flexDirection: orientation === \"horizontal\" ? \"row\" : \"column\",\n              borderRadius,\n              ...restProps,\n              children: wrapScroll({ ...activeProps, orientation }, indexedChildren)\n            }\n          )\n        }\n      );\n    }),\n    {\n      Item: GroupItem\n    }\n  );\n}\nconst GroupItem = (props) => {\n  var _a;\n  const { __scopeGroup, children } = props;\n  const groupItemProps = useGroupItem(\n    { disabled: isValidElement(children) ? children.props.disabled : void 0 },\n    __scopeGroup\n  );\n  if (!isValidElement(children)) {\n    return children;\n  }\n  if (isTamaguiElement(children)) {\n    return React.cloneElement(children, groupItemProps);\n  }\n  return React.cloneElement(children, {\n    style: {\n      ...(_a = children.props) == null ? void 0 : _a[\"style\"],\n      ...groupItemProps\n    }\n  });\n};\nconst useGroupItem = (childrenProps, __scopeGroup) => {\n  const treeIndex = useIndex();\n  const context = useGroupContext(\"GroupItem\", __scopeGroup);\n  React.useEffect(() => {\n    context.onItemMount();\n    return () => {\n      context.onItemUnmount();\n    };\n  }, []);\n  if (!treeIndex) {\n    throw Error(\"<Group.Item/> should only be used within a <Group/>\");\n  }\n  const isFirst = treeIndex.index === 0;\n  const isLast = treeIndex.index === treeIndex.maxIndex;\n  const disabled = childrenProps.disabled ?? context.disabled;\n  let propsToPass = {\n    disabled\n  };\n  if (context.disablePassBorderRadius !== true) {\n    const borderRadius = getBorderRadius({\n      radius: context.radius,\n      isFirst,\n      isLast,\n      vertical: context.vertical,\n      disable: context.disablePassBorderRadius\n    });\n    return { ...propsToPass, ...borderRadius };\n  }\n  return propsToPass;\n};\nconst Group = createGroup(true);\nconst YGroup = Group;\nconst XGroup = createGroup(false);\nconst wrapScroll = ({ scrollable, orientation, showScrollIndicator = false }, children) => {\n  if (scrollable)\n    return /* @__PURE__ */ jsx(\n      ScrollView,\n      {\n        ...orientation === \"vertical\" && {\n          showsVerticalScrollIndicator: showScrollIndicator\n        },\n        ...orientation === \"horizontal\" && {\n          horizontal: true,\n          showsHorizontalScrollIndicator: showScrollIndicator\n        },\n        children\n      }\n    );\n  return children;\n};\nconst getBorderRadius = ({\n  isFirst,\n  isLast,\n  radius,\n  vertical,\n  disable\n}) => {\n  return {\n    borderTopLeftRadius: isFirst && disable !== \"top\" && disable !== \"start\" ? radius : 0,\n    borderTopRightRadius: disable !== \"top\" && disable !== \"end\" && (vertical && isFirst || !vertical && isLast) ? radius : 0,\n    borderBottomLeftRadius: disable !== \"bottom\" && disable !== \"start\" && (vertical && isLast || !vertical && isFirst) ? radius : 0,\n    borderBottomRightRadius: isLast && disable !== \"bottom\" && disable !== \"end\" ? radius : 0\n  };\n};\nconst cloneElementWithPropOrder = (child, props) => {\n  const next = mergeProps(child.props, props, false, getConfig().shorthands)[0];\n  return React.cloneElement({ ...child, props: null }, next);\n};\nexport {\n  Group,\n  GroupFrame,\n  XGroup,\n  YGroup,\n  useGroupItem\n};\n//# sourceMappingURL=Group.mjs.map\n","export * from \"./Group\";\n//# sourceMappingURL=index.mjs.map\n","import { getTokens } from \"@tamagui/core\";\nconst getSpace = (token, sizeUpOrDownBy = 0) => {\n  const spaces = getTokens().space;\n  const spaceNames = Object.keys(spaces);\n  const key = spaceNames[Math.max(0, spaceNames.indexOf(String(token || \"$true\")) + sizeUpOrDownBy)];\n  return spaces[key] || spaces[\"$true\"];\n};\nexport {\n  getSpace\n};\n//# sourceMappingURL=getSpace.mjs.map\n","export * from \"@tamagui/helpers\";\nexport * from \"./prevent\";\nexport * from \"./getSpace\";\nexport * from \"./useCurrentColor\";\nexport * from \"./useGetThemedIcon\";\n//# sourceMappingURL=index.mjs.map\n","const prevent = (e) => [e.preventDefault(), e.stopPropagation()];\nexport {\n  prevent\n};\n//# sourceMappingURL=prevent.mjs.map\n","import {\n  useTheme,\n  variableToString\n} from \"@tamagui/core\";\nconst useCurrentColor = (colorProp) => {\n  const theme = useTheme();\n  return variableToString(theme[colorProp] || colorProp || theme.color);\n};\nexport {\n  useCurrentColor\n};\n//# sourceMappingURL=useCurrentColor.mjs.map\n","import { cloneElement, createElement, isValidElement } from \"react\";\nimport { useCurrentColor } from \"./useCurrentColor\";\nconst useGetThemedIcon = (props) => {\n  const color = useCurrentColor(props.color);\n  return (el) => {\n    if (!el)\n      return el;\n    if (isValidElement(el)) {\n      return cloneElement(el, {\n        ...props,\n        // @ts-expect-error\n        ...el.props\n      });\n    }\n    return createElement(el, props);\n  };\n};\nexport {\n  useGetThemedIcon\n};\n//# sourceMappingURL=useGetThemedIcon.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport {\n  isWeb,\n  setupReactNative,\n  styled,\n  useMediaPropsActive\n} from \"@tamagui/core\";\nimport { forwardRef } from \"react\";\nimport { Image as RNImage } from \"react-native\";\nsetupReactNative({\n  Image: RNImage\n});\nconst StyledImage = styled(RNImage, {\n  name: \"Image\",\n  position: \"relative\",\n  source: { uri: \"\" },\n  zIndex: 1\n});\nlet hasWarned = false;\nconst Image = StyledImage.extractable(\n  forwardRef((inProps, ref) => {\n    const props = useMediaPropsActive(inProps);\n    const { src, source, ...rest } = props;\n    if (process.env.NODE_ENV === \"development\") {\n      if (typeof src === \"string\") {\n        if (typeof props.width === \"string\" && props.width[0] !== \"$\" || typeof props.height === \"string\" && props.height[0] !== \"$\") {\n          if (!hasWarned) {\n            hasWarned = true;\n            console.warn(\n              `React Native expects a numerical width/height. If you want to use a percent you must define the \"source\" prop with width, height, and uri.`\n            );\n          }\n        }\n      }\n    }\n    const finalSource = typeof src === \"string\" ? { uri: src, ...isWeb && { width: props.width, height: props.height } } : source ?? src;\n    return /* @__PURE__ */ jsx(StyledImage, { ref, source: finalSource, ...rest });\n  })\n);\nImage.getSize = RNImage.getSize;\nImage.getSizeWithHeaders = RNImage.getSizeWithHeaders;\nImage.prefetch = RNImage.prefetch;\nImage.prefetchWithMetadata = RNImage.prefetchWithMetadata;\nImage.abortPrefetch = RNImage.abortPrefetch;\nImage.queryCache = RNImage.queryCache;\nexport {\n  Image\n};\n//# sourceMappingURL=Image.mjs.map\n","export * from \"./Image\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { useComposedRefs } from \"@tamagui/compose-refs\";\nimport { createContext } from \"@tamagui/create-context\";\nimport { focusFocusable } from \"@tamagui/focusable\";\nimport { getButtonSized } from \"@tamagui/get-button-sized\";\nimport { getFontSized } from \"@tamagui/get-font-sized\";\nimport { SizableText } from \"@tamagui/text\";\nimport { isWeb, styled, themeable } from \"@tamagui/web\";\nimport * as React from \"react\";\nconst NAME = \"Label\";\nconst [LabelProvider, useLabelContextImpl] = createContext(NAME, {\n  id: void 0,\n  controlRef: { current: null }\n});\nconst LabelFrame = styled(SizableText, {\n  name: \"Label\",\n  tag: \"label\",\n  variants: {\n    unstyled: {\n      false: {\n        size: \"$true\",\n        color: \"$color\",\n        backgroundColor: \"transparent\",\n        display: \"flex\",\n        alignItems: \"center\",\n        userSelect: \"none\",\n        cursor: \"default\",\n        pressStyle: {\n          color: \"$colorPress\"\n        }\n      }\n    },\n    size: {\n      \"...size\": (val, extras) => {\n        const buttonStyle = getButtonSized(val, extras);\n        return {\n          ...getFontSized(val, extras),\n          height: buttonStyle.height,\n          lineHeight: buttonStyle.height\n        };\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst LabelComponent = React.forwardRef(\n  (props, forwardedRef) => {\n    const { htmlFor, id: idProp, ...labelProps } = props;\n    const controlRef = React.useRef(null);\n    const ref = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const backupId = React.useId();\n    const id = idProp ?? backupId;\n    if (isWeb) {\n      React.useEffect(() => {\n        if (htmlFor) {\n          const element = document.getElementById(htmlFor);\n          const label = ref.current;\n          if (label && element) {\n            const getAriaLabel = () => element.getAttribute(\"aria-labelledby\");\n            const ariaLabelledBy = [id, getAriaLabel()].filter(Boolean).join(\" \");\n            element.setAttribute(\"aria-labelledby\", ariaLabelledBy);\n            controlRef.current = element;\n            return () => {\n              var _a;\n              if (!id)\n                return;\n              const ariaLabelledBy2 = (_a = getAriaLabel()) == null ? void 0 : _a.replace(id, \"\");\n              if (ariaLabelledBy2 === \"\") {\n                element.removeAttribute(\"aria-labelledby\");\n              } else if (ariaLabelledBy2) {\n                element.setAttribute(\"aria-labelledby\", ariaLabelledBy2);\n              }\n            };\n          }\n        }\n      }, [id, htmlFor]);\n    }\n    return /* @__PURE__ */ jsx(LabelProvider, { id, controlRef, children: /* @__PURE__ */ jsx(\n      LabelFrame,\n      {\n        role: \"heading\",\n        id,\n        htmlFor,\n        ...labelProps,\n        ref: composedRefs,\n        onMouseDown: (event) => {\n          var _a;\n          (_a = props.onMouseDown) == null ? void 0 : _a.call(props, event);\n          if (!event.defaultPrevented && event.detail > 1) {\n            event.preventDefault();\n          }\n        },\n        onPress: (event) => {\n          var _a;\n          (_a = props.onPress) == null ? void 0 : _a.call(props, event);\n          if (isWeb) {\n            if (htmlFor || !controlRef.current || event.defaultPrevented)\n              return;\n            const isClickingControl = controlRef.current.contains(\n              event.target\n            );\n            const isUserClick = event.isTrusted === true;\n            if (!isClickingControl && isUserClick) {\n              controlRef.current.click();\n              controlRef.current.focus();\n            }\n          } else {\n            if (props.htmlFor) {\n              focusFocusable(props.htmlFor);\n            }\n          }\n        }\n      }\n    ) });\n  }\n);\nLabelComponent.displayName = NAME;\nconst Label = LabelFrame.extractable(themeable(LabelComponent), {\n  neverFlatten: true\n});\nconst useLabelContext = (element) => {\n  const context = useLabelContextImpl(\"LabelConsumer\");\n  const { controlRef } = context;\n  React.useEffect(() => {\n    if (element)\n      controlRef.current = element;\n  }, [element, controlRef]);\n  return context.id;\n};\nconst Root = Label;\nexport {\n  Label,\n  LabelFrame,\n  useLabelContext\n};\n//# sourceMappingURL=Label.mjs.map\n","export * from \"./Label\";\n//# sourceMappingURL=index.mjs.map\n","import { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nimport {\n  Spacer,\n  getTokens,\n  getVariableValue,\n  styled,\n  themeable,\n  useMediaPropsActive,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { getFontSize } from \"@tamagui/font-size\";\nimport { getSpace, useGetThemedIcon } from \"@tamagui/helpers-tamagui\";\nimport { ThemeableStack, YStack } from \"@tamagui/stacks\";\nimport { SizableText, wrapChildrenInText } from \"@tamagui/text\";\nimport { forwardRef } from \"react\";\nconst NAME = \"ListItem\";\nconst ListItemFrame = styled(ThemeableStack, {\n  name: NAME,\n  tag: \"li\",\n  variants: {\n    unstyled: {\n      false: {\n        size: \"$true\",\n        alignItems: \"center\",\n        flexWrap: \"nowrap\",\n        width: \"100%\",\n        borderColor: \"$borderColor\",\n        maxWidth: \"100%\",\n        overflow: \"hidden\",\n        flexDirection: \"row\",\n        backgroundColor: \"$background\"\n      }\n    },\n    size: {\n      \"...size\": (val, { tokens }) => {\n        return {\n          minHeight: tokens.size[val],\n          paddingHorizontal: tokens.space[val],\n          paddingVertical: getSpace(val, -2)\n        };\n      }\n    },\n    active: {\n      true: {\n        hoverStyle: {\n          backgroundColor: \"$background\"\n        }\n      }\n    },\n    disabled: {\n      true: {\n        opacity: 0.5,\n        // TODO breaking types\n        pointerEvents: \"none\"\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst ListItemText = styled(SizableText, {\n  name: \"ListItemText\",\n  variants: {\n    unstyled: {\n      false: {\n        color: \"$color\",\n        flexGrow: 1,\n        flexShrink: 1,\n        ellipse: true,\n        cursor: \"default\"\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst ListItemSubtitle = styled(ListItemText, {\n  name: \"ListItemSubtitle\",\n  variants: {\n    unstyled: {\n      false: {\n        opacity: 0.6,\n        maxWidth: \"100%\",\n        size: \"$3\",\n        color: \"$color\"\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst ListItemTitle = styled(ListItemText, {\n  name: \"ListItemTitle\"\n});\nconst useListItem = (props, {\n  Text = ListItemText,\n  Subtitle = ListItemSubtitle,\n  Title = ListItemTitle\n} = { Text: ListItemText, Subtitle: ListItemSubtitle, Title: ListItemTitle }) => {\n  const {\n    children,\n    icon,\n    iconAfter,\n    noTextWrap,\n    theme: themeName,\n    space,\n    spaceFlex,\n    scaleIcon = 1,\n    scaleSpace = 1,\n    subTitle,\n    // text props\n    color,\n    fontWeight,\n    letterSpacing,\n    fontSize,\n    fontFamily,\n    textAlign,\n    textProps,\n    title,\n    ...rest\n  } = props;\n  const mediaActiveProps = useMediaPropsActive(props);\n  const size = mediaActiveProps.size || \"$true\";\n  const subtitleSize = `$${+String(size).replace(\"$\", \"\") - 1}`;\n  const iconSize = getFontSize(size) * scaleIcon;\n  const getThemedIcon = useGetThemedIcon({ size: iconSize, color });\n  const [themedIcon, themedIconAfter] = [icon, iconAfter].map(getThemedIcon);\n  const spaceSize = getVariableValue(getTokens().space[mediaActiveProps.space] ?? iconSize) * scaleSpace;\n  const contents = wrapChildrenInText(Text, mediaActiveProps);\n  return {\n    props: {\n      fontFamily,\n      ...rest,\n      children: /* @__PURE__ */ jsxs(Fragment, { children: [\n        themedIcon ? /* @__PURE__ */ jsxs(Fragment, { children: [\n          themedIcon,\n          /* @__PURE__ */ jsx(Spacer, { size: spaceSize })\n        ] }) : null,\n        title || subTitle ? /* @__PURE__ */ jsxs(YStack, { flex: 1, children: [\n          noTextWrap === \"all\" ? title : /* @__PURE__ */ jsx(Title, { size, children: title }),\n          subTitle ? /* @__PURE__ */ jsx(Fragment, { children: typeof subTitle === \"string\" && noTextWrap !== \"all\" ? (\n            // TODO can use theme but we need to standardize to alt themes\n            // or standardize on subtle colors in themes\n            /* @__PURE__ */ jsx(Subtitle, { size: subtitleSize, children: subTitle })\n          ) : subTitle }) : null,\n          contents\n        ] }) : contents,\n        themedIconAfter ? /* @__PURE__ */ jsxs(Fragment, { children: [\n          /* @__PURE__ */ jsx(Spacer, { size: spaceSize }),\n          themedIconAfter\n        ] }) : null\n      ] })\n    }\n  };\n};\nconst ListItemComponent = forwardRef((props, ref) => {\n  const { props: listItemProps } = useListItem(props);\n  return /* @__PURE__ */ jsx(ListItemFrame, { ref, justifyContent: \"space-between\", ...listItemProps });\n});\nconst listItemStaticConfig = {\n  inlineProps: /* @__PURE__ */ new Set([\n    // text props go here (can't really optimize them, but we never fully extract listItem anyway)\n    \"color\",\n    \"fontWeight\",\n    \"fontSize\",\n    \"fontFamily\",\n    \"letterSpacing\",\n    \"textAlign\"\n  ])\n};\nconst ListItem = withStaticProperties(\n  ListItemFrame.extractable(\n    themeable(ListItemComponent, { componentName: NAME }),\n    listItemStaticConfig\n  ),\n  {\n    Text: ListItemText,\n    Subtitle: ListItemSubtitle\n  }\n);\nexport {\n  ListItem,\n  ListItemFrame,\n  ListItemSubtitle,\n  ListItemText,\n  ListItemTitle,\n  listItemStaticConfig,\n  useListItem\n};\n//# sourceMappingURL=ListItem.mjs.map\n","export * from \"./ListItem\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport {\n  getTokens,\n  getVariable,\n  getVariableValue,\n  useMediaPropsActive,\n  useTheme\n} from \"@tamagui/core\";\nfunction themed(Component) {\n  const wrapped = (propsIn) => {\n    const props = useMediaPropsActive(propsIn);\n    const theme = useTheme();\n    const color = getVariable(\n      (props.color in theme ? theme[props.color] : void 0) || props.color || (!props.disableTheme ? theme.color : null) || \"#000\"\n    );\n    const size = typeof props.size === \"string\" ? getVariableValue(getTokens().size[props.size] || props.size) : props.size;\n    return /* @__PURE__ */ jsx(Component, { ...props, color, size });\n  };\n  return wrapped;\n}\nexport {\n  themed\n};\n//# sourceMappingURL=themed.mjs.map\n","import { jsx, jsxs } from \"react/jsx-runtime\";\nimport \"@tamagui/polyfill-dev\";\nimport { Adapt, useAdaptParent } from \"@tamagui/adapt\";\nimport { AnimatePresence } from \"@tamagui/animate-presence\";\nimport { hideOthers } from \"@tamagui/aria-hidden\";\nimport { useComposedRefs } from \"@tamagui/compose-refs\";\nimport {\n  Stack,\n  Theme,\n  composeEventHandlers,\n  isWeb,\n  useEvent,\n  useGet,\n  useMedia,\n  useThemeName,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport { FloatingOverrideContext } from \"@tamagui/floating\";\nimport { FocusScope } from \"@tamagui/focus-scope\";\nimport {\n  Popper,\n  PopperAnchor,\n  PopperArrow,\n  PopperContent,\n  PopperContentFrame,\n  PopperProvider,\n  createPopperScope,\n  usePopperContext\n} from \"@tamagui/popper\";\nimport { Portal, PortalHost, PortalItem } from \"@tamagui/portal\";\nimport { RemoveScroll } from \"@tamagui/remove-scroll\";\nimport { ControlledSheet, SheetController } from \"@tamagui/sheet\";\nimport { YStack } from \"@tamagui/stacks\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport * as React from \"react\";\nimport { Platform, ScrollView } from \"react-native\";\nimport { useFloatingContext } from \"./useFloatingContext\";\nconst POPOVER_NAME = \"Popover\";\nconst [createPopoverContext, createPopoverScopeInternal] = createContextScope(\n  POPOVER_NAME,\n  [createPopperScope]\n);\nconst usePopoverScope = createPopperScope();\nconst createPopoverScope = createPopoverScopeInternal;\nconst [PopoverProviderInternal, usePopoverInternalContext] = createPopoverContext(POPOVER_NAME);\nconst __PopoverProviderInternal = PopoverProviderInternal;\nconst ANCHOR_NAME = \"PopoverAnchor\";\nconst PopoverAnchor = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopePopover, ...anchorProps } = props;\n    const context = usePopoverInternalContext(ANCHOR_NAME, __scopePopover);\n    const popperScope = usePopoverScope(__scopePopover);\n    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;\n    React.useEffect(() => {\n      onCustomAnchorAdd();\n      return () => onCustomAnchorRemove();\n    }, [onCustomAnchorAdd, onCustomAnchorRemove]);\n    return /* @__PURE__ */ jsx(PopperAnchor, { ...popperScope, ...anchorProps, ref: forwardedRef });\n  }\n);\nPopoverAnchor.displayName = ANCHOR_NAME;\nconst TRIGGER_NAME = \"PopoverTrigger\";\nconst PopoverTrigger = React.forwardRef((props, forwardedRef) => {\n  const { __scopePopover, ...triggerProps } = props;\n  const context = usePopoverInternalContext(TRIGGER_NAME, __scopePopover);\n  const popperScope = usePopoverScope(__scopePopover);\n  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n  const trigger = /* @__PURE__ */ jsx(\n    YStack,\n    {\n      \"aria-haspopup\": \"dialog\",\n      \"aria-expanded\": context.open,\n      \"data-state\": getState(context.open),\n      ...triggerProps,\n      ref: composedTriggerRef,\n      onPress: composeEventHandlers(props.onPress, context.onOpenToggle)\n    }\n  );\n  return context.hasCustomAnchor ? trigger : /* @__PURE__ */ jsx(PopperAnchor, { asChild: true, ...popperScope, children: trigger });\n});\nPopoverTrigger.displayName = TRIGGER_NAME;\nconst CONTENT_NAME = \"PopoverContent\";\nconst PopoverContent = PopperContentFrame.extractable(\n  React.forwardRef(\n    function PopoverContent2(props, forwardedRef) {\n      const {\n        allowPinchZoom,\n        trapFocus,\n        disableRemoveScroll = true,\n        zIndex,\n        ...contentImplProps\n      } = props;\n      const context = usePopoverInternalContext(CONTENT_NAME, props.__scopePopover);\n      const contentRef = React.useRef(null);\n      const composedRefs = useComposedRefs(forwardedRef, contentRef);\n      const isRightClickOutsideRef = React.useRef(false);\n      React.useEffect(() => {\n        if (!context.open)\n          return;\n        const content = contentRef.current;\n        if (content)\n          return hideOthers(content);\n      }, [context.open]);\n      return /* @__PURE__ */ jsx(PopoverContentPortal, { zIndex, children: /* @__PURE__ */ jsx(\n        PopoverContentImpl,\n        {\n          ...contentImplProps,\n          disableRemoveScroll,\n          ref: composedRefs,\n          trapFocus: trapFocus ?? context.open,\n          disableOutsidePointerEvents: true,\n          onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {\n            var _a;\n            event.preventDefault();\n            if (!isRightClickOutsideRef.current)\n              (_a = context.triggerRef.current) == null ? void 0 : _a.focus();\n          }),\n          onPointerDownOutside: composeEventHandlers(\n            props.onPointerDownOutside,\n            (event) => {\n              const originalEvent = event.detail.originalEvent;\n              const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n              const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n              isRightClickOutsideRef.current = isRightClick;\n            },\n            { checkDefaultPrevented: false }\n          ),\n          onFocusOutside: composeEventHandlers(\n            props.onFocusOutside,\n            (event) => event.preventDefault(),\n            { checkDefaultPrevented: false }\n          )\n        }\n      ) });\n    }\n  )\n);\nfunction PopoverContentPortal(props) {\n  const themeName = useThemeName();\n  const context = usePopoverInternalContext(CONTENT_NAME, props.__scopePopover);\n  let contents = props.children;\n  if (Platform.OS === \"android\") {\n    const popperContext = usePopperContext(CONTENT_NAME, context.popperScope);\n    contents = /* @__PURE__ */ jsx(PopperProvider, { ...popperContext, scope: context.popperScope, children: /* @__PURE__ */ jsx(PopoverProviderInternal, { scope: props.__scopePopover, ...context, children: props.children }) });\n  }\n  const zIndex = props.zIndex ?? 1e3;\n  return /* @__PURE__ */ jsx(Portal, { zIndex, children: /* @__PURE__ */ jsxs(Theme, { forceClassName: true, name: themeName, children: [\n    !!context.open && !context.breakpointActive && /* @__PURE__ */ jsx(\n      YStack,\n      {\n        fullscreen: true,\n        onPress: composeEventHandlers(props.onPress, context.onOpenToggle)\n      }\n    ),\n    /* @__PURE__ */ jsx(Stack, { zIndex: zIndex + 1, children: contents })\n  ] }) });\n}\nconst PopoverContentImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopePopover,\n    trapFocus,\n    onOpenAutoFocus,\n    onCloseAutoFocus,\n    disableOutsidePointerEvents,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    children,\n    disableRemoveScroll,\n    ...contentProps\n  } = props;\n  const popperScope = usePopoverScope(__scopePopover);\n  const context = usePopoverInternalContext(CONTENT_NAME, popperScope.__scopePopover);\n  if (context.breakpointActive) {\n    const childrenWithoutScrollView = React.Children.toArray(children).map((child) => {\n      if (React.isValidElement(child)) {\n        if (child.type === PopoverScrollView) {\n          return child.props.children;\n        }\n      }\n      return child;\n    });\n    return /* @__PURE__ */ jsx(PortalItem, { hostName: `${context.scopeKey}PopoverContents`, children: childrenWithoutScrollView });\n  }\n  return /* @__PURE__ */ jsx(AnimatePresence, { children: !!context.open && /* @__PURE__ */ jsx(\n    PopperContent,\n    {\n      \"data-state\": getState(context.open),\n      id: context.contentId,\n      pointerEvents: \"auto\",\n      ref: forwardedRef,\n      ...popperScope,\n      ...contentProps,\n      children: /* @__PURE__ */ jsx(\n        RemoveScroll,\n        {\n          enabled: disableRemoveScroll ? false : context.open,\n          allowPinchZoom: true,\n          removeScrollBar: false,\n          style: {\n            display: \"contents\"\n          },\n          children: trapFocus === false ? children : /* @__PURE__ */ jsx(\n            FocusScope,\n            {\n              loop: true,\n              trapped: trapFocus ?? context.open,\n              onMountAutoFocus: onOpenAutoFocus,\n              onUnmountAutoFocus: onCloseAutoFocus,\n              children: isWeb ? /* @__PURE__ */ jsx(\"div\", { style: { display: \"contents\" }, children }) : children\n            }\n          )\n        }\n      )\n    },\n    context.contentId\n  ) });\n});\nconst CLOSE_NAME = \"PopoverClose\";\nconst PopoverClose = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopePopover, ...closeProps } = props;\n    const context = usePopoverInternalContext(CLOSE_NAME, __scopePopover);\n    return /* @__PURE__ */ jsx(\n      YStack,\n      {\n        ...closeProps,\n        ref: forwardedRef,\n        onPress: composeEventHandlers(\n          props.onPress,\n          () => context.onOpenChange(false)\n        )\n      }\n    );\n  }\n);\nPopoverClose.displayName = CLOSE_NAME;\nconst ARROW_NAME = \"PopoverArrow\";\nconst PopoverArrow = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopePopover, ...arrowProps } = props;\n    const popperScope = usePopoverScope(__scopePopover);\n    return /* @__PURE__ */ jsx(PopperArrow, { ...popperScope, ...arrowProps, ref: forwardedRef });\n  }\n);\nPopoverArrow.displayName = ARROW_NAME;\nconst PopoverScrollView = React.forwardRef((props, ref) => {\n  return /* @__PURE__ */ jsx(ScrollView, { ref, ...props });\n});\nconst Popover = withStaticProperties(\n  function Popover2(props) {\n    const {\n      __scopePopover,\n      children,\n      open: openProp,\n      defaultOpen,\n      onOpenChange,\n      ...restProps\n    } = props;\n    const internalId = React.useId();\n    const id = __scopePopover ? Object.keys(__scopePopover)[0] : internalId;\n    const { when, AdaptProvider } = useAdaptParent({\n      Contents: React.useCallback(() => {\n        return /* @__PURE__ */ jsx(PortalHost, { name: `${id}PopoverContents` });\n      }, [])\n    });\n    const sheetBreakpoint = when;\n    const popperScope = usePopoverScope(__scopePopover);\n    const triggerRef = React.useRef(null);\n    const [hasCustomAnchor, setHasCustomAnchor] = React.useState(false);\n    const [open, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen || false,\n      onChange: onOpenChange,\n      transition: true\n    });\n    const breakpointActive = useSheetBreakpointActive(sheetBreakpoint);\n    const floatingContext = useFloatingContext({ open, setOpen, breakpointActive });\n    const popoverContext = {\n      scope: __scopePopover,\n      scopeKey: id,\n      popperScope: popperScope.__scopePopper,\n      sheetBreakpoint,\n      contentId: React.useId(),\n      triggerRef,\n      open,\n      breakpointActive,\n      onOpenChange: setOpen,\n      onOpenToggle: useEvent(() => {\n        if (open && breakpointActive) {\n          return;\n        }\n        setOpen(!open);\n      }),\n      hasCustomAnchor,\n      onCustomAnchorAdd: React.useCallback(() => setHasCustomAnchor(true), []),\n      onCustomAnchorRemove: React.useCallback(() => setHasCustomAnchor(false), [])\n    };\n    const contents = /* @__PURE__ */ jsx(Popper, { ...popperScope, stayInFrame: true, ...restProps, children: /* @__PURE__ */ jsx(PopoverProviderInternal, { ...popoverContext, children: /* @__PURE__ */ jsx(PopoverSheetController, { onOpenChange: setOpen, __scopePopover, children }) }) });\n    return /* @__PURE__ */ jsx(AdaptProvider, { children: isWeb ? /* @__PURE__ */ jsx(FloatingOverrideContext.Provider, { value: floatingContext, children: contents }) : contents });\n  },\n  {\n    Anchor: PopoverAnchor,\n    Arrow: PopoverArrow,\n    Trigger: PopoverTrigger,\n    Content: PopoverContent,\n    Close: PopoverClose,\n    Adapt,\n    ScrollView: PopoverScrollView,\n    Sheet: ControlledSheet\n  }\n);\nfunction getState(open) {\n  return open ? \"open\" : \"closed\";\n}\nconst PopoverSheetController = (props) => {\n  const context = usePopoverInternalContext(\n    \"PopoverSheetController\",\n    props.__scopePopover\n  );\n  const showSheet = useShowPopoverSheet(context);\n  const breakpointActive = context.breakpointActive;\n  const getShowSheet = useGet(showSheet);\n  return /* @__PURE__ */ jsx(\n    SheetController,\n    {\n      onOpenChange: (val) => {\n        if (getShowSheet()) {\n          props.onOpenChange(val);\n        }\n      },\n      open: context.open,\n      hidden: breakpointActive === false,\n      children: props.children\n    }\n  );\n};\nconst useSheetBreakpointActive = (breakpoint) => {\n  const media = useMedia();\n  if (typeof breakpoint === \"boolean\" || !breakpoint) {\n    return !!breakpoint;\n  }\n  return media[breakpoint];\n};\nconst useShowPopoverSheet = (context) => {\n  const breakpointActive = useSheetBreakpointActive(context.sheetBreakpoint);\n  return context.open === false ? false : breakpointActive;\n};\nexport {\n  Popover,\n  PopoverAnchor,\n  PopoverArrow,\n  PopoverClose,\n  PopoverContent,\n  PopoverTrigger,\n  __PopoverProviderInternal,\n  createPopoverScope,\n  usePopoverScope\n};\n//# sourceMappingURL=Popover.mjs.map\n","export * from \"./Popover\";\nexport * from \"./useFloatingContext\";\n//# sourceMappingURL=index.mjs.map\n","import { useDismiss, useFloating, useInteractions, useRole } from \"@floating-ui/react\";\nimport { useCallback } from \"react\";\nconst useFloatingContext = ({ open, setOpen, breakpointActive }) => useCallback(\n  (props) => {\n    const floating = useFloating({\n      ...props,\n      open,\n      onOpenChange: setOpen\n    });\n    const { getReferenceProps, getFloatingProps } = useInteractions([\n      // useFocus(floating.context, {\n      //   enabled: !breakpointActive,\n      //   keyboardOnly: true,\n      // }),\n      useRole(floating.context, { role: \"dialog\" }),\n      useDismiss(floating.context, {\n        enabled: !breakpointActive\n      })\n    ]);\n    return {\n      ...floating,\n      getReferenceProps,\n      getFloatingProps\n    };\n  },\n  [open, setOpen, breakpointActive]\n);\nexport {\n  useFloatingContext\n};\n//# sourceMappingURL=useFloatingContext.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { useComposedRefs } from \"@tamagui/compose-refs\";\nimport {\n  getVariableValue,\n  isWeb,\n  styled,\n  useIsomorphicLayoutEffect\n} from \"@tamagui/core\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport {\n  arrow,\n  autoUpdate,\n  flip,\n  offset,\n  shift,\n  useFloating\n} from \"@tamagui/floating\";\nimport { stepTokenUpOrDown } from \"@tamagui/get-size\";\nimport { ThemeableStack, YStack } from \"@tamagui/stacks\";\nimport * as React from \"react\";\nimport { Keyboard, useWindowDimensions } from \"react-native\";\nconst POPPER_NAME = \"Popper\";\nconst [createPopperContext, createScope] = createContextScope(POPPER_NAME);\nconst createPopperScope = createScope;\nconst [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);\nfunction Popper(props) {\n  const {\n    __scopePopper,\n    children,\n    size,\n    strategy = \"absolute\",\n    placement = \"bottom\",\n    stayInFrame,\n    allowFlip\n  } = props;\n  const [isMounted, setIsMounted] = React.useState(false);\n  useIsomorphicLayoutEffect(() => {\n    setIsMounted(true);\n  }, []);\n  const anchorRef = React.useRef();\n  const [arrowEl, setArrow] = React.useState(null);\n  const [arrowSize, setArrowSize] = React.useState(0);\n  const arrowRef = React.useRef();\n  const floating = useFloating({\n    strategy,\n    placement,\n    sameScrollView: false,\n    // this only takes effect on native\n    middleware: [\n      stayInFrame ? shift(typeof stayInFrame === \"boolean\" ? {} : stayInFrame) : null,\n      allowFlip ? flip(typeof allowFlip === \"boolean\" ? {} : allowFlip) : null,\n      arrowEl ? arrow({ element: arrowEl }) : null,\n      arrowSize ? offset(arrowSize) : null\n    ].filter(Boolean)\n  });\n  const { refs, middlewareData } = floating;\n  const composedArrowRefs = useComposedRefs(arrowRef, setArrow);\n  useIsomorphicLayoutEffect(() => {\n    floating.reference(anchorRef.current);\n  }, [anchorRef]);\n  if (isWeb) {\n    React.useEffect(() => {\n      if (!(refs.reference.current && refs.floating.current)) {\n        return;\n      }\n      return autoUpdate(refs.reference.current, refs.floating.current, floating.update);\n    }, [floating.update, refs.floating, refs.reference]);\n  } else {\n    const dimensions = useWindowDimensions();\n    const [keyboardOpen, setKeyboardOpen] = React.useState(false);\n    React.useEffect(() => {\n      const showSubscription = Keyboard.addListener(\"keyboardDidShow\", () => {\n        setKeyboardOpen(true);\n      });\n      const hideSubscription = Keyboard.addListener(\"keyboardDidHide\", () => {\n        setKeyboardOpen(false);\n      });\n      return () => {\n        showSubscription.remove();\n        hideSubscription.remove();\n      };\n    }, []);\n    useIsomorphicLayoutEffect(() => {\n      floating.update();\n    }, [dimensions, keyboardOpen]);\n  }\n  return /* @__PURE__ */ jsx(\n    PopperProvider,\n    {\n      scope: __scopePopper,\n      anchorRef,\n      size,\n      arrowRef: composedArrowRefs,\n      arrowStyle: middlewareData.arrow,\n      onArrowSize: setArrowSize,\n      isMounted,\n      ...floating,\n      children\n    }\n  );\n}\nconst ANCHOR_NAME = \"PopperAnchor\";\nconst PopperAnchor = YStack.extractable(\n  React.forwardRef(function PopperAnchor2(props, forwardedRef) {\n    const { __scopePopper, virtualRef, ...anchorProps } = props;\n    const { anchorRef, getReferenceProps } = usePopperContext(ANCHOR_NAME, __scopePopper);\n    const ref = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, anchorRef);\n    if (virtualRef) {\n      return null;\n    }\n    const stackProps = {\n      ref: composedRefs,\n      ...anchorProps\n    };\n    return /* @__PURE__ */ jsx(YStack, { ...getReferenceProps ? getReferenceProps(stackProps) : stackProps });\n  })\n);\nconst CONTENT_NAME = \"PopperContent\";\nconst PopperContentFrame = styled(ThemeableStack, {\n  name: \"PopperContent\",\n  variants: {\n    unstyled: {\n      false: {\n        size: \"$true\",\n        backgroundColor: \"$background\",\n        alignItems: \"center\",\n        radiused: true\n      }\n    },\n    size: {\n      \"...size\": (val, { tokens }) => {\n        return {\n          padding: tokens.space[val],\n          borderRadius: tokens.radius[val]\n        };\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst PopperContent = React.forwardRef(\n  function PopperContent2(props, forwardedRef) {\n    const { __scopePopper, ...contentProps } = props;\n    const { strategy, placement, floating, x, y, getFloatingProps, size, isMounted } = usePopperContext(CONTENT_NAME, __scopePopper);\n    const contentRefs = useComposedRefs(floating, forwardedRef);\n    const contents = React.useMemo(() => {\n      return /* @__PURE__ */ jsx(\n        PopperContentFrame,\n        {\n          \"data-placement\": placement,\n          \"data-strategy\": strategy,\n          size: contentProps.size || size,\n          ...contentProps\n        },\n        \"popper-content-frame\"\n      );\n    }, [placement, strategy, props]);\n    if (!isMounted) {\n      return null;\n    }\n    const frameProps = {\n      ref: contentRefs,\n      x: x || 0,\n      y: y || 0,\n      position: strategy\n    };\n    return /* @__PURE__ */ jsx(\n      YStack,\n      {\n        animateOnly: [\"transform\"],\n        ...getFloatingProps ? getFloatingProps(frameProps) : frameProps,\n        children: contents\n      }\n    );\n  }\n);\nconst ARROW_NAME = \"PopperArrow\";\nconst PopperArrowFrame = styled(YStack, {\n  name: \"PopperArrow\",\n  variants: {\n    unstyled: {\n      false: {\n        borderColor: \"$borderColor\",\n        backgroundColor: \"$background\",\n        position: \"relative\"\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst PopperArrowOuterFrame = styled(YStack, {\n  name: \"PopperArrowOuter\",\n  variants: {\n    unstyled: {\n      false: {\n        position: \"absolute\",\n        zIndex: -1,\n        pointerEvents: \"none\",\n        overflow: \"hidden\",\n        alignItems: \"center\",\n        justifyContent: \"center\"\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst opposites = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\nconst PopperArrow = PopperArrowFrame.extractable(\n  React.forwardRef(function PopperArrow2(props, forwardedRef) {\n    var _a, _b;\n    const {\n      __scopePopper,\n      offset: offset2,\n      size: sizeProp,\n      borderWidth = 0,\n      ...arrowProps\n    } = props;\n    const context = usePopperContext(ARROW_NAME, __scopePopper);\n    const sizeVal = sizeProp ?? context.size;\n    const sizeValResolved = getVariableValue(stepTokenUpOrDown(\"space\", sizeVal, -2, [2]));\n    const size = +sizeValResolved;\n    const { placement } = context;\n    const refs = useComposedRefs(context.arrowRef, forwardedRef);\n    const x = ((_a = context.arrowStyle) == null ? void 0 : _a.x) || 0;\n    const y = ((_b = context.arrowStyle) == null ? void 0 : _b.y) || 0;\n    const primaryPlacement = placement ? placement.split(\"-\")[0] : \"top\";\n    const arrowStyle = { x, y, width: size, height: size };\n    const innerArrowStyle = {};\n    const isVertical = primaryPlacement === \"bottom\" || primaryPlacement === \"top\";\n    if (primaryPlacement) {\n      arrowStyle[isVertical ? \"width\" : \"height\"] = size * 2;\n      const oppSide = opposites[primaryPlacement];\n      if (oppSide) {\n        arrowStyle[oppSide] = -size;\n        innerArrowStyle[oppSide] = size / 2;\n      }\n      if (oppSide === \"top\" || oppSide === \"bottom\") {\n        arrowStyle.left = 0;\n      }\n      if (oppSide === \"left\" || oppSide === \"right\") {\n        arrowStyle.top = 0;\n      }\n    }\n    useIsomorphicLayoutEffect(() => {\n      var _a2;\n      (_a2 = context.onArrowSize) == null ? void 0 : _a2.call(context, size);\n    }, [size, context.onArrowSize]);\n    return /* @__PURE__ */ jsx(PopperArrowOuterFrame, { ref: refs, ...arrowStyle, children: /* @__PURE__ */ jsx(\n      PopperArrowFrame,\n      {\n        width: size,\n        height: size,\n        ...arrowProps,\n        ...innerArrowStyle,\n        rotate: \"45deg\",\n        ...primaryPlacement === \"bottom\" && {\n          borderBottomWidth: borderWidth,\n          borderRightWidth: borderWidth\n        },\n        ...primaryPlacement === \"top\" && {\n          borderTopWidth: borderWidth,\n          borderLeftWidth: borderWidth\n        },\n        ...primaryPlacement === \"right\" && {\n          borderTopWidth: borderWidth,\n          borderRightWidth: borderWidth\n        },\n        ...primaryPlacement === \"left\" && {\n          borderBottomWidth: borderWidth,\n          borderLeftWidth: borderWidth\n        }\n      }\n    ) });\n  })\n);\nexport {\n  Popper,\n  PopperAnchor,\n  PopperArrow,\n  PopperContent,\n  PopperContentFrame,\n  PopperProvider,\n  createPopperScope,\n  usePopperContext\n};\n//# sourceMappingURL=Popper.mjs.map\n","export * from \"./Popper\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { getVariableValue, styled, withStaticProperties } from \"@tamagui/core\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport { getSize } from \"@tamagui/get-size\";\nimport { ThemeableStack } from \"@tamagui/stacks\";\nimport * as React from \"react\";\nconst PROGRESS_NAME = \"Progress\";\nconst [createProgressContext, createProgressScope] = createContextScope(PROGRESS_NAME);\nconst [ProgressProvider, useProgressContext] = createProgressContext(PROGRESS_NAME);\nconst INDICATOR_NAME = \"ProgressIndicator\";\nconst ProgressIndicatorFrame = styled(ThemeableStack, {\n  name: INDICATOR_NAME,\n  height: \"100%\",\n  width: \"100%\",\n  backgrounded: true\n});\nconst ProgressIndicator = ProgressIndicatorFrame.extractable(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const { __scopeProgress, ...indicatorProps } = props;\n      const context = useProgressContext(INDICATOR_NAME, __scopeProgress);\n      const pct = context.max - (context.value ?? 0);\n      const x = -context.width * (pct / 100);\n      return /* @__PURE__ */ jsx(\n        ProgressIndicatorFrame,\n        {\n          \"data-state\": getProgressState(context.value, context.max),\n          \"data-value\": context.value ?? void 0,\n          \"data-max\": context.max,\n          x,\n          width: context.width,\n          ...indicatorProps,\n          ref: forwardedRef\n        }\n      );\n    }\n  )\n);\nProgressIndicator.displayName = INDICATOR_NAME;\nfunction defaultGetValueLabel(value, max) {\n  return `${Math.round(value / max * 100)}%`;\n}\nfunction getProgressState(value, maxValue) {\n  return value == null ? \"indeterminate\" : value === maxValue ? \"complete\" : \"loading\";\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nfunction isValidMaxNumber(max) {\n  return isNumber(max) && !isNaN(max) && max > 0;\n}\nfunction isValidValueNumber(value, max) {\n  return isNumber(value) && !isNaN(value) && value <= max && value >= 0;\n}\nfunction getInvalidMaxError(propValue, componentName) {\n  return `Invalid prop \\`max\\` of value \\`${propValue}\\` supplied to \\`${componentName}\\`. Only numbers greater than 0 are valid max values. Defaulting to \\`${DEFAULT_MAX}\\`.`;\n}\nfunction getInvalidValueError(propValue, componentName) {\n  return `Invalid prop \\`value\\` of value \\`${propValue}\\` supplied to \\`${componentName}\\`. The \\`value\\` prop must be:\n  - a positive number\n  - less than the value passed to \\`max\\` (or ${DEFAULT_MAX} if no \\`max\\` prop is set)\n  - \\`null\\` if the progress is indeterminate.\n\nDefaulting to \\`null\\`.`;\n}\nconst DEFAULT_MAX = 100;\nconst ProgressFrame = styled(ThemeableStack, {\n  name: PROGRESS_NAME,\n  borderRadius: 1e5,\n  overflow: \"hidden\",\n  backgrounded: true,\n  variants: {\n    size: {\n      \"...size\": (val) => {\n        const size = Math.round(getVariableValue(getSize(val)) * 0.25);\n        return {\n          height: size,\n          minWidth: getVariableValue(size) * 20,\n          width: \"100%\"\n        };\n      }\n    }\n  }\n});\nconst Progress = withStaticProperties(\n  ProgressFrame.extractable(\n    React.forwardRef(\n      (props, forwardedRef) => {\n        const {\n          __scopeProgress,\n          value: valueProp,\n          max: maxProp,\n          getValueLabel = defaultGetValueLabel,\n          size = \"$true\",\n          ...progressProps\n        } = props;\n        const max = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX;\n        const value = isValidValueNumber(valueProp, max) ? valueProp : null;\n        const valueLabel = isNumber(value) ? getValueLabel(value, max) : void 0;\n        const [width, setWidth] = React.useState(0);\n        return /* @__PURE__ */ jsx(ProgressProvider, { scope: __scopeProgress, value, max, width, children: /* @__PURE__ */ jsx(\n          ProgressFrame,\n          {\n            size,\n            \"aria-valuemax\": max,\n            \"aria-valuemin\": 0,\n            \"aria-valuenow\": isNumber(value) ? value : void 0,\n            \"aria-valuetext\": valueLabel,\n            role: \"progressbar\",\n            \"data-state\": getProgressState(value, max),\n            \"data-value\": value ?? void 0,\n            \"data-max\": max,\n            ...progressProps,\n            onLayout: (e) => {\n              var _a;\n              setWidth(e.nativeEvent.layout.width);\n              (_a = progressProps.onLayout) == null ? void 0 : _a.call(progressProps, e);\n            },\n            ref: forwardedRef\n          }\n        ) });\n      }\n    )\n  ),\n  {\n    Indicator: ProgressIndicator\n  }\n);\nProgress.displayName = PROGRESS_NAME;\nProgress.propTypes = {\n  max(props, propName, componentName) {\n    const propValue = props[propName];\n    const strVal = String(propValue);\n    if (propValue && !isValidMaxNumber(propValue)) {\n      return new Error(getInvalidMaxError(strVal, componentName));\n    }\n    return null;\n  },\n  value(props, propName, componentName) {\n    const valueProp = props[propName];\n    const strVal = String(valueProp);\n    const max = isValidMaxNumber(props.max) ? props.max : DEFAULT_MAX;\n    if (valueProp != null && !isValidValueNumber(valueProp, max)) {\n      return new Error(getInvalidValueError(strVal, componentName));\n    }\n    return null;\n  }\n};\nexport {\n  Progress,\n  ProgressFrame,\n  ProgressIndicator,\n  ProgressIndicatorFrame,\n  createProgressScope\n};\n//# sourceMappingURL=Progress.mjs.map\n","export * from \"./Progress\";\n//# sourceMappingURL=index.mjs.map\n","import { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nimport { usePrevious } from \"@radix-ui/react-use-previous\";\nimport {\n  composeEventHandlers,\n  getVariableValue,\n  isWeb,\n  styled,\n  useComposedRefs,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport { registerFocusable } from \"@tamagui/focusable\";\nimport { getSize } from \"@tamagui/get-size\";\nimport { useLabelContext } from \"@tamagui/label\";\nimport { ThemeableStack } from \"@tamagui/stacks\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport * as React from \"react\";\nconst RADIO_GROUP_NAME = \"RadioGroup\";\nconst ARROW_KEYS = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\nconst [createRadioGroupContext, createRadioGroupScope] = createContextScope(RADIO_GROUP_NAME);\nconst [RadioGroupProvider, useRadioGroupContext] = createRadioGroupContext(RADIO_GROUP_NAME);\nconst getState = (checked) => {\n  return checked ? \"checked\" : \"unchecked\";\n};\nconst RADIO_GROUP_INDICATOR_NAME = \"RadioGroupIndicator\";\nconst RadioIndicatorFrame = styled(ThemeableStack, {\n  name: RADIO_GROUP_INDICATOR_NAME,\n  variants: {\n    unstyled: {\n      false: {\n        width: \"33%\",\n        height: \"33%\",\n        borderRadius: 1e3,\n        backgroundColor: \"$color\",\n        pressTheme: true\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst RadioIndicator = RadioIndicatorFrame.extractable(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const { __scopeRadioGroupItem, forceMount, disabled, ...indicatorProps } = props;\n      const { checked } = useRadioGroupItemContext(\n        RADIO_GROUP_INDICATOR_NAME,\n        __scopeRadioGroupItem\n      );\n      if (forceMount || checked) {\n        return /* @__PURE__ */ jsx(\n          RadioIndicatorFrame,\n          {\n            \"data-state\": getState(checked),\n            \"data-disabled\": disabled ? \"\" : void 0,\n            ...indicatorProps,\n            ref: forwardedRef\n          }\n        );\n      }\n      return null;\n    }\n  )\n);\nRadioIndicator.displayName = RADIO_GROUP_INDICATOR_NAME;\nconst RADIO_GROUP_ITEM_NAME = \"RadioGroupItem\";\nconst [RadioGroupItemProvider, useRadioGroupItemContext] = createRadioGroupContext(RADIO_GROUP_NAME);\nconst RadioGroupItemFrame = styled(ThemeableStack, {\n  name: RADIO_GROUP_ITEM_NAME,\n  tag: \"button\",\n  variants: {\n    unstyled: {\n      false: {\n        size: \"$true\",\n        borderRadius: 1e3,\n        backgroundColor: \"$background\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        borderWidth: 1,\n        borderColor: \"$borderColor\",\n        padding: 0,\n        hoverStyle: {\n          borderColor: \"$borderColorHover\",\n          background: \"$backgroundHover\"\n        },\n        focusStyle: {\n          borderColor: \"$borderColorHover\",\n          background: \"$backgroundHover\"\n        },\n        pressStyle: {\n          borderColor: \"$borderColorFocus\",\n          background: \"$backgroundFocus\"\n        }\n      }\n    },\n    size: {\n      \"...size\": (value, { props }) => {\n        const size = Math.floor(\n          getVariableValue(getSize(value)) * (props[\"scaleSize\"] ?? 0.5)\n        );\n        return {\n          width: size,\n          height: size\n        };\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst RadioGroupItem = RadioGroupItemFrame.extractable(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const {\n        __scopeRadioGroup,\n        value,\n        labelledBy: ariaLabelledby,\n        disabled: itemDisabled,\n        ...itemProps\n      } = props;\n      const {\n        value: groupValue,\n        disabled,\n        required,\n        onChange,\n        name,\n        native,\n        accentColor\n      } = useRadioGroupContext(RADIO_GROUP_ITEM_NAME, __scopeRadioGroup);\n      const [button, setButton] = React.useState(null);\n      const hasConsumerStoppedPropagationRef = React.useRef(false);\n      const ref = React.useRef(null);\n      const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node), ref);\n      const isArrowKeyPressedRef = React.useRef(false);\n      const isFormControl = isWeb ? button ? Boolean(button.closest(\"form\")) : true : false;\n      const checked = groupValue === value;\n      const labelId = useLabelContext(button);\n      const labelledBy = ariaLabelledby || labelId;\n      React.useEffect(() => {\n        if (isWeb) {\n          const handleKeyDown = (event) => {\n            if (ARROW_KEYS.includes(event.key)) {\n              isArrowKeyPressedRef.current = true;\n            }\n          };\n          const handleKeyUp = () => isArrowKeyPressedRef.current = false;\n          document.addEventListener(\"keydown\", handleKeyDown);\n          document.addEventListener(\"keyup\", handleKeyUp);\n          return () => {\n            document.removeEventListener(\"keydown\", handleKeyDown);\n            document.removeEventListener(\"keyup\", handleKeyUp);\n          };\n        }\n      }, []);\n      if (process.env.TAMAGUI_TARGET === \"native\") {\n        React.useEffect(() => {\n          if (!props.id)\n            return;\n          return registerFocusable(props.id, {\n            focusAndSelect: () => {\n              onChange == null ? void 0 : onChange(value);\n            },\n            focus: () => {\n            }\n          });\n        }, [props.id, value]);\n      }\n      const isDisabled = disabled || itemDisabled;\n      return /* @__PURE__ */ jsx(RadioGroupItemProvider, { checked, scope: __scopeRadioGroup, children: isWeb && native ? /* @__PURE__ */ jsx(\n        BubbleInput,\n        {\n          control: button,\n          bubbles: !hasConsumerStoppedPropagationRef.current,\n          name,\n          value,\n          checked,\n          required,\n          disabled: isDisabled,\n          id: props.id,\n          accentColor\n        }\n      ) : /* @__PURE__ */ jsxs(Fragment, { children: [\n        /* @__PURE__ */ jsx(\n          RadioGroupItemFrame,\n          {\n            \"data-state\": getState(checked),\n            \"data-disabled\": isDisabled ? \"\" : void 0,\n            role: \"radio\",\n            \"aria-labelledby\": labelledBy,\n            \"aria-checked\": checked,\n            \"aria-required\": required,\n            disabled: isDisabled,\n            ref: composedRefs,\n            ...isWeb && {\n              type: \"button\",\n              value\n            },\n            ...itemProps,\n            onPress: composeEventHandlers(props.onPress, (event) => {\n              if (!checked) {\n                onChange == null ? void 0 : onChange(value);\n              }\n              if (isFormControl) {\n                hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n                if (!hasConsumerStoppedPropagationRef.current)\n                  event.stopPropagation();\n              }\n            }),\n            ...isWeb && {\n              onKeyDown: composeEventHandlers(\n                props.onKeyDown,\n                (event) => {\n                  if (event.key === \"Enter\")\n                    event.preventDefault();\n                }\n              ),\n              onFocus: composeEventHandlers(itemProps.onFocus, () => {\n                var _a;\n                if (isArrowKeyPressedRef.current)\n                  (_a = ref.current) == null ? void 0 : _a.click();\n              })\n            }\n          }\n        ),\n        isFormControl && /* @__PURE__ */ jsx(\n          BubbleInput,\n          {\n            isHidden: true,\n            control: button,\n            bubbles: !hasConsumerStoppedPropagationRef.current,\n            name,\n            value,\n            checked,\n            required,\n            disabled: isDisabled\n          }\n        )\n      ] }) });\n    }\n  )\n);\nconst BubbleInput = (props) => {\n  const { checked, bubbles = true, control, isHidden, accentColor, ...inputProps } = props;\n  const ref = React.useRef(null);\n  const prevChecked = usePrevious(checked);\n  React.useEffect(() => {\n    const input = ref.current;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(\n      inputProto,\n      \"checked\"\n    );\n    const setChecked = descriptor.set;\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event(\"click\", { bubbles });\n      setChecked.call(input, checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n  return /* @__PURE__ */ jsx(\n    \"input\",\n    {\n      type: \"radio\",\n      defaultChecked: checked,\n      ...inputProps,\n      tabIndex: -1,\n      ref,\n      \"aria-hidden\": isHidden,\n      style: {\n        ...isHidden ? {\n          // ...controlSize,\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        } : {\n          appearance: \"auto\",\n          accentColor\n        },\n        ...props.style\n      }\n    }\n  );\n};\nconst RadioGroupFrame = styled(ThemeableStack, {\n  name: RADIO_GROUP_NAME,\n  variants: {\n    orientation: {\n      horizontal: {\n        flexDirection: \"row\",\n        spaceDirection: \"horizontal\"\n      },\n      vertical: {\n        flexDirection: \"column\",\n        spaceDirection: \"vertical\"\n      }\n    }\n  }\n});\nconst RadioGroup = withStaticProperties(\n  RadioGroupFrame.extractable(\n    React.forwardRef(\n      (props, forwardedRef) => {\n        const {\n          __scopeRadioGroup,\n          value: valueProp,\n          defaultValue,\n          onValueChange,\n          disabled = false,\n          required = false,\n          name,\n          orientation,\n          native,\n          accentColor,\n          ...radioGroupProps\n        } = props;\n        const [value, setValue] = useControllableState({\n          prop: valueProp,\n          defaultProp: defaultValue,\n          onChange: onValueChange\n        });\n        return /* @__PURE__ */ jsx(\n          RadioGroupProvider,\n          {\n            scope: __scopeRadioGroup,\n            value,\n            required,\n            onChange: setValue,\n            disabled,\n            name,\n            native,\n            accentColor,\n            children: /* @__PURE__ */ jsx(\n              RadioGroupFrame,\n              {\n                \"aria-valuetext\": value,\n                role: \"radiogroup\",\n                \"aria-orientation\": orientation,\n                ref: forwardedRef,\n                orientation,\n                \"data-disabled\": disabled ? \"\" : void 0,\n                ...radioGroupProps\n              }\n            )\n          }\n        );\n      }\n    )\n  ),\n  {\n    Indicator: RadioIndicator,\n    Item: RadioGroupItem\n  }\n);\nRadioGroup.displayName = RADIO_GROUP_NAME;\nexport {\n  RadioGroup,\n  createRadioGroupScope\n};\n//# sourceMappingURL=RadioGroup.mjs.map\n","export * from \"./RadioGroup\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { RemoveScroll as RS } from \"react-remove-scroll\";\nconst RemoveScroll = (props) => {\n  if (!props.children)\n    return null;\n  return /* @__PURE__ */ jsx(RS, { ...props });\n};\nRemoveScroll.classNames = RS.classNames;\nexport {\n  RemoveScroll\n};\n//# sourceMappingURL=RemoveScroll.mjs.map\n","export * from \"./RemoveScroll\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { createCollection } from \"@tamagui/collection\";\nimport { useComposedRefs } from \"@tamagui/compose-refs\";\nimport {\n  Stack,\n  composeEventHandlers,\n  isWeb,\n  useEvent,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport { useDirection } from \"@tamagui/use-direction\";\nimport * as React from \"react\";\nconst ENTRY_FOCUS = \"rovingFocusGroup.onEntryFocus\";\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\nconst RovingFocusGroupImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    ...groupProps\n  } = props;\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId ?? null,\n    onChange: onCurrentTabStopIdChange\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useEvent(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n  return /* @__PURE__ */ jsx(\n    RovingFocusProvider,\n    {\n      scope: __scopeRovingFocusGroup,\n      orientation,\n      dir: direction,\n      loop,\n      currentTabStopId,\n      onItemFocus: React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      ),\n      onItemShiftTab: React.useCallback(() => setIsTabbingBackOut(true), []),\n      onFocusableItemAdd: React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount + 1),\n        []\n      ),\n      onFocusableItemRemove: React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount - 1),\n        []\n      ),\n      children: /* @__PURE__ */ jsx(\n        Stack,\n        {\n          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,\n          \"data-orientation\": orientation,\n          ...groupProps,\n          ref: composedRefs,\n          style: [{ outline: \"none\" }, props.style],\n          onMouseDown: composeEventHandlers(props.onMouseDown, () => {\n            isClickFocusRef.current = true;\n          }),\n          onFocus: composeEventHandlers(props.onFocus, (event) => {\n            const isKeyboardFocus = !isClickFocusRef.current;\n            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n              event.currentTarget.dispatchEvent(entryFocusEvent);\n              if (!entryFocusEvent.defaultPrevented) {\n                const items = getItems().filter((item) => item.focusable);\n                const activeItem = items.find((item) => item.active);\n                const currentItem = items.find((item) => item.id === currentTabStopId);\n                const candidateItems = [activeItem, currentItem, ...items].filter(\n                  Boolean\n                );\n                const candidateNodes = candidateItems.map((item) => item.ref.current);\n                focusFirst(candidateNodes);\n              }\n            }\n            isClickFocusRef.current = false;\n          }),\n          onBlur: composeEventHandlers(\n            props.onBlur,\n            () => setIsTabbingBackOut(false)\n          )\n        }\n      )\n    }\n  );\n});\nconst ITEM_NAME = \"RovingFocusGroupItem\";\nconst RovingFocusGroupItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    focusable = true,\n    active = false,\n    tabStopId,\n    ...itemProps\n  } = props;\n  const autoId = React.useId();\n  const id = tabStopId || autoId;\n  const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n  const isCurrentTabStop = context.currentTabStopId === id;\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const { onFocusableItemAdd, onFocusableItemRemove } = context;\n  React.useEffect(() => {\n    if (focusable) {\n      onFocusableItemAdd();\n      return () => onFocusableItemRemove();\n    }\n  }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n  return /* @__PURE__ */ jsx(\n    Collection.ItemSlot,\n    {\n      scope: __scopeRovingFocusGroup,\n      id,\n      focusable,\n      active,\n      children: /* @__PURE__ */ jsx(\n        Stack,\n        {\n          tabIndex: isCurrentTabStop ? 0 : -1,\n          \"data-orientation\": context.orientation,\n          ...itemProps,\n          ref: forwardedRef,\n          onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {\n            if (!focusable)\n              event.preventDefault();\n            else\n              context.onItemFocus(id);\n          }),\n          onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),\n          ...isWeb && {\n            onKeyDown: composeEventHandlers(\n              props.onKeyDown,\n              (event) => {\n                if (event.key === \"Tab\" && event.shiftKey) {\n                  context.onItemShiftTab();\n                  return;\n                }\n                if (event.target !== event.currentTarget)\n                  return;\n                const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n                if (focusIntent !== void 0) {\n                  event.preventDefault();\n                  const items = getItems().filter((item) => item.focusable);\n                  let candidateNodes = items.map((item) => item.ref.current);\n                  if (focusIntent === \"last\")\n                    candidateNodes.reverse();\n                  else if (focusIntent === \"prev\" || focusIntent === \"next\") {\n                    if (focusIntent === \"prev\")\n                      candidateNodes.reverse();\n                    const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                    candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);\n                  }\n                  setTimeout(() => focusFirst(candidateNodes));\n                }\n              }\n            )\n          }\n        }\n      )\n    }\n  );\n});\nRovingFocusGroupItem.displayName = ITEM_NAME;\nconst GROUP_NAME = \"RovingFocusGroup\";\nconst [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\nconst [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);\nconst RovingFocusGroup = withStaticProperties(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      return /* @__PURE__ */ jsx(Collection.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx(Collection.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });\n    }\n  ),\n  {\n    Item: RovingFocusGroupItem\n  }\n);\nRovingFocusGroup.displayName = GROUP_NAME;\nconst MAP_KEY_TO_FOCUS_INTENT = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction getDirectionAwareKey(key, dir) {\n  if (dir !== \"rtl\")\n    return key;\n  return key === \"ArrowLeft\" ? \"ArrowRight\" : key === \"ArrowRight\" ? \"ArrowLeft\" : key;\n}\nfunction getFocusIntent(event, orientation, dir) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(key))\n    return void 0;\n  if (orientation === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(key))\n    return void 0;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\nfunction focusFirst(candidates) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)\n      return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)\n      return;\n  }\n}\nfunction wrapArray(array, startIndex) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\nexport {\n  RovingFocusGroup,\n  createRovingFocusGroupScope\n};\n//# sourceMappingURL=RovingFocusGroup.mjs.map\n","import { fullscreenStyle } from \"@tamagui/stacks\";\nimport { setupReactNative, styled } from \"@tamagui/web\";\nimport { ScrollView as ScrollViewNative } from \"react-native\";\nsetupReactNative({\n  ScrollView: ScrollViewNative\n});\nconst ScrollView = styled(ScrollViewNative, {\n  name: \"ScrollView\",\n  scrollEnabled: true,\n  variants: {\n    fullscreen: {\n      true: fullscreenStyle\n    }\n  }\n});\nexport {\n  ScrollView\n};\n//# sourceMappingURL=ScrollView.mjs.map\n","export * from \"./ScrollView\";\n//# sourceMappingURL=index.mjs.map\n","import { Fragment, jsx } from \"react/jsx-runtime\";\nimport { Adapt, useAdaptParent } from \"@tamagui/adapt\";\nimport { useComposedRefs } from \"@tamagui/compose-refs\";\nimport {\n  isWeb,\n  styled,\n  useGet,\n  useIsomorphicLayoutEffect,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { ListItem } from \"@tamagui/list-item\";\nimport { PortalHost } from \"@tamagui/portal\";\nimport { Separator } from \"@tamagui/separator\";\nimport { ControlledSheet, SheetController } from \"@tamagui/sheet\";\nimport { XStack, YStack } from \"@tamagui/stacks\";\nimport { Paragraph, SizableText } from \"@tamagui/text\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport * as React from \"react\";\nimport { SELECT_NAME } from \"./constants\";\nimport { SelectProvider, createSelectContext, useSelectContext } from \"./context\";\nimport { SelectContent } from \"./SelectContent\";\nimport { SelectInlineImpl } from \"./SelectImpl\";\nimport { SelectScrollDownButton, SelectScrollUpButton } from \"./SelectScrollButton\";\nimport { SelectViewport } from \"./SelectViewport\";\nimport {\n  useSelectBreakpointActive,\n  useShowSelectSheet\n} from \"./useSelectBreakpointActive\";\nconst TRIGGER_NAME = \"SelectTrigger\";\nconst SelectTrigger = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeSelect,\n      disabled = false,\n      // @ts-ignore\n      \"aria-labelledby\": ariaLabelledby,\n      ...triggerProps\n    } = props;\n    const context = useSelectContext(TRIGGER_NAME, __scopeSelect);\n    const labelledBy = ariaLabelledby;\n    return /* @__PURE__ */ jsx(\n      ListItem,\n      {\n        componentName: TRIGGER_NAME,\n        backgrounded: true,\n        radiused: true,\n        hoverTheme: true,\n        pressTheme: true,\n        focusTheme: true,\n        focusable: true,\n        borderWidth: 1,\n        size: context.size,\n        \"aria-expanded\": context.open,\n        \"aria-autocomplete\": \"none\",\n        \"aria-labelledby\": labelledBy,\n        dir: context.dir,\n        disabled,\n        \"data-disabled\": disabled ? \"\" : void 0,\n        ...triggerProps,\n        ref: forwardedRef,\n        ...process.env.TAMAGUI_TARGET === \"web\" && context.interactions ? context.interactions.getReferenceProps() : {\n          onPress() {\n            context.setOpen(!context.open);\n          }\n        }\n      }\n    );\n  }\n);\nSelectTrigger.displayName = TRIGGER_NAME;\nconst VALUE_NAME = \"SelectValue\";\nconst SelectValueFrame = styled(Paragraph, {\n  name: VALUE_NAME,\n  userSelect: \"none\"\n});\nconst SelectValue = SelectValueFrame.extractable(\n  React.forwardRef(\n    ({\n      __scopeSelect,\n      children: childrenProp,\n      placeholder\n    }, forwardedRef) => {\n      const context = useSelectContext(VALUE_NAME, __scopeSelect);\n      const { onValueNodeHasChildrenChange } = context;\n      const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);\n      const children = childrenProp ?? context.selectedItem;\n      const hasChildren = !!children;\n      const isEmptyValue = context.value == null || context.value === \"\";\n      const selectValueChildren = isEmptyValue ? placeholder ?? children : children;\n      useIsomorphicLayoutEffect(() => {\n        onValueNodeHasChildrenChange(hasChildren);\n      }, [onValueNodeHasChildrenChange, hasChildren]);\n      return /* @__PURE__ */ jsx(\n        SelectValueFrame,\n        {\n          size: context.size,\n          ref: composedRefs,\n          pointerEvents: \"none\",\n          children: selectValueChildren\n        }\n      );\n    }\n  )\n);\nSelectValue.displayName = VALUE_NAME;\nconst SelectIcon = styled(XStack, {\n  name: \"SelectIcon\",\n  // @ts-ignore\n  \"aria-hidden\": true,\n  children: /* @__PURE__ */ jsx(Paragraph, { children: \"\\u25BC\" })\n});\nconst ITEM_NAME = \"SelectItem\";\nconst [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);\nconst SelectItem = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeSelect,\n      value,\n      disabled = false,\n      textValue: textValueProp,\n      index,\n      ...itemProps\n    } = props;\n    const context = useSelectContext(ITEM_NAME, __scopeSelect);\n    const isSelected = context.value === value;\n    const textId = React.useId();\n    const {\n      selectedIndex,\n      setSelectedIndex,\n      listRef,\n      open,\n      setOpen,\n      onChange,\n      setActiveIndex,\n      allowMouseUpRef,\n      allowSelectRef,\n      setValueAtIndex,\n      selectTimeoutRef,\n      dataRef\n    } = context;\n    const composedRefs = useComposedRefs(forwardedRef, (node) => {\n      if (!isWeb)\n        return;\n      if (node instanceof HTMLElement) {\n        if (listRef) {\n          listRef.current[index] = node;\n        }\n      }\n    });\n    React.useEffect(() => {\n      setValueAtIndex(index, value);\n    }, [index, setValueAtIndex, value]);\n    function handleSelect() {\n      setSelectedIndex(index);\n      onChange(value);\n      setOpen(false);\n    }\n    const selectItemProps = context.interactions ? context.interactions.getItemProps({\n      onTouchStart() {\n        allowSelectRef.current = true;\n        allowMouseUpRef.current = false;\n      },\n      onKeyDown(event) {\n        if (event.key === \"Enter\" || event.key === \" \" && !(dataRef == null ? void 0 : dataRef.current.typing)) {\n          event.preventDefault();\n          handleSelect();\n        } else {\n          allowSelectRef.current = true;\n        }\n      },\n      onClick() {\n        if (allowSelectRef.current) {\n          setSelectedIndex(index);\n          setOpen(false);\n        }\n      },\n      onMouseUp() {\n        if (!allowMouseUpRef.current) {\n          return;\n        }\n        if (allowSelectRef.current) {\n          handleSelect();\n        }\n        clearTimeout(selectTimeoutRef.current);\n        selectTimeoutRef.current = setTimeout(() => {\n          allowSelectRef.current = true;\n        });\n      }\n    }) : {\n      onPress: handleSelect\n    };\n    return /* @__PURE__ */ jsx(\n      SelectItemContextProvider,\n      {\n        scope: __scopeSelect,\n        value,\n        textId: textId || \"\",\n        isSelected,\n        children: /* @__PURE__ */ jsx(\n          ListItem,\n          {\n            tag: \"div\",\n            backgrounded: true,\n            pressTheme: true,\n            hoverTheme: true,\n            cursor: \"default\",\n            outlineWidth: 0,\n            componentName: ITEM_NAME,\n            ref: composedRefs,\n            \"aria-labelledby\": textId,\n            \"aria-selected\": isSelected,\n            \"data-state\": isSelected ? \"active\" : \"inactive\",\n            \"aria-disabled\": disabled || void 0,\n            \"data-disabled\": disabled ? \"\" : void 0,\n            tabIndex: disabled ? void 0 : -1,\n            size: context.size,\n            focusStyle: {\n              backgroundColor: \"$backgroundHover\"\n            },\n            ...itemProps,\n            ...selectItemProps\n          }\n        )\n      }\n    );\n  }\n);\nSelectItem.displayName = ITEM_NAME;\nconst ITEM_TEXT_NAME = \"SelectItemText\";\nconst SelectItemTextFrame = styled(SizableText, {\n  name: ITEM_TEXT_NAME,\n  userSelect: \"none\"\n});\nconst SelectItemText = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, className, ...itemTextProps } = props;\n    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);\n    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);\n    const ref = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const isSelected = Boolean(itemContext.isSelected && context.valueNode);\n    const contents = React.useMemo(\n      () => /* @__PURE__ */ jsx(\n        SelectItemTextFrame,\n        {\n          className,\n          size: context.size,\n          id: itemContext.textId,\n          ...itemTextProps,\n          ref: composedRefs\n        }\n      ),\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [props, context.size, className, itemContext.textId]\n    );\n    useIsomorphicLayoutEffect(() => {\n      if (isSelected) {\n        context.setSelectedItem(contents);\n      }\n    }, [isSelected, contents]);\n    return /* @__PURE__ */ jsx(Fragment, { children: contents });\n  }\n);\nSelectItemText.displayName = ITEM_TEXT_NAME;\nconst ITEM_INDICATOR_NAME = \"SelectItemIndicator\";\nconst SelectItemIndicatorFrame = styled(XStack, {\n  name: ITEM_TEXT_NAME\n});\nconst SelectItemIndicator = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, ...itemIndicatorProps } = props;\n    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);\n    return itemContext.isSelected ? /* @__PURE__ */ jsx(SelectItemIndicatorFrame, { \"aria-hidden\": true, ...itemIndicatorProps, ref: forwardedRef }) : null;\n  }\n);\nSelectItemIndicator.displayName = ITEM_INDICATOR_NAME;\nconst GROUP_NAME = \"SelectGroup\";\nconst [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);\nconst SelectGroupFrame = styled(YStack, {\n  name: GROUP_NAME,\n  width: \"100%\"\n});\nconst SelectGroup = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, ...groupProps } = props;\n    const groupId = React.useId();\n    return /* @__PURE__ */ jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId || \"\", children: /* @__PURE__ */ jsx(\n      SelectGroupFrame,\n      {\n        role: \"group\",\n        \"aria-labelledby\": groupId,\n        ...groupProps,\n        ref: forwardedRef\n      }\n    ) });\n  }\n);\nSelectGroup.displayName = GROUP_NAME;\nconst LABEL_NAME = \"SelectLabel\";\nconst SelectLabel = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, ...labelProps } = props;\n    const context = useSelectContext(LABEL_NAME, __scopeSelect);\n    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);\n    return /* @__PURE__ */ jsx(\n      ListItem,\n      {\n        tag: \"div\",\n        componentName: LABEL_NAME,\n        fontWeight: \"800\",\n        id: groupContext.id,\n        size: context.size,\n        ...labelProps,\n        ref: forwardedRef\n      }\n    );\n  }\n);\nSelectLabel.displayName = LABEL_NAME;\nconst SelectSeparator = styled(Separator, {\n  name: \"SelectSeparator\"\n});\nconst SelectSheetController = (props) => {\n  const context = useSelectContext(\"SelectSheetController\", props.__scopeSelect);\n  const showSheet = useShowSelectSheet(context);\n  const breakpointActive = useSelectBreakpointActive(context.sheetBreakpoint);\n  const getShowSheet = useGet(showSheet);\n  return /* @__PURE__ */ jsx(\n    SheetController,\n    {\n      onOpenChange: (val) => {\n        if (getShowSheet()) {\n          props.onOpenChange(val);\n        }\n      },\n      open: context.open,\n      hidden: breakpointActive === false,\n      children: props.children\n    }\n  );\n};\nconst SelectSheetImpl = (props) => {\n  return /* @__PURE__ */ jsx(Fragment, { children: props.children });\n};\nconst Select = withStaticProperties(\n  (props) => {\n    const {\n      __scopeSelect,\n      children,\n      open: openProp,\n      defaultOpen,\n      onOpenChange,\n      value: valueProp,\n      defaultValue,\n      onValueChange,\n      size: sizeProp = \"$true\",\n      dir\n    } = props;\n    const id = React.useId();\n    const scopeKey = __scopeSelect ? Object.keys(__scopeSelect)[0] ?? id : id;\n    const { when, AdaptProvider } = useAdaptParent({\n      Contents: React.useCallback(\n        () => /* @__PURE__ */ jsx(PortalHost, { name: `${scopeKey}SheetContents` }),\n        [scopeKey]\n      )\n    });\n    const sheetBreakpoint = when;\n    const isSheet = useSelectBreakpointActive(sheetBreakpoint);\n    const SelectImpl = isSheet || !isWeb ? SelectSheetImpl : SelectInlineImpl;\n    const forceUpdate = React.useReducer(() => ({}), {})[1];\n    const [selectedItem, setSelectedItem] = React.useState(null);\n    const [open, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen || false,\n      onChange: onOpenChange\n    });\n    const [value, setValue] = useControllableState({\n      prop: valueProp,\n      defaultProp: defaultValue || \"\",\n      onChange: onValueChange,\n      transition: true\n    });\n    const [activeIndex, setActiveIndex] = React.useState(0);\n    const selectedIndexRef = React.useRef(null);\n    const activeIndexRef = React.useRef(null);\n    const listContentRef = React.useRef([]);\n    const [selectedIndex, setSelectedIndex] = React.useState(0);\n    const [valueNode, setValueNode] = React.useState(null);\n    const [valueNodeHasChildren, setValueNodeHasChildren] = React.useState(false);\n    useIsomorphicLayoutEffect(() => {\n      selectedIndexRef.current = selectedIndex;\n      activeIndexRef.current = activeIndex;\n    });\n    return /* @__PURE__ */ jsx(AdaptProvider, { children: /* @__PURE__ */ jsx(\n      SelectProvider,\n      {\n        dir,\n        blockSelection: false,\n        size: sizeProp,\n        fallback: false,\n        selectedItem,\n        setSelectedItem,\n        forceUpdate,\n        valueNode,\n        onValueNodeChange: setValueNode,\n        onValueNodeHasChildrenChange: setValueNodeHasChildren,\n        valueNodeHasChildren,\n        scopeKey,\n        sheetBreakpoint,\n        scope: __scopeSelect,\n        setValueAtIndex: (index, value2) => {\n          listContentRef.current[index] = value2;\n        },\n        activeIndex,\n        onChange: setValue,\n        selectedIndex,\n        setActiveIndex,\n        setOpen,\n        setSelectedIndex,\n        value,\n        open,\n        children: /* @__PURE__ */ jsx(SelectSheetController, { onOpenChange: setOpen, __scopeSelect, children: /* @__PURE__ */ jsx(\n          SelectImpl,\n          {\n            activeIndexRef,\n            listContentRef,\n            selectedIndexRef,\n            ...props,\n            open,\n            value,\n            children\n          }\n        ) })\n      }\n    ) });\n  },\n  {\n    Adapt,\n    Content: SelectContent,\n    Group: SelectGroup,\n    Icon: SelectIcon,\n    Item: SelectItem,\n    ItemIndicator: SelectItemIndicator,\n    ItemText: SelectItemText,\n    Label: SelectLabel,\n    ScrollDownButton: SelectScrollDownButton,\n    ScrollUpButton: SelectScrollUpButton,\n    Trigger: SelectTrigger,\n    Value: SelectValue,\n    Viewport: SelectViewport,\n    Sheet: ControlledSheet\n  }\n);\nSelect.displayName = SELECT_NAME;\nexport {\n  Select,\n  SelectGroupFrame,\n  SelectIcon,\n  SelectItem,\n  SelectItemTextFrame,\n  SelectSeparator,\n  SelectTrigger\n};\n//# sourceMappingURL=Select.mjs.map\n","import { Fragment, jsx } from \"react/jsx-runtime\";\nimport { FloatingOverlay, FloatingPortal } from \"@floating-ui/react\";\nimport { Theme, useIsTouchDevice, useThemeName } from \"@tamagui/core\";\nimport { Dismissable } from \"@tamagui/dismissable\";\nimport { FocusScope } from \"@tamagui/focus-scope\";\nimport { useSelectContext } from \"./context\";\nimport { useShowSelectSheet } from \"./useSelectBreakpointActive\";\nconst CONTENT_NAME = \"SelectContent\";\nconst SelectContent = ({\n  children,\n  __scopeSelect,\n  zIndex = 1e3,\n  ...focusScopeProps\n}) => {\n  const context = useSelectContext(CONTENT_NAME, __scopeSelect);\n  const themeName = useThemeName();\n  const showSheet = useShowSelectSheet(context);\n  const contents = /* @__PURE__ */ jsx(Theme, { forceClassName: true, name: themeName, children });\n  const touch = useIsTouchDevice();\n  if (showSheet) {\n    if (!context.open) {\n      return null;\n    }\n    return /* @__PURE__ */ jsx(Fragment, { children: contents });\n  }\n  return /* @__PURE__ */ jsx(FloatingPortal, { children: context.open ? /* @__PURE__ */ jsx(FloatingOverlay, { style: { zIndex }, lockScroll: !touch, children: /* @__PURE__ */ jsx(FocusScope, { loop: true, trapped: true, ...focusScopeProps, children: /* @__PURE__ */ jsx(Dismissable, { children: contents }) }) }) : /* @__PURE__ */ jsx(\"div\", { style: { display: \"none\" }, children: contents }) });\n};\nexport {\n  SelectContent\n};\n//# sourceMappingURL=SelectContent.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport {\n  autoUpdate,\n  flip,\n  inner,\n  offset,\n  shift,\n  size,\n  useClick,\n  useDismiss,\n  useFloating,\n  useInnerOffset,\n  useInteractions,\n  useListNavigation,\n  useRole,\n  useTypeahead\n} from \"@floating-ui/react\";\nimport {\n  isClient,\n  isWeb,\n  useIsTouchDevice,\n  useIsomorphicLayoutEffect\n} from \"@tamagui/core\";\nimport * as React from \"react\";\nimport { flushSync } from \"react-dom\";\nimport { SCROLL_ARROW_THRESHOLD, WINDOW_PADDING } from \"./constants\";\nimport { SelectProvider, useSelectContext } from \"./context\";\nconst SelectInlineImpl = (props) => {\n  const {\n    __scopeSelect,\n    children,\n    open = false,\n    selectedIndexRef,\n    listContentRef\n  } = props;\n  const selectContext = useSelectContext(\"SelectSheetImpl\", __scopeSelect);\n  const {\n    setActiveIndex,\n    setOpen,\n    setSelectedIndex,\n    selectedIndex,\n    activeIndex,\n    forceUpdate\n  } = selectContext;\n  const [scrollTop, setScrollTop] = React.useState(0);\n  const touch = useIsTouchDevice();\n  const listItemsRef = React.useRef([]);\n  const overflowRef = React.useRef(null);\n  const upArrowRef = React.useRef(null);\n  const downArrowRef = React.useRef(null);\n  const allowSelectRef = React.useRef(false);\n  const allowMouseUpRef = React.useRef(true);\n  const selectTimeoutRef = React.useRef();\n  const state = React.useRef({\n    isMouseOutside: false\n  });\n  const [controlledScrolling, setControlledScrolling] = React.useState(false);\n  const [fallback, setFallback] = React.useState(false);\n  const [innerOffset, setInnerOffset] = React.useState(0);\n  const [blockSelection, setBlockSelection] = React.useState(false);\n  const floatingStyle = React.useRef({});\n  React.useEffect(() => {\n    const frame = requestAnimationFrame(() => {\n      if (!open) {\n        setScrollTop(0);\n        setFallback(false);\n        setActiveIndex(null);\n        setControlledScrolling(false);\n      }\n    });\n    return () => {\n      cancelAnimationFrame(frame);\n    };\n  }, [open, setActiveIndex]);\n  if (isWeb && isClient) {\n    React.useEffect(() => {\n      if (!open)\n        return;\n      const mouseUp = (e) => {\n        if (state.current.isMouseOutside) {\n          setOpen(false);\n        }\n      };\n      document.addEventListener(\"mouseup\", mouseUp);\n      return () => {\n        document.removeEventListener(\"mouseup\", mouseUp);\n      };\n    }, [open]);\n  }\n  const updateFloatingSize = size({\n    apply({\n      availableHeight,\n      rects: {\n        reference: { width }\n      }\n    }) {\n      floatingStyle.current = {\n        width,\n        maxHeight: availableHeight\n      };\n    },\n    padding: WINDOW_PADDING\n  });\n  const { x, y, reference, floating, strategy, context, refs } = useFloating({\n    open,\n    onOpenChange: setOpen,\n    whileElementsMounted: autoUpdate,\n    placement: \"bottom-start\",\n    middleware: fallback ? [\n      offset(5),\n      ...[\n        touch ? shift({ crossAxis: true, padding: WINDOW_PADDING }) : flip({ padding: WINDOW_PADDING })\n      ],\n      updateFloatingSize\n    ] : [\n      inner({\n        listRef: listItemsRef,\n        overflowRef,\n        index: selectedIndex,\n        offset: innerOffset,\n        onFallbackChange: setFallback,\n        padding: 10,\n        minItemsVisible: touch ? 10 : 4,\n        referenceOverflowThreshold: 20\n      }),\n      updateFloatingSize\n    ]\n  });\n  const floatingRef = refs.floating;\n  const showUpArrow = open && scrollTop > SCROLL_ARROW_THRESHOLD;\n  const showDownArrow = open && floatingRef.current && scrollTop < floatingRef.current.scrollHeight - floatingRef.current.clientHeight - SCROLL_ARROW_THRESHOLD;\n  const interactions = useInteractions([\n    useClick(context, { event: \"mousedown\" }),\n    useDismiss(context, { outsidePress: true }),\n    useRole(context, { role: \"listbox\" }),\n    useInnerOffset(context, {\n      enabled: !fallback,\n      onChange: setInnerOffset,\n      overflowRef\n    }),\n    useListNavigation(context, {\n      listRef: listItemsRef,\n      activeIndex,\n      selectedIndex,\n      onNavigate: setActiveIndex\n    }),\n    useTypeahead(context, {\n      listRef: listContentRef,\n      onMatch: open ? setActiveIndex : setSelectedIndex,\n      selectedIndex,\n      activeIndex\n    })\n  ]);\n  const interactionsContext = React.useMemo(() => {\n    return {\n      ...interactions,\n      getReferenceProps() {\n        return interactions.getReferenceProps({\n          ref: reference,\n          className: \"SelectTrigger\",\n          onKeyDown(event) {\n            if (event.key === \"Enter\" || event.key === \" \" && !context.dataRef.current.typing) {\n              event.preventDefault();\n              setOpen(true);\n            }\n          }\n        });\n      },\n      getFloatingProps(props2) {\n        return interactions.getFloatingProps({\n          ref: floating,\n          className: \"Select\",\n          ...props2,\n          style: {\n            position: strategy,\n            top: y ?? \"\",\n            left: x ?? \"\",\n            outline: 0,\n            scrollbarWidth: \"none\",\n            ...floatingStyle.current,\n            ...props2 == null ? void 0 : props2.style\n          },\n          onPointerEnter() {\n            setControlledScrolling(false);\n            state.current.isMouseOutside = false;\n          },\n          onPointerLeave() {\n            state.current.isMouseOutside = true;\n          },\n          onPointerMove() {\n            state.current.isMouseOutside = false;\n            setControlledScrolling(false);\n          },\n          onKeyDown() {\n            setControlledScrolling(true);\n          },\n          onContextMenu(e) {\n            e.preventDefault();\n          },\n          onScroll(event) {\n            flushSync(() => setScrollTop(event.currentTarget.scrollTop));\n          }\n        });\n      }\n    };\n  }, [floating, y, x, interactions]);\n  useIsomorphicLayoutEffect(() => {\n    if (open) {\n      selectTimeoutRef.current = setTimeout(() => {\n        allowSelectRef.current = true;\n      }, 300);\n      return () => {\n        clearTimeout(selectTimeoutRef.current);\n      };\n    } else {\n      allowSelectRef.current = false;\n      allowMouseUpRef.current = true;\n      setInnerOffset(0);\n      setFallback(false);\n      setBlockSelection(false);\n    }\n  }, [open]);\n  useIsomorphicLayoutEffect(() => {\n    function onPointerDown(e) {\n      var _a, _b, _c;\n      const target = e.target;\n      if (!(((_a = refs.floating.current) == null ? void 0 : _a.contains(target)) || ((_b = upArrowRef.current) == null ? void 0 : _b.contains(target)) || ((_c = downArrowRef.current) == null ? void 0 : _c.contains(target)))) {\n        setOpen(false);\n        setControlledScrolling(false);\n      }\n    }\n    if (open) {\n      document.addEventListener(\"pointerdown\", onPointerDown);\n      return () => {\n        document.removeEventListener(\"pointerdown\", onPointerDown);\n      };\n    }\n  }, [open, refs, setOpen]);\n  useIsomorphicLayoutEffect(() => {\n    var _a, _b;\n    if (open && controlledScrolling) {\n      if (activeIndex != null) {\n        (_a = listItemsRef.current[activeIndex]) == null ? void 0 : _a.scrollIntoView({ block: \"nearest\" });\n      }\n    }\n    setScrollTop(((_b = refs.floating.current) == null ? void 0 : _b.scrollTop) ?? 0);\n  }, [open, refs, controlledScrolling, activeIndex]);\n  useIsomorphicLayoutEffect(() => {\n    var _a;\n    if (open && fallback) {\n      if (selectedIndex != null) {\n        (_a = listItemsRef.current[selectedIndex]) == null ? void 0 : _a.scrollIntoView({ block: \"nearest\" });\n      }\n    }\n  }, [open, fallback, selectedIndex]);\n  useIsomorphicLayoutEffect(() => {\n    if (refs.floating.current && fallback) {\n      refs.floating.current.style.maxHeight = \"\";\n    }\n  }, [refs, fallback]);\n  return /* @__PURE__ */ jsx(\n    SelectProvider,\n    {\n      scope: __scopeSelect,\n      ...selectContext,\n      setScrollTop,\n      setInnerOffset,\n      floatingRef,\n      setValueAtIndex: (index, value) => {\n        listContentRef.current[index] = value;\n      },\n      fallback,\n      interactions: interactionsContext,\n      floatingContext: context,\n      activeIndex,\n      canScrollDown: !!showDownArrow,\n      canScrollUp: !!showUpArrow,\n      controlledScrolling,\n      dataRef: context.dataRef,\n      listRef: listItemsRef,\n      blockSelection,\n      allowMouseUpRef,\n      upArrowRef,\n      downArrowRef,\n      selectTimeoutRef,\n      allowSelectRef,\n      children\n    }\n  );\n};\nconst userAgent = typeof navigator !== \"undefined\" && navigator.userAgent || \"\";\nexport {\n  SelectInlineImpl\n};\n//# sourceMappingURL=SelectImpl.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { autoUpdate, offset, useFloating } from \"@floating-ui/react\";\nimport { useComposedRefs } from \"@tamagui/compose-refs\";\nimport { useIsomorphicLayoutEffect } from \"@tamagui/core\";\nimport { YStack } from \"@tamagui/stacks\";\nimport * as React from \"react\";\nimport { flushSync } from \"react-dom\";\nimport { useSelectContext } from \"./context\";\nconst SCROLL_UP_BUTTON_NAME = \"SelectScrollUpButton\";\nconst SelectScrollUpButton = React.forwardRef((props, forwardedRef) => {\n  return /* @__PURE__ */ jsx(\n    SelectScrollButtonImpl,\n    {\n      componentName: SCROLL_UP_BUTTON_NAME,\n      ...props,\n      dir: \"up\",\n      ref: forwardedRef\n    }\n  );\n});\nSelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;\nconst SCROLL_DOWN_BUTTON_NAME = \"SelectScrollDownButton\";\nconst SelectScrollDownButton = React.forwardRef((props, forwardedRef) => {\n  return /* @__PURE__ */ jsx(\n    SelectScrollButtonImpl,\n    {\n      componentName: SCROLL_DOWN_BUTTON_NAME,\n      ...props,\n      dir: \"down\",\n      ref: forwardedRef\n    }\n  );\n});\nSelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;\nconst SelectScrollButtonImpl = React.memo(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      var _a;\n      const { __scopeSelect, dir, componentName, ...scrollIndicatorProps } = props;\n      const {\n        floatingRef,\n        forceUpdate,\n        open,\n        fallback,\n        setScrollTop,\n        setInnerOffset,\n        ...context\n      } = useSelectContext(componentName, __scopeSelect);\n      const [element, setElement] = React.useState(null);\n      const statusRef = React.useRef(\"idle\");\n      const isVisible = context[dir === \"down\" ? \"canScrollDown\" : \"canScrollUp\"];\n      const frameRef = React.useRef();\n      const { x, y, reference, floating, strategy, update, refs } = useFloating({\n        open: open && isVisible,\n        strategy: \"fixed\",\n        placement: dir === \"up\" ? \"top\" : \"bottom\",\n        middleware: [offset(({ rects }) => -rects.floating.height)],\n        whileElementsMounted: (...args) => autoUpdate(...args, { animationFrame: true })\n      });\n      const composedRef = useComposedRefs(forwardedRef, floating);\n      if (floatingRef) {\n        if (open) {\n          if (element !== floatingRef.current) {\n            setElement(floatingRef.current);\n            reference(floatingRef.current);\n            requestAnimationFrame(update);\n          }\n        } else {\n          cancelAnimationFrame(frameRef.current);\n        }\n      }\n      useIsomorphicLayoutEffect(() => {\n        return () => {\n          cancelAnimationFrame(frameRef.current);\n        };\n      }, []);\n      if (!(isVisible && floatingRef)) {\n        return null;\n      }\n      const onScroll = (amount) => {\n        console.log(\"on scroll?\");\n        if (fallback) {\n          if (refs.floating.current) {\n            refs.floating.current.scrollTop -= amount;\n            flushSync(() => {\n              var _a2;\n              return setScrollTop(((_a2 = refs.floating.current) == null ? void 0 : _a2.scrollTop) ?? 0);\n            });\n          }\n        } else {\n          flushSync(() => setInnerOffset((value) => value - amount));\n        }\n      };\n      return /* @__PURE__ */ jsx(\n        YStack,\n        {\n          ref: composedRef,\n          componentName,\n          \"aria-hidden\": true,\n          ...scrollIndicatorProps,\n          zIndex: 1e3,\n          position: strategy,\n          left: x || 0,\n          top: y || 0,\n          width: `calc(${(((_a = floatingRef == null ? void 0 : floatingRef.current) == null ? void 0 : _a.offsetWidth) ?? 0) - 2}px)`,\n          onPointerEnter: () => {\n            statusRef.current = \"active\";\n            let prevNow = Date.now();\n            function frame() {\n              if (element) {\n                const currentNow = Date.now();\n                const msElapsed = currentNow - prevNow;\n                prevNow = currentNow;\n                const pixelsToScroll = msElapsed / 2;\n                const remainingPixels = dir === \"up\" ? element.scrollTop : element.scrollHeight - element.clientHeight - element.scrollTop;\n                const scrollRemaining = dir === \"up\" ? element.scrollTop - pixelsToScroll > 0 : element.scrollTop + pixelsToScroll < element.scrollHeight - element.clientHeight;\n                onScroll(\n                  dir === \"up\" ? Math.min(pixelsToScroll, remainingPixels) : Math.max(-pixelsToScroll, -remainingPixels)\n                );\n                if (scrollRemaining) {\n                  frameRef.current = requestAnimationFrame(frame);\n                }\n              }\n            }\n            cancelAnimationFrame(frameRef.current);\n            frameRef.current = requestAnimationFrame(frame);\n          },\n          onPointerLeave: () => {\n            statusRef.current = \"idle\";\n            cancelAnimationFrame(frameRef.current);\n          }\n        }\n      );\n    }\n  )\n);\nexport {\n  SelectScrollDownButton,\n  SelectScrollUpButton\n};\n//# sourceMappingURL=SelectScrollButton.mjs.map\n","import { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nimport { FloatingFocusManager } from \"@floating-ui/react\";\nimport { isWeb } from \"@tamagui/core\";\nimport { styled } from \"@tamagui/core\";\nimport { PortalItem } from \"@tamagui/portal\";\nimport { ThemeableStack } from \"@tamagui/stacks\";\nimport * as React from \"react\";\nimport { VIEWPORT_NAME } from \"./constants\";\nimport { ForwardSelectContext, useSelectContext } from \"./context\";\nimport { useSelectBreakpointActive } from \"./useSelectBreakpointActive\";\nconst SelectViewportFrame = styled(ThemeableStack, {\n  name: VIEWPORT_NAME,\n  backgroundColor: \"$background\",\n  elevate: true,\n  bordered: true,\n  userSelect: \"none\",\n  outlineWidth: 0,\n  variants: {\n    size: {\n      \"...size\": (val, { tokens }) => {\n        return {\n          borderRadius: tokens.radius[val] ?? val\n        };\n      }\n    }\n  },\n  defaultVariants: {\n    size: \"$2\"\n  }\n});\nconst SelectViewport = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSelect, children, disableScroll, ...viewportProps } = props;\n    const context = useSelectContext(VIEWPORT_NAME, __scopeSelect);\n    const breakpointActive = useSelectBreakpointActive(context.sheetBreakpoint);\n    if (breakpointActive || !isWeb) {\n      return /* @__PURE__ */ jsx(PortalItem, { hostName: `${context.scopeKey}SheetContents`, children: /* @__PURE__ */ jsx(ForwardSelectContext, { context, children }) });\n    }\n    if (!context.floatingContext) {\n      return null;\n    }\n    if (!context.open) {\n      return children;\n    }\n    const {\n      style: { scrollbarWidth, listStyleType, overflow, ...restStyle },\n      ...floatingProps\n    } = context.interactions.getFloatingProps();\n    return /* @__PURE__ */ jsxs(Fragment, { children: [\n      !disableScroll && /* @__PURE__ */ jsx(\n        \"style\",\n        {\n          dangerouslySetInnerHTML: {\n            __html: selectViewportCSS\n          }\n        }\n      ),\n      /* @__PURE__ */ jsx(FloatingFocusManager, { context: context.floatingContext, children: /* @__PURE__ */ jsx(\n        SelectViewportFrame,\n        {\n          size: context.size,\n          role: \"presentation\",\n          ...viewportProps,\n          ref: forwardedRef,\n          ...floatingProps,\n          ...restStyle,\n          overflow: disableScroll ? void 0 : overflow ?? \"scroll\",\n          children\n        }\n      ) })\n    ] });\n  }\n);\nSelectViewport.displayName = VIEWPORT_NAME;\nconst selectViewportCSS = `\n.is_SelectViewport {\n  scrollbar-width: none;\n  -webkit-overflow-scrolling: touch;\n  overscroll-behavior: contain;\n}\n\n.is_SelectViewport::-webkit-scrollbar{\n  display:none\n}\n`;\nexport {\n  SelectViewport,\n  SelectViewportFrame\n};\n//# sourceMappingURL=SelectViewport.mjs.map\n","const SELECT_NAME = \"Select\";\nconst WINDOW_PADDING = 8;\nconst SCROLL_ARROW_VELOCITY = 8;\nconst SCROLL_ARROW_THRESHOLD = 8;\nconst MIN_HEIGHT = 80;\nconst FALLBACK_THRESHOLD = 16;\nconst VIEWPORT_NAME = \"SelectViewport\";\nexport {\n  FALLBACK_THRESHOLD,\n  MIN_HEIGHT,\n  SCROLL_ARROW_THRESHOLD,\n  SCROLL_ARROW_VELOCITY,\n  SELECT_NAME,\n  VIEWPORT_NAME,\n  WINDOW_PADDING\n};\n//# sourceMappingURL=constants.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport { SELECT_NAME } from \"./constants\";\nconst [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME);\nconst [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);\nconst ForwardSelectContext = (props) => {\n  return /* @__PURE__ */ jsx(SelectProvider, { isInSheet: true, scope: props.__scopeSelect, ...props.context, children: props.children });\n};\nexport {\n  ForwardSelectContext,\n  SelectProvider,\n  createSelectContext,\n  createSelectScope,\n  useSelectContext\n};\n//# sourceMappingURL=context.mjs.map\n","export * from \"./Select\";\nexport * from \"./context\";\n//# sourceMappingURL=index.mjs.map\n","import { useMedia } from \"@tamagui/core\";\nconst useSelectBreakpointActive = (sheetBreakpoint) => {\n  const media = useMedia();\n  if (!sheetBreakpoint)\n    return false;\n  if (sheetBreakpoint === true)\n    return true;\n  return sheetBreakpoint ? media[sheetBreakpoint] : false;\n};\nconst useShowSelectSheet = (context) => {\n  const breakpointActive = useSelectBreakpointActive(context.sheetBreakpoint);\n  return context.open === false ? false : breakpointActive;\n};\nexport {\n  useSelectBreakpointActive,\n  useShowSelectSheet\n};\n//# sourceMappingURL=useSelectBreakpointActive.mjs.map\n","import { Stack, isWeb, styled } from \"@tamagui/core\";\nconst Separator = styled(Stack, {\n  name: \"Separator\",\n  borderColor: \"$borderColor\",\n  flexShrink: 0,\n  borderWidth: 0,\n  flex: 1,\n  height: 0,\n  maxHeight: 0,\n  borderBottomWidth: 1,\n  y: -0.5,\n  variants: {\n    vertical: {\n      true: {\n        y: 0,\n        x: -0.5,\n        height: isWeb ? \"initial\" : \"auto\",\n        // maxHeight auto WILL BE passed to style attribute, but for some reason not used?\n        // almost seems like a react or browser bug, but for now `initial` works\n        // also, it doesn't happen for `height`, but for consistency using the same values\n        maxHeight: isWeb ? \"initial\" : \"auto\",\n        width: 0,\n        maxWidth: 0,\n        borderBottomWidth: 0,\n        borderRightWidth: 1\n      }\n    }\n  }\n});\nexport {\n  Separator\n};\n//# sourceMappingURL=Separator.mjs.map\n","export * from \"./Separator\";\n//# sourceMappingURL=index.mjs.map\n","import { styled } from \"@tamagui/web\";\nimport { Square } from \"./Square\";\nconst Circle = styled(Square, {\n  name: \"Circle\",\n  circular: true\n});\nexport {\n  Circle\n};\n//# sourceMappingURL=Circle.mjs.map\n","import { ThemeableStack } from \"@tamagui/stacks\";\nimport { styled } from \"@tamagui/web\";\nimport { getShapeSize } from \"./getShapeSize\";\nconst Square = styled(ThemeableStack, {\n  name: \"Square\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  variants: {\n    circular: {\n      true: {\n        borderRadius: 1e5\n      }\n    },\n    size: {\n      \"...size\": getShapeSize\n    }\n  }\n});\nexport {\n  Square\n};\n//# sourceMappingURL=Square.mjs.map\n","const getShapeSize = (size, { tokens }) => {\n  const width = tokens.size[size] ?? size;\n  const height = tokens.size[size] ?? size;\n  return {\n    width,\n    height,\n    minWidth: width,\n    maxWidth: width,\n    maxHeight: height,\n    minHeight: height\n  };\n};\nexport {\n  getShapeSize\n};\n//# sourceMappingURL=getShapeSize.mjs.map\n","export * from \"./Square\";\nexport * from \"./Circle\";\nexport * from \"./getShapeSize\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx, jsxs } from \"react/jsx-runtime\";\nimport { AdaptParentContext } from \"@tamagui/adapt\";\nimport { useComposedRefs } from \"@tamagui/compose-refs\";\nimport {\n  Theme,\n  isClient,\n  isTouchable,\n  isWeb,\n  mergeEvent,\n  styled,\n  themeable,\n  useAnimationDriver,\n  useDidFinishSSR,\n  useEvent,\n  useIsomorphicLayoutEffect,\n  useThemeName,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { Portal } from \"@tamagui/portal\";\nimport { RemoveScroll } from \"@tamagui/remove-scroll\";\nimport { ThemeableStack, XStack, YStack } from \"@tamagui/stacks\";\nimport { useConstant } from \"@tamagui/use-constant\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport { useKeyboardVisible } from \"@tamagui/use-keyboard-visible\";\nimport React, {\n  createContext,\n  forwardRef,\n  isValidElement,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState\n} from \"react\";\nimport {\n  Keyboard,\n  PanResponder\n} from \"react-native\";\nimport { SHEET_HANDLE_NAME, SHEET_NAME } from \"./constants\";\nimport { SheetProvider, useSheetContext } from \"./SheetContext\";\nimport { SheetScrollView } from \"./SheetScrollView\";\nimport { createSheetScope } from \"./SheetContext\";\nconst SheetHandleFrame = styled(XStack, {\n  name: SHEET_HANDLE_NAME,\n  height: 10,\n  borderRadius: 100,\n  backgroundColor: \"$background\",\n  zIndex: 10,\n  marginHorizontal: \"35%\",\n  marginBottom: \"$2\",\n  opacity: 0.5,\n  hoverStyle: {\n    opacity: 0.7\n  },\n  variants: {\n    open: {\n      true: {\n        pointerEvents: \"auto\"\n      },\n      false: {\n        opacity: 0,\n        pointerEvents: \"none\"\n      }\n    }\n  }\n});\nconst SheetHandle = SheetHandleFrame.extractable(\n  ({ __scopeSheet, ...props }) => {\n    const context = useSheetContext(SHEET_HANDLE_NAME, __scopeSheet);\n    return /* @__PURE__ */ jsx(\n      SheetHandleFrame,\n      {\n        onPress: () => {\n          const max = context.snapPoints.length + (context.dismissOnSnapToBottom ? -1 : 0);\n          const nextPos = (context.position + 1) % max;\n          context.setPosition(nextPos);\n        },\n        open: context.open,\n        ...props\n      }\n    );\n  }\n);\nconst SHEET_OVERLAY_NAME = \"SheetOverlay\";\nconst SheetOverlayFrame = styled(ThemeableStack, {\n  name: SHEET_OVERLAY_NAME,\n  fullscreen: true,\n  backgrounded: true,\n  opacity: 0.5,\n  zIndex: 0,\n  variants: {\n    closed: {\n      true: {\n        opacity: 0,\n        pointerEvents: \"none\"\n      },\n      false: {\n        pointerEvents: \"auto\"\n      }\n    }\n  }\n});\nconst SheetOverlay = SheetOverlayFrame.extractable(\n  ({ __scopeSheet, ...props }) => {\n    const context = useSheetContext(SHEET_OVERLAY_NAME, __scopeSheet);\n    return /* @__PURE__ */ jsx(\n      SheetOverlayFrame,\n      {\n        closed: !context.open || context.hidden,\n        ...props,\n        onPress: mergeEvent(\n          props.onPress,\n          context.dismissOnOverlayPress ? () => {\n            context.setOpen(false);\n          } : void 0\n        )\n      }\n    );\n  }\n);\nconst selectionStyleSheet = isClient ? document.createElement(\"style\") : null;\nif (selectionStyleSheet) {\n  document.head.appendChild(selectionStyleSheet);\n}\nconst SheetFrameFrame = styled(YStack, {\n  name: SHEET_NAME,\n  flex: 1,\n  backgroundColor: \"$background\",\n  borderTopLeftRadius: \"$true\",\n  borderTopRightRadius: \"$true\",\n  width: \"100%\",\n  maxHeight: \"100%\",\n  overflow: \"hidden\",\n  pointerEvents: \"auto\"\n});\nconst SheetFrame = SheetFrameFrame.extractable(\n  forwardRef(\n    ({ __scopeSheet, ...props }, forwardedRef) => {\n      const context = useSheetContext(SHEET_NAME, __scopeSheet);\n      const composedContentRef = useComposedRefs(forwardedRef, context.contentRef);\n      return /* @__PURE__ */ jsx(SheetFrameFrame, { ref: composedContentRef, ...props });\n    }\n  )\n);\nconst HIDDEN_SIZE = 1e4;\nconst sheetComponents = {\n  Handle: SheetHandle,\n  Frame: SheetFrame,\n  Overlay: SheetOverlay,\n  ScrollView: SheetScrollView\n};\nconst ParentSheetContext = createContext({\n  zIndex: 40\n});\nconst useSheetContoller = () => {\n  const controller = useContext(SheetControllerContext);\n  const isHidden = controller == null ? void 0 : controller.hidden;\n  const isShowingNonSheet = isHidden && (controller == null ? void 0 : controller.open);\n  return {\n    controller,\n    isHidden,\n    isShowingNonSheet\n  };\n};\nconst Sheet = withStaticProperties(\n  forwardRef(function Sheet2(props, ref) {\n    const hydrated = useDidFinishSSR();\n    const { isShowingNonSheet } = useSheetContoller();\n    if (isShowingNonSheet || !hydrated) {\n      return null;\n    }\n    return /* @__PURE__ */ jsx(SheetImplementation, { ref, ...props });\n  }),\n  sheetComponents\n);\nconst SheetImplementation = themeable(\n  forwardRef(function SheetImplementation2(props, forwardedRef) {\n    const parentSheet = useContext(ParentSheetContext);\n    const { isHidden, controller } = useSheetContoller();\n    const {\n      __scopeSheet,\n      snapPoints: snapPointsProp = [80],\n      open: openProp,\n      defaultOpen,\n      children: childrenProp,\n      position: positionProp,\n      onPositionChange,\n      onOpenChange,\n      defaultPosition,\n      dismissOnOverlayPress = true,\n      animationConfig,\n      dismissOnSnapToBottom = false,\n      forceRemoveScrollEnabled = null,\n      disableDrag: disableDragProp,\n      modal = false,\n      zIndex = parentSheet.zIndex + 1,\n      moveOnKeyboardChange = false,\n      portalProps\n    } = props;\n    if (process.env.NODE_ENV === \"development\") {\n      if (snapPointsProp.some((p) => p < 0 || p > 100)) {\n        console.warn(\n          \"\\u26A0\\uFE0F Invalid snapPoint given, snapPoints must be between 0 and 100, equal to percent height of frame\"\n        );\n      }\n    }\n    const sheetRef = useRef(null);\n    const ref = useComposedRefs(forwardedRef, sheetRef);\n    const driver = useAnimationDriver();\n    if (!driver) {\n      throw new Error(\"Must set animations in tamagui.config.ts\");\n    }\n    const disableDrag = disableDragProp ?? (controller == null ? void 0 : controller.disableDrag);\n    const keyboardIsVisible = useKeyboardVisible();\n    const themeName = useThemeName();\n    const contentRef = React.useRef(null);\n    const scrollBridge = useConstant(() => ({\n      enabled: false,\n      y: 0,\n      paneY: 0,\n      paneMinY: 0,\n      scrollStartY: -1,\n      drag: () => {\n      },\n      release: () => {\n      },\n      scrollLock: false\n    }));\n    const onOpenChangeInternal = (val) => {\n      var _a;\n      (_a = controller == null ? void 0 : controller.onOpenChange) == null ? void 0 : _a.call(controller, val);\n      onOpenChange == null ? void 0 : onOpenChange(val);\n    };\n    const [open, setOpen] = useControllableState({\n      prop: (controller == null ? void 0 : controller.open) ?? openProp,\n      defaultProp: true,\n      onChange: onOpenChangeInternal,\n      strategy: \"most-recent-wins\",\n      transition: true\n    });\n    const [frameSize, setFrameSize] = useState(0);\n    const snapPoints = useMemo(\n      () => dismissOnSnapToBottom ? [...snapPointsProp, 0] : snapPointsProp,\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [JSON.stringify(snapPointsProp), dismissOnSnapToBottom]\n    );\n    const [position_, setPosition_] = useControllableState({\n      prop: positionProp,\n      defaultProp: defaultPosition || (open ? 0 : -1),\n      onChange: onPositionChange,\n      strategy: \"most-recent-wins\",\n      transition: true\n    });\n    const position = open === false ? -1 : position_;\n    if (open && dismissOnSnapToBottom && position === snapPoints.length - 1) {\n      setPosition_(0);\n    }\n    const setPosition = useCallback(\n      (next) => {\n        if (dismissOnSnapToBottom && next === snapPoints.length - 1) {\n          setOpen(false);\n        } else {\n          setPosition_(next);\n        }\n      },\n      [dismissOnSnapToBottom, snapPoints.length, setPosition_, setOpen]\n    );\n    const { useAnimatedNumber, useAnimatedNumberReaction, useAnimatedNumberStyle } = driver;\n    const animatedNumber = useAnimatedNumber(HIDDEN_SIZE);\n    const at = useRef(0);\n    useAnimatedNumberReaction(\n      {\n        value: animatedNumber,\n        hostRef: sheetRef\n      },\n      (value) => {\n        if (!driver.isReactNative)\n          return;\n        at.current = value;\n        scrollBridge.paneY = value;\n      }\n    );\n    function stopSpring() {\n      animatedNumber.stop();\n      if (scrollBridge.onFinishAnimate) {\n        scrollBridge.onFinishAnimate();\n        scrollBridge.onFinishAnimate = void 0;\n      }\n    }\n    const shouldSetPositionOpen = open && position < 0;\n    useEffect(() => {\n      if (shouldSetPositionOpen) {\n        setPosition(0);\n      }\n    }, [setPosition, shouldSetPositionOpen]);\n    const maxSnapPoint = snapPoints.reduce((prev, cur) => Math.max(prev, cur));\n    const screenSize = frameSize / (maxSnapPoint / 100);\n    const positions = useMemo(\n      () => snapPoints.map((point) => getPercentSize(point, screenSize)),\n      [frameSize, snapPoints]\n    );\n    const [opacity, setOpacity] = useState(open ? 1 : 0);\n    if (open && opacity === 0) {\n      setOpacity(1);\n    }\n    useEffect(() => {\n      if (!open) {\n        const tm = setTimeout(() => {\n          setOpacity(0);\n        }, 400);\n        return () => {\n          clearTimeout(tm);\n        };\n      }\n    }, [open]);\n    const animateTo = useEvent((position2) => {\n      const current = animatedNumber.getValue();\n      if (isHidden && open)\n        return;\n      if (!current)\n        return;\n      if (frameSize === 0)\n        return;\n      const hiddenValue = frameSize === 0 ? HIDDEN_SIZE : screenSize;\n      const toValue = isHidden || position2 === -1 ? hiddenValue : positions[position2];\n      if (at.current === toValue)\n        return;\n      stopSpring();\n      if (isHidden) {\n        animatedNumber.setValue(toValue, {\n          type: \"timing\",\n          duration: 0\n        });\n        at.current = toValue;\n        return;\n      }\n      const overshootClamping = at.current === HIDDEN_SIZE;\n      animatedNumber.setValue(toValue, {\n        ...animationConfig,\n        type: \"spring\",\n        overshootClamping\n      });\n    });\n    useIsomorphicLayoutEffect(() => {\n      animateTo(position);\n    }, [isHidden, frameSize, position, animateTo]);\n    const [isShowingInnerSheet, setIsShowingInnerSheet] = useState(false);\n    const shouldHideParentSheet = !isWeb && modal && isShowingInnerSheet;\n    const parentSheetContext = useContext(SheetInsideSheetContext);\n    const onInnerSheet = useCallback((hasChild) => {\n      setIsShowingInnerSheet(hasChild);\n    }, []);\n    const panResponder = useMemo(\n      () => {\n        if (disableDrag)\n          return;\n        if (!frameSize)\n          return;\n        if (isShowingInnerSheet)\n          return;\n        const minY = positions[0];\n        scrollBridge.paneMinY = minY;\n        let startY = at.current;\n        function makeUnselectable(val) {\n          if (!selectionStyleSheet)\n            return;\n          if (!val) {\n            selectionStyleSheet.innerText = \"\";\n          } else {\n            selectionStyleSheet.innerText = \":root * { user-select: none !important; -webkit-user-select: none !important; }\";\n          }\n        }\n        const release = ({ vy, dragAt }) => {\n          isExternalDrag = false;\n          previouslyScrolling = false;\n          makeUnselectable(false);\n          const at2 = dragAt + startY;\n          const end = at2 + frameSize * vy * 0.2;\n          let closestPoint = 0;\n          let dist = Infinity;\n          for (let i = 0; i < positions.length; i++) {\n            const position2 = positions[i];\n            const curDist = end > position2 ? end - position2 : position2 - end;\n            if (curDist < dist) {\n              dist = curDist;\n              closestPoint = i;\n            }\n          }\n          setPosition(closestPoint);\n          animateTo(closestPoint);\n        };\n        const finish = (_e, state) => {\n          release({\n            vy: state.vy,\n            dragAt: state.dy\n          });\n        };\n        let previouslyScrolling = false;\n        const onMoveShouldSet = (_e, { dy }) => {\n          const isScrolled = scrollBridge.y !== 0;\n          const isDraggingUp = dy < 0;\n          const isNearTop = scrollBridge.paneY - 5 <= scrollBridge.paneMinY;\n          if (isScrolled) {\n            previouslyScrolling = true;\n            return false;\n          }\n          if (isNearTop) {\n            if (!isScrolled && isDraggingUp) {\n              return false;\n            }\n          }\n          return Math.abs(dy) > 5;\n        };\n        const grant = () => {\n          makeUnselectable(true);\n          stopSpring();\n          startY = at.current;\n        };\n        let isExternalDrag = false;\n        scrollBridge.drag = (dy) => {\n          if (!isExternalDrag) {\n            isExternalDrag = true;\n            grant();\n          }\n          const to = dy + startY;\n          animatedNumber.setValue(resisted(to, minY), { type: \"direct\" });\n        };\n        scrollBridge.release = release;\n        return PanResponder.create({\n          onMoveShouldSetPanResponder: onMoveShouldSet,\n          onPanResponderGrant: grant,\n          onPanResponderMove: (_e, { dy }) => {\n            const toFull = dy + startY;\n            const to = resisted(toFull, minY);\n            animatedNumber.setValue(to, { type: \"direct\" });\n          },\n          onPanResponderEnd: finish,\n          onPanResponderTerminate: finish,\n          onPanResponderRelease: finish\n        });\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [disableDrag, isShowingInnerSheet, animateTo, frameSize, positions, setPosition]\n    );\n    let handleComponent = null;\n    let overlayComponent = null;\n    let frameComponent = null;\n    React.Children.forEach(childrenProp, (child) => {\n      var _a, _b;\n      if (isValidElement(child)) {\n        const name = (_b = (_a = child.type) == null ? void 0 : _a[\"staticConfig\"]) == null ? void 0 : _b.componentName;\n        switch (name) {\n          case \"SheetHandle\":\n            handleComponent = child;\n            break;\n          case \"Sheet\":\n            frameComponent = child;\n            break;\n          case \"SheetOverlay\":\n            overlayComponent = child;\n            break;\n          default:\n            console.warn(\"Warning: passed invalid child to Sheet\", child);\n        }\n      }\n    });\n    const animatedStyle = useAnimatedNumberStyle(animatedNumber, (val) => {\n      const translateY = frameSize === 0 ? HIDDEN_SIZE : val;\n      return {\n        transform: [{ translateY }]\n      };\n    });\n    const sizeBeforeKeyboard = useRef(null);\n    useEffect(() => {\n      if (isWeb || !moveOnKeyboardChange)\n        return;\n      const keyboardDidShowListener = Keyboard.addListener(\"keyboardDidShow\", (e) => {\n        if (sizeBeforeKeyboard.current !== null)\n          return;\n        sizeBeforeKeyboard.current = animatedNumber.getValue();\n        animatedNumber.setValue(\n          Math.max(animatedNumber.getValue() - e.endCoordinates.height, 0)\n        );\n      });\n      const keyboardDidHideListener = Keyboard.addListener(\"keyboardDidHide\", () => {\n        if (sizeBeforeKeyboard.current === null)\n          return;\n        animatedNumber.setValue(sizeBeforeKeyboard.current);\n        sizeBeforeKeyboard.current = null;\n      });\n      return () => {\n        keyboardDidHideListener.remove();\n        keyboardDidShowListener.remove();\n      };\n    }, []);\n    const AnimatedView = driver[\"NumberView\"] ?? driver.View;\n    useIsomorphicLayoutEffect(() => {\n      if (!(parentSheetContext && open))\n        return;\n      parentSheetContext(true);\n      return () => {\n        parentSheetContext(false);\n      };\n    }, [parentSheetContext, open]);\n    const nextParentContext = useMemo(\n      () => ({\n        zIndex\n      }),\n      [zIndex]\n    );\n    const handleLayout = useCallback(\n      (e) => {\n        var _a;\n        let next = (_a = e.nativeEvent) == null ? void 0 : _a.layout.height;\n        if (isWeb && isTouchable && !open) {\n          next += 100;\n        }\n        if (!next)\n          return;\n        setFrameSize(() => next);\n      },\n      [keyboardIsVisible]\n    );\n    const removeScrollEnabled = forceRemoveScrollEnabled ?? (open && modal);\n    const contents = /* @__PURE__ */ jsx(ParentSheetContext.Provider, { value: nextParentContext, children: /* @__PURE__ */ jsxs(\n      SheetProvider,\n      {\n        modal,\n        contentRef,\n        frameSize,\n        dismissOnOverlayPress,\n        dismissOnSnapToBottom,\n        open,\n        hidden: !!isHidden,\n        scope: __scopeSheet,\n        position,\n        snapPoints,\n        setPosition,\n        setOpen,\n        scrollBridge,\n        children: [\n          shouldHideParentSheet ? null : overlayComponent,\n          /* @__PURE__ */ jsxs(\n            AnimatedView,\n            {\n              ref,\n              ...panResponder == null ? void 0 : panResponder.panHandlers,\n              onLayout: handleLayout,\n              pointerEvents: open && !shouldHideParentSheet ? \"auto\" : \"none\",\n              animation: props.animation,\n              style: [\n                {\n                  position: \"absolute\",\n                  zIndex,\n                  width: \"100%\",\n                  height: `${maxSnapPoint}%`,\n                  opacity\n                },\n                animatedStyle\n              ],\n              children: [\n                handleComponent,\n                /* @__PURE__ */ jsx(\n                  RemoveScroll,\n                  {\n                    forwardProps: true,\n                    enabled: removeScrollEnabled,\n                    allowPinchZoom: true,\n                    shards: [contentRef],\n                    removeScrollBar: false,\n                    children: frameComponent\n                  }\n                )\n              ]\n            }\n          )\n        ]\n      }\n    ) });\n    const adaptContext = useContext(AdaptParentContext);\n    if (modal) {\n      const modalContents = /* @__PURE__ */ jsx(Portal, { zIndex, ...portalProps, children: /* @__PURE__ */ jsx(Theme, { forceClassName: true, name: themeName, children: /* @__PURE__ */ jsx(AdaptParentContext.Provider, { value: adaptContext, children: contents }) }) });\n      if (isWeb) {\n        return modalContents;\n      }\n      return /* @__PURE__ */ jsx(SheetInsideSheetContext.Provider, { value: onInnerSheet, children: modalContents });\n    }\n    return contents;\n  }),\n  { componentName: \"Sheet\" }\n);\nconst SheetInsideSheetContext = createContext(null);\nconst ControlledSheet = Sheet;\nfunction getPercentSize(point, screenSize) {\n  if (!screenSize)\n    return 0;\n  if (point === void 0) {\n    console.warn(\"No snapPoint\");\n    return 0;\n  }\n  const pct = point / 100;\n  const next = Math.round(screenSize - pct * screenSize);\n  return next;\n}\nfunction resisted(y, minY, maxOverflow = 25) {\n  if (y < minY) {\n    const past = minY - y;\n    const pctPast = Math.min(maxOverflow, past) / maxOverflow;\n    const diminishBy = 1.1 - Math.pow(0.1, pctPast);\n    const extra = -diminishBy * maxOverflow;\n    return minY + extra;\n  }\n  return y;\n}\nconst SheetControllerContext = createContext(null);\nconst SheetController = ({\n  children,\n  onOpenChange: onOpenChangeProp,\n  ...value\n}) => {\n  const onOpenChange = useEvent(onOpenChangeProp);\n  const memoValue = useMemo(\n    () => ({\n      open: value.open,\n      hidden: value.hidden,\n      disableDrag: value.disableDrag,\n      onOpenChange\n    }),\n    [onOpenChange, value.open, value.hidden, value.disableDrag]\n  );\n  return /* @__PURE__ */ jsx(SheetControllerContext.Provider, { value: memoValue, children });\n};\nexport {\n  ControlledSheet,\n  Sheet,\n  SheetController,\n  SheetFrame,\n  SheetFrameFrame,\n  SheetHandle,\n  SheetHandleFrame,\n  SheetOverlay,\n  SheetOverlayFrame,\n  createSheetScope\n};\n//# sourceMappingURL=Sheet.mjs.map\n","import { createContextScope } from \"@tamagui/create-context\";\nimport { SHEET_NAME } from \"./constants\";\nconst [createSheetContext, createSheetScope] = createContextScope(SHEET_NAME);\nconst [SheetProvider, useSheetContext] = createSheetContext(\n  SHEET_NAME,\n  {}\n);\nexport {\n  SheetProvider,\n  createSheetContext,\n  createSheetScope,\n  useSheetContext\n};\n//# sourceMappingURL=SheetContext.mjs.map\n","import { jsx, jsxs } from \"react/jsx-runtime\";\nimport { Stack, composeRefs } from \"@tamagui/core\";\nimport { ScrollView } from \"@tamagui/scroll-view\";\nimport { forwardRef, useMemo, useRef, useState } from \"react\";\nimport { useSheetContext } from \"./SheetContext\";\nconst SHEET_SCROLL_VIEW_NAME = \"SheetScrollView\";\nconst SheetScrollView = forwardRef(\n  ({ __scopeSheet, children, ...props }, ref) => {\n    const { scrollBridge, position, snapPoints, frameSize, open } = useSheetContext(\n      SHEET_SCROLL_VIEW_NAME,\n      __scopeSheet\n    );\n    const scrollRef = useRef(null);\n    const percentOpened = snapPoints[position] ?? 0;\n    const [percentToPadBottom, setPercentToPadBottom] = useState(0);\n    const next = 100 - percentOpened;\n    if (open && next !== percentToPadBottom) {\n      setPercentToPadBottom(next);\n    }\n    const state = useRef({\n      lastPageY: 0,\n      dragAt: 0,\n      dys: [],\n      // store a few recent dys to get velocity on release\n      isScrolling: false,\n      isDragging: false\n    });\n    const release = () => {\n      if (!state.current.isDragging) {\n        return;\n      }\n      state.current.isDragging = false;\n      scrollBridge.scrollStartY = -1;\n      state.current.isScrolling = false;\n      let vy = 0;\n      if (state.current.dys.length) {\n        const recentDys = state.current.dys.slice(-10);\n        const dist = recentDys.length ? recentDys.reduce((a, b) => a + b, 0) : 0;\n        const avgDy = dist / recentDys.length;\n        vy = avgDy * 0.04;\n      }\n      state.current.dys = [];\n      scrollBridge.release({\n        dragAt: state.current.dragAt,\n        vy\n      });\n    };\n    return /* @__PURE__ */ jsxs(\n      ScrollView,\n      {\n        ref: composeRefs(scrollRef, ref),\n        flex: 1,\n        scrollEventThrottle: 8,\n        onScroll: (e) => {\n          const { y } = e.nativeEvent.contentOffset;\n          scrollBridge.y = y;\n          if (y > 0) {\n            scrollBridge.scrollStartY = -1;\n          }\n        },\n        onStartShouldSetResponder: () => {\n          scrollBridge.scrollStartY = -1;\n          state.current.isDragging = true;\n          return true;\n        },\n        onMoveShouldSetResponder: () => false,\n        onResponderRelease: release,\n        className: \"_ovs-contain\",\n        ...props,\n        children: [\n          useMemo(() => children, [children]),\n          /* @__PURE__ */ jsx(Stack, { height: percentToPadBottom / 100 * frameSize, width: 0 })\n        ]\n      }\n    );\n  }\n);\nexport {\n  SheetScrollView\n};\n//# sourceMappingURL=SheetScrollView.mjs.map\n","const constants = {};\nconst SHEET_NAME = \"Sheet\";\nconst SHEET_HANDLE_NAME = \"SheetHandle\";\nexport {\n  SHEET_HANDLE_NAME,\n  SHEET_NAME,\n  constants\n};\n//# sourceMappingURL=constants.mjs.map\n","export * from \"./Sheet\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { composeRefs, useComposedRefs } from \"@tamagui/compose-refs\";\nimport {\n  getVariableValue,\n  isWeb,\n  styled,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { getSize } from \"@tamagui/get-size\";\nimport { clamp, composeEventHandlers } from \"@tamagui/helpers\";\nimport { ThemeableStack } from \"@tamagui/stacks\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport { useDirection } from \"@tamagui/use-direction\";\nimport * as React from \"react\";\nimport {\n  ARROW_KEYS,\n  BACK_KEYS,\n  PAGE_KEYS,\n  SLIDER_NAME,\n  SliderOrientationProvider,\n  SliderProvider,\n  useSliderContext,\n  useSliderOrientationContext\n} from \"./constants\";\nimport {\n  convertValueToPercentage,\n  getClosestValueIndex,\n  getDecimalCount,\n  getLabel,\n  getNextSortedValues,\n  getThumbInBoundsOffset,\n  hasMinStepsBetweenValues,\n  linearScale,\n  roundValue\n} from \"./helpers\";\nimport { SliderFrame, SliderImpl } from \"./SliderImpl\";\nconst SliderHorizontal = React.forwardRef(\n  (props, forwardedRef) => {\n    const { min, max, dir, onSlideStart, onSlideMove, onStepKeyDown, ...sliderProps } = props;\n    const direction = useDirection(dir);\n    const isDirectionLTR = direction === \"ltr\";\n    const sliderRef = React.useRef(null);\n    const [state, setState] = React.useState(() => ({ size: 0, offset: 0 }));\n    function getValueFromPointer(pointerPosition) {\n      const input = [0, state.size];\n      const output = isDirectionLTR ? [min, max] : [max, min];\n      const value = linearScale(input, output);\n      return value(pointerPosition);\n    }\n    return /* @__PURE__ */ jsx(\n      SliderOrientationProvider,\n      {\n        scope: props.__scopeSlider,\n        startEdge: isDirectionLTR ? \"left\" : \"right\",\n        endEdge: isDirectionLTR ? \"right\" : \"left\",\n        direction: isDirectionLTR ? 1 : -1,\n        sizeProp: \"width\",\n        size: state.size,\n        children: /* @__PURE__ */ jsx(\n          SliderImpl,\n          {\n            ref: composeRefs(forwardedRef, sliderRef),\n            dir: direction,\n            ...sliderProps,\n            orientation: \"horizontal\",\n            onLayout: () => {\n              var _a;\n              (_a = sliderRef.current) == null ? void 0 : _a.measure((_x, _y, width, _height, pageX, _pageY) => {\n                setState({\n                  size: width,\n                  offset: pageX\n                });\n              });\n            },\n            onSlideStart: (event, target) => {\n              const value = getValueFromPointer(event.nativeEvent.locationX);\n              if (value) {\n                onSlideStart == null ? void 0 : onSlideStart(value, target);\n              }\n            },\n            onSlideMove: (event) => {\n              const value = getValueFromPointer(event.nativeEvent.pageX - state.offset);\n              if (value) {\n                onSlideMove == null ? void 0 : onSlideMove(value);\n              }\n            },\n            onSlideEnd: () => {\n            },\n            onStepKeyDown: (event) => {\n              const isBackKey = BACK_KEYS[direction].includes(event.key);\n              onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });\n            }\n          }\n        )\n      }\n    );\n  }\n);\nconst SliderVertical = React.forwardRef(\n  (props, forwardedRef) => {\n    const { min, max, onSlideStart, onSlideMove, onStepKeyDown, ...sliderProps } = props;\n    const [state, setState] = React.useState(() => ({ size: 0, offset: 0 }));\n    const sliderRef = React.useRef(null);\n    function getValueFromPointer(pointerPosition) {\n      const input = [0, state.size];\n      const output = [max, min];\n      const value = linearScale(input, output);\n      return value(pointerPosition);\n    }\n    return /* @__PURE__ */ jsx(\n      SliderOrientationProvider,\n      {\n        scope: props.__scopeSlider,\n        startEdge: \"bottom\",\n        endEdge: \"top\",\n        sizeProp: \"height\",\n        size: state.size,\n        direction: 1,\n        children: /* @__PURE__ */ jsx(\n          SliderImpl,\n          {\n            ref: composeRefs(forwardedRef, sliderRef),\n            ...sliderProps,\n            orientation: \"vertical\",\n            onLayout: ({ nativeEvent: { layout } }) => {\n              var _a;\n              (_a = sliderRef.current) == null ? void 0 : _a.measure((_x, _y, _width, height, _pageX, pageY) => {\n                setState({\n                  size: height,\n                  offset: pageY\n                });\n              });\n            },\n            onSlideStart: (event, target) => {\n              const value = getValueFromPointer(event.nativeEvent.locationY);\n              if (value) {\n                onSlideStart == null ? void 0 : onSlideStart(value, target);\n              }\n            },\n            onSlideMove: (event) => {\n              const value = getValueFromPointer(event.nativeEvent.pageY - state.offset);\n              if (value) {\n                onSlideMove == null ? void 0 : onSlideMove(value);\n              }\n            },\n            onSlideEnd: () => {\n            },\n            onStepKeyDown: (event) => {\n              const isBackKey = BACK_KEYS.ltr.includes(event.key);\n              onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });\n            }\n          }\n        )\n      }\n    );\n  }\n);\nconst TRACK_NAME = \"SliderTrack\";\nconst SliderTrackFrame = styled(SliderFrame, {\n  name: \"SliderTrack\",\n  height: \"100%\",\n  width: \"100%\",\n  backgroundColor: \"$background\",\n  position: \"relative\",\n  borderRadius: 1e5,\n  overflow: \"hidden\"\n});\nconst SliderTrack = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSlider, ...trackProps } = props;\n    const context = useSliderContext(TRACK_NAME, __scopeSlider);\n    return /* @__PURE__ */ jsx(\n      SliderTrackFrame,\n      {\n        \"data-disabled\": context.disabled ? \"\" : void 0,\n        \"data-orientation\": context.orientation,\n        orientation: context.orientation,\n        size: context.size,\n        ...trackProps,\n        ref: forwardedRef\n      }\n    );\n  }\n);\nSliderTrack.displayName = TRACK_NAME;\nconst RANGE_NAME = \"SliderTrackActive\";\nconst SliderTrackActiveFrame = styled(SliderFrame, {\n  name: \"SliderTrackActive\",\n  backgroundColor: \"$background\",\n  position: \"absolute\"\n});\nconst SliderTrackActive = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSlider, ...rangeProps } = props;\n    const context = useSliderContext(RANGE_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);\n    const ref = React.useRef(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const valuesCount = context.values.length;\n    const percentages = context.values.map(\n      (value) => convertValueToPercentage(value, context.min, context.max)\n    );\n    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;\n    const offsetEnd = 100 - Math.max(...percentages);\n    return /* @__PURE__ */ jsx(\n      SliderTrackActiveFrame,\n      {\n        orientation: context.orientation,\n        \"data-orientation\": context.orientation,\n        \"data-disabled\": context.disabled ? \"\" : void 0,\n        size: context.size,\n        ...rangeProps,\n        ref: composedRefs,\n        ...{\n          [orientation.startEdge]: `${offsetStart}%`,\n          [orientation.endEdge]: `${offsetEnd}%`\n        },\n        ...orientation.sizeProp === \"width\" ? {\n          height: \"100%\"\n        } : {\n          left: 0,\n          right: 0\n        }\n      }\n    );\n  }\n);\nSliderTrackActive.displayName = RANGE_NAME;\nconst THUMB_NAME = \"SliderThumb\";\nconst getThumbSize = (val) => {\n  const size = typeof val === \"number\" ? val : getSize(val, -1);\n  return {\n    width: size,\n    height: size,\n    minWidth: size,\n    minHeight: size\n  };\n};\nconst SliderThumbFrame = styled(ThemeableStack, {\n  name: \"SliderThumb\",\n  position: \"absolute\",\n  bordered: 2,\n  borderWidth: 2,\n  backgrounded: true,\n  pressTheme: isWeb,\n  focusTheme: isWeb,\n  hoverTheme: isWeb,\n  variants: {\n    size: {\n      \"...size\": getThumbSize\n    }\n  }\n});\nconst SliderThumb = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeSlider, index, size: sizeProp, ...thumbProps } = props;\n    const context = useSliderContext(THUMB_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);\n    const [thumb, setThumb] = React.useState(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    const value = context.values[index];\n    const percent = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);\n    const label = getLabel(index, context.values.length);\n    const sizeIn = sizeProp ?? context.size ?? \"$true\";\n    const [size, setSize] = React.useState(() => {\n      const estimatedSize = getVariableValue(getThumbSize(sizeIn).width);\n      return estimatedSize;\n    });\n    const thumbInBoundsOffset = size ? getThumbInBoundsOffset(size, percent, orientation.direction) : 0;\n    React.useEffect(() => {\n      if (thumb) {\n        context.thumbs.add(thumb);\n        return () => {\n          context.thumbs.delete(thumb);\n        };\n      }\n    }, [thumb, context.thumbs]);\n    return /* @__PURE__ */ jsx(\n      SliderThumbFrame,\n      {\n        ref: composedRefs,\n        role: \"slider\",\n        \"aria-label\": props[\"aria-label\"] || label,\n        \"aria-valuemin\": context.min,\n        \"aria-valuenow\": value,\n        \"aria-valuemax\": context.max,\n        \"aria-orientation\": context.orientation,\n        \"data-orientation\": context.orientation,\n        \"data-disabled\": context.disabled ? \"\" : void 0,\n        tabIndex: context.disabled ? void 0 : 0,\n        animateOnly: [\"transform\", \"left\", \"right\", \"top\", \"bottom\"],\n        ...thumbProps,\n        ...context.orientation === \"horizontal\" ? {\n          x: thumbInBoundsOffset - size / 2,\n          y: -size / 2,\n          top: \"50%\",\n          ...size === 0 && {\n            top: \"auto\",\n            bottom: \"auto\"\n          }\n        } : {\n          x: -size / 2,\n          y: size / 2,\n          left: \"50%\",\n          ...size === 0 && {\n            left: \"auto\",\n            right: \"auto\"\n          }\n        },\n        ...{\n          [orientation.startEdge]: `${percent}%`\n        },\n        size: sizeIn,\n        onLayout: (e) => {\n          setSize(e.nativeEvent.layout[orientation.sizeProp]);\n        },\n        onFocus: composeEventHandlers(props.onFocus, () => {\n          context.valueIndexToChangeRef.current = index;\n        })\n      }\n    );\n  }\n);\nSliderThumb.displayName = THUMB_NAME;\nconst Slider = withStaticProperties(\n  React.forwardRef((props, forwardedRef) => {\n    const {\n      name,\n      min = 0,\n      max = 100,\n      step = 1,\n      orientation = \"horizontal\",\n      disabled = false,\n      minStepsBetweenThumbs = 0,\n      defaultValue = [min],\n      value,\n      onValueChange = () => {\n      },\n      size: sizeProp,\n      ...sliderProps\n    } = props;\n    const sliderRef = React.useRef(null);\n    const composedRefs = useComposedRefs(sliderRef, forwardedRef);\n    const thumbRefs = React.useRef(/* @__PURE__ */ new Set());\n    const valueIndexToChangeRef = React.useRef(0);\n    const isHorizontal = orientation === \"horizontal\";\n    const [values = [], setValues] = useControllableState({\n      prop: value,\n      defaultProp: defaultValue,\n      transition: true,\n      onChange: (value2) => {\n        var _a;\n        if (isWeb) {\n          const thumbs = [...thumbRefs.current];\n          (_a = thumbs[valueIndexToChangeRef.current]) == null ? void 0 : _a.focus();\n        }\n        onValueChange(value2);\n      }\n    });\n    if (isWeb) {\n      React.useEffect(() => {\n        const node = sliderRef.current;\n        if (!node)\n          return;\n        const preventDefault = (e) => {\n          e.preventDefault();\n        };\n        node.addEventListener(\"touchstart\", preventDefault);\n        return () => {\n          node.removeEventListener(\"touchstart\", preventDefault);\n        };\n      }, []);\n    }\n    function handleSlideMove(value2) {\n      updateValues(value2, valueIndexToChangeRef.current);\n    }\n    function updateValues(value2, atIndex) {\n      const decimalCount = getDecimalCount(step);\n      const snapToStep = roundValue(\n        Math.round((value2 - min) / step) * step + min,\n        decimalCount\n      );\n      const nextValue = clamp(snapToStep, [min, max]);\n      setValues((prevValues = []) => {\n        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);\n        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {\n          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);\n          return String(nextValues) === String(prevValues) ? prevValues : nextValues;\n        } else {\n          return prevValues;\n        }\n      });\n    }\n    const SliderOriented = isHorizontal ? SliderHorizontal : SliderVertical;\n    return /* @__PURE__ */ jsx(\n      SliderProvider,\n      {\n        scope: props.__scopeSlider,\n        disabled,\n        min,\n        max,\n        valueIndexToChangeRef,\n        thumbs: thumbRefs.current,\n        values,\n        orientation,\n        size: sizeProp,\n        children: /* @__PURE__ */ jsx(\n          SliderOriented,\n          {\n            \"aria-disabled\": disabled,\n            \"data-disabled\": disabled ? \"\" : void 0,\n            ...sliderProps,\n            ref: composedRefs,\n            min,\n            max,\n            onSlideStart: disabled ? void 0 : (value2, target) => {\n              if (target !== \"thumb\") {\n                const closestIndex = getClosestValueIndex(values, value2);\n                updateValues(value2, closestIndex);\n              }\n            },\n            onSlideMove: disabled ? void 0 : handleSlideMove,\n            onHomeKeyDown: () => !disabled && updateValues(min, 0),\n            onEndKeyDown: () => !disabled && updateValues(max, values.length - 1),\n            onStepKeyDown: ({ event, direction: stepDirection }) => {\n              if (!disabled) {\n                const isPageKey = PAGE_KEYS.includes(event.key);\n                const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);\n                const multiplier = isSkipKey ? 10 : 1;\n                const atIndex = valueIndexToChangeRef.current;\n                const value2 = values[atIndex];\n                const stepInDirection = step * multiplier * stepDirection;\n                updateValues(value2 + stepInDirection, atIndex);\n              }\n            }\n          }\n        )\n      }\n    );\n  }),\n  {\n    Track: SliderTrack,\n    TrackActive: SliderTrackActive,\n    Thumb: SliderThumb\n  }\n);\nSlider.displayName = SLIDER_NAME;\nconst Track = SliderTrack;\nconst Range = SliderTrackActive;\nconst Thumb = SliderThumb;\nexport {\n  Range,\n  Slider,\n  SliderThumb,\n  SliderThumbFrame,\n  SliderTrack,\n  SliderTrackActive,\n  SliderTrackActiveFrame,\n  SliderTrackFrame,\n  Thumb,\n  Track\n};\n//# sourceMappingURL=Slider.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { composeEventHandlers, getVariableValue, isWeb, styled } from \"@tamagui/core\";\nimport { getSize } from \"@tamagui/get-size\";\nimport { YStack } from \"@tamagui/stacks\";\nimport * as React from \"react\";\nimport { ARROW_KEYS, PAGE_KEYS, SLIDER_NAME, useSliderContext } from \"./constants\";\nconst DirectionalYStack = styled(YStack, {\n  variants: {\n    orientation: {\n      horizontal: {},\n      vertical: {}\n    }\n  }\n});\nconst SliderFrame = styled(DirectionalYStack, {\n  position: \"relative\",\n  variants: {\n    size: (val, extras) => {\n      const orientation = extras.props.orientation;\n      const size = Math.round(getVariableValue(getSize(val)) / 6);\n      if (orientation === \"horizontal\") {\n        return {\n          height: size,\n          borderRadius: size,\n          justifyContent: \"center\"\n        };\n      }\n      return {\n        width: size,\n        borderRadius: size,\n        alignItems: \"center\"\n      };\n    }\n  }\n});\nconst SliderImpl = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeSlider,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onHomeKeyDown,\n      onEndKeyDown,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const context = useSliderContext(SLIDER_NAME, __scopeSlider);\n    return /* @__PURE__ */ jsx(\n      SliderFrame,\n      {\n        size: \"$4\",\n        ...sliderProps,\n        \"data-orientation\": sliderProps.orientation,\n        ref: forwardedRef,\n        ...isWeb && {\n          onKeyDown: (event) => {\n            if (event.key === \"Home\") {\n              onHomeKeyDown(event);\n              event.preventDefault();\n            } else if (event.key === \"End\") {\n              onEndKeyDown(event);\n              event.preventDefault();\n            } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\n              onStepKeyDown(event);\n              event.preventDefault();\n            }\n          }\n        },\n        onMoveShouldSetResponderCapture: () => true,\n        onScrollShouldSetResponder: () => true,\n        onScrollShouldSetResponderCapture: () => true,\n        onMoveShouldSetResponder: () => true,\n        onStartShouldSetResponder: () => true,\n        onResponderTerminationRequest: () => {\n          return false;\n        },\n        onResponderGrant: composeEventHandlers(props.onResponderGrant, (event) => {\n          const target = event.target;\n          const isStartingOnThumb = context.thumbs.has(target);\n          if (isWeb && target instanceof HTMLElement) {\n            if (context.thumbs.has(target)) {\n              target.focus();\n            }\n          }\n          onSlideStart(event, isStartingOnThumb ? \"thumb\" : \"track\");\n        }),\n        onResponderMove: composeEventHandlers(props.onResponderMove, (event) => {\n          event.stopPropagation();\n          onSlideMove(event);\n        }),\n        onResponderRelease: composeEventHandlers(props.onResponderRelease, (event) => {\n          onSlideEnd(event);\n        })\n      }\n    );\n  }\n);\nexport {\n  DirectionalYStack,\n  SliderFrame,\n  SliderImpl\n};\n//# sourceMappingURL=SliderImpl.mjs.map\n","import { createContextScope } from \"@tamagui/create-context\";\nconst SLIDER_NAME = \"Slider\";\nconst [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME);\nconst [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);\nconst [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {\n  startEdge: \"left\",\n  endEdge: \"right\",\n  sizeProp: \"width\",\n  size: 0,\n  direction: 1\n});\nconst PAGE_KEYS = [\"PageUp\", \"PageDown\"];\nconst ARROW_KEYS = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\nconst BACK_KEYS = {\n  ltr: [\"ArrowDown\", \"Home\", \"ArrowLeft\", \"PageDown\"],\n  rtl: [\"ArrowDown\", \"Home\", \"ArrowRight\", \"PageDown\"]\n};\nexport {\n  ARROW_KEYS,\n  BACK_KEYS,\n  PAGE_KEYS,\n  SLIDER_NAME,\n  SliderOrientationProvider,\n  SliderProvider,\n  createSliderContext,\n  createSliderScope,\n  useSliderContext,\n  useSliderOrientationContext\n};\n//# sourceMappingURL=constants.mjs.map\n","function getNextSortedValues(prevValues = [], nextValue, atIndex) {\n  const nextValues = [...prevValues];\n  nextValues[atIndex] = nextValue;\n  return nextValues.sort((a, b) => a - b);\n}\nfunction convertValueToPercentage(value, min, max) {\n  const maxSteps = max - min;\n  const percentPerStep = 100 / maxSteps;\n  return percentPerStep * (value - min);\n}\nfunction getLabel(index, totalValues) {\n  if (totalValues > 2) {\n    return `Value ${index + 1} of ${totalValues}`;\n  } else if (totalValues === 2) {\n    return [\"Minimum\", \"Maximum\"][index];\n  } else {\n    return void 0;\n  }\n}\nfunction getClosestValueIndex(values, nextValue) {\n  if (values.length === 1)\n    return 0;\n  const distances = values.map((value) => Math.abs(value - nextValue));\n  const closestDistance = Math.min(...distances);\n  return distances.indexOf(closestDistance);\n}\nfunction getThumbInBoundsOffset(width, left, direction) {\n  const halfWidth = width / 2;\n  const halfPercent = 50;\n  const offset = linearScale([0, halfPercent], [0, halfWidth]);\n  return (halfWidth - offset(left) * direction) * direction;\n}\nfunction getStepsBetweenValues(values) {\n  return values.slice(0, -1).map((value, index) => values[index + 1] - value);\n}\nfunction hasMinStepsBetweenValues(values, minStepsBetweenValues) {\n  if (minStepsBetweenValues > 0) {\n    const stepsBetweenValues = getStepsBetweenValues(values);\n    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);\n    return actualMinStepsBetweenValues >= minStepsBetweenValues;\n  }\n  return true;\n}\nfunction linearScale(input, output) {\n  return (value) => {\n    if (input[0] === input[1] || output[0] === output[1])\n      return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\nfunction getDecimalCount(value) {\n  return (String(value).split(\".\")[1] || \"\").length;\n}\nfunction roundValue(value, decimalCount) {\n  const rounder = Math.pow(10, decimalCount);\n  return Math.round(value * rounder) / rounder;\n}\nexport {\n  convertValueToPercentage,\n  getClosestValueIndex,\n  getDecimalCount,\n  getLabel,\n  getNextSortedValues,\n  getThumbInBoundsOffset,\n  hasMinStepsBetweenValues,\n  linearScale,\n  roundValue\n};\n//# sourceMappingURL=helpers.mjs.map\n","export * from \"./Slider\";\nimport { SliderFrame, DirectionalYStack } from \"./SliderImpl\";\nexport {\n  DirectionalYStack,\n  SliderFrame\n};\n//# sourceMappingURL=index.mjs.map\n","import { styled } from \"@tamagui/core\";\nimport { getButtonSized } from \"@tamagui/get-button-sized\";\nimport { XStack } from \"./Stacks\";\nimport {\n  bordered,\n  circular,\n  elevate,\n  focusTheme,\n  hoverTheme,\n  pressTheme\n} from \"./variants\";\nconst SizableStack = styled(XStack, {\n  name: \"SizableStack\",\n  variants: {\n    unstyled: {\n      true: {\n        hoverTheme: false,\n        pressTheme: false,\n        focusTheme: false,\n        elevate: false,\n        bordered: false\n      },\n      false: {\n        backgroundColor: \"$background\",\n        flexShrink: 1\n      }\n    },\n    hoverTheme,\n    pressTheme,\n    focusTheme,\n    circular,\n    elevate,\n    bordered,\n    size: {\n      \"...size\": getButtonSized\n    }\n  }\n});\nexport {\n  SizableStack\n};\n//# sourceMappingURL=SizableStack.js.map\n","import { Stack, styled } from \"@tamagui/core\";\nimport { getElevation } from \"./getElevation.js\";\nconst fullscreenStyle = {\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0\n};\nconst variants = {\n  fullscreen: {\n    true: fullscreenStyle\n  },\n  elevation: {\n    \"...size\": getElevation\n  }\n};\nconst YStack = styled(Stack, {\n  flexDirection: \"column\",\n  name: \"YStack\",\n  variants\n});\nconst XStack = styled(Stack, {\n  flexDirection: \"row\",\n  name: \"XStack\",\n  variants\n});\nconst ZStack = styled(\n  YStack,\n  {\n    name: \"ZStack\",\n    position: \"relative\"\n  },\n  {\n    neverFlatten: true,\n    isZStack: true\n  }\n);\nexport {\n  XStack,\n  YStack,\n  ZStack,\n  fullscreenStyle\n};\n//# sourceMappingURL=Stacks.mjs.map\n","export * from \"./Stacks.js\";\nexport * from \"./SizableStack.js\";\nexport * from \"./ThemeableStack.js\";\n//# sourceMappingURL=index.mjs.map\n","import { getElevation } from \"./getElevation\";\nconst elevate = {\n  true: (_, extras) => {\n    return getElevation(extras.props[\"size\"], extras);\n  }\n};\nconst bordered = (val, { props }) => {\n  return {\n    // TODO size it with size in '...size'\n    borderWidth: typeof val === \"number\" ? val : 1,\n    borderColor: \"$borderColor\",\n    ...props.hoverTheme && {\n      hoverStyle: {\n        borderColor: \"$borderColorHover\"\n      }\n    },\n    ...props.pressTheme && {\n      pressStyle: {\n        borderColor: \"$borderColorPress\"\n      }\n    },\n    ...props.focusTheme && {\n      focusStyle: {\n        borderColor: \"$borderColorFocus\"\n      }\n    }\n  };\n};\nconst padded = {\n  true: (_, extras) => {\n    const { tokens, props } = extras;\n    return {\n      padding: tokens.space[props.size] || tokens.space[\"$true\"]\n    };\n  }\n};\nconst radiused = {\n  true: (_, extras) => {\n    const { tokens, props } = extras;\n    return {\n      borderRadius: tokens.radius[props.size] || tokens.radius[\"$true\"]\n    };\n  }\n};\nconst circular = {\n  true: (_, { props, tokens }) => {\n    const size = tokens.size[props.size];\n    return {\n      width: size,\n      height: size,\n      maxWidth: size,\n      maxHeight: size,\n      minWidth: size,\n      minHeight: size,\n      borderRadius: 1e5,\n      padding: 0\n    };\n  }\n};\nconst hoverTheme = {\n  true: {\n    hoverStyle: {\n      backgroundColor: \"$backgroundHover\",\n      borderColor: \"$borderColorHover\"\n    }\n  },\n  false: {}\n};\nconst pressTheme = {\n  true: {\n    cursor: \"pointer\",\n    pressStyle: {\n      backgroundColor: \"$backgroundPress\",\n      borderColor: \"$borderColorPress\"\n    }\n  },\n  false: {}\n};\nconst focusTheme = {\n  true: {\n    focusStyle: {\n      backgroundColor: \"$backgroundFocus\",\n      borderColor: \"$borderColorFocus\"\n    }\n  },\n  false: {}\n};\nexport {\n  bordered,\n  circular,\n  elevate,\n  focusTheme,\n  hoverTheme,\n  padded,\n  pressTheme,\n  radiused\n};\n//# sourceMappingURL=variants.mjs.map\n","import { jsx, jsxs } from \"react/jsx-runtime\";\nimport { usePrevious } from \"@radix-ui/react-use-previous\";\nimport { useComposedRefs } from \"@tamagui/compose-refs\";\nimport {\n  getVariableValue,\n  isWeb,\n  styled,\n  withStaticProperties\n} from \"@tamagui/core\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport { registerFocusable } from \"@tamagui/focusable\";\nimport { getSize } from \"@tamagui/get-size\";\nimport { useLabelContext } from \"@tamagui/label\";\nimport { ThemeableStack, XStack } from \"@tamagui/stacks\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport * as React from \"react\";\nconst SWITCH_NAME = \"Switch\";\nconst getSwitchHeight = (val) => Math.round(getVariableValue(getSize(val)) * 0.65);\nconst getSwitchWidth = (val) => getSwitchHeight(val) * 2;\nconst scopeContexts = createContextScope(SWITCH_NAME);\nconst [createSwitchContext] = scopeContexts;\nconst createSwitchScope = scopeContexts[1];\nconst [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);\nconst THUMB_NAME = \"SwitchThumb\";\nconst SwitchThumbFrame = styled(ThemeableStack, {\n  name: \"SwitchThumb\",\n  variants: {\n    unstyled: {\n      false: {\n        size: \"$true\",\n        backgroundColor: \"$background\",\n        borderRadius: 1e3\n      }\n    },\n    size: {\n      \"...size\": (val) => {\n        const size = getSwitchHeight(val);\n        return {\n          height: size,\n          width: size\n        };\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst SwitchThumb = SwitchThumbFrame.extractable(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const { __scopeSwitch, size: sizeProp, ...thumbProps } = props;\n      const {\n        size: sizeContext,\n        disabled,\n        checked,\n        unstyled\n      } = useSwitchContext(THUMB_NAME, __scopeSwitch);\n      const size = sizeProp ?? sizeContext;\n      return /* @__PURE__ */ jsx(\n        SwitchThumbFrame,\n        {\n          unstyled,\n          theme: checked ? \"active\" : null,\n          size,\n          \"data-state\": getState(checked),\n          \"data-disabled\": disabled ? \"\" : void 0,\n          ...thumbProps,\n          x: checked ? getVariableValue(getSwitchWidth(size)) - getVariableValue(getSwitchHeight(size)) : 0,\n          ref: forwardedRef\n        }\n      );\n    }\n  )\n);\nSwitchThumb.displayName = THUMB_NAME;\nconst SwitchFrame = styled(XStack, {\n  name: SWITCH_NAME,\n  tag: \"button\",\n  variants: {\n    unstyled: {\n      false: {\n        size: \"$true\",\n        borderRadius: 1e3,\n        borderWidth: 2,\n        borderColor: \"transparent\",\n        backgroundColor: \"$background\",\n        focusStyle: {\n          borderColor: \"$borderColorFocus\"\n        }\n      }\n    },\n    size: {\n      \"...size\": (val) => {\n        const height = getSwitchHeight(val) + 4;\n        const width = getSwitchWidth(val) + 4;\n        return {\n          height,\n          minHeight: height,\n          width\n        };\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst Switch = withStaticProperties(\n  SwitchFrame.extractable(\n    React.forwardRef(\n      (props, forwardedRef) => {\n        const {\n          __scopeSwitch,\n          labeledBy: ariaLabelledby,\n          name,\n          checked: checkedProp,\n          defaultChecked,\n          required,\n          disabled,\n          value = \"on\",\n          onCheckedChange,\n          size = \"$true\",\n          unstyled = false,\n          ...switchProps\n        } = props;\n        const [button, setButton] = React.useState(null);\n        const composedRefs = useComposedRefs(\n          forwardedRef,\n          (node) => setButton(node)\n        );\n        const labelId = useLabelContext(button);\n        const labelledBy = ariaLabelledby || labelId;\n        const hasConsumerStoppedPropagationRef = React.useRef(false);\n        const isFormControl = isWeb ? button ? Boolean(button.closest(\"form\")) : true : false;\n        const [checked = false, setChecked] = useControllableState({\n          prop: checkedProp,\n          defaultProp: defaultChecked || false,\n          onChange: onCheckedChange,\n          transition: true\n        });\n        if (!isWeb) {\n          React.useEffect(() => {\n            if (!props.id)\n              return;\n            return registerFocusable(props.id, {\n              focus: () => {\n                setChecked((x) => !x);\n              }\n            });\n          }, [props.id, setChecked]);\n        }\n        return /* @__PURE__ */ jsxs(\n          SwitchProvider,\n          {\n            scope: __scopeSwitch,\n            checked,\n            disabled,\n            size,\n            unstyled,\n            children: [\n              /* @__PURE__ */ jsx(\n                SwitchFrame,\n                {\n                  unstyled,\n                  size,\n                  theme: checked ? \"active\" : null,\n                  role: \"switch\",\n                  \"aria-checked\": checked,\n                  \"aria-labelledby\": labelledBy,\n                  \"aria-required\": required,\n                  \"data-state\": getState(checked),\n                  \"data-disabled\": disabled ? \"\" : void 0,\n                  disabled,\n                  tabIndex: disabled ? void 0 : 0,\n                  value,\n                  ...switchProps,\n                  ref: composedRefs,\n                  onPress: (event) => {\n                    var _a;\n                    (_a = props.onPress) == null ? void 0 : _a.call(props, event);\n                    setChecked((prevChecked) => !prevChecked);\n                    if (isWeb && isFormControl) {\n                      hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n                      if (!hasConsumerStoppedPropagationRef.current)\n                        event.stopPropagation();\n                    }\n                  }\n                }\n              ),\n              isWeb && isFormControl && /* @__PURE__ */ jsx(\n                BubbleInput,\n                {\n                  control: button,\n                  bubbles: !hasConsumerStoppedPropagationRef.current,\n                  name,\n                  value,\n                  checked,\n                  required,\n                  disabled,\n                  style: { transform: \"translateX(-100%)\" }\n                }\n              )\n            ]\n          }\n        );\n      }\n    )\n  ),\n  {\n    Thumb: SwitchThumb\n  }\n);\nconst BubbleInput = (props) => {\n  const { control, checked, bubbles = true, ...inputProps } = props;\n  const ref = React.useRef(null);\n  const prevChecked = usePrevious(checked);\n  React.useEffect(() => {\n    const input = ref.current;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(\n      inputProto,\n      \"checked\"\n    );\n    const setChecked = descriptor.set;\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event(\"click\", { bubbles });\n      setChecked.call(input, checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n  return /* @__PURE__ */ jsx(\n    \"input\",\n    {\n      type: \"checkbox\",\n      \"aria-hidden\": true,\n      defaultChecked: checked,\n      ...inputProps,\n      tabIndex: -1,\n      ref,\n      style: {\n        ...props.style,\n        // ...controlSize,\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        opacity: 0,\n        margin: 0\n      }\n    }\n  );\n};\nfunction getState(checked) {\n  return checked ? \"checked\" : \"unchecked\";\n}\nexport {\n  Switch,\n  SwitchFrame,\n  SwitchThumb,\n  SwitchThumbFrame,\n  createSwitchScope\n};\n//# sourceMappingURL=Switch.mjs.map\n","export * from \"./Switch\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport { getButtonSized } from \"@tamagui/get-button-sized\";\nimport { Group, useGroupItem } from \"@tamagui/group\";\nimport { RovingFocusGroup, createRovingFocusGroupScope } from \"@tamagui/roving-focus\";\nimport { SizableStack, ThemeableStack } from \"@tamagui/stacks\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport { useDirection } from \"@tamagui/use-direction\";\nimport {\n  Theme,\n  composeEventHandlers,\n  composeRefs,\n  isWeb,\n  styled,\n  useEvent,\n  withStaticProperties\n} from \"@tamagui/web\";\nimport * as React from \"react\";\nconst TAB_LIST_NAME = \"TabsList\";\nconst TabsListFrame = styled(Group, {\n  name: TAB_LIST_NAME,\n  focusable: true\n});\nconst TabsList = TabsListFrame.extractable(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const { __scopeTabs, loop = true, children, ...listProps } = props;\n      const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);\n      const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);\n      return /* @__PURE__ */ jsx(\n        RovingFocusGroup,\n        {\n          asChild: true,\n          orientation: context.orientation,\n          dir: context.dir,\n          loop,\n          ...rovingFocusGroupScope,\n          children: /* @__PURE__ */ jsx(\n            TabsListFrame,\n            {\n              role: \"tablist\",\n              \"aria-orientation\": context.orientation,\n              ref: forwardedRef,\n              axis: context.orientation,\n              ...listProps,\n              children\n            }\n          )\n        }\n      );\n    }\n  )\n);\nTabsList.displayName = TAB_LIST_NAME;\nconst TRIGGER_NAME = \"TabsTrigger\";\nconst TabsTriggerFrame = styled(ThemeableStack, {\n  name: TRIGGER_NAME,\n  justifyContent: \"center\",\n  alignItems: \"center\",\n  flexWrap: \"nowrap\",\n  flexDirection: \"row\",\n  cursor: \"pointer\",\n  backgroundColor: \"$background\",\n  focusable: true,\n  variants: {\n    size: {\n      \"...size\": getButtonSized\n    },\n    disabled: {\n      true: {\n        pointerEvents: \"none\"\n      }\n    },\n    unstyled: {\n      false: {\n        backgroundColor: \"$background\",\n        pressStyle: {\n          backgroundColor: \"$backgroundPress\"\n        },\n        hoverStyle: {\n          backgroundColor: \"$backgroundHover\"\n        },\n        focusStyle: {\n          backgroundColor: \"$backgroundFocus\"\n        }\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst TabsTrigger = TabsTriggerFrame.extractable(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const {\n        __scopeTabs,\n        value,\n        disabled = false,\n        onInteraction,\n        ...triggerProps\n      } = props;\n      const context = useTabsContext(TRIGGER_NAME, __scopeTabs);\n      const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);\n      const triggerId = makeTriggerId(context.baseId, value);\n      const contentId = makeContentId(context.baseId, value);\n      const isSelected = value === context.value;\n      const [layout, setLayout] = React.useState(null);\n      const triggerRef = React.useRef(null);\n      const groupItemProps = useGroupItem({ disabled });\n      React.useEffect(() => {\n        context.registerTrigger();\n        return () => context.unregisterTrigger();\n      }, []);\n      React.useEffect(() => {\n        if (!triggerRef.current || !isWeb)\n          return;\n        function getTriggerSize() {\n          if (!triggerRef.current)\n            return;\n          setLayout({\n            width: triggerRef.current.offsetWidth,\n            height: triggerRef.current.offsetHeight,\n            x: triggerRef.current.offsetLeft,\n            y: triggerRef.current.offsetTop\n          });\n        }\n        getTriggerSize();\n        const observer = new ResizeObserver(getTriggerSize);\n        observer.observe(triggerRef.current);\n        return () => {\n          if (!triggerRef.current)\n            return;\n          observer.unobserve(triggerRef.current);\n        };\n      }, [context.triggersCount]);\n      React.useEffect(() => {\n        if (isSelected && layout) {\n          onInteraction == null ? void 0 : onInteraction(\"select\", layout);\n        }\n      }, [isSelected, value, layout]);\n      return /* @__PURE__ */ jsx(Theme, { name: isSelected ? \"active\" : null, children: /* @__PURE__ */ jsx(\n        RovingFocusGroup.Item,\n        {\n          asChild: true,\n          ...rovingFocusGroupScope,\n          focusable: !disabled,\n          active: isSelected,\n          children: /* @__PURE__ */ jsx(\n            TabsTriggerFrame,\n            {\n              onLayout: (event) => {\n                if (!isWeb) {\n                  setLayout(event.nativeEvent.layout);\n                }\n              },\n              onHoverIn: composeEventHandlers(props.onHoverIn, () => {\n                if (layout) {\n                  onInteraction == null ? void 0 : onInteraction(\"hover\", layout);\n                }\n              }),\n              onHoverOut: composeEventHandlers(props.onHoverOut, () => {\n                onInteraction == null ? void 0 : onInteraction(\"hover\", null);\n              }),\n              role: \"tab\",\n              \"aria-selected\": isSelected,\n              \"aria-controls\": contentId,\n              \"data-state\": isSelected ? \"active\" : \"inactive\",\n              \"data-disabled\": disabled ? \"\" : void 0,\n              disabled,\n              id: triggerId,\n              size: context.size,\n              ...triggerProps,\n              ref: composeRefs(forwardedRef, triggerRef),\n              onPress: composeEventHandlers(props.onPress ?? void 0, (event) => {\n                const webChecks = !isWeb || event.button === 0 && event.ctrlKey === false;\n                if (!disabled && !isSelected && webChecks) {\n                  context.onChange(value);\n                } else {\n                  event.preventDefault();\n                }\n              }),\n              ...isWeb && {\n                type: \"button\",\n                onKeyDown: composeEventHandlers(\n                  props.onKeyDown,\n                  (event) => {\n                    if ([\" \", \"Enter\"].includes(event.key)) {\n                      context.onChange(value);\n                      event.preventDefault();\n                    }\n                  }\n                ),\n                onFocus: composeEventHandlers(props.onFocus, (event) => {\n                  if (layout) {\n                    onInteraction == null ? void 0 : onInteraction(\"focus\", layout);\n                  }\n                  const isAutomaticActivation = context.activationMode !== \"manual\";\n                  if (!isSelected && !disabled && isAutomaticActivation) {\n                    context.onChange(value);\n                  }\n                }),\n                onBlur: composeEventHandlers(props.onFocus, () => {\n                  onInteraction == null ? void 0 : onInteraction(\"focus\", null);\n                })\n              },\n              ...groupItemProps\n            }\n          )\n        }\n      ) });\n    }\n  )\n);\nTabsTrigger.displayName = TRIGGER_NAME;\nconst CONTENT_NAME = \"TabsContent\";\nconst TabsContentFrame = styled(ThemeableStack, {\n  name: CONTENT_NAME\n});\nconst TabsContent = TabsContentFrame.extractable(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const { __scopeTabs, value, forceMount, children, ...contentProps } = props;\n      const context = useTabsContext(CONTENT_NAME, __scopeTabs);\n      const isSelected = value === context.value;\n      const show = forceMount || isSelected;\n      const triggerId = makeTriggerId(context.baseId, value);\n      const contentId = makeContentId(context.baseId, value);\n      if (!show)\n        return null;\n      return /* @__PURE__ */ jsx(\n        TabsContentFrame,\n        {\n          \"data-state\": isSelected ? \"active\" : \"inactive\",\n          \"data-orientation\": context.orientation,\n          role: \"tabpanel\",\n          \"aria-labelledby\": triggerId,\n          hidden: !show,\n          id: contentId,\n          tabIndex: 0,\n          ...contentProps,\n          ref: forwardedRef,\n          children\n        },\n        value\n      );\n    }\n  )\n);\nTabsContent.displayName = CONTENT_NAME;\nconst TABS_NAME = \"Tabs\";\nconst [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [\n  createRovingFocusGroupScope\n]);\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\nconst [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);\nconst TabsFrame = styled(SizableStack, {\n  name: TABS_NAME\n});\nconst Tabs = withStaticProperties(\n  TabsFrame.extractable(\n    React.forwardRef(\n      (props, forwardedRef) => {\n        const {\n          __scopeTabs,\n          value: valueProp,\n          onValueChange,\n          defaultValue,\n          orientation = \"horizontal\",\n          dir,\n          activationMode = \"automatic\",\n          size = \"$true\",\n          ...tabsProps\n        } = props;\n        const direction = useDirection(dir);\n        const [value, setValue] = useControllableState({\n          prop: valueProp,\n          onChange: onValueChange,\n          defaultProp: defaultValue ?? \"\"\n        });\n        const [triggersCount, setTriggersCount] = React.useState(0);\n        const registerTrigger = useEvent(() => setTriggersCount((v) => v + 1));\n        const unregisterTrigger = useEvent(() => setTriggersCount((v) => v - 1));\n        return /* @__PURE__ */ jsx(\n          TabsProvider,\n          {\n            scope: __scopeTabs,\n            baseId: React.useId(),\n            value,\n            onChange: setValue,\n            orientation,\n            dir: direction,\n            activationMode,\n            size,\n            registerTrigger,\n            triggersCount,\n            unregisterTrigger,\n            children: /* @__PURE__ */ jsx(\n              TabsFrame,\n              {\n                direction,\n                \"data-orientation\": orientation,\n                ...tabsProps,\n                ref: forwardedRef\n              }\n            )\n          }\n        );\n      }\n    )\n  ),\n  {\n    List: TabsList,\n    /**\n     * @deprecated Use Tabs.Tab instead\n     */\n    Trigger: TabsTrigger,\n    Tab: TabsTrigger,\n    Content: TabsContent\n  }\n);\nTabs.displayName = TABS_NAME;\nfunction makeTriggerId(baseId, value) {\n  return `${baseId}-trigger-${value}`;\n}\nfunction makeContentId(baseId, value) {\n  return `${baseId}-content-${value}`;\n}\nexport {\n  Tabs\n};\n//# sourceMappingURL=Tabs.mjs.map\n","export * from \"./Tabs\";\n//# sourceMappingURL=index.mjs.map\n","import { styled } from \"@tamagui/web\";\nimport { Paragraph } from \"./Paragraph\";\nconst Heading = styled(Paragraph, {\n  tag: \"span\",\n  name: \"Heading\",\n  accessibilityRole: \"header\",\n  fontFamily: \"$heading\",\n  size: \"$8\",\n  margin: 0\n});\nconst H1 = styled(Heading, {\n  name: \"H1\",\n  tag: \"h1\",\n  size: \"$10\"\n});\nconst H2 = styled(Heading, {\n  name: \"H2\",\n  tag: \"h2\",\n  size: \"$9\"\n});\nconst H3 = styled(Heading, {\n  name: \"H3\",\n  tag: \"h3\",\n  size: \"$8\"\n});\nconst H4 = styled(Heading, {\n  name: \"H4\",\n  tag: \"h4\",\n  size: \"$7\"\n});\nconst H5 = styled(Heading, {\n  name: \"H5\",\n  tag: \"h5\",\n  size: \"$6\"\n});\nconst H6 = styled(Heading, {\n  name: \"H6\",\n  tag: \"h6\",\n  size: \"$5\"\n});\nexport {\n  H1,\n  H2,\n  H3,\n  H4,\n  H5,\n  H6,\n  Heading\n};\n//# sourceMappingURL=Headings.mjs.map\n","import { styled } from \"@tamagui/web\";\nimport { SizableText } from \"./SizableText\";\nconst Paragraph = styled(SizableText, {\n  name: \"Paragraph\",\n  tag: \"p\",\n  userSelect: \"auto\",\n  color: \"$color\",\n  size: \"$true\"\n});\nexport {\n  Paragraph\n};\n//# sourceMappingURL=Paragraph.mjs.map\n","export * from \"./SizableText\";\nexport * from \"./Paragraph\";\nexport * from \"./Headings\";\nexport * from \"./wrapChildrenInText\";\nexport * from \"./types\";\n//# sourceMappingURL=index.mjs.map\n","//# sourceMappingURL=types.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport React from \"react\";\nfunction wrapChildrenInText(TextComponent, propsIn, extraProps) {\n  const {\n    children,\n    textProps,\n    size,\n    noTextWrap,\n    color,\n    fontFamily,\n    fontSize,\n    fontWeight,\n    letterSpacing,\n    textAlign,\n    fontStyle\n  } = propsIn;\n  if (noTextWrap || !children) {\n    return [children];\n  }\n  const allChildren = React.Children.toArray(children);\n  const nextChildren = [];\n  let lastIsString = false;\n  const props = {\n    ...extraProps\n  };\n  if (color)\n    props.color = color;\n  if (fontFamily)\n    props.fontFamily = fontFamily;\n  if (fontSize)\n    props.fontSize = fontSize;\n  if (fontWeight)\n    props.fontWeight = fontWeight;\n  if (letterSpacing)\n    props.letterSpacing = letterSpacing;\n  if (textAlign)\n    props.textAlign = textAlign;\n  if (size)\n    props.size = size;\n  if (fontStyle)\n    props.fontStyle = fontStyle;\n  function concatStringChildren() {\n    if (!lastIsString)\n      return;\n    const index = nextChildren.length - 1;\n    const childrenStrings = nextChildren[index];\n    nextChildren[index] = /* @__PURE__ */ jsx(TextComponent, { ...props, ...textProps, children: childrenStrings }, index);\n  }\n  for (const child of allChildren) {\n    const last = nextChildren[nextChildren.length - 1];\n    const isString = typeof child === \"string\";\n    if (isString) {\n      if (lastIsString) {\n        last.push(child);\n      } else {\n        nextChildren.push([child]);\n      }\n    } else {\n      concatStringChildren();\n      nextChildren.push(child);\n    }\n    lastIsString = isString;\n  }\n  concatStringChildren();\n  return nextChildren;\n}\nexport {\n  wrapChildrenInText\n};\n//# sourceMappingURL=wrapChildrenInText.mjs.map\n","import { isWeb } from \"@tamagui/constants\";\nimport {\n  ensureThemeVariable,\n  getConfig,\n  getThemeCSSRules,\n  proxyThemeToParents,\n  updateConfig\n} from \"@tamagui/web\";\nfunction addTheme(props) {\n  var _a;\n  const config = getConfig();\n  if (process.env.NODE_ENV === \"development\") {\n    if (!config) {\n      throw new Error(\"No config\");\n    }\n    const theme2 = config.themes[props.name];\n    if (!props.update && theme2) {\n      return { theme: theme2 };\n    }\n  }\n  const { name: themeName, theme: themeIn, insertCSS } = props;\n  const theme = { ...themeIn };\n  for (const key in theme) {\n    ensureThemeVariable(theme, key);\n  }\n  const themeProxied = proxyThemeToParents(themeName, theme, config.themes);\n  config.themes[themeName] = themeProxied;\n  let cssRules = [];\n  if (isWeb) {\n    if (insertCSS) {\n      cssRules = getThemeCSSRules({\n        // @ts-ignore this works but should be fixed types\n        config,\n        themeName,\n        names: [themeName],\n        theme\n      });\n      const id = `t_theme_style_${themeName}`;\n      const existing = document.querySelector(`#${id}`);\n      const style = document.createElement(\"style\");\n      style.id = id;\n      style.appendChild(document.createTextNode(cssRules.join(\"\\n\")));\n      document.head.appendChild(style);\n      if (existing) {\n        (_a = existing.parentElement) == null ? void 0 : _a.removeChild(existing);\n      }\n    }\n  }\n  updateConfig(\"themes\", { ...config.themes, [themeName]: themeProxied });\n  return {\n    theme: themeProxied,\n    cssRules\n  };\n}\nexport {\n  addTheme\n};\n//# sourceMappingURL=addTheme.js.map\n","import { isWeb } from \"@tamagui/constants\";\nimport {\n  ensureThemeVariable,\n  getConfig,\n  getThemeCSSRules,\n  proxyThemeToParents,\n  updateConfig\n} from \"@tamagui/web\";\nfunction addTheme(props) {\n  var _a;\n  const config = getConfig();\n  if (process.env.NODE_ENV === \"development\") {\n    if (!config) {\n      throw new Error(\"No config\");\n    }\n    const theme2 = config.themes[props.name];\n    if (!props.update && theme2) {\n      return { theme: theme2 };\n    }\n  }\n  const { name: themeName, theme: themeIn, insertCSS } = props;\n  const theme = { ...themeIn };\n  for (const key in theme) {\n    ensureThemeVariable(theme, key);\n  }\n  const themeProxied = proxyThemeToParents(themeName, theme, config.themes);\n  config.themes[themeName] = themeProxied;\n  let cssRules = [];\n  if (isWeb) {\n    if (insertCSS) {\n      cssRules = getThemeCSSRules({\n        // @ts-ignore this works but should be fixed types\n        config,\n        themeName,\n        names: [themeName],\n        theme\n      });\n      const id = `t_theme_style_${themeName}`;\n      const existing = document.querySelector(`#${id}`);\n      const style = document.createElement(\"style\");\n      style.id = id;\n      style.appendChild(document.createTextNode(cssRules.join(\"\\n\")));\n      document.head.appendChild(style);\n      if (existing) {\n        (_a = existing.parentElement) == null ? void 0 : _a.removeChild(existing);\n      }\n    }\n  }\n  updateConfig(\"themes\", { ...config.themes, [themeName]: themeProxied });\n  return {\n    theme: themeProxied,\n    cssRules\n  };\n}\nexport {\n  addTheme\n};\n//# sourceMappingURL=addTheme.mjs.map\n","export * from \"./addTheme\";\nexport * from \"./updateTheme\";\n//# sourceMappingURL=index.mjs.map\n","import { activeThemeManagers } from \"@tamagui/web\";\nimport { addTheme } from \"./addTheme.js\";\nfunction updateTheme({\n  name,\n  theme\n}) {\n  const next = addTheme({ name, theme, insertCSS: true, update: true });\n  if (process.env.TAMAGUI_TARGET === \"native\") {\n    activeThemeManagers.forEach((manager) => {\n      if (manager.state.name === name) {\n        manager.updateState({\n          name,\n          forceTheme: next.theme\n        });\n      }\n    });\n  }\n  return next;\n}\nexport {\n  updateTheme\n};\n//# sourceMappingURL=updateTheme.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { ThemeableStack } from \"@tamagui/stacks\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport { Theme, composeEventHandlers, styled } from \"@tamagui/web\";\nimport * as React from \"react\";\nconst NAME = \"Toggle\";\nconst ToggleFrame = styled(ThemeableStack, {\n  name: NAME,\n  tag: \"button\",\n  variants: {\n    unstyled: {\n      false: {\n        pressTheme: true,\n        backgroundColor: \"$background\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        display: \"flex\",\n        borderColor: \"$borderColor\",\n        borderWidth: \"1px\",\n        margin: \"-1px\",\n        hoverStyle: {\n          backgroundColor: \"$backgroundHover\"\n        },\n        pressStyle: {\n          backgroundColor: \"$backgroundPress\"\n        },\n        focusStyle: {\n          borderColor: \"$borderColorPress\",\n          backgroundColor: \"$backgroundPress\"\n        }\n      }\n    },\n    active: {\n      true: {\n        zIndex: 1,\n        hoverStyle: {\n          backgroundColor: \"$background\"\n        },\n        focusStyle: {\n          borderColor: \"$borderColorPress\",\n          backgroundColor: \"$backgroundPress\"\n        }\n      }\n    },\n    orientation: {\n      horizontal: {\n        flexDirection: \"row\",\n        spaceDirection: \"horizontal\"\n      },\n      vertical: {\n        flexDirection: \"column\",\n        spaceDirection: \"vertical\"\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst Toggle = ToggleFrame.extractable(\n  React.forwardRef((props, forwardedRef) => {\n    const {\n      pressed: pressedProp,\n      defaultPressed = false,\n      onPressedChange,\n      ...buttonProps\n    } = props;\n    const [pressed = false, setPressed] = useControllableState({\n      prop: pressedProp,\n      onChange: onPressedChange,\n      defaultProp: defaultPressed\n    });\n    return /* @__PURE__ */ jsx(Theme, { name: pressed ? \"active\" : null, children: /* @__PURE__ */ jsx(\n      ToggleFrame,\n      {\n        active: !props.unstyled ? pressed : void 0,\n        \"aria-pressed\": pressed,\n        \"data-state\": pressed ? \"on\" : \"off\",\n        \"data-disabled\": props.disabled ? \"\" : void 0,\n        ...buttonProps,\n        ref: forwardedRef,\n        onPress: composeEventHandlers(props.onPress ?? void 0, (event) => {\n          if (!props.disabled) {\n            setPressed(!pressed);\n          }\n        })\n      }\n    ) });\n  })\n);\nToggle.displayName = NAME;\nexport {\n  Toggle,\n  ToggleFrame\n};\n//# sourceMappingURL=Toggle.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { createContextScope } from \"@tamagui/create-context\";\nimport { registerFocusable } from \"@tamagui/focusable\";\nimport { getFontSize } from \"@tamagui/font-size\";\nimport { stepTokenUpOrDown } from \"@tamagui/get-size\";\nimport { Group, useGroupItem } from \"@tamagui/group\";\nimport { useGetThemedIcon } from \"@tamagui/helpers-tamagui\";\nimport { RovingFocusGroup, createRovingFocusGroupScope } from \"@tamagui/roving-focus\";\nimport { useControllableState } from \"@tamagui/use-controllable-state\";\nimport { useDirection } from \"@tamagui/use-direction\";\nimport {\n  getVariableValue,\n  isWeb,\n  styled,\n  useTheme,\n  withStaticProperties\n} from \"@tamagui/web\";\nimport React from \"react\";\nimport { Toggle, ToggleFrame } from \"./Toggle\";\nconst TOGGLE_GROUP_NAME = \"ToggleGroup\";\nconst [createToggleGroupContext, createToggleGroupScope] = createContextScope(\n  TOGGLE_GROUP_NAME,\n  [createRovingFocusGroupScope]\n);\nconst TOGGLE_GROUP_ITEM_NAME = \"ToggleGroupItem\";\nconst [createToggleGroupItemContext, createToggleGroupItemScope] = createContextScope(TOGGLE_GROUP_ITEM_NAME);\nconst [ToggleGroupItemProvider, useToggleGroupItemContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);\nconst useToggleGroupItemScope = createToggleGroupItemScope();\nconst ToggleGroupItem = ToggleFrame.extractable(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const valueContext = useToggleGroupValueContext(\n        TOGGLE_GROUP_ITEM_NAME,\n        props.__scopeToggleGroup\n      );\n      const context = useToggleGroupContext(\n        TOGGLE_GROUP_ITEM_NAME,\n        props.__scopeToggleGroup\n      );\n      const __scopeToggleGroup = props.__scopeToggleGroup;\n      const rovingFocusGroupScope = useRovingFocusGroupScope(props.__scopeToggleGroup);\n      const pressed = valueContext.value.includes(props.value);\n      const disabled = context.disabled || props.disabled || false;\n      const ref = React.useRef(null);\n      const groupItemProps = useGroupItem({ disabled });\n      const size = props.size ?? context.size;\n      const sizeProps = {\n        width: void 0,\n        height: void 0,\n        padding: getVariableValue(size) * 0.6\n      };\n      if (props.orientation === \"horizontal\")\n        sizeProps.height = getVariableValue(size) * 2.4;\n      else\n        sizeProps.width = getVariableValue(size) * 2.4;\n      const iconSize = (typeof size === \"number\" ? size * 0.7 : getFontSize(size)) * 1.2;\n      const theme = useTheme();\n      const getThemedIcon = useGetThemedIcon({ size: iconSize, color: theme.color });\n      const childrens = React.Children.toArray(props.children);\n      const children = childrens.map((child) => {\n        if (props.disablePassStyles || !React.isValidElement(child)) {\n          return child;\n        }\n        return getThemedIcon(child);\n      });\n      const commonProps = { ...props, pressed, disabled, ...sizeProps, children };\n      return /* @__PURE__ */ jsx(ToggleGroupItemProvider, { scope: __scopeToggleGroup, children: context.rovingFocus ? /* @__PURE__ */ jsx(\n        RovingFocusGroup.Item,\n        {\n          asChild: true,\n          ...rovingFocusGroupScope,\n          focusable: !disabled,\n          active: pressed,\n          children: /* @__PURE__ */ jsx(\n            ToggleFrame,\n            {\n              asChild: true,\n              focusable: !disabled,\n              disabled,\n              ref,\n              ...groupItemProps,\n              children: /* @__PURE__ */ jsx(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef })\n            }\n          )\n        }\n      ) : /* @__PURE__ */ jsx(ToggleFrame, { asChild: true, focusable: !disabled, disabled, ref, children: /* @__PURE__ */ jsx(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef }) }) });\n    }\n  )\n);\nToggleGroupItem.displayName = TOGGLE_GROUP_ITEM_NAME;\nconst ToggleGroupItemImpl = ToggleFrame.extractable(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const { __scopeToggleGroup, value, ...itemProps } = props;\n      const valueContext = useToggleGroupValueContext(\n        TOGGLE_GROUP_ITEM_NAME,\n        __scopeToggleGroup\n      );\n      const singleProps = {\n        \"aria-pressed\": void 0\n      };\n      const typeProps = valueContext.type === \"single\" ? singleProps : void 0;\n      return /* @__PURE__ */ jsx(\n        Toggle,\n        {\n          ...typeProps,\n          ...itemProps,\n          ref: forwardedRef,\n          onPressedChange: (pressed) => {\n            if (pressed) {\n              valueContext.onItemActivate(value);\n            } else {\n              valueContext.onItemDeactivate(value);\n            }\n          }\n        }\n      );\n    }\n  )\n);\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\nconst ToggleGroup = withStaticProperties(\n  React.forwardRef((props, forwardedRef) => {\n    const { type, ...toggleGroupProps } = props;\n    if (!isWeb) {\n      React.useEffect(() => {\n        if (!props.id)\n          return;\n        return registerFocusable(props.id, {\n          // TODO: would be nice to focus on the first child later - could be done with reforest\n          // for now leaving it empty\n          focus: () => {\n          }\n        });\n      }, [props.id]);\n    }\n    if (type === \"single\") {\n      const singleProps = toggleGroupProps;\n      return /* @__PURE__ */ jsx(ToggleGroupImplSingle, { ...singleProps, ref: forwardedRef });\n    }\n    if (type === \"multiple\") {\n      const multipleProps = toggleGroupProps;\n      return /* @__PURE__ */ jsx(ToggleGroupImplMultiple, { ...multipleProps, ref: forwardedRef });\n    }\n    throw new Error(`Missing prop \\`type\\` expected on \\`${TOGGLE_GROUP_NAME}\\``);\n  }),\n  {\n    Item: ToggleGroupItem\n  }\n);\nToggleGroup.displayName = TOGGLE_GROUP_NAME;\nconst [ToggleGroupValueProvider, useToggleGroupValueContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);\nconst ToggleGroupImplSingle = React.forwardRef((props, forwardedRef) => {\n  const {\n    value: valueProp,\n    defaultValue,\n    onValueChange = () => {\n    },\n    disableDeactivation = false,\n    ...toggleGroupSingleProps\n  } = props;\n  const [value, setValue] = useControllableState({\n    prop: valueProp,\n    defaultProp: defaultValue,\n    onChange: onValueChange\n  });\n  return /* @__PURE__ */ jsx(\n    ToggleGroupValueProvider,\n    {\n      scope: props.__scopeToggleGroup,\n      type: \"single\",\n      value: value ? [value] : [],\n      defaultValue: value,\n      onItemActivate: setValue,\n      onItemDeactivate: React.useCallback(() => disableDeactivation ? null : setValue(\"\"), [setValue, disableDeactivation]),\n      children: /* @__PURE__ */ jsx(ToggleGroupImpl, { ...toggleGroupSingleProps, ref: forwardedRef })\n    }\n  );\n});\nconst ToggleGroupImplMultiple = React.forwardRef((props, forwardedRef) => {\n  const {\n    value: valueProp,\n    defaultValue,\n    onValueChange = () => {\n    },\n    ...toggleGroupMultipleProps\n  } = props;\n  const [value = [], setValue] = useControllableState({\n    prop: valueProp,\n    defaultProp: defaultValue,\n    onChange: onValueChange\n  });\n  const handleButtonActivate = React.useCallback(\n    (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),\n    [setValue]\n  );\n  const handleButtonDeactivate = React.useCallback(\n    (itemValue) => setValue((prevValue = []) => prevValue.filter((value2) => value2 !== itemValue)),\n    [setValue]\n  );\n  return /* @__PURE__ */ jsx(\n    ToggleGroupValueProvider,\n    {\n      scope: props.__scopeToggleGroup,\n      type: \"multiple\",\n      value,\n      defaultValue: value,\n      onItemActivate: handleButtonActivate,\n      onItemDeactivate: handleButtonDeactivate,\n      children: /* @__PURE__ */ jsx(ToggleGroupImpl, { ...toggleGroupMultipleProps, ref: forwardedRef })\n    }\n  );\n});\nToggleGroup.displayName = TOGGLE_GROUP_NAME;\nconst [ToggleGroupContext, useToggleGroupContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);\nconst ToggleGroupImplElementFrame = styled(Group, {\n  name: TOGGLE_GROUP_NAME,\n  variants: {\n    unstyled: {\n      false: {\n        backgroundColor: \"$background\"\n      }\n    },\n    orientation: {\n      vertical: {\n        flexDirection: \"column\",\n        spaceDirection: \"vertical\"\n      },\n      horizontal: {\n        flexDirection: \"row\",\n        spaceDirection: \"horizontal\"\n      }\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst ToggleGroupImpl = ToggleGroupImplElementFrame.extractable(\n  React.forwardRef(\n    (props, forwardedRef) => {\n      const {\n        __scopeToggleGroup,\n        disabled = false,\n        orientation = \"horizontal\",\n        dir,\n        rovingFocus = true,\n        loop = true,\n        unstyled = false,\n        size: sizeProp = \"$true\",\n        sizeAdjust = 0,\n        ...toggleGroupProps\n      } = props;\n      const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToggleGroup);\n      const direction = useDirection(dir);\n      const commonProps = {\n        role: \"togglegroup\",\n        dir: direction,\n        ...toggleGroupProps\n      };\n      const adjustedSize = getVariableValue(\n        stepTokenUpOrDown(\"size\", props.size, sizeAdjust)\n      );\n      const size = Math.round(adjustedSize * 0.45);\n      return /* @__PURE__ */ jsx(\n        ToggleGroupContext,\n        {\n          scope: __scopeToggleGroup,\n          rovingFocus,\n          disabled,\n          size,\n          children: rovingFocus ? /* @__PURE__ */ jsx(\n            RovingFocusGroup,\n            {\n              asChild: true,\n              ...rovingFocusGroupScope,\n              orientation,\n              dir: direction,\n              loop,\n              children: /* @__PURE__ */ jsx(\n                ToggleGroupImplElementFrame,\n                {\n                  \"aria-orientation\": orientation,\n                  orientation,\n                  axis: orientation,\n                  ref: forwardedRef,\n                  \"data-disabled\": disabled ? \"\" : void 0,\n                  unstyled,\n                  ...commonProps\n                }\n              )\n            }\n          ) : /* @__PURE__ */ jsx(\n            ToggleGroupImplElementFrame,\n            {\n              \"aria-orientation\": orientation,\n              ref: forwardedRef,\n              orientation,\n              \"data-disabled\": disabled ? \"\" : void 0,\n              unstyled,\n              ...commonProps\n            }\n          )\n        }\n      );\n    }\n  )\n);\nexport {\n  ToggleGroup,\n  createToggleGroupScope\n};\n//# sourceMappingURL=ToggleGroup.mjs.map\n","export * from \"./ToggleGroup\";\n//# sourceMappingURL=index.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport \"@tamagui/polyfill-dev\";\nimport {\n  FloatingDelayGroup,\n  useDelayGroup,\n  useDelayGroupContext,\n  useDismiss,\n  useFloating,\n  useFocus,\n  useHover,\n  useInteractions,\n  useRole\n} from \"@floating-ui/react\";\nimport { useEvent, withStaticProperties } from \"@tamagui/core\";\nimport { FloatingOverrideContext } from \"@tamagui/floating\";\nimport { stepTokenUpOrDown } from \"@tamagui/get-size\";\nimport {\n  PopoverAnchor,\n  PopoverArrow,\n  PopoverContent,\n  PopoverTrigger,\n  __PopoverProviderInternal,\n  usePopoverScope\n} from \"@tamagui/popover\";\nimport {\n  Popper,\n  PopperContentFrame,\n  usePopperContext\n} from \"@tamagui/popper\";\nimport * as React from \"react\";\nconst TooltipContent = PopperContentFrame.extractable(\n  React.forwardRef(\n    ({ __scopePopover, ...props }, ref) => {\n      const popperScope = usePopoverScope(__scopePopover);\n      const popper = usePopperContext(\"PopperContent\", popperScope[\"__scopePopper\"]);\n      const padding = props.size || popper.size || stepTokenUpOrDown(\"size\", \"$true\", -2);\n      return /* @__PURE__ */ jsx(\n        PopoverContent,\n        {\n          componentName: \"Tooltip\",\n          disableRemoveScroll: true,\n          trapFocus: false,\n          padding,\n          pointerEvents: \"none\",\n          ref,\n          ...props\n        }\n      );\n    }\n  )\n);\nconst TooltipArrow = React.forwardRef((props, ref) => {\n  return /* @__PURE__ */ jsx(PopoverArrow, { componentName: \"Tooltip\", ref, ...props });\n});\nconst TooltipGroup = ({ children, delay }) => {\n  return /* @__PURE__ */ jsx(FloatingDelayGroup, { delay: React.useMemo(() => delay, [JSON.stringify(delay)]), children });\n};\nconst TooltipComponent = React.forwardRef(function Tooltip(props, ref) {\n  const {\n    __scopePopover,\n    children,\n    delay: delayProp,\n    restMs = typeof delayProp === \"undefined\" ? 500 : typeof delayProp === \"number\" ? delayProp : 0,\n    onOpenChange: onOpenChangeProp,\n    focus,\n    ...restProps\n  } = props;\n  const popperScope = usePopoverScope(__scopePopover);\n  const triggerRef = React.useRef(null);\n  const [hasCustomAnchor, setHasCustomAnchor] = React.useState(false);\n  const { delay: delayGroup, setCurrentId } = useDelayGroupContext();\n  const delay = delayProp ?? delayGroup;\n  const [open, setOpen] = React.useState(false);\n  const id = props.groupId;\n  const onOpenChange = useEvent((open2) => {\n    setOpen(open2);\n    if (open2) {\n      setCurrentId(id);\n    }\n    onOpenChangeProp == null ? void 0 : onOpenChangeProp(open2);\n  });\n  const useFloatingFn = (props2) => {\n    const floating = useFloating({\n      ...props2,\n      open,\n      onOpenChange\n    });\n    const { getReferenceProps, getFloatingProps } = useInteractions([\n      useHover(floating.context, { delay, restMs }),\n      useFocus(floating.context, focus),\n      useRole(floating.context, { role: \"tooltip\" }),\n      useDismiss(floating.context),\n      useDelayGroup(floating.context, { id })\n    ]);\n    return {\n      ...floating,\n      getReferenceProps,\n      getFloatingProps\n    };\n  };\n  const useFloatingContext = React.useCallback(useFloatingFn, [id, delay, open]);\n  const onCustomAnchorAdd = React.useCallback(() => setHasCustomAnchor(true), []);\n  const onCustomAnchorRemove = React.useCallback(() => setHasCustomAnchor(false), []);\n  const contentId = React.useId();\n  const twoSmallerKey = stepTokenUpOrDown(\"size\", \"$true\", -2).key;\n  const size = `$${twoSmallerKey}`;\n  return /* @__PURE__ */ jsx(FloatingOverrideContext.Provider, { value: useFloatingContext, children: /* @__PURE__ */ jsx(Popper, { size, ...popperScope, ...restProps, children: /* @__PURE__ */ jsx(\n    __PopoverProviderInternal,\n    {\n      scope: __scopePopover,\n      popperScope: popperScope.__scopePopper,\n      contentId,\n      triggerRef,\n      sheetBreakpoint: false,\n      scopeKey: \"\",\n      open,\n      onOpenChange: setOpen,\n      onOpenToggle: voidFn,\n      hasCustomAnchor,\n      onCustomAnchorAdd,\n      onCustomAnchorRemove,\n      children\n    }\n  ) }) });\n});\nconst Tooltip2 = withStaticProperties(TooltipComponent, {\n  Anchor: PopoverAnchor,\n  Arrow: TooltipArrow,\n  Content: TooltipContent,\n  Trigger: PopoverTrigger\n});\nconst voidFn = () => {\n};\nexport {\n  Tooltip2 as Tooltip,\n  TooltipGroup\n};\n//# sourceMappingURL=Tooltip.mjs.map\n","import { jsx, jsxs } from \"react/jsx-runtime\";\nimport { useDelayGroupContext } from \"@floating-ui/react\";\nimport { Paragraph } from \"@tamagui/text\";\nimport { Tooltip, TooltipGroup } from \"./Tooltip\";\nconst TooltipSimple = ({\n  label,\n  children,\n  contentProps,\n  ...tooltipProps\n}) => {\n  let context;\n  try {\n    context = useDelayGroupContext();\n  } catch {\n  }\n  const contents = /* @__PURE__ */ jsxs(Tooltip, { ...tooltipProps, children: [\n    /* @__PURE__ */ jsx(Tooltip.Trigger, { asChild: true, children }),\n    /* @__PURE__ */ jsxs(\n      Tooltip.Content,\n      {\n        zIndex: 1e6,\n        enterStyle: { x: 0, y: -8, opacity: 0, scale: 0.93 },\n        exitStyle: { x: 0, y: -8, opacity: 0, scale: 0.93 },\n        x: 0,\n        scale: 1,\n        y: 0,\n        elevation: \"$1\",\n        opacity: 1,\n        animation: [\n          \"quick\",\n          {\n            opacity: {\n              overshootClamping: true\n            }\n          }\n        ],\n        ...contentProps,\n        children: [\n          /* @__PURE__ */ jsx(Tooltip.Arrow, {}),\n          /* @__PURE__ */ jsx(Paragraph, { size: \"$2\", lineHeight: \"$0\", children: label })\n        ]\n      }\n    )\n  ] });\n  if (!context) {\n    return /* @__PURE__ */ jsx(TooltipGroup, { delay: defaultTooltipDelay, children: contents });\n  }\n  return contents;\n};\nconst defaultTooltipDelay = { open: 3e3, close: 100 };\nexport {\n  TooltipSimple\n};\n//# sourceMappingURL=TooltipSimple.mjs.map\n","export * from \"./Tooltip\";\nexport * from \"./TooltipSimple\";\n//# sourceMappingURL=index.mjs.map\n","import { useMemo, useRef } from \"react\";\nfunction useConstant(fn) {\n  if (typeof document === \"undefined\") {\n    return useMemo(() => fn(), []);\n  }\n  const ref = useRef();\n  if (!ref.current) {\n    ref.current = { v: fn() };\n  }\n  return ref.current.v;\n}\nexport {\n  useConstant\n};\n//# sourceMappingURL=index.mjs.map\n","export * from \"./useControllableState\";\n//# sourceMappingURL=index.mjs.map\n","import { useEffect, useMemo, useRef, useState } from \"react\";\nfunction debounce(func, wait, leading) {\n  let timeout;\n  let isCancelled = false;\n  function debounced() {\n    isCancelled = false;\n    const context = this;\n    const args = arguments;\n    if (leading && !timeout) {\n      func.apply(context, args);\n    }\n    clearTimeout(timeout);\n    timeout = setTimeout(function() {\n      timeout = null;\n      if (!(leading || isCancelled)) {\n        func.apply(context, args);\n      }\n      isCancelled = false;\n    }, wait);\n  }\n  debounced.cancel = () => {\n    isCancelled = true;\n  };\n  return debounced;\n}\nconst defaultOpts = { leading: false };\nfunction useDebounce(fn, wait, options = defaultOpts, mountArgs = []) {\n  const dbEffect = useRef(null);\n  useEffect(() => {\n    return () => {\n      var _a;\n      (_a = dbEffect.current) == null ? void 0 : _a.cancel();\n    };\n  }, []);\n  return useMemo(() => {\n    dbEffect.current = debounce(fn, wait, options.leading);\n    return dbEffect.current;\n  }, [options.leading, ...mountArgs]);\n}\nfunction useDebounceValue(val, amt = 0) {\n  const [state, setState] = useState(val);\n  useEffect(() => {\n    const tm = setTimeout(() => {\n      setState((prev) => {\n        if (prev === val)\n          return prev;\n        return val;\n      });\n    }, amt);\n    return () => {\n      clearTimeout(tm);\n    };\n  }, [val]);\n  return state;\n}\nexport {\n  debounce,\n  useDebounce,\n  useDebounceValue\n};\n//# sourceMappingURL=index.mjs.map\n","export * from \"./useDirection\";\n//# sourceMappingURL=index.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nconst DirectionContext = React.createContext(void 0);\nconst DirectionProvider = (props) => {\n  const { dir, children } = props;\n  return /* @__PURE__ */ jsx(DirectionContext.Provider, { value: dir, children });\n};\nfunction useDirection(localDir) {\n  const globalDir = React.useContext(DirectionContext);\n  return localDir || globalDir || \"ltr\";\n}\nconst Provider = DirectionProvider;\nexport {\n  DirectionProvider,\n  Provider,\n  useDirection\n};\n//# sourceMappingURL=useDirection.mjs.map\n","import { useKeyboardVisible } from \"./useKeyboardVisible\";\nexport {\n  useKeyboardVisible\n};\n//# sourceMappingURL=index.mjs.map\n","import { useEffect, useState } from \"react\";\nimport { Keyboard } from \"react-native\";\nconst useKeyboardVisible = () => {\n  const [isKeyboardVisible, setKeyboardVisible] = useState(false);\n  useEffect(() => {\n    const keyboardDidShowListener = Keyboard.addListener(\"keyboardDidShow\", () => {\n      setKeyboardVisible(true);\n    });\n    const keyboardDidHideListener = Keyboard.addListener(\"keyboardDidHide\", () => {\n      setKeyboardVisible(false);\n    });\n    return () => {\n      keyboardDidHideListener.remove();\n      keyboardDidShowListener.remove();\n    };\n  }, []);\n  return isKeyboardVisible;\n};\nexport {\n  useKeyboardVisible\n};\n//# sourceMappingURL=useKeyboardVisible.mjs.map\n","import { useIsomorphicLayoutEffect } from \"@tamagui/constants\";\nimport { useState } from \"react\";\nimport {\n  useWindowDimensions as useWindowDimensionsRN\n} from \"react-native\";\nconst initialValue = {\n  fontScale: 1,\n  height: 800,\n  width: 600,\n  scale: 1\n};\nfunction useWindowDimensions() {\n  const current = useWindowDimensionsRN();\n  if (process.env.TAMAGUI_TARGET != \"web\")\n    return current;\n  const [state, setState] = useState(initialValue);\n  useIsomorphicLayoutEffect(() => {\n    setState(current);\n  }, [current.height, current.width, current.fontScale, current.scale]);\n  return state;\n}\nexport {\n  useWindowDimensions\n};\n//# sourceMappingURL=index.mjs.map\n","export * from \"./VisuallyHidden\";\n//# sourceMappingURL=index.mjs.map\n","var getDefaultParent = function (originalTarget) {\n    if (typeof document === 'undefined') {\n        return null;\n    }\n    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;\n    return sampleTarget.ownerDocument.body;\n};\nvar counterMap = new WeakMap();\nvar uncontrolledNodes = new WeakMap();\nvar markerMap = {};\nvar lockCount = 0;\nvar unwrapHost = function (node) {\n    return node && (node.host || unwrapHost(node.parentNode));\n};\nvar correctTargets = function (parent, targets) {\n    return targets.map(function (target) {\n        if (parent.contains(target)) {\n            return target;\n        }\n        var correctedTarget = unwrapHost(target);\n        if (correctedTarget && parent.contains(correctedTarget)) {\n            return correctedTarget;\n        }\n        console.error('aria-hidden', target, 'in not contained inside', parent, '. Doing nothing');\n        return null;\n    }).filter(function (x) { return Boolean(x); });\n};\n/**\n * Marks everything except given node(or nodes) as aria-hidden\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @param {String} [controlAttribute] - html Attribute to control\n * @return {Undo} undo command\n */\nvar applyAttributeToOthers = function (originalTarget, parentNode, markerName, controlAttribute) {\n    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n    if (!markerMap[markerName]) {\n        markerMap[markerName] = new WeakMap();\n    }\n    var markerCounter = markerMap[markerName];\n    var hiddenNodes = [];\n    var elementsToKeep = new Set();\n    var elementsToStop = new Set(targets);\n    var keep = function (el) {\n        if (!el || elementsToKeep.has(el)) {\n            return;\n        }\n        elementsToKeep.add(el);\n        keep(el.parentNode);\n    };\n    targets.forEach(keep);\n    var deep = function (parent) {\n        if (!parent || elementsToStop.has(parent)) {\n            return;\n        }\n        Array.prototype.forEach.call(parent.children, function (node) {\n            if (elementsToKeep.has(node)) {\n                deep(node);\n            }\n            else {\n                var attr = node.getAttribute(controlAttribute);\n                var alreadyHidden = attr !== null && attr !== 'false';\n                var counterValue = (counterMap.get(node) || 0) + 1;\n                var markerValue = (markerCounter.get(node) || 0) + 1;\n                counterMap.set(node, counterValue);\n                markerCounter.set(node, markerValue);\n                hiddenNodes.push(node);\n                if (counterValue === 1 && alreadyHidden) {\n                    uncontrolledNodes.set(node, true);\n                }\n                if (markerValue === 1) {\n                    node.setAttribute(markerName, 'true');\n                }\n                if (!alreadyHidden) {\n                    node.setAttribute(controlAttribute, 'true');\n                }\n            }\n        });\n    };\n    deep(parentNode);\n    elementsToKeep.clear();\n    lockCount++;\n    return function () {\n        hiddenNodes.forEach(function (node) {\n            var counterValue = counterMap.get(node) - 1;\n            var markerValue = markerCounter.get(node) - 1;\n            counterMap.set(node, counterValue);\n            markerCounter.set(node, markerValue);\n            if (!counterValue) {\n                if (!uncontrolledNodes.has(node)) {\n                    node.removeAttribute(controlAttribute);\n                }\n                uncontrolledNodes.delete(node);\n            }\n            if (!markerValue) {\n                node.removeAttribute(markerName);\n            }\n        });\n        lockCount--;\n        if (!lockCount) {\n            // clear\n            counterMap = new WeakMap();\n            counterMap = new WeakMap();\n            uncontrolledNodes = new WeakMap();\n            markerMap = {};\n        }\n    };\n};\n/**\n * Marks everything except given node(or nodes) as aria-hidden\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Undo} undo command\n */\nexport var hideOthers = function (originalTarget, parentNode, markerName) {\n    if (markerName === void 0) { markerName = 'data-aria-hidden'; }\n    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n    var activeParentNode = parentNode || getDefaultParent(originalTarget);\n    if (!activeParentNode) {\n        return function () { return null; };\n    }\n    // we should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10\n    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live]')));\n    return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');\n};\n/**\n * Marks everything except given node(or nodes) as inert\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Undo} undo command\n */\nexport var inertOthers = function (originalTarget, parentNode, markerName) {\n    if (markerName === void 0) { markerName = 'data-inert-ed'; }\n    var activeParentNode = parentNode || getDefaultParent(originalTarget);\n    if (!activeParentNode) {\n        return function () { return null; };\n    }\n    return applyAttributeToOthers(originalTarget, activeParentNode, markerName, 'inert');\n};\n/**\n * @returns if current browser supports inert\n */\nexport var supportsInert = function () {\n    return typeof HTMLElement !== 'undefined' && HTMLElement.prototype.hasOwnProperty('inert');\n};\n/**\n * Automatic function to \"suppress\" DOM elements - _hide_ or _inert_ in the best possible way\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Undo} undo command\n */\nexport var suppressOthers = function (originalTarget, parentNode, markerName) {\n    if (markerName === void 0) { markerName = 'data-suppressed'; }\n    return (supportsInert() ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);\n};\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect } from 'react';\nimport * as ReactDOM from 'react-dom';\n\n/**\n * A data provider that provides data to position an inner element of the\n * floating element (usually a triangle or caret) so that it is centered to the\n * reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => {\n  const {\n    element,\n    padding\n  } = options;\n  function isRef(value) {\n    return Object.prototype.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(args) {\n      if (isRef(element)) {\n        if (element.current != null) {\n          return arrow$1({\n            element: element.current,\n            padding\n          }).fn(args);\n        }\n        return {};\n      } else if (element) {\n        return arrow$1({\n          element,\n          padding\n        }).fn(args);\n      }\n      return {};\n    }\n  };\n};\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length, i, keys;\n  if (a && b && typeof a == 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\n\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/react\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React.useState({\n    x: null,\n    y: null,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const referenceRef = React.useRef(null);\n  const floatingRef = React.useRef(null);\n  const dataRef = React.useRef(data);\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const [reference, _setReference] = React.useState(null);\n  const [floating, _setFloating] = React.useState(null);\n  const setReference = React.useCallback(node => {\n    if (referenceRef.current !== node) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = React.useCallback(node => {\n    if (floatingRef.current !== node) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const update = React.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    computePosition(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = {\n        ...data,\n        isPositioned: true\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => ({\n        ...data,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (reference && floating) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(reference, floating, update);\n      } else {\n        update();\n      }\n    }\n  }, [reference, floating, update, whileElementsMountedRef]);\n  const refs = React.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React.useMemo(() => ({\n    reference,\n    floating\n  }), [reference, floating]);\n  return React.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    reference: setReference,\n    floating: setFloating\n  }), [data, update, refs, elements, setReference, setFloating]);\n}\n\nexport { arrow, useFloating };\n","import * as React from 'react';\nimport { useLayoutEffect, useEffect, useRef } from 'react';\nimport { hideOthers } from 'aria-hidden';\nimport { tabbable } from 'tabbable';\nimport { createPortal, flushSync } from 'react-dom';\nimport { getOverflowAncestors, offset, detectOverflow, useFloating as useFloating$1 } from '@floating-ui/react-dom';\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/react-dom';\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = () => \"floating-ui-\" + count++;\nfunction useFloatingId() {\n  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : undefined);\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  React.useEffect(() => {\n    if (!serverHandoffComplete) {\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id;\n}\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useReactId = React[/*#__PURE__*/'useId'.toString()];\n\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/useId\n */\nconst useId = useReactId || useFloatingId;\n\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach(handler => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n    off(event, listener) {\n      map.set(event, (map.get(event) || []).filter(l => l !== listener));\n    }\n  };\n}\n\nconst FloatingNodeContext = /*#__PURE__*/React.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/React.createContext(null);\nconst useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\nconst useFloatingTree = () => React.useContext(FloatingTreeContext);\n\n/**\n * Registers a node into the floating tree, returning its id.\n */\nconst useFloatingNodeId = customParentId => {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null ? void 0 : tree.addNode(node);\n    return () => {\n      tree == null ? void 0 : tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n};\n\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nconst FloatingNode = _ref => {\n  let {\n    children,\n    id\n  } = _ref;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/React.createElement(FloatingNodeContext.Provider, {\n    value: React.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n};\n\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM (i.e. portalled to a common node, rather than their\n * respective parent).\n * @see https://floating-ui.com/docs/FloatingTree\n */\nconst FloatingTree = _ref2 => {\n  let {\n    children\n  } = _ref2;\n  const nodesRef = React.useRef([]);\n  const addNode = React.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = React.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = React.useState(() => createPubSub())[0];\n  return /*#__PURE__*/React.createElement(FloatingTreeContext.Provider, {\n    value: React.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [nodesRef, addNode, removeNode, events])\n  }, children);\n};\n\nfunction getDocument(node) {\n  return (node == null ? void 0 : node.ownerDocument) || document;\n}\n\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(_ref => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(' ');\n  }\n  return navigator.userAgent;\n}\n\nfunction getWindow(value) {\n  return getDocument(value).defaultView || window;\n}\nfunction isElement(value) {\n  return value ? value instanceof getWindow(value).Element : false;\n}\nfunction isHTMLElement(value) {\n  return value ? value instanceof getWindow(value).HTMLElement : false;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n  const androidRe = /Android/i;\n  if ((androidRe.test(getPlatform()) || androidRe.test(getUserAgent())) && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n  return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n  return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType !== 'mouse' ||\n  // iOS VoiceOver returns 0.333• for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;\n}\nfunction isSafari() {\n  // Chrome DevTools does not complain about navigator.vendor\n  return /apple/i.test(navigator.vendor);\n}\nfunction isMac() {\n  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n  // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n  // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n  const values = ['mouse', 'pen'];\n  if (!strict) {\n    values.push('', undefined);\n  }\n  return values.includes(pointerType);\n}\n\nfunction useLatestRef(value) {\n  const ref = useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\nconst safePolygonIdentifier = 'data-floating-ui-safe-polygon';\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !isMouseLikePointerType(pointerType)) {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */\nconst useHover = function (context, _temp) {\n  let {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = _temp === void 0 ? {} : _temp;\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    elements: {\n      domReference,\n      floating\n    },\n    refs\n  } = context;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = useLatestRef(handleClose);\n  const delayRef = useLatestRef(delay);\n  const pointerTypeRef = React.useRef();\n  const timeoutRef = React.useRef();\n  const handlerRef = React.useRef();\n  const restTimeoutRef = React.useRef();\n  const blockMouseMoveRef = React.useRef(true);\n  const performedPointerEventsMutationRef = React.useRef(false);\n  const unbindMouseMoveRef = React.useRef(() => {});\n  const isHoverOpen = React.useCallback(() => {\n    var _dataRef$current$open;\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  }, [dataRef]);\n\n  // When dismissing before opening, clear the delay timeouts to cancel it\n  // from showing.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onDismiss() {\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      blockMouseMoveRef.current = true;\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [enabled, events]);\n  React.useEffect(() => {\n    if (!enabled || !handleCloseRef.current || !open) {\n      return;\n    }\n    function onLeave() {\n      if (isHoverOpen()) {\n        onOpenChange(false);\n      }\n    }\n    const html = getDocument(floating).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [floating, open, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);\n  const closeWithDelay = React.useCallback(function (runElseBranch) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => onOpenChange(false), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChange(false);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = React.useCallback(() => {\n    unbindMouseMoveRef.current();\n    handlerRef.current = undefined;\n  }, []);\n  const clearPointerEvents = React.useCallback(() => {\n    if (performedPointerEventsMutationRef.current) {\n      const body = getDocument(refs.floating.current).body;\n      body.style.pointerEvents = '';\n      body.removeAttribute(safePolygonIdentifier);\n      performedPointerEventsMutationRef.current = false;\n    }\n  }, [refs]);\n\n  // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function isClickLikeOpenEvent() {\n      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n    }\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {\n        return;\n      }\n      dataRef.current.openEvent = event;\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n      if (openDelay) {\n        timeoutRef.current = setTimeout(() => {\n          onOpenChange(true);\n        }, openDelay);\n      } else {\n        onOpenChange(true);\n      }\n    }\n    function onMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      unbindMouseMoveRef.current();\n      const doc = getDocument(floating);\n      clearTimeout(restTimeoutRef.current);\n      if (handleCloseRef.current) {\n        // Prevent clearing `onScrollMouseLeave` timeout.\n        if (!open) {\n          clearTimeout(timeoutRef.current);\n        }\n        handlerRef.current = handleCloseRef.current({\n          ...context,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            closeWithDelay();\n          }\n        });\n        const handler = handlerRef.current;\n        doc.addEventListener('mousemove', handler);\n        unbindMouseMoveRef.current = () => {\n          doc.removeEventListener('mousemove', handler);\n        };\n        return;\n      }\n      closeWithDelay();\n    }\n\n    // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      handleCloseRef.current == null ? void 0 : handleCloseRef.current({\n        ...context,\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          closeWithDelay();\n        }\n      })(event);\n    }\n    if (isElement(domReference)) {\n      const ref = domReference;\n      open && ref.addEventListener('mouseleave', onScrollMouseLeave);\n      floating == null ? void 0 : floating.addEventListener('mouseleave', onScrollMouseLeave);\n      move && ref.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      ref.addEventListener('mouseenter', onMouseEnter);\n      ref.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        open && ref.removeEventListener('mouseleave', onScrollMouseLeave);\n        floating == null ? void 0 : floating.removeEventListener('mouseleave', onScrollMouseLeave);\n        move && ref.removeEventListener('mousemove', onMouseEnter);\n        ref.removeEventListener('mouseenter', onMouseEnter);\n        ref.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);\n\n  // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n  index(() => {\n    var _handleCloseRef$curre;\n    if (!enabled) {\n      return;\n    }\n    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n      const body = getDocument(floating).body;\n      body.setAttribute(safePolygonIdentifier, '');\n      body.style.pointerEvents = 'none';\n      performedPointerEventsMutationRef.current = true;\n      if (isElement(domReference) && floating) {\n        var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n        const ref = domReference;\n        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n        ref.style.pointerEvents = 'auto';\n        floating.style.pointerEvents = 'auto';\n        return () => {\n          ref.style.pointerEvents = '';\n          floating.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, dataRef, isHoverOpen]);\n  index(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      cleanupMouseMoveHandler();\n      clearPointerEvents();\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n  React.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      clearPointerEvents();\n    };\n  }, [enabled, cleanupMouseMoveHandler, clearPointerEvents]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerRef,\n        onPointerEnter: setPointerRef,\n        onMouseMove() {\n          if (open || restMs === 0) {\n            return;\n          }\n          clearTimeout(restTimeoutRef.current);\n          restTimeoutRef.current = setTimeout(() => {\n            if (!blockMouseMoveRef.current) {\n              onOpenChange(true);\n            }\n          }, restMs);\n        }\n      },\n      floating: {\n        onMouseEnter() {\n          clearTimeout(timeoutRef.current);\n        },\n        onMouseLeave() {\n          events.emit('dismiss', {\n            type: 'mouseLeave',\n            data: {\n              returnFocus: false\n            }\n          });\n          closeWithDelay(false);\n        }\n      }\n    };\n  }, [events, enabled, restMs, open, onOpenChange, closeWithDelay]);\n};\n\nconst FloatingDelayGroupContext = /*#__PURE__*/React.createContext({\n  delay: 0,\n  initialDelay: 0,\n  timeoutMs: 0,\n  currentId: null,\n  setCurrentId: () => {},\n  setState: () => {},\n  isInstantPhase: false\n});\nconst useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);\n\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nconst FloatingDelayGroup = _ref => {\n  let {\n    children,\n    delay,\n    timeoutMs = 0\n  } = _ref;\n  const [state, setState] = React.useReducer((prev, next) => ({\n    ...prev,\n    ...next\n  }), {\n    delay,\n    timeoutMs,\n    initialDelay: delay,\n    currentId: null,\n    isInstantPhase: false\n  });\n  const initialCurrentIdRef = React.useRef(null);\n  const setCurrentId = React.useCallback(currentId => {\n    setState({\n      currentId\n    });\n  }, []);\n  index(() => {\n    if (state.currentId) {\n      if (initialCurrentIdRef.current === null) {\n        initialCurrentIdRef.current = state.currentId;\n      } else {\n        setState({\n          isInstantPhase: true\n        });\n      }\n    } else {\n      setState({\n        isInstantPhase: false\n      });\n      initialCurrentIdRef.current = null;\n    }\n  }, [state.currentId]);\n  return /*#__PURE__*/React.createElement(FloatingDelayGroupContext.Provider, {\n    value: React.useMemo(() => ({\n      ...state,\n      setState,\n      setCurrentId\n    }), [state, setState, setCurrentId])\n  }, children);\n};\nconst useDelayGroup = (_ref2, _ref3) => {\n  let {\n    open,\n    onOpenChange\n  } = _ref2;\n  let {\n    id\n  } = _ref3;\n  const {\n    currentId,\n    setCurrentId,\n    initialDelay,\n    setState,\n    timeoutMs\n  } = useDelayGroupContext();\n  React.useEffect(() => {\n    if (currentId) {\n      setState({\n        delay: {\n          open: 1,\n          close: getDelay(initialDelay, 'close')\n        }\n      });\n      if (currentId !== id) {\n        onOpenChange(false);\n      }\n    }\n  }, [id, onOpenChange, setState, currentId, initialDelay]);\n  React.useEffect(() => {\n    function unset() {\n      onOpenChange(false);\n      setState({\n        delay: initialDelay,\n        currentId: null\n      });\n    }\n    if (!open && currentId === id) {\n      if (timeoutMs) {\n        const timeout = window.setTimeout(unset, timeoutMs);\n        return () => {\n          clearTimeout(timeout);\n        };\n      } else {\n        unset();\n      }\n    }\n  }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n  React.useEffect(() => {\n    if (open) {\n      setCurrentId(id);\n    }\n  }, [open, setCurrentId, id]);\n};\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\n * Find the real active element. Traverses into shadowRoots.\n */\nfunction activeElement$1(doc) {\n  let activeElement = doc.activeElement;\n  while (((_activeElement = activeElement) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {\n    var _activeElement, _activeElement$shadow;\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\n\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode && child.getRootNode();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n  // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    do {\n      if (next && parent === next) {\n        return true;\n      }\n      // @ts-ignore\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  // Give up, the result is false\n  return false;\n}\n\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\n\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}\n\nfunction getChildren(nodes, id) {\n  let allChildren = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  }) || [];\n  let currentChildren = allChildren;\n  while (currentChildren.length) {\n    currentChildren = nodes.filter(node => {\n      var _currentChildren;\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    }) || [];\n    allChildren = allChildren.concat(currentChildren);\n  }\n  return allChildren;\n}\n\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\n\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\n\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\n\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, direction) {\n  const allTabbable = tabbable(container, getTabbableOptions());\n  if (direction === 'prev') {\n    allTabbable.reverse();\n  }\n  const activeIndex = allTabbable.indexOf(activeElement$1(getDocument(container)));\n  const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n  return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n  return getTabbableIn(document.body, 'next');\n}\nfunction getPreviousTabbable() {\n  return getTabbableIn(document.body, 'prev');\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = tabbable(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    element.dataset.tabindex = element.getAttribute('tabindex') || '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\n\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = React[/*#__PURE__*/'useInsertionEffect'.toString()];\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\nfunction useEvent(callback) {\n  const ref = React.useRef(() => {\n    if (process.env.NODE_ENV !== \"production\") {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\n\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nlet activeElement;\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n  if (event.key === 'Tab') {\n    activeElement = event.target;\n    clearTimeout(timeoutId);\n  }\n}\nfunction isTabFocus(event) {\n  const result = activeElement === event.relatedTarget;\n  activeElement = event.relatedTarget;\n  clearTimeout(timeoutId);\n  return result;\n}\nconst FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref) {\n  const onFocus = useEvent(props.onFocus);\n  const [role, setRole] = React.useState();\n  index(() => {\n    if (isSafari()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n    document.addEventListener('keydown', setActiveElementOnTab);\n    return () => {\n      document.removeEventListener('keydown', setActiveElementOnTab);\n    };\n  }, []);\n  return /*#__PURE__*/React.createElement(\"span\", _extends({}, props, {\n    ref: ref,\n    tabIndex: 0\n    // Role is only for VoiceOver\n    ,\n    role: role,\n    \"aria-hidden\": role ? undefined : true,\n    \"data-floating-ui-focus-guard\": \"\",\n    style: HIDDEN_STYLES,\n    onFocus: event => {\n      if (isSafari() && isMac() && !isTabFocus(event)) {\n        // On macOS we need to wait a little bit before moving\n        // focus again.\n        event.persist();\n        timeoutId = window.setTimeout(() => {\n          onFocus(event);\n        }, 50);\n      } else {\n        onFocus(event);\n      }\n    }\n  }));\n});\n\nconst PortalContext = /*#__PURE__*/React.createContext(null);\nconst useFloatingPortalNode = function (_temp) {\n  let {\n    id,\n    enabled = true\n  } = _temp === void 0 ? {} : _temp;\n  const [portalEl, setPortalEl] = React.useState(null);\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    const rootNode = id ? document.getElementById(id) : null;\n    if (rootNode) {\n      rootNode.setAttribute('data-floating-ui-portal', '');\n      setPortalEl(rootNode);\n    } else {\n      const newPortalEl = document.createElement('div');\n      if (id !== '') {\n        newPortalEl.id = id || uniqueId;\n      }\n      newPortalEl.setAttribute('data-floating-ui-portal', '');\n      setPortalEl(newPortalEl);\n      const container = (portalContext == null ? void 0 : portalContext.portalNode) || document.body;\n      container.appendChild(newPortalEl);\n      return () => {\n        container.removeChild(newPortalEl);\n      };\n    }\n  }, [id, portalContext, uniqueId, enabled]);\n  return portalEl;\n};\n\n/**\n * Portals the floating element into a given container element — by default,\n * outside of the app root and into the body.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\nconst FloatingPortal = _ref => {\n  let {\n    children,\n    id,\n    root = null,\n    preserveTabOrder = true\n  } = _ref;\n  const portalNode = useFloatingPortalNode({\n    id,\n    enabled: !root\n  });\n  const [focusManagerState, setFocusManagerState] = React.useState(null);\n  const beforeOutsideRef = React.useRef(null);\n  const afterOutsideRef = React.useRef(null);\n  const beforeInsideRef = React.useRef(null);\n  const afterInsideRef = React.useRef(null);\n  const shouldRenderGuards =\n  // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState &&\n  // Guards are only for non-modal focus management.\n  !focusManagerState.modal && !!(root || portalNode) && preserveTabOrder;\n\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n  React.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n      return;\n    }\n\n    // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n    function onFocus(event) {\n      if (portalNode && isOutsideEvent(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n        manageFocus(portalNode);\n      }\n    }\n    // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);\n  return /*#__PURE__*/React.createElement(PortalContext.Provider, {\n    value: React.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode])\n  }, shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: beforeOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _beforeInsideRef$curr;\n        (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();\n      } else {\n        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        prevTabbable == null ? void 0 : prevTabbable.focus();\n      }\n    }\n  }), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-owns\": portalNode.id,\n    style: HIDDEN_STYLES\n  }), root ? /*#__PURE__*/createPortal(children, root) : portalNode ? /*#__PURE__*/createPortal(children, portalNode) : null, shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: afterOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _afterInsideRef$curre;\n        (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();\n      } else {\n        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        nextTabbable == null ? void 0 : nextTabbable.focus();\n        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false));\n      }\n    }\n  }));\n};\nconst usePortalContext = () => React.useContext(PortalContext);\n\nconst VisuallyHiddenDismiss = /*#__PURE__*/React.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/React.createElement(\"button\", _extends({}, props, {\n    type: \"button\",\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(_ref) {\n  let {\n    context,\n    children,\n    order = ['content'],\n    guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    modal = true,\n    visuallyHiddenDismiss = false,\n    closeOnFocusOut = true\n  } = _ref;\n  const {\n    refs,\n    nodeId,\n    onOpenChange,\n    events,\n    dataRef,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const orderRef = useLatestRef(order);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const [tabbableContentLength, setTabbableContentLength] = React.useState(null);\n\n  // Controlled by `useListNavigation`.\n  const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n  const startDismissButtonRef = React.useRef(null);\n  const endDismissButtonRef = React.useRef(null);\n  const preventReturnFocusRef = React.useRef(false);\n  const previouslyFocusedElementRef = React.useRef(null);\n  const isPointerDownRef = React.useRef(false);\n  const isInsidePortal = portalContext != null;\n\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isTypeableCombobox = domReference && domReference.getAttribute('role') === 'combobox' && isTypeableElement(domReference);\n  const getTabbableContent = React.useCallback(function (container) {\n    if (container === void 0) {\n      container = floating;\n    }\n    return container ? tabbable(container, getTabbableOptions()) : [];\n  }, [floating]);\n  const getTabbableElements = React.useCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (domReference && type === 'reference') {\n        return domReference;\n      }\n      if (floating && type === 'floating') {\n        return floating;\n      }\n      return content;\n    }).filter(Boolean).flat();\n  }, [domReference, floating, orderRef, getTabbableContent]);\n  React.useEffect(() => {\n    if (!modal) {\n      return;\n    }\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if (getTabbableContent().length === 0 && !isTypeableCombobox) {\n          stopEvent(event);\n        }\n        const els = getTabbableElements();\n        const target = getTarget(event);\n        if (orderRef.current[0] === 'reference' && target === domReference) {\n          stopEvent(event);\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n        if (orderRef.current[1] === 'floating' && target === floating && event.shiftKey) {\n          stopEvent(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n    const doc = getDocument(floating);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [domReference, floating, modal, orderRef, refs, isTypeableCombobox, getTabbableContent, getTabbableElements]);\n  React.useEffect(() => {\n    if (!closeOnFocusOut) {\n      return;\n    }\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      setTimeout(() => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute('data-floating-ui-focus-guard') || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n        var _node$context, _node$context2;\n        return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n      }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n        var _node$context3, _node$context4;\n        return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n      })));\n\n      // Focus did not move inside the floating tree, and there are no tabbable\n      // portal guards to handle closing.\n      if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n      // Fix React 18 Strict Mode returnFocus due to double rendering.\n      relatedTarget !== previouslyFocusedElementRef.current) {\n        preventReturnFocusRef.current = true;\n        // On iOS VoiceOver, dismissing the nested submenu will cause the\n        // first item of the list to receive focus. Delaying it appears to fix\n        // the issue.\n        setTimeout(() => onOpenChange(false));\n      }\n    }\n    if (floating && isHTMLElement(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      !modal && floating.addEventListener('focusout', handleFocusOutside);\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        !modal && floating.removeEventListener('focusout', handleFocusOutside);\n      };\n    }\n  }, [domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);\n  React.useEffect(() => {\n    var _portalContext$portal;\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from((portalContext == null ? void 0 : (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll('[data-floating-ui-portal]')) || []);\n    function getDismissButtons() {\n      return [startDismissButtonRef.current, endDismissButtonRef.current].filter(Boolean);\n    }\n    if (floating && modal) {\n      const insideNodes = [floating, ...portalNodes, ...getDismissButtons()];\n      const cleanup = hideOthers(orderRef.current.includes('reference') || isTypeableCombobox ? insideNodes.concat(domReference || []) : insideNodes);\n      return () => {\n        cleanup();\n      };\n    }\n  }, [domReference, floating, modal, orderRef, portalContext, isTypeableCombobox]);\n  React.useEffect(() => {\n    if (modal && !guards && floating) {\n      const tabIndexValues = [];\n      const options = getTabbableOptions();\n      const allTabbable = tabbable(getDocument(floating).body, options);\n      const floatingTabbable = getTabbableElements();\n\n      // Exclude all tabbable elements that are part of the order\n      const elements = allTabbable.filter(el => !floatingTabbable.includes(el));\n      elements.forEach((el, i) => {\n        tabIndexValues[i] = el.getAttribute('tabindex');\n        el.setAttribute('tabindex', '-1');\n      });\n      return () => {\n        elements.forEach((el, i) => {\n          const value = tabIndexValues[i];\n          if (value == null) {\n            el.removeAttribute('tabindex');\n          } else {\n            el.setAttribute('tabindex', value);\n          }\n        });\n      };\n    }\n  }, [floating, modal, guards, getTabbableElements]);\n  index(() => {\n    if (!floating) return;\n    const doc = getDocument(floating);\n    let returnFocusValue = returnFocus;\n    let preventReturnFocusScroll = false;\n    const previouslyFocusedElement = activeElement$1(doc);\n    const contextData = dataRef.current;\n    previouslyFocusedElementRef.current = previouslyFocusedElement;\n    const focusableElements = getTabbableElements(floating);\n    const elToFocus = (typeof initialFocus === 'number' ? focusableElements[initialFocus] : initialFocus.current) || floating;\n\n    // If the `useListNavigation` hook is active, always ignore `initialFocus`\n    // because it has its own handling of the initial focus.\n    !ignoreInitialFocus && enqueueFocus(elToFocus, {\n      preventScroll: elToFocus === floating\n    });\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onDismiss(payload) {\n      if (payload.type === 'escapeKey' && refs.domReference.current) {\n        previouslyFocusedElementRef.current = refs.domReference.current;\n      }\n      if (['referencePress', 'escapeKey'].includes(payload.type)) {\n        return;\n      }\n      const returnFocus = payload.data.returnFocus;\n      if (typeof returnFocus === 'object') {\n        returnFocusValue = true;\n        preventReturnFocusScroll = returnFocus.preventScroll;\n      } else {\n        returnFocusValue = returnFocus;\n      }\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n      if (contains(floating, activeElement$1(doc)) && refs.domReference.current) {\n        previouslyFocusedElementRef.current = refs.domReference.current;\n      }\n      if (returnFocusValue && isHTMLElement(previouslyFocusedElementRef.current) && !preventReturnFocusRef.current) {\n        // `isPointerDownRef.current` to avoid the focus ring from appearing on\n        // the reference element when click-toggling it.\n        if (!refs.domReference.current || isPointerDownRef.current) {\n          enqueueFocus(previouslyFocusedElementRef.current, {\n            // When dismissing nested floating elements, by the time the rAF has\n            // executed, the menus will all have been unmounted. When they try\n            // to get focused, the calls get ignored — leaving the root\n            // reference focused as desired.\n            cancelPrevious: false,\n            preventScroll: preventReturnFocusScroll\n          });\n        } else {\n          var _previouslyFocusedEle;\n          // If the user has specified a `keydown` listener that calls\n          // setOpen(false) (e.g. selecting an item and closing the floating\n          // element), then sync return focus causes `useClick` to immediately\n          // re-open it, unless they call `event.preventDefault()` in the\n          // `keydown` listener. This helps keep backwards compatibility with\n          // older examples.\n          contextData.__syncReturnFocus = true;\n\n          // In Safari, `useListNavigation` moves focus sync, so making this\n          // sync ensures the initial item remains focused despite this being\n          // invoked in Strict Mode due to double-invoked useEffects. This also\n          // has the positive side effect of closing a modally focus-managed\n          // <Menu> on `Tab` keydown to move naturally to the next focusable\n          // element.\n          (_previouslyFocusedEle = previouslyFocusedElementRef.current) == null ? void 0 : _previouslyFocusedEle.focus({\n            preventScroll: preventReturnFocusScroll\n          });\n          setTimeout(() => {\n            // This isn't an actual property the user should access, make sure\n            // it doesn't persist.\n            delete contextData.__syncReturnFocus;\n          });\n        }\n      }\n    };\n  }, [floating, getTabbableElements, initialFocus, returnFocus, dataRef, refs, events, ignoreInitialFocus]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  index(() => {\n    if (!portalContext) return;\n    portalContext.setFocusManagerState({\n      ...context,\n      modal,\n      closeOnFocusOut\n      // Not concerned about the <RT> generic type.\n    });\n\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [portalContext, modal, closeOnFocusOut, context]);\n  index(() => {\n    if (ignoreInitialFocus || !floating) return;\n    function setState() {\n      setTabbableContentLength(getTabbableContent().length);\n    }\n    setState();\n    if (typeof MutationObserver === 'function') {\n      const observer = new MutationObserver(setState);\n      observer.observe(floating, {\n        childList: true,\n        subtree: true\n      });\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [floating, getTabbableContent, ignoreInitialFocus, refs]);\n  const shouldRenderGuards = guards && (isInsidePortal || modal) && !isTypeableCombobox;\n  function renderDismissButton(location) {\n    return visuallyHiddenDismiss && modal ? /*#__PURE__*/React.createElement(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: () => onOpenChange(false)\n    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss') : null;\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n    onFocus: event => {\n      if (modal) {\n        const els = getTabbableElements();\n        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = false;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const nextTabbable = getNextTabbable() || domReference;\n          nextTabbable == null ? void 0 : nextTabbable.focus();\n        } else {\n          var _portalContext$before;\n          (_portalContext$before = portalContext.beforeOutsideRef.current) == null ? void 0 : _portalContext$before.focus();\n        }\n      }\n    }\n  }), isTypeableCombobox ? null : renderDismissButton('start'), /*#__PURE__*/React.cloneElement(children, tabbableContentLength === 0 || order.includes('floating') ? {\n    tabIndex: 0\n  } : {}), renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n    onFocus: event => {\n      if (modal) {\n        enqueueFocus(getTabbableElements()[0]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = true;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const prevTabbable = getPreviousTabbable() || domReference;\n          prevTabbable == null ? void 0 : prevTabbable.focus();\n        } else {\n          var _portalContext$afterO;\n          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null ? void 0 : _portalContext$afterO.focus();\n        }\n      }\n    }\n  }));\n}\n\nconst identifier = 'data-floating-ui-scroll-lock';\n\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\nconst FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(_ref, ref) {\n  let {\n    lockScroll = false,\n    ...rest\n  } = _ref;\n  index(() => {\n    var _window$visualViewpor, _window$visualViewpor2;\n    if (!lockScroll) {\n      return;\n    }\n    const alreadyLocked = document.body.hasAttribute(identifier);\n    if (alreadyLocked) {\n      return;\n    }\n    document.body.setAttribute(identifier, '');\n\n    // RTL <body> scrollbar\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n\n    // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {\n      Object.assign(document.body.style, {\n        overflow: 'hidden',\n        [paddingProp]: scrollbarWidth + \"px\"\n      });\n      return () => {\n        document.body.removeAttribute(identifier);\n        Object.assign(document.body.style, {\n          overflow: '',\n          [paddingProp]: ''\n        });\n      };\n    }\n\n    // iOS 12 does not support `visualViewport`.\n    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n    const scrollX = window.pageXOffset;\n    const scrollY = window.pageYOffset;\n    Object.assign(document.body.style, {\n      position: 'fixed',\n      overflow: 'hidden',\n      top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n      left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n      right: '0',\n      [paddingProp]: scrollbarWidth + \"px\"\n    });\n    return () => {\n      Object.assign(document.body.style, {\n        position: '',\n        overflow: '',\n        top: '',\n        left: '',\n        right: '',\n        [paddingProp]: ''\n      });\n      document.body.removeAttribute(identifier);\n      window.scrollTo(scrollX, scrollY);\n    };\n  }, [lockScroll]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: {\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...rest.style\n    }\n  }));\n});\n\nfunction isButtonTarget(event) {\n  return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';\n}\nfunction isSpaceIgnored(element) {\n  return isTypeableElement(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */\nconst useClick = function (_ref, _temp) {\n  let {\n    open,\n    onOpenChange,\n    dataRef,\n    elements: {\n      domReference\n    }\n  } = _ref;\n  let {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true\n  } = _temp === void 0 ? {} : _temp;\n  const pointerTypeRef = React.useRef();\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(event) {\n          pointerTypeRef.current = event.pointerType;\n        },\n        onMouseDown(event) {\n          // Ignore all buttons except for the \"main\" button.\n          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n          if (event.button !== 0) {\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (eventOption === 'click') {\n            return;\n          }\n          if (open) {\n            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n              onOpenChange(false);\n            }\n          } else {\n            // Prevent stealing focus from the floating element\n            event.preventDefault();\n            onOpenChange(true);\n          }\n          dataRef.current.openEvent = event.nativeEvent;\n        },\n        onClick(event) {\n          if (dataRef.current.__syncReturnFocus) {\n            return;\n          }\n          if (eventOption === 'mousedown' && pointerTypeRef.current) {\n            pointerTypeRef.current = undefined;\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (open) {\n            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n              onOpenChange(false);\n            }\n          } else {\n            onOpenChange(true);\n          }\n          dataRef.current.openEvent = event.nativeEvent;\n        },\n        onKeyDown(event) {\n          pointerTypeRef.current = undefined;\n          if (!keyboardHandlers) {\n            return;\n          }\n          if (isButtonTarget(event)) {\n            return;\n          }\n          if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n            // Prevent scrolling\n            event.preventDefault();\n          }\n          if (event.key === 'Enter') {\n            if (open) {\n              if (toggle) {\n                onOpenChange(false);\n              }\n            } else {\n              onOpenChange(true);\n            }\n          }\n        },\n        onKeyUp(event) {\n          if (!keyboardHandlers) {\n            return;\n          }\n          if (isButtonTarget(event) || isSpaceIgnored(domReference)) {\n            return;\n          }\n          if (event.key === ' ') {\n            if (open) {\n              if (toggle) {\n                onOpenChange(false);\n              }\n            } else {\n              onOpenChange(true);\n            }\n          }\n        }\n      }\n    };\n  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);\n};\n\n/**\n * Check whether the event.target is within the provided node. Uses event.composedPath if available for custom element support.\n *\n * @param event The event whose target/composedPath to check\n * @param node The node to check against\n * @returns Whether the event.target/composedPath is within the node.\n */\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\n\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\nconst normalizeBubblesProp = function (bubbles) {\n  var _bubbles$escapeKey, _bubbles$outsidePress;\n  if (bubbles === void 0) {\n    bubbles = true;\n  }\n  return {\n    escapeKeyBubbles: typeof bubbles === 'boolean' ? bubbles : (_bubbles$escapeKey = bubbles.escapeKey) != null ? _bubbles$escapeKey : true,\n    outsidePressBubbles: typeof bubbles === 'boolean' ? bubbles : (_bubbles$outsidePress = bubbles.outsidePress) != null ? _bubbles$outsidePress : true\n  };\n};\n/**\n * Closes the floating element when a dismissal is requested — by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nconst useDismiss = function (_ref, _temp) {\n  let {\n    open,\n    onOpenChange,\n    events,\n    nodeId,\n    elements: {\n      reference,\n      domReference,\n      floating\n    },\n    dataRef\n  } = _ref;\n  let {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: unstable_outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles = true\n  } = _temp === void 0 ? {} : _temp;\n  const tree = useFloatingTree();\n  const nested = useFloatingParentNodeId() != null;\n  const outsidePressFn = useEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n  const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n  const insideReactTreeRef = React.useRef(false);\n  const {\n    escapeKeyBubbles,\n    outsidePressBubbles\n  } = normalizeBubblesProp(bubbles);\n  React.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    function onKeyDown(event) {\n      if (event.key === 'Escape') {\n        const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n        if (children.length > 0) {\n          let shouldDismiss = true;\n          children.forEach(child => {\n            var _child$context;\n            if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n              shouldDismiss = false;\n              return;\n            }\n          });\n          if (!shouldDismiss) {\n            return;\n          }\n        }\n        events.emit('dismiss', {\n          type: 'escapeKey',\n          data: {\n            returnFocus: {\n              preventScroll: false\n            }\n          }\n        });\n        onOpenChange(false);\n      }\n    }\n    function onOutsidePress(event) {\n      // Given developers can stop the propagation of the synthetic event,\n      // we can only be confident with a positive value.\n      const insideReactTree = insideReactTreeRef.current;\n      insideReactTreeRef.current = false;\n      if (insideReactTree) {\n        return;\n      }\n      if (typeof outsidePress === 'function' && !outsidePress(event)) {\n        return;\n      }\n      const target = getTarget(event);\n\n      // Check if the click occurred on the scrollbar\n      if (isHTMLElement(target) && floating) {\n        const win = floating.ownerDocument.defaultView || window;\n        const canScrollX = target.scrollWidth > target.clientWidth;\n        const canScrollY = target.scrollHeight > target.clientHeight;\n        let xCond = canScrollY && event.offsetX > target.clientWidth;\n\n        // In some browsers it is possible to change the <body> (or window)\n        // scrollbar to the left side, but is very rare and is difficult to\n        // check for. Plus, for modal dialogs with backdrops, it is more\n        // important that the backdrop is checked but not so much the window.\n        if (canScrollY) {\n          const isRTL = win.getComputedStyle(target).direction === 'rtl';\n          if (isRTL) {\n            xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n          }\n        }\n        if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n          return;\n        }\n      }\n      const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context;\n        return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n      });\n      if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {\n        return;\n      }\n      const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context2;\n          if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n      events.emit('dismiss', {\n        type: 'outsidePress',\n        data: {\n          returnFocus: nested ? {\n            preventScroll: true\n          } : isVirtualClick(event) || isVirtualPointerEvent(event)\n        }\n      });\n      onOpenChange(false);\n    }\n    function onScroll() {\n      onOpenChange(false);\n    }\n    const doc = getDocument(floating);\n    escapeKey && doc.addEventListener('keydown', onKeyDown);\n    outsidePress && doc.addEventListener(outsidePressEvent, onOutsidePress);\n    let ancestors = [];\n    if (ancestorScroll) {\n      if (isElement(domReference)) {\n        ancestors = getOverflowAncestors(domReference);\n      }\n      if (isElement(floating)) {\n        ancestors = ancestors.concat(getOverflowAncestors(floating));\n      }\n      if (!isElement(reference) && reference && reference.contextElement) {\n        ancestors = ancestors.concat(getOverflowAncestors(reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      escapeKey && doc.removeEventListener('keydown', onKeyDown);\n      outsidePress && doc.removeEventListener(outsidePressEvent, onOutsidePress);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n    };\n  }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, events, tree, nodeId, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, nested]);\n  React.useEffect(() => {\n    insideReactTreeRef.current = false;\n  }, [outsidePress, outsidePressEvent]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        [bubbleHandlerKeys[referencePressEvent]]: () => {\n          if (referencePress) {\n            events.emit('dismiss', {\n              type: 'referencePress',\n              data: {\n                returnFocus: false\n              }\n            });\n            onOpenChange(false);\n          }\n        }\n      },\n      floating: {\n        [captureHandlerKeys[outsidePressEvent]]: () => {\n          insideReactTreeRef.current = true;\n        }\n      }\n    };\n  }, [enabled, events, referencePress, outsidePressEvent, referencePressEvent, onOpenChange]);\n};\n\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */\nconst useFocus = function (_ref, _temp) {\n  let {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    refs,\n    elements: {\n      floating,\n      domReference\n    }\n  } = _ref;\n  let {\n    enabled = true,\n    keyboardOnly = true\n  } = _temp === void 0 ? {} : _temp;\n  const pointerTypeRef = React.useRef('');\n  const blockFocusRef = React.useRef(false);\n  const timeoutRef = React.useRef();\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    const doc = getDocument(floating);\n    const win = doc.defaultView || window;\n\n    // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n    function onBlur() {\n      if (!open && isHTMLElement(domReference) && domReference === activeElement$1(getDocument(domReference))) {\n        blockFocusRef.current = true;\n      }\n    }\n    win.addEventListener('blur', onBlur);\n    return () => {\n      win.removeEventListener('blur', onBlur);\n    };\n  }, [floating, domReference, open, enabled]);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onDismiss(payload) {\n      if (payload.type === 'referencePress' || payload.type === 'escapeKey') {\n        blockFocusRef.current = true;\n      }\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [events, enabled]);\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(timeoutRef.current);\n    };\n  }, []);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(_ref2) {\n          let {\n            pointerType\n          } = _ref2;\n          pointerTypeRef.current = pointerType;\n          blockFocusRef.current = !!(pointerType && keyboardOnly);\n        },\n        onMouseLeave() {\n          blockFocusRef.current = false;\n        },\n        onFocus(event) {\n          var _dataRef$current$open;\n          if (blockFocusRef.current) {\n            return;\n          }\n\n          // Dismiss with click should ignore the subsequent `focus` trigger,\n          // but only if the click originated inside the reference element.\n          if (event.type === 'focus' && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === 'mousedown' && dataRef.current.openEvent && isEventTargetWithin(dataRef.current.openEvent, domReference)) {\n            return;\n          }\n          dataRef.current.openEvent = event.nativeEvent;\n          onOpenChange(true);\n        },\n        onBlur(event) {\n          blockFocusRef.current = false;\n          const relatedTarget = event.relatedTarget;\n\n          // Hit the non-modal focus management portal guard. Focus will be\n          // moved into the floating element immediately after.\n          const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute('data-floating-ui-focus-guard') && relatedTarget.getAttribute('data-type') === 'outside';\n\n          // Wait for the window blur listener to fire.\n          timeoutRef.current = setTimeout(() => {\n            // When focusing the reference element (e.g. regular click), then\n            // clicking into the floating element, prevent it from hiding.\n            // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n            if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {\n              return;\n            }\n            onOpenChange(false);\n          });\n        }\n      }\n    };\n  }, [enabled, keyboardOnly, domReference, refs, dataRef, onOpenChange]);\n};\n\nlet isPreventScrollSupported = false;\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nfunction isDifferentRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  let index = startingIndex;\n  do {\n    var _list$index, _list$index2;\n    index = index + (decrement ? -amount : amount);\n  } while (index >= 0 && index <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index) : list[index] == null || ((_list$index = list[index]) == null ? void 0 : _list$index.hasAttribute('disabled')) || ((_list$index2 = list[index]) == null ? void 0 : _list$index2.getAttribute('aria-disabled')) === 'true'));\n  return index;\n}\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key == ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nconst useListNavigation = function (_ref, _temp2) {\n  let {\n    open,\n    onOpenChange,\n    refs,\n    elements: {\n      domReference\n    }\n  } = _ref;\n  let {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    cols = 1,\n    scrollItemIntoView = true\n  } = _temp2 === void 0 ? {\n    listRef: {\n      current: []\n    },\n    activeIndex: null,\n    onNavigate: () => {}\n  } : _temp2;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (allowEscape) {\n      if (!loop) {\n        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));\n      }\n      if (!virtual) {\n        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either \"horizontal\" or \"both\".'].join(' '));\n    }\n  }\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const onNavigate = useEvent(unstable_onNavigate);\n  const focusItemOnOpenRef = React.useRef(focusItemOnOpen);\n  const indexRef = React.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = React.useRef(null);\n  const isPointerModalityRef = React.useRef(true);\n  const previousOnNavigateRef = React.useRef(onNavigate);\n  const previousOpenRef = React.useRef(open);\n  const forceSyncFocus = React.useRef(false);\n  const forceScrollIntoViewRef = React.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n  const [activeId, setActiveId] = React.useState();\n  const focusItem = React.useCallback(function (listRef, indexRef, forceScrollIntoView) {\n    if (forceScrollIntoView === void 0) {\n      forceScrollIntoView = false;\n    }\n    const item = listRef.current[indexRef.current];\n    if (virtual) {\n      setActiveId(item == null ? void 0 : item.id);\n    } else {\n      enqueueFocus(item, {\n        preventScroll: true,\n        // Mac Safari does not move the virtual cursor unless the focus call\n        // is sync. However, for the very first focus call, we need to wait\n        // for the position to be ready in order to prevent unwanted\n        // scrolling. This means the virtual cursor will not move to the first\n        // item when first opening the floating element, but will on\n        // subsequent calls. `preventScroll` is supported in modern Safari,\n        // so we can use that instead.\n        // iOS Safari must be async or the first item will not be focused.\n        sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false\n      });\n    }\n    requestAnimationFrame(() => {\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        item.scrollIntoView == null ? void 0 : item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  }, [virtual, scrollItemIntoViewRef]);\n  index(() => {\n    document.createElement('div').focus({\n      get preventScroll() {\n        isPreventScrollSupported = true;\n        return false;\n      }\n    });\n  }, []);\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        onNavigate(selectedIndex);\n      }\n    } else if (previousOpenRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current(null);\n    }\n  }, [enabled, open, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open) {\n      if (activeIndex == null) {\n        forceSyncFocus.current = false;\n        if (selectedIndex != null) {\n          return;\n        }\n\n        // Reset while the floating element was open (e.g. the list changed).\n        if (previousOpenRef.current) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        }\n\n        // Initial sync.\n        if (!previousOpenRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n          onNavigate(indexRef.current);\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n        forceScrollIntoViewRef.current = false;\n      }\n    }\n  }, [enabled, open, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (previousOpenRef.current && !open) {\n      var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n      const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;\n      if (parentFloating && !contains(parentFloating, activeElement$1(getDocument(parentFloating)))) {\n        parentFloating.focus({\n          preventScroll: true\n        });\n      }\n    }\n  }, [enabled, open, tree, parentId]);\n  index(() => {\n    keyRef.current = null;\n    previousOnNavigateRef.current = onNavigate;\n    previousOpenRef.current = open;\n  });\n  const hasActiveIndex = activeIndex != null;\n  const item = React.useMemo(() => {\n    function syncCurrentTarget(currentTarget) {\n      if (!open) return;\n      const index = listRef.current.indexOf(currentTarget);\n      if (index !== -1) {\n        onNavigate(index);\n      }\n    }\n    const props = {\n      onFocus(_ref2) {\n        let {\n          currentTarget\n        } = _ref2;\n        syncCurrentTarget(currentTarget);\n      },\n      onClick: _ref3 => {\n        let {\n          currentTarget\n        } = _ref3;\n        return currentTarget.focus({\n          preventScroll: true\n        });\n      },\n      // Safari\n      ...(focusItemOnHover && {\n        onMouseMove(_ref4) {\n          let {\n            currentTarget\n          } = _ref4;\n          syncCurrentTarget(currentTarget);\n        },\n        onPointerLeave() {\n          if (!isPointerModalityRef.current) {\n            return;\n          }\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n\n          // Virtual cursor with VoiceOver on iOS needs this to be flushed\n          // synchronously or there is a glitch that prevents nested\n          // submenus from being accessible.\n          flushSync(() => onNavigate(null));\n          if (!virtual) {\n            var _refs$floating$curren;\n            // This also needs to be sync to prevent fast mouse movements\n            // from leaving behind a stale active item when landing on a\n            // disabled button item.\n            (_refs$floating$curren = refs.floating.current) == null ? void 0 : _refs$floating$curren.focus({\n              preventScroll: true\n            });\n          }\n        }\n      })\n    };\n    return props;\n  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    const disabledIndices = disabledIndicesRef.current;\n    function onKeyDown(event) {\n      isPointerModalityRef.current = false;\n      forceSyncFocus.current = true;\n\n      // If the floating element is animating out, ignore navigation. Otherwise,\n      // the `activeIndex` gets set to 0 despite not being open so the next time\n      // the user ArrowDowns, the first item won't be focused.\n      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n        return;\n      }\n      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n        stopEvent(event);\n        onOpenChange(false);\n        if (isHTMLElement(domReference)) {\n          domReference.focus();\n        }\n        return;\n      }\n      const currentIndex = indexRef.current;\n      const minIndex = getMinIndex(listRef, disabledIndices);\n      const maxIndex = getMaxIndex(listRef, disabledIndices);\n      if (event.key === 'Home') {\n        indexRef.current = minIndex;\n        onNavigate(indexRef.current);\n      }\n      if (event.key === 'End') {\n        indexRef.current = maxIndex;\n        onNavigate(indexRef.current);\n      }\n\n      // Grid navigation.\n      if (cols > 1) {\n        const prevIndex = indexRef.current;\n        if (event.key === ARROW_UP) {\n          stopEvent(event);\n          if (prevIndex === -1) {\n            indexRef.current = maxIndex;\n          } else {\n            indexRef.current = findNonDisabledIndex(listRef, {\n              startingIndex: prevIndex,\n              amount: cols,\n              decrement: true,\n              disabledIndices\n            });\n            if (loop && (prevIndex - cols < minIndex || indexRef.current < 0)) {\n              const col = prevIndex % cols;\n              const maxCol = maxIndex % cols;\n              const offset = maxIndex - (maxCol - col);\n              if (maxCol === col) {\n                indexRef.current = maxIndex;\n              } else {\n                indexRef.current = maxCol > col ? offset : offset - cols;\n              }\n            }\n          }\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            indexRef.current = prevIndex;\n          }\n          onNavigate(indexRef.current);\n        }\n        if (event.key === ARROW_DOWN) {\n          stopEvent(event);\n          if (prevIndex === -1) {\n            indexRef.current = minIndex;\n          } else {\n            indexRef.current = findNonDisabledIndex(listRef, {\n              startingIndex: prevIndex,\n              amount: cols,\n              disabledIndices\n            });\n            if (loop && prevIndex + cols > maxIndex) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex % cols - cols,\n                amount: cols,\n                disabledIndices\n              });\n            }\n          }\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            indexRef.current = prevIndex;\n          }\n          onNavigate(indexRef.current);\n        }\n\n        // Remains on the same row/column.\n        if (orientation === 'both') {\n          const prevRow = Math.floor(prevIndex / cols);\n          if (event.key === ARROW_RIGHT) {\n            stopEvent(event);\n            if (prevIndex % cols !== cols - 1) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                disabledIndices\n              });\n              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex - prevIndex % cols - 1,\n                  disabledIndices\n                });\n              }\n            } else if (loop) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex - prevIndex % cols - 1,\n                disabledIndices\n              });\n            }\n            if (isDifferentRow(indexRef.current, cols, prevRow)) {\n              indexRef.current = prevIndex;\n            }\n          }\n          if (event.key === ARROW_LEFT) {\n            stopEvent(event);\n            if (prevIndex % cols !== 0) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                disabledIndices,\n                decrement: true\n              });\n              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex + (cols - prevIndex % cols),\n                  decrement: true,\n                  disabledIndices\n                });\n              }\n            } else if (loop) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex + (cols - prevIndex % cols),\n                decrement: true,\n                disabledIndices\n              });\n            }\n            if (isDifferentRow(indexRef.current, cols, prevRow)) {\n              indexRef.current = prevIndex;\n            }\n          }\n          const lastRow = Math.floor(maxIndex / cols) === prevRow;\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            if (loop && lastRow) {\n              indexRef.current = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex - prevIndex % cols - 1,\n                disabledIndices\n              });\n            } else {\n              indexRef.current = prevIndex;\n            }\n          }\n          onNavigate(indexRef.current);\n          return;\n        }\n      }\n      if (isMainOrientationKey(event.key, orientation)) {\n        stopEvent(event);\n\n        // Reset the index if no item is focused.\n        if (open && !virtual && activeElement$1(event.currentTarget.ownerDocument) === event.currentTarget) {\n          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n          onNavigate(indexRef.current);\n          return;\n        }\n        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n          if (loop) {\n            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            }));\n          }\n        } else {\n          if (loop) {\n            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            }));\n          }\n        }\n        if (isIndexOutOfBounds(listRef, indexRef.current)) {\n          onNavigate(null);\n        } else {\n          onNavigate(indexRef.current);\n        }\n      }\n    }\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n      'aria-activedescendant': activeId\n    };\n    return {\n      reference: {\n        ...ariaActiveDescendantProp,\n        onKeyDown(event) {\n          isPointerModalityRef.current = false;\n          const isArrowKey = event.key.indexOf('Arrow') === 0;\n          if (virtual && open) {\n            return onKeyDown(event);\n          }\n\n          // If a floating element should not open on arrow key down, avoid\n          // setting `activeIndex` while it's closed.\n          if (!open && !openOnArrowKeyDown && isArrowKey) {\n            return;\n          }\n          const isNavigationKey = isArrowKey || event.key === 'Enter' || event.key === ' ' || event.key === '';\n          if (isNavigationKey) {\n            keyRef.current = event.key;\n          }\n          if (nested) {\n            if (isCrossOrientationOpenKey(event.key, orientation, rtl)) {\n              stopEvent(event);\n              if (open) {\n                indexRef.current = getMinIndex(listRef, disabledIndices);\n                onNavigate(indexRef.current);\n              } else {\n                onOpenChange(true);\n              }\n            }\n            return;\n          }\n          if (isMainOrientationKey(event.key, orientation)) {\n            if (selectedIndex != null) {\n              indexRef.current = selectedIndex;\n            }\n            stopEvent(event);\n            if (!open && openOnArrowKeyDown) {\n              onOpenChange(true);\n            } else {\n              onKeyDown(event);\n            }\n            if (open) {\n              onNavigate(indexRef.current);\n            }\n          }\n        },\n        onFocus() {\n          if (open) {\n            onNavigate(null);\n          }\n        },\n        onPointerDown: checkVirtualPointer,\n        onMouseDown: checkVirtualMouse,\n        onClick: checkVirtualMouse\n      },\n      floating: {\n        'aria-orientation': orientation === 'both' ? undefined : orientation,\n        ...ariaActiveDescendantProp,\n        onKeyDown,\n        onPointerMove() {\n          isPointerModalityRef.current = true;\n        }\n      },\n      item\n    };\n  }, [domReference, refs, activeId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item]);\n};\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/useMergeRefs\n */\nfunction useMergeRefs(refs) {\n  return React.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return value => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref != null) {\n          ref.current = value;\n        }\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nconst useRole = function (_ref, _temp) {\n  let {\n    open\n  } = _ref;\n  let {\n    enabled = true,\n    role = 'dialog'\n  } = _temp === void 0 ? {} : _temp;\n  const rootId = useId();\n  const referenceId = useId();\n  return React.useMemo(() => {\n    const floatingProps = {\n      id: rootId,\n      role\n    };\n    if (!enabled) {\n      return {};\n    }\n    if (role === 'tooltip') {\n      return {\n        reference: {\n          'aria-describedby': open ? rootId : undefined\n        },\n        floating: floatingProps\n      };\n    }\n    return {\n      reference: {\n        'aria-expanded': open ? 'true' : 'false',\n        'aria-haspopup': role === 'alertdialog' ? 'dialog' : role,\n        'aria-controls': open ? rootId : undefined,\n        ...(role === 'listbox' && {\n          role: 'combobox'\n        }),\n        ...(role === 'menu' && {\n          id: referenceId\n        })\n      },\n      floating: {\n        ...floatingProps,\n        ...(role === 'menu' && {\n          'aria-labelledby': referenceId\n        })\n      }\n    };\n  }, [enabled, role, open, rootId, referenceId]);\n};\n\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\nfunction useDelayUnmount(open, durationMs) {\n  const [isMounted, setIsMounted] = React.useState(open);\n  if (open && !isMounted) {\n    setIsMounted(true);\n  }\n  React.useEffect(() => {\n    if (!open) {\n      const timeout = setTimeout(() => setIsMounted(false), durationMs);\n      return () => clearTimeout(timeout);\n    }\n  }, [open, durationMs]);\n  return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */\nfunction useTransitionStatus(_ref, _temp) {\n  let {\n    open,\n    elements: {\n      floating\n    }\n  } = _ref;\n  let {\n    duration = 250\n  } = _temp === void 0 ? {} : _temp;\n  const isNumberDuration = typeof duration === 'number';\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [initiated, setInitiated] = React.useState(false);\n  const [status, setStatus] = React.useState('unmounted');\n  const isMounted = useDelayUnmount(open, closeDuration);\n\n  // `initiated` check prevents this `setState` call from breaking\n  // <FloatingPortal />. This call is necessary to ensure subsequent opens\n  // after the initial one allows the correct side animation to play when the\n  // placement has changed.\n  index(() => {\n    if (initiated && !isMounted) {\n      setStatus('unmounted');\n    }\n  }, [initiated, isMounted]);\n  index(() => {\n    if (!floating) return;\n    if (open) {\n      setStatus('initial');\n      const frame = requestAnimationFrame(() => {\n        setStatus('open');\n      });\n      return () => {\n        cancelAnimationFrame(frame);\n      };\n    } else {\n      setInitiated(true);\n      setStatus('close');\n    }\n  }, [open, floating]);\n  return {\n    isMounted,\n    status\n  };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */\nfunction useTransitionStyles(context, _temp2) {\n  let {\n    initial: unstable_initial = {\n      opacity: 0\n    },\n    open: unstable_open,\n    close: unstable_close,\n    common: unstable_common,\n    duration = 250\n  } = _temp2 === void 0 ? {} : _temp2;\n  const placement = context.placement;\n  const side = placement.split('-')[0];\n  const [styles, setStyles] = React.useState({});\n  const {\n    isMounted,\n    status\n  } = useTransitionStatus(context, {\n    duration\n  });\n  const initialRef = useLatestRef(unstable_initial);\n  const openRef = useLatestRef(unstable_open);\n  const closeRef = useLatestRef(unstable_close);\n  const commonRef = useLatestRef(unstable_common);\n  const isNumberDuration = typeof duration === 'number';\n  const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  index(() => {\n    const fnArgs = {\n      side,\n      placement\n    };\n    const initial = initialRef.current;\n    const close = closeRef.current;\n    const open = openRef.current;\n    const common = commonRef.current;\n    const initialStyles = typeof initial === 'function' ? initial(fnArgs) : initial;\n    const closeStyles = typeof close === 'function' ? close(fnArgs) : close;\n    const commonStyles = typeof common === 'function' ? common(fnArgs) : common;\n    const openStyles = (typeof open === 'function' ? open(fnArgs) : open) || Object.keys(initialStyles).reduce((acc, key) => {\n      acc[key] = '';\n      return acc;\n    }, {});\n    if (status === 'initial' || status === 'unmounted') {\n      setStyles(styles => ({\n        transitionProperty: styles.transitionProperty,\n        ...commonStyles,\n        ...initialStyles\n      }));\n    }\n    if (status === 'open') {\n      setStyles({\n        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: openDuration + \"ms\",\n        ...commonStyles,\n        ...openStyles\n      });\n    }\n    if (status === 'close') {\n      const styles = closeStyles || initialStyles;\n      setStyles({\n        transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: closeDuration + \"ms\",\n        ...commonStyles,\n        ...styles\n      });\n    }\n  }, [side, placement, closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status]);\n  return {\n    isMounted,\n    styles\n  };\n}\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nconst useTypeahead = function (_ref, _temp) {\n  var _ref2;\n  let {\n    open,\n    dataRef,\n    refs\n  } = _ref;\n  let {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch = () => {},\n    enabled = true,\n    findMatch = null,\n    resetMs = 1000,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = _temp === void 0 ? {\n    listRef: {\n      current: []\n    },\n    activeIndex: null\n  } : _temp;\n  const timeoutIdRef = React.useRef();\n  const stringRef = React.useRef('');\n  const prevIndexRef = React.useRef((_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1);\n  const matchIndexRef = React.useRef(null);\n  const onMatch = useEvent(unstable_onMatch);\n  const findMatchRef = useLatestRef(findMatch);\n  const ignoreKeysRef = useLatestRef(ignoreKeys);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation.\n    if (open && stringRef.current === '') {\n      var _ref3;\n      prevIndexRef.current = (_ref3 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref3 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function onKeyDown(event) {\n      var _refs$floating$curren;\n      // Correctly scope nested non-portalled floating elements. Since the nested\n      // floating element is inside of the another, we find the closest role\n      // that indicates the floating element scope.\n      const target = getTarget(event.nativeEvent);\n      if (isElement(target) && (activeElement$1(getDocument(target)) !== event.currentTarget ? (_refs$floating$curren = refs.floating.current) != null && _refs$floating$curren.contains(target) ? target.closest('[role=\"dialog\"],[role=\"menu\"],[role=\"listbox\"],[role=\"tree\"],[role=\"grid\"]') !== event.currentTarget : false : !event.currentTarget.contains(target))) {\n        return;\n      }\n      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n        dataRef.current.typing = true;\n        if (event.key === ' ') {\n          stopEvent(event);\n        }\n      }\n      const listContent = listRef.current;\n      if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n      // Character key.\n      event.key.length !== 1 ||\n      // Modifier key.\n      event.ctrlKey || event.metaKey || event.altKey) {\n        return;\n      }\n\n      // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n      // allow it in this case, too.\n      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n        var _text$, _text$2;\n        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n      });\n\n      // Allows the user to cycle through items that start with the same letter\n      // in rapid succession.\n      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n      }\n      stringRef.current += event.key;\n      clearTimeout(timeoutIdRef.current);\n      timeoutIdRef.current = setTimeout(() => {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n        dataRef.current.typing = false;\n      }, resetMs);\n      const prevIndex = prevIndexRef.current;\n      const orderedList = [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)];\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, stringRef.current) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(stringRef.current.toLocaleLowerCase())) === 0);\n      const index = str ? listContent.indexOf(str) : -1;\n      if (index !== -1) {\n        onMatch(index);\n        matchIndexRef.current = index;\n      }\n    }\n    return {\n      reference: {\n        onKeyDown\n      },\n      floating: {\n        onKeyDown\n      }\n    };\n  }, [enabled, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, refs]);\n};\n\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return {\n    ...state,\n    rects: {\n      ...state.rects,\n      floating: {\n        ...state.rects.floating,\n        height\n      }\n    }\n  };\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */\nconst inner = props => ({\n  name: 'inner',\n  options: props,\n  async fn(state) {\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = props;\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = state;\n    const item = listRef.current[index];\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!state.placement.startsWith('bottom')) {\n        console.warn(['Floating UI: `placement` side must be \"bottom\" when using the', '`inner` middleware.'].join(' '));\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = {\n      ...state,\n      ...(await offset(-item.offsetTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))\n    };\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n    const refOverflow = await detectOverflow(nextArgs, {\n      ...detectOverflowOptions,\n      elementContext: 'reference'\n    });\n    const diffY = Math.max(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n    el.style.maxHeight = maxHeight + \"px\";\n    el.scrollTop = diffY;\n\n    // There is not enough space, fallback to standard anchored positioning\n    if (onFallbackChange) {\n      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n        flushSync(() => onFallbackChange(true));\n      } else {\n        flushSync(() => onFallbackChange(false));\n      }\n    }\n    if (overflowRef) {\n      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({\n        ...nextArgs,\n        y: nextY\n      }, el.offsetHeight), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */\nconst useInnerOffset = (_ref, _ref2) => {\n  let {\n    open,\n    elements\n  } = _ref;\n  let {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = _ref2;\n  const onChange = useEvent(unstable_onChange);\n  const controlledScrollingRef = React.useRef(false);\n  const prevScrollTopRef = React.useRef(null);\n  const initialOverflowRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        flushSync(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test(getUserAgent())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el) {\n      el.addEventListener('wheel', onWheel);\n\n      // Wait for the position to be ready.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = {\n            ...overflowRef.current\n          };\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      floating: {\n        onKeyDown() {\n          controlledScrollingRef.current = true;\n        },\n        onWheel() {\n          controlledScrollingRef.current = false;\n        },\n        onPointerMove() {\n          controlledScrollingRef.current = false;\n        },\n        onScroll() {\n          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n          if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n            return;\n          }\n          if (prevScrollTopRef.current !== null) {\n            const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n              flushSync(() => onChange(d => d + scrollDiff));\n            }\n          }\n\n          // [Firefox] Wait for the height change to have been applied.\n          requestAnimationFrame(() => {\n            prevScrollTopRef.current = el.scrollTop;\n          });\n        }\n      }\n    };\n  }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);\n};\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\nfunction safePolygon(_temp) {\n  let {\n    restMs = 0,\n    buffer = 0.5,\n    blockPointerEvents = false\n  } = _temp === void 0 ? {} : _temp;\n  let timeoutId;\n  let isInsideRect = false;\n  let hasLanded = false;\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      elements,\n      onClose,\n      nodeId,\n      tree\n    } = _ref;\n    return function onMouseMove(event) {\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n      clearTimeout(timeoutId);\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = getTarget(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = contains(elements.floating, target);\n      const isOverReferenceEl = contains(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n        return;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[rect.left, refRect.top + 1], [rect.left, rect.bottom - 1], [rect.right, rect.bottom - 1], [rect.right, refRect.top + 1]];\n          isInsideRect = clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= refRect.top + 1;\n          break;\n        case 'bottom':\n          rectPoly = [[rect.left, rect.top + 1], [rect.left, refRect.bottom - 1], [rect.right, refRect.bottom - 1], [rect.right, rect.top + 1]];\n          isInsideRect = clientX >= rect.left && clientX <= rect.right && clientY >= refRect.bottom - 1 && clientY <= rect.bottom;\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, rect.bottom], [rect.right - 1, rect.top], [refRect.left + 1, rect.top], [refRect.left + 1, rect.bottom]];\n          isInsideRect = clientX >= rect.left && clientX <= refRect.left + 1 && clientY >= rect.top && clientY <= rect.bottom;\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, rect.bottom], [refRect.right - 1, rect.top], [rect.left + 1, rect.top], [rect.left + 1, rect.bottom]];\n          isInsideRect = clientX >= refRect.right - 1 && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n          break;\n      }\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        const isFloatingWider = rect.width > refRect.width;\n        const isFloatingTaller = rect.height > refRect.height;\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n      const poly = isInsideRect ? rectPoly : getPolygon([x, y]);\n      if (isInsideRect) {\n        return;\n      } else if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isPointInPolygon([clientX, clientY], poly)) {\n        close();\n      } else if (restMs && !hasLanded) {\n        timeoutId = setTimeout(close, restMs);\n      }\n    };\n  };\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/react\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open = false,\n    onOpenChange: unstable_onOpenChange,\n    nodeId\n  } = options;\n  const position = useFloating$1(options);\n  const tree = useFloatingTree();\n  const domReferenceRef = React.useRef(null);\n  const dataRef = React.useRef({});\n  const events = React.useState(() => createPubSub())[0];\n  const [domReference, setDomReference] = React.useState(null);\n  const setPositionReference = React.useCallback(node => {\n    const positionReference = isElement(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      contextElement: node\n    } : node;\n    position.refs.setReference(positionReference);\n  }, [position.refs]);\n  const setReference = React.useCallback(node => {\n    if (isElement(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if (isElement(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !isElement(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = React.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = React.useMemo(() => ({\n    ...position.elements,\n    domReference: domReference\n  }), [position.elements, domReference]);\n  const onOpenChange = useEvent(unstable_onOpenChange);\n  const context = React.useMemo(() => ({\n    ...position,\n    refs,\n    elements,\n    dataRef,\n    nodeId,\n    events,\n    open,\n    onOpenChange\n  }), [position, nodeId, events, open, onOpenChange, refs, elements]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return React.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    reference: setReference,\n    positionReference: setPositionReference\n  }), [position, refs, context, setReference, setPositionReference]);\n}\n\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  return {\n    ...(elementKey === 'floating' && {\n      tabIndex: -1\n    }),\n    ...userProps,\n    ...propsList.map(value => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n      Object.entries(props).forEach(_ref => {\n        let [key, value] = _ref;\n        if (key.indexOf('on') === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n          if (typeof value === 'function') {\n            var _map$get;\n            (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);\n            acc[key] = function () {\n              var _map$get2;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.forEach(fn => fn(...args));\n            };\n          }\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\nconst useInteractions = function (propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  // The dependencies are a dynamic array, so we can't use the linter's\n  // suggestion to add it to the deps array.\n  const deps = propsList;\n  const getReferenceProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getFloatingProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getItemProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n  // Granularly check for `item` changes, because the `getItemProps` getter\n  // should be as referentially stable as possible since it may be passed as\n  // a prop to many components. All `item` key values must therefore be\n  // memoized.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  propsList.map(key => key == null ? void 0 : key.item));\n  return React.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n};\n\nexport { FloatingDelayGroup, FloatingFocusManager, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, inner, safePolygon, useClick, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInnerOffset, useInteractions, useListNavigation, useMergeRefs, useRole, useTransitionStatus, useTransitionStyles, useTypeahead };\n","// @ts-ignore\nimport * as React from 'react';\nimport {\n  GestureResponderEvent,\n  // @ts-ignore\n  unstable_createElement as ucE,\n  // @ts-ignore\n  createElement as cE,\n} from 'react-native';\nimport { NumberArray, NumberProp } from './lib/extract/types';\nimport SvgTouchableMixin from './lib/SvgTouchableMixin';\nimport { resolve } from './lib/resolve';\n\nconst createElement = cE || ucE;\n\ntype BlurEvent = Object;\ntype FocusEvent = Object;\ntype PressEvent = Object;\ntype LayoutEvent = Object;\ntype EdgeInsetsProp = Object;\n\ninterface BaseProps {\n  accessible?: boolean;\n  accessibilityLabel?: string;\n  accessibilityHint?: string;\n  accessibilityIgnoresInvertColors?: boolean;\n  accessibilityRole?: string;\n  accessibilityState?: Object;\n  delayLongPress?: number;\n  delayPressIn?: number;\n  delayPressOut?: number;\n  disabled?: boolean;\n  hitSlop?: EdgeInsetsProp;\n  nativeID?: string;\n  touchSoundDisabled?: boolean;\n  onBlur?: (e: BlurEvent) => void;\n  onFocus?: (e: FocusEvent) => void;\n  onLayout?: (event: LayoutEvent) => object;\n  onLongPress?: (event: PressEvent) => object;\n  onClick?: (event: PressEvent) => object;\n  onPress?: (event: PressEvent) => object;\n  onPressIn?: (event: PressEvent) => object;\n  onPressOut?: (event: PressEvent) => object;\n  pressRetentionOffset?: EdgeInsetsProp;\n  rejectResponderTermination?: boolean;\n\n  translate: NumberArray;\n  translateX: NumberProp;\n  translateY: NumberProp;\n  scale: NumberArray;\n  rotation: NumberArray;\n  skewX: NumberProp;\n  skewY: NumberProp;\n  originX: NumberProp;\n  originY: NumberProp;\n\n  fontStyle?: string;\n  fontWeight?: NumberProp;\n  fontSize?: NumberProp;\n  fontFamily?: string;\n  forwardedRef: {};\n  style: Iterable<{}>;\n}\n\nconst hasTouchableProperty = (props: BaseProps) =>\n  props.onPress || props.onPressIn || props.onPressOut || props.onLongPress;\n\n/**\n * `react-native-svg` supports additional props that aren't defined in the spec.\n * This function replaces them in a spec conforming manner.\n *\n * @param {WebShape} self Instance given to us.\n * @param {Object?} props Optional overridden props given to us.\n * @returns {Object} Cleaned props object.\n * @private\n */\nconst prepare = <T extends BaseProps>(\n  self: WebShape<T>,\n  props = self.props,\n) => {\n  const {\n    translate,\n    translateX,\n    translateY,\n    scale,\n    rotation,\n    skewX,\n    skewY,\n    originX,\n    originY,\n    fontFamily,\n    fontSize,\n    fontWeight,\n    fontStyle,\n    style,\n    forwardedRef,\n    // @ts-ignore\n    ...rest\n  } = props;\n\n  const clean: {\n    onStartShouldSetResponder?: (e: GestureResponderEvent) => boolean;\n    onResponderMove?: (e: GestureResponderEvent) => void;\n    onResponderGrant?: (e: GestureResponderEvent) => void;\n    onResponderRelease?: (e: GestureResponderEvent) => void;\n    onResponderTerminate?: (e: GestureResponderEvent) => void;\n    onResponderTerminationRequest?: (e: GestureResponderEvent) => boolean;\n    transform?: string;\n    style?: {};\n    ref?: {};\n  } = {\n    ...(hasTouchableProperty(props)\n      ? {\n          onStartShouldSetResponder:\n            self.touchableHandleStartShouldSetResponder,\n          onResponderTerminationRequest:\n            self.touchableHandleResponderTerminationRequest,\n          onResponderGrant: self.touchableHandleResponderGrant,\n          onResponderMove: self.touchableHandleResponderMove,\n          onResponderRelease: self.touchableHandleResponderRelease,\n          onResponderTerminate: self.touchableHandleResponderTerminate,\n        }\n      : null),\n    ...rest,\n  };\n\n  const transform = [];\n\n  if (originX != null || originY != null) {\n    transform.push(`translate(${originX || 0}, ${originY || 0})`);\n  }\n  if (translate != null) {\n    transform.push(`translate(${translate})`);\n  }\n  if (translateX != null || translateY != null) {\n    transform.push(`translate(${translateX || 0}, ${translateY || 0})`);\n  }\n  if (scale != null) {\n    transform.push(`scale(${scale})`);\n  }\n  // rotation maps to rotate, not to collide with the text rotate attribute (which acts per glyph rather than block)\n  if (rotation != null) {\n    transform.push(`rotate(${rotation})`);\n  }\n  if (skewX != null) {\n    transform.push(`skewX(${skewX})`);\n  }\n  if (skewY != null) {\n    transform.push(`skewY(${skewY})`);\n  }\n  if (originX != null || originY != null) {\n    transform.push(`translate(${-originX || 0}, ${-originY || 0})`);\n  }\n\n  if (transform.length) {\n    clean.transform = transform.join(' ');\n  }\n\n  if (forwardedRef) {\n    clean.ref = forwardedRef;\n  }\n\n  const styles: {\n    fontStyle?: string;\n    fontFamily?: string;\n    fontSize?: NumberProp;\n    fontWeight?: NumberProp;\n  } = {};\n\n  if (fontFamily != null) {\n    styles.fontFamily = fontFamily;\n  }\n  if (fontSize != null) {\n    styles.fontSize = fontSize;\n  }\n  if (fontWeight != null) {\n    styles.fontWeight = fontWeight;\n  }\n  if (fontStyle != null) {\n    styles.fontStyle = fontStyle;\n  }\n\n  clean.style = resolve(style, styles);\n\n  return clean;\n};\n\nconst getBoundingClientRect = (node: SVGElement) => {\n  if (node) {\n    // @ts-ignore\n    const isElement = node.nodeType === 1; /* Node.ELEMENT_NODE */\n    // @ts-ignore\n    if (isElement && typeof node.getBoundingClientRect === 'function') {\n      // @ts-ignore\n      return node.getBoundingClientRect();\n    }\n  }\n};\n\nconst measureLayout = (\n  node: SVGElement,\n  callback: (\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    left: number,\n    top: number,\n  ) => void,\n) => {\n  // @ts-ignore\n  const relativeNode = node && node.parentNode;\n  if (relativeNode) {\n    setTimeout(() => {\n      // @ts-ignore\n      const relativeRect = getBoundingClientRect(relativeNode);\n      const { height, left, top, width } = getBoundingClientRect(node);\n      const x = left - relativeRect.left;\n      const y = top - relativeRect.top;\n      callback(x, y, width, height, left, top);\n    }, 0);\n  }\n};\n\nfunction remeasure() {\n  // @ts-ignore\n  const tag = this.state.touchable.responderID;\n  if (tag == null) {\n    return;\n  }\n  // @ts-ignore\n  measureLayout(tag, this._handleQueryLayout);\n}\n\nexport class WebShape<\n  P extends BaseProps = BaseProps,\n  C = {},\n> extends React.Component<P, C> {\n  [x: string]: unknown;\n  _remeasureMetricsOnActivation: () => void;\n  touchableHandleStartShouldSetResponder?: (\n    e: GestureResponderEvent,\n  ) => boolean;\n  touchableHandleResponderMove?: (e: GestureResponderEvent) => void;\n  touchableHandleResponderGrant?: (e: GestureResponderEvent) => void;\n  touchableHandleResponderRelease?: (e: GestureResponderEvent) => void;\n  touchableHandleResponderTerminate?: (e: GestureResponderEvent) => void;\n  touchableHandleResponderTerminationRequest?: (\n    e: GestureResponderEvent,\n  ) => boolean;\n  constructor(props: P, context: C) {\n    super(props, context);\n\n    // Do not attach touchable mixin handlers if SVG element doesn't have a touchable prop\n    if (hasTouchableProperty(props)) {\n      SvgTouchableMixin(this);\n    }\n\n    this._remeasureMetricsOnActivation = remeasure.bind(this);\n  }\n}\n\nexport class Circle extends WebShape {\n  render(): JSX.Element {\n    return createElement('circle', prepare(this));\n  }\n}\n\nexport class ClipPath extends WebShape {\n  render(): JSX.Element {\n    return createElement('clipPath', prepare(this));\n  }\n}\n\nexport class Defs extends WebShape {\n  render(): JSX.Element {\n    return createElement('defs', prepare(this));\n  }\n}\n\nexport class Ellipse extends WebShape {\n  render(): JSX.Element {\n    return createElement('ellipse', prepare(this));\n  }\n}\n\nexport class G extends WebShape<\n  BaseProps & {\n    x?: NumberProp;\n    y?: NumberProp;\n    translate?: string;\n  }\n> {\n  render(): JSX.Element {\n    const { x, y, ...rest } = this.props;\n\n    if ((x || y) && !rest.translate) {\n      rest.translate = `${x || 0}, ${y || 0}`;\n    }\n\n    return createElement('g', prepare(this, rest));\n  }\n}\n\nexport class Image extends WebShape {\n  render(): JSX.Element {\n    return createElement('image', prepare(this));\n  }\n}\n\nexport class Line extends WebShape {\n  render(): JSX.Element {\n    return createElement('line', prepare(this));\n  }\n}\n\nexport class LinearGradient extends WebShape {\n  render(): JSX.Element {\n    return createElement('linearGradient', prepare(this));\n  }\n}\n\nexport class Path extends WebShape {\n  render(): JSX.Element {\n    return createElement('path', prepare(this));\n  }\n}\n\nexport class Polygon extends WebShape {\n  render(): JSX.Element {\n    return createElement('polygon', prepare(this));\n  }\n}\n\nexport class Polyline extends WebShape {\n  render(): JSX.Element {\n    return createElement('polyline', prepare(this));\n  }\n}\n\nexport class RadialGradient extends WebShape {\n  render(): JSX.Element {\n    return createElement('radialGradient', prepare(this));\n  }\n}\n\nexport class Rect extends WebShape {\n  render(): JSX.Element {\n    return createElement('rect', prepare(this));\n  }\n}\n\nexport class Stop extends WebShape {\n  render(): JSX.Element {\n    return createElement('stop', prepare(this));\n  }\n}\n\nexport class Svg extends WebShape {\n  render(): JSX.Element {\n    return createElement('svg', prepare(this));\n  }\n}\n\nexport class Symbol extends WebShape {\n  render(): JSX.Element {\n    return createElement('symbol', prepare(this));\n  }\n}\n\nexport class Text extends WebShape {\n  render(): JSX.Element {\n    return createElement('text', prepare(this));\n  }\n}\n\nexport class TSpan extends WebShape {\n  render(): JSX.Element {\n    return createElement('tspan', prepare(this));\n  }\n}\n\nexport class TextPath extends WebShape {\n  render(): JSX.Element {\n    return createElement('textPath', prepare(this));\n  }\n}\n\nexport class Use extends WebShape {\n  render(): JSX.Element {\n    return createElement('use', prepare(this));\n  }\n}\n\nexport class Mask extends WebShape {\n  render(): JSX.Element {\n    return createElement('mask', prepare(this));\n  }\n}\n\nexport class ForeignObject extends WebShape {\n  render(): JSX.Element {\n    return createElement('foreignObject', prepare(this));\n  }\n}\n\nexport class Marker extends WebShape {\n  render(): JSX.Element {\n    return createElement('marker', prepare(this));\n  }\n}\n\nexport class Pattern extends WebShape {\n  render(): JSX.Element {\n    return createElement('pattern', prepare(this));\n  }\n}\n\nexport default Svg;\n","export * from './ReactNativeSVG';\n\nexport { default } from './ReactNativeSVG';\n","// @ts-ignore\nimport { Touchable, GestureResponderEvent } from 'react-native';\nconst PRESS_RETENTION_OFFSET = { top: 20, left: 20, right: 20, bottom: 30 };\n// @ts-ignore\nconst { Mixin } = Touchable;\nconst {\n  touchableHandleStartShouldSetResponder,\n  touchableHandleResponderTerminationRequest,\n  touchableHandleResponderGrant,\n  touchableHandleResponderMove,\n  touchableHandleResponderRelease,\n  touchableHandleResponderTerminate,\n  touchableGetInitialState,\n} = Mixin;\n\nconst SvgTouchableMixin = {\n  ...Mixin,\n\n  touchableHandleStartShouldSetResponder(e: GestureResponderEvent) {\n    const { onStartShouldSetResponder } = this.props;\n    if (onStartShouldSetResponder) {\n      return onStartShouldSetResponder(e);\n    } else {\n      return touchableHandleStartShouldSetResponder.call(this, e);\n    }\n  },\n\n  touchableHandleResponderTerminationRequest(e: GestureResponderEvent) {\n    const { onResponderTerminationRequest } = this.props;\n    if (onResponderTerminationRequest) {\n      return onResponderTerminationRequest(e);\n    } else {\n      return touchableHandleResponderTerminationRequest.call(this, e);\n    }\n  },\n\n  touchableHandleResponderGrant(e: GestureResponderEvent) {\n    const { onResponderGrant } = this.props;\n    if (onResponderGrant) {\n      return onResponderGrant(e);\n    } else {\n      return touchableHandleResponderGrant.call(this, e);\n    }\n  },\n\n  touchableHandleResponderMove(e: GestureResponderEvent) {\n    const { onResponderMove } = this.props;\n    if (onResponderMove) {\n      return onResponderMove(e);\n    } else {\n      return touchableHandleResponderMove.call(this, e);\n    }\n  },\n\n  touchableHandleResponderRelease(e: GestureResponderEvent) {\n    const { onResponderRelease } = this.props;\n    if (onResponderRelease) {\n      return onResponderRelease(e);\n    } else {\n      return touchableHandleResponderRelease.call(this, e);\n    }\n  },\n\n  touchableHandleResponderTerminate(e: GestureResponderEvent) {\n    const { onResponderTerminate } = this.props;\n    if (onResponderTerminate) {\n      return onResponderTerminate(e);\n    } else {\n      return touchableHandleResponderTerminate.call(this, e);\n    }\n  },\n\n  touchableHandlePress(e: GestureResponderEvent) {\n    const { onPress } = this.props;\n    onPress && onPress(e);\n  },\n\n  touchableHandleActivePressIn(e: GestureResponderEvent) {\n    const { onPressIn } = this.props;\n    onPressIn && onPressIn(e);\n  },\n\n  touchableHandleActivePressOut(e: GestureResponderEvent) {\n    const { onPressOut } = this.props;\n    onPressOut && onPressOut(e);\n  },\n\n  touchableHandleLongPress(e: GestureResponderEvent) {\n    const { onLongPress } = this.props;\n    onLongPress && onLongPress(e);\n  },\n\n  touchableGetPressRectOffset() {\n    const { pressRetentionOffset } = this.props;\n    return pressRetentionOffset || PRESS_RETENTION_OFFSET;\n  },\n\n  touchableGetHitSlop() {\n    const { hitSlop } = this.props;\n    return hitSlop;\n  },\n\n  touchableGetHighlightDelayMS() {\n    const { delayPressIn } = this.props;\n    return delayPressIn || 0;\n  },\n\n  touchableGetLongPressDelayMS() {\n    const { delayLongPress } = this.props;\n    return delayLongPress === 0 ? 0 : delayLongPress || 500;\n  },\n\n  touchableGetPressOutDelayMS() {\n    const { delayPressOut } = this.props;\n    return delayPressOut || 0;\n  },\n};\n\nconst touchKeys = Object.keys(SvgTouchableMixin);\nconst touchVals = touchKeys.map((key) => SvgTouchableMixin[key]);\nconst numTouchKeys = touchKeys.length;\n\nexport default (target: { [x: string]: unknown; state: unknown }) => {\n  for (let i = 0; i < numTouchKeys; i++) {\n    const key = touchKeys[i];\n    const val = touchVals[i];\n    if (typeof val === 'function') {\n      target[key] = val.bind(target);\n    } else {\n      target[key] = val;\n    }\n  }\n  target.state = touchableGetInitialState();\n};\n","import { StyleSheet } from 'react-native';\n\n// Kept in separate file, to avoid name collision with Symbol element\nexport function resolve<T>(styleProp: Iterable<T>, cleanedProps: T) {\n  if (styleProp) {\n    return StyleSheet\n      ? [styleProp, cleanedProps]\n      : // Compatibility for arrays of styles in plain react web\n      styleProp[Symbol.iterator]\n      ? Object.assign({}, ...styleProp, cleanedProps)\n      : Object.assign({}, styleProp, cleanedProps);\n  } else {\n    return cleanedProps;\n  }\n}\n","import React from 'react'\nimport type { ComponentProps, ComponentType } from 'react'\nimport { Platform } from 'react-native'\n\nimport { openURL } from './linking'\nimport { NextLink } from './next-link'\nimport { useLink } from './use-custom-link'\n\nexport type LinkCoreProps = {\n  children: React.ReactNode\n} & Omit<\n  ComponentProps<typeof NextLink>,\n  'passHref' | 'replace' | 'legacyBehavior'\n> &\n  (\n    | {\n        replace?: false\n        experimental?: undefined\n      }\n    | {\n        replace: true\n        experimental?: {\n          nativeBehavior: 'stack-replace'\n          isNestedNavigator: boolean\n        }\n      }\n  )\n\nfunction LinkCore({\n  children,\n  href,\n  as,\n  componentProps,\n  Component,\n  replace,\n  experimental,\n  ...props\n}: LinkCoreProps & {\n  Component: ComponentType<any>\n  componentProps?: any\n}) {\n  if (Platform.OS === 'web') {\n    return (\n      <NextLink\n        {...props}\n        replace={replace}\n        href={href}\n        as={as}\n        passHref\n        legacyBehavior\n      >\n        <Component {...componentProps}>{children}</Component>\n      </NextLink>\n    )\n  }\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const linkTo = useLink({\n    href,\n    as,\n    replace,\n    experimental,\n  })\n  return (\n    <Component\n      accessibilityRole=\"link\"\n      {...componentProps}\n      onPress={(e?: any) => {\n        componentProps?.onPress?.(e)\n        const link = as || href\n        // Handles external URLs\n        if (\n          !e?.defaultPrevented &&\n          typeof link === 'string' &&\n          isAbsoluteUrl(link)\n        ) {\n          openURL(link)\n        } else {\n          linkTo.onPress(e)\n        }\n      }}\n    >\n      {children}\n    </Component>\n  )\n}\n\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/\n// Source - https://github.com/vercel/next.js/blob/77b5f79a4dff453abb62346bf75b14d859539b81/packages/next/shared/lib/utils.ts#L313\nconst isAbsoluteUrl = (url: string) => ABSOLUTE_URL_REGEX.test(url)\n\nexport { LinkCore }\n","export * from './core'\nexport * from './text-link'\nexport * from './link'\nexport * from './use-custom-link'\n","'use client'\nimport { Platform, Pressable, ViewProps, View } from 'react-native'\n\nimport { LinkCore, LinkCoreProps } from './core'\n\ntype LinkProps = LinkCoreProps & { viewProps?: ViewProps }\n\nfunction Link({ viewProps, ...props }: LinkProps) {\n  return (\n    <LinkCore\n      {...props}\n      Component={Platform.select({\n        web: View,\n        default: Pressable as any,\n      })}\n      componentProps={viewProps}\n    />\n  )\n}\n\nexport { Link }\nexport type { LinkProps }\n","// noop, not supported on web\nexport const openURL = (url: string) => {}\n","export { default as NextLink } from 'next/link'\n","'use client'\nimport { TextProps, Text } from 'react-native'\n\nimport { LinkCore, LinkCoreProps } from './core'\n\ntype TextLinkProps = LinkCoreProps & { textProps?: TextProps }\n\nfunction TextLink({ textProps, ...props }: TextLinkProps) {\n  return (\n    <LinkCore\n      {...props}\n      Component={Text}\n      componentProps={{ selectable: false, ...textProps }}\n    />\n  )\n}\n\nexport { TextLink }\nexport type { TextLinkProps }\n","import { GestureResponderEvent, Platform } from 'react-native'\n\nimport { useRouter } from '../router'\nimport { LinkCoreProps } from './core'\n\nexport type UseLinkProps = Pick<\n  LinkCoreProps,\n  'as' | 'shallow' | 'href' | 'scroll' | 'replace' | 'experimental'\n>\n\nexport function useLink({\n  href,\n  as,\n  shallow,\n  scroll,\n  replace,\n  experimental,\n}: UseLinkProps) {\n  const router = useRouter()\n\n  // https://github.com/react-navigation/react-navigation/blob/main/packages/native/src/useLinkProps.tsx#L64\n  const onPress = (\n    e?: React.MouseEvent<HTMLAnchorElement, MouseEvent> | GestureResponderEvent\n  ) => {\n    let shouldHandle = false\n\n    if (Platform.OS !== 'web' || !e) {\n      shouldHandle = e ? !e.defaultPrevented : true\n    } else if (\n      !e.defaultPrevented && // onPress prevented default\n      // @ts-expect-error: these properties exist on web, but not in React Native\n      !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && // ignore clicks with modifier keys\n      // @ts-expect-error: these properties exist on web, but not in React Native\n      (e.button == null || e.button === 0) && // ignore everything but left clicks\n      // @ts-expect-error: these properties exist on web, but not in React Native\n      [undefined, null, '', 'self'].includes(e.currentTarget?.target) // let browser handle \"target=_blank\" etc.\n    ) {\n      e.preventDefault()\n      shouldHandle = true\n    }\n\n    if (shouldHandle) {\n      if (href === '#') {\n        // this is a way on web to stay on the same page\n        // useful for conditional hrefs\n        return\n      }\n      if (replace) {\n        router.replace(href, as, { shallow, scroll, experimental })\n      } else {\n        router.push(href, as, {\n          shallow,\n          scroll,\n        })\n      }\n    }\n  }\n\n  return {\n    accessibilityRole: 'link' as const,\n    onPress,\n    href: router.parseNextPath(as || href),\n  }\n}\n","export * from './parse-next-path'\nexport * from './use-router'\n","import type { NextRouter } from 'next/router'\n\nconst parseNextPath = (from: Parameters<NextRouter['push']>[0]) => {\n  let path = (typeof from == 'string' ? from : from.pathname) || ''\n\n  // replace each instance of [key] with the corresponding value from query[key]\n  // this ensures we're navigating to the correct URL\n  // it currently ignores [[...param]]\n  // but I can't see why you would use this with RN + Next.js\n  if (typeof from == 'object' && from.query && typeof from.query == 'object') {\n    const query = { ...from.query }\n    for (const key in query) {\n      if (path.includes(`[${key}]`)) {\n        path = path.replace(`[${key}]`, `${query[key] ?? ''}`)\n        delete query[key]\n      } else if (path.includes(`[...${key}]`)) {\n        const values = query[key]\n        if (Array.isArray(values)) {\n          path = path.replace(`[...${key}]`, values.join('/'))\n          delete query[key]\n        }\n      }\n    }\n    if (Object.keys(query).length) {\n      path += '?'\n      for (const key in query) {\n        if (query[key] != null) {\n          path += `${key}=${query[key]}&`\n        }\n      }\n      if (path.endsWith('&') || path.endsWith('?')) {\n        path = path.slice(0, -1)\n      }\n    }\n  }\n\n  return path\n}\n\nexport { parseNextPath }\n","import { createContext } from 'react'\n\nconst LinkingContext = createContext({\n  options: undefined,\n})\n\nlet StackActions, getStateFromPath, getActionFromState\n\nexport { LinkingContext, StackActions, getStateFromPath, getActionFromState }\n","const noOp = () => {\n  throw new Error(\n    '[use-link-to] is not supported on the web. Something went wrong if you called this.'\n  )\n}\n\n/**\n * @deprecated imported from the wrong file. Use `use-link-to` instead.\n */\nexport const useLinkTo = () => noOp\n","export const useNavigation = () => undefined\n","export { useRouter as useNextRouter } from 'next/router'\n","import type { NextRouter as NextRouterType } from 'next/router'\nimport { useContext, useMemo } from 'react'\nimport { Platform } from 'react-native'\n\nimport { parseNextPath } from './parse-next-path'\nimport {\n  getActionFromState,\n  getStateFromPath,\n  LinkingContext,\n  StackActions,\n} from './replace-helpers'\nimport { useLinkTo } from './use-link-to'\nimport { useNavigation } from './use-navigation'\nimport { useNextRouter } from './use-next-router'\n\n// copied from next/router to appease typescript error\n// if we don't manually write this here, then we get some ReturnType error on build\n// 🤷‍♂️\ninterface TransitionOptions {\n  shallow?: boolean\n  locale?: string | false\n  scroll?: boolean\n}\n\nexport function useRouter() {\n  const linkTo = useLinkTo()\n  const navigation = useNavigation()\n\n  const nextRouter = useNextRouter()\n\n  const linking = useContext(LinkingContext)\n\n  return useMemo(\n    () => ({\n      push: (\n        url: Parameters<NextRouterType['push']>[0],\n        as?: Parameters<NextRouterType['push']>[1],\n        transitionOptions?: TransitionOptions\n      ) => {\n        if (Platform.OS === 'web') {\n          nextRouter?.push(url, as, transitionOptions)\n        } else {\n          const to = parseNextPath(as || url)\n\n          if (to) {\n            linkTo(to)\n          }\n        }\n      },\n      replace: (\n        url: Parameters<NextRouterType['replace']>[0],\n        as?: Parameters<NextRouterType['replace']>[1],\n        transitionOptions?: TransitionOptions & {\n          experimental?:\n            | {\n                nativeBehavior?: undefined\n              }\n            | {\n                nativeBehavior: 'stack-replace'\n                isNestedNavigator: boolean\n              }\n        }\n      ) => {\n        if (Platform.OS === 'web') {\n          nextRouter?.replace(url, as, transitionOptions)\n        } else {\n          const to = parseNextPath(as || url)\n\n          if (to) {\n            if (\n              transitionOptions?.experimental?.nativeBehavior ===\n              'stack-replace'\n            ) {\n              if (linking?.options) {\n                // custom logic to create a replace() from a URL on native\n                // https://github.com/react-navigation/react-navigation/discussions/10517\n                const { options } = linking\n\n                const state = options?.getStateFromPath\n                  ? options.getStateFromPath(to, options.config)\n                  : getStateFromPath(to, options?.config)\n\n                if (state) {\n                  const action = getActionFromState(state, options?.config)\n\n                  if (action !== undefined) {\n                    if (\n                      'payload' in action &&\n                      action.payload &&\n                      'name' in action.payload &&\n                      action.payload.name\n                    ) {\n                      const { name, params } = action.payload\n                      if (\n                        transitionOptions?.experimental?.isNestedNavigator &&\n                        params &&\n                        'screen' in params &&\n                        params.screen\n                      ) {\n                        navigation?.dispatch(\n                          StackActions.replace(\n                            params.screen,\n                            params.params as object | undefined\n                          )\n                        )\n                      } else {\n                        navigation?.dispatch(StackActions.replace(name, params))\n                      }\n                    } else {\n                      navigation?.dispatch(action)\n                    }\n                  } else {\n                    navigation?.reset(state)\n                  }\n                }\n              } else {\n                // fallback in case the linking context didn't work\n                console.warn(`[solito] replace(\"${to}\") faced an issue. You should still see your new screen, but it probably didn't replace the previous one. This may be due to a breaking change in React Navigation. \n  Please open an issue at https://github.com/nandorojo/solito and report how this happened. Thanks!`)\n                linkTo(to)\n              }\n            } else {\n              linkTo(to)\n            }\n          }\n        }\n      },\n      back: () => {\n        if (Platform.OS === 'web') {\n          nextRouter?.back()\n        } else {\n          navigation?.goBack()\n        }\n      },\n      parseNextPath,\n    }),\n    [\n      linkTo,\n      navigation,\n      nextRouter?.push,\n      nextRouter?.back,\n      nextRouter?.replace,\n    ]\n  )\n}\n","export * from '../build/link'\n","var currentNonce;\nexport var setNonce = function (nonce) {\n    currentNonce = nonce;\n};\nexport var getNonce = function () {\n    if (currentNonce) {\n        return currentNonce;\n    }\n    if (typeof __webpack_nonce__ !== 'undefined') {\n        return __webpack_nonce__;\n    }\n    return undefined;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.addBasePath = addBasePath;\nvar _addPathPrefix = require(\"../shared/lib/router/utils/add-path-prefix\");\nvar _normalizeTrailingSlash = require(\"./normalize-trailing-slash\");\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction addBasePath(path, required) {\n    if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {\n        if (!required) {\n            return path;\n        }\n    }\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash((0, _addPathPrefix).addPathPrefix(path, basePath));\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=add-base-path.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.addLocale = void 0;\nvar _normalizeTrailingSlash = require(\"./normalize-trailing-slash\");\nconst addLocale = (path, ...args)=>{\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(require('../shared/lib/router/utils/add-locale').addLocale(path, ...args));\n    }\n    return path;\n};\nexports.addLocale = addLocale;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=add-locale.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.detectDomainLocale = void 0;\nconst detectDomainLocale = (...args)=>{\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        return require('../shared/lib/i18n/detect-domain-locale').detectDomainLocale(...args);\n    }\n};\nexports.detectDomainLocale = detectDomainLocale;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=detect-domain-locale.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getDomainLocale = getDomainLocale;\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        const normalizeLocalePath = require('./normalize-locale-path').normalizeLocalePath;\n        const detectDomainLocale = require('./detect-domain-locale').detectDomainLocale;\n        const target = locale || normalizeLocalePath(path, locales).detectedLocale;\n        const domain = detectDomainLocale(domainLocales, undefined, target);\n        if (domain) {\n            const proto = `http${domain.http ? '' : 's'}://`;\n            const finalLocale = target === domain.defaultLocale ? '' : `/${target}`;\n            return `${proto}${domain.domain}${basePath}${finalLocale}${path}`;\n        }\n        return false;\n    } else {\n        return false;\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=get-domain-locale.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.hasBasePath = hasBasePath;\nvar _pathHasPrefix = require(\"../shared/lib/router/utils/path-has-prefix\");\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction hasBasePath(path) {\n    return (0, _pathHasPrefix).pathHasPrefix(path, basePath);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=has-base-path.js.map","\"use client\";\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = void 0;\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\nvar _object_without_properties_loose = require(\"@swc/helpers/lib/_object_without_properties_loose.js\").default;\nvar _react = _interop_require_default(require(\"react\"));\nvar _resolveHref = require(\"../shared/lib/router/utils/resolve-href\");\nvar _isLocalUrl = require(\"../shared/lib/router/utils/is-local-url\");\nvar _formatUrl = require(\"../shared/lib/router/utils/format-url\");\nvar _utils = require(\"../shared/lib/utils\");\nvar _addLocale = require(\"./add-locale\");\nvar _routerContext = require(\"../shared/lib/router-context\");\nvar _appRouterContext = require(\"../shared/lib/app-router-context\");\nvar _useIntersection = require(\"./use-intersection\");\nvar _getDomainLocale = require(\"./get-domain-locale\");\nvar _addBasePath = require(\"./add-base-path\");\n\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, isAppRouter) {\n    if (typeof window === 'undefined') {\n        return;\n    }\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _isLocalUrl).isLocalURL(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = // Let the link's locale prop override the default router locale.\n        typeof options.locale !== 'undefined' ? options.locale : 'locale' in router ? router.locale : undefined;\n        const prefetchedKey = href + '%' + as + '%' + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(router.prefetch(href, as, options)).catch((err)=>{\n        if (process.env.NODE_ENV !== 'production') {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute('target');\n    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled) {\n    const { nodeName  } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === 'A';\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    (!isAppRouter && !(0, _isLocalUrl).isLocalURL(href)))) {\n        // ignore click for browser’s default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        if ('beforePopState' in router) {\n            router[replace ? 'replace' : 'push'](href, as, {\n                shallow,\n                locale,\n                scroll\n            });\n        } else {\n            router[replace ? 'replace' : 'push'](as || href, {\n                forceOptimisticNavigation: !prefetchEnabled\n            });\n        }\n    };\n    if (isAppRouter) {\n        // @ts-expect-error startTransition exists.\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === 'string') {\n        return urlObjOrString;\n    }\n    return (0, _formatUrl).formatUrl(urlObjOrString);\n}\n/**\n * React Component that enables client-side transitions between routes.\n */ const Link = /*#__PURE__*/ _react.default.forwardRef(function LinkComponent(props, forwardedRef) {\n    if (process.env.NODE_ENV !== 'production') {\n        function createPropError(args) {\n            return new Error(`Failed prop type: The prop \\`${args.key}\\` expects a ${args.expected} in \\`<Link>\\`, but got \\`${args.actual}\\` instead.` + (typeof window !== 'undefined' ? \"\\nOpen your browser's console to view the Component stack trace.\" : ''));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === 'href') {\n                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: props[key] === null ? 'null' : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === 'as') {\n                if (props[key] && valType !== 'string' && valType !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'locale') {\n                if (props[key] && valType !== 'string') {\n                    throw createPropError({\n                        key,\n                        expected: '`string`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart') {\n                if (props[key] && valType !== 'function') {\n                    throw createPropError({\n                        key,\n                        expected: '`function`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch' || key === 'legacyBehavior') {\n                if (props[key] != null && valType !== 'boolean') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean`',\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current) {\n            hasWarned.current = true;\n            console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated');\n        }\n    }\n    let children;\n    const { href: hrefProp , as: asProp , children: childrenProp , prefetch: prefetchProp , passHref , replace , shallow , scroll , locale , onClick , onMouseEnter: onMouseEnterProp , onTouchStart: onTouchStartProp , // @ts-expect-error this is inlined as a literal boolean not a string\n    legacyBehavior =process.env.__NEXT_NEW_LINK_BEHAVIOR === false  } = props, restProps = _object_without_properties_loose(props, [\n        \"href\",\n        \"as\",\n        \"children\",\n        \"prefetch\",\n        \"passHref\",\n        \"replace\",\n        \"shallow\",\n        \"scroll\",\n        \"locale\",\n        \"onClick\",\n        \"onMouseEnter\",\n        \"onTouchStart\",\n        \"legacyBehavior\"\n    ]);\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {\n        children = /*#__PURE__*/ _react.default.createElement(\"a\", null, children);\n    }\n    const prefetchEnabled = prefetchProp !== false;\n    const pagesRouter = _react.default.useContext(_routerContext.RouterContext);\n    const appRouter = _react.default.useContext(_appRouterContext.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    if (process.env.NODE_ENV !== 'production') {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === 'string') {\n                href = hrefProp;\n            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));\n                if (hasDynamicSegment) {\n                    throw new Error(`Dynamic href \\`${href}\\` found in <Link> while using the \\`/app\\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`);\n                }\n            }\n        }\n    }\n    const { href , as  } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolveHref).resolveHref(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolveHref).resolveHref(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (process.env.NODE_ENV === 'development') {\n            if (onClick) {\n                console.warn(`\"onClick\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link`);\n            }\n            if (onMouseEnterProp) {\n                console.warn(`\"onMouseEnter\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`);\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(`No children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but one child is required https://nextjs.org/docs/messages/link-no-children`);\n                }\n                throw new Error(`Multiple children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` + (typeof window !== 'undefined' ? \" \\nOpen your browser's console to view the Component stack trace.\" : ''));\n            }\n        } else {\n            child = _react.default.Children.only(children);\n        }\n    } else {\n        if (process.env.NODE_ENV === 'development') {\n            var ref;\n            if (((ref = children) == null ? void 0 : ref.type) === 'a') {\n                throw new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor');\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useIntersection).useIntersection({\n        rootMargin: '200px'\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === 'function') childRef(el);\n            else if (typeof childRef === 'object') {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (process.env.NODE_ENV !== 'production') {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter, \n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (!e) {\n                    throw new Error(`Component rendered inside next/link has to pass click event to \"onClick\" prop.`);\n                }\n            }\n            if (!legacyBehavior && typeof onClick === 'function') {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, isAppRouter);\n        },\n        onTouchStart (e) {\n            if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils).isAbsoluteUrl(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {\n        const curLocale = typeof locale !== 'undefined' ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getDomainLocale).getDomainLocale(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ _react.default.createElement(\"a\", Object.assign({}, restProps, childProps), children);\n});\nvar _default = Link;\nexports.default = _default;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=link.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.normalizeLocalePath = void 0;\nconst normalizeLocalePath = (pathname, locales)=>{\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        return require('../shared/lib/i18n/normalize-locale-path').normalizeLocalePath(pathname, locales);\n    }\n    return {\n        pathname,\n        detectedLocale: undefined\n    };\n};\nexports.normalizeLocalePath = normalizeLocalePath;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=normalize-locale-path.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.removeBasePath = removeBasePath;\nvar _hasBasePath = require(\"./has-base-path\");\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction removeBasePath(path) {\n    if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {\n        if (!(0, _hasBasePath).hasBasePath(path)) {\n            return path;\n        }\n    }\n    path = path.slice(basePath.length);\n    if (!path.startsWith('/')) path = `/${path}`;\n    return path;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=remove-base-path.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.removeLocale = removeLocale;\nvar _parsePath = require(\"../shared/lib/router/utils/parse-path\");\nfunction removeLocale(path, locale) {\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        const { pathname  } = (0, _parsePath).parsePath(path);\n        const pathLower = pathname.toLowerCase();\n        const localeLower = locale == null ? void 0 : locale.toLowerCase();\n        return locale && (pathLower.startsWith(`/${localeLower}/`) || pathLower === `/${localeLower}`) ? `${pathname.length === locale.length + 1 ? `/` : ``}${path.slice(locale.length + 1)}` : path;\n    }\n    return path;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=remove-locale.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.createRouteLoader = createRouteLoader;\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\nvar _getAssetPathFromRoute = _interop_require_default(require(\"../shared/lib/router/utils/get-asset-path-from-route\"));\nvar _trustedTypes = require(\"./trusted-types\");\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nconst MS_MAX_IDLE_DELAY = 3800;\nfunction withFuture(key, map, generator) {\n    let entry = map.get(key);\n    if (entry) {\n        if ('future' in entry) {\n            return entry.future;\n        }\n        return Promise.resolve(entry);\n    }\n    let resolver;\n    const prom = new Promise((resolve)=>{\n        resolver = resolve;\n    });\n    map.set(key, entry = {\n        resolve: resolver,\n        future: prom\n    });\n    return generator ? generator()// eslint-disable-next-line no-sequences\n    .then((value)=>(resolver(value), value)).catch((err)=>{\n        map.delete(key);\n        throw err;\n    }) : prom;\n}\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\nfunction markAssetError(err) {\n    return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\nfunction isAssetError(err) {\n    return err && ASSET_LOAD_ERROR in err;\n}\nfunction hasPrefetch(link) {\n    try {\n        link = document.createElement('link');\n        return(// detect IE11 since it supports prefetch but isn't detected\n        // with relList.support\n        (!!window.MSInputMethodContext && !!document.documentMode) || link.relList.supports('prefetch'));\n    } catch (e) {\n        return false;\n    }\n}\nconst canPrefetch = hasPrefetch();\nfunction prefetchViaDom(href, as, link) {\n    return new Promise((resolve, reject)=>{\n        const selector = `\n      link[rel=\"prefetch\"][href^=\"${href}\"],\n      link[rel=\"preload\"][href^=\"${href}\"],\n      script[src^=\"${href}\"]`;\n        if (document.querySelector(selector)) {\n            return resolve();\n        }\n        link = document.createElement('link');\n        // The order of property assignment here is intentional:\n        if (as) link.as = as;\n        link.rel = `prefetch`;\n        link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n        link.onload = resolve;\n        link.onerror = ()=>reject(markAssetError(new Error(`Failed to prefetch: ${href}`)));\n        // `href` should always be last:\n        link.href = href;\n        document.head.appendChild(link);\n    });\n}\nfunction appendScript(src, script) {\n    return new Promise((resolve, reject)=>{\n        script = document.createElement('script');\n        // The order of property assignment here is intentional.\n        // 1. Setup success/failure hooks in case the browser synchronously\n        //    executes when `src` is set.\n        script.onload = resolve;\n        script.onerror = ()=>reject(markAssetError(new Error(`Failed to load script: ${src}`)));\n        // 2. Configure the cross-origin attribute before setting `src` in case the\n        //    browser begins to fetch.\n        script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n        // 3. Finally, set the source and inject into the DOM in case the child\n        //    must be appended for fetching to start.\n        script.src = src;\n        document.body.appendChild(script);\n    });\n}\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nlet devBuildPromise;\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout(p, ms, err) {\n    return new Promise((resolve, reject)=>{\n        let cancelled = false;\n        p.then((r)=>{\n            // Resolved, cancel the timeout\n            cancelled = true;\n            resolve(r);\n        }).catch(reject);\n        // We wrap these checks separately for better dead-code elimination in\n        // production bundles.\n        if (process.env.NODE_ENV === 'development') {\n            (devBuildPromise || Promise.resolve()).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>setTimeout(()=>{\n                        if (!cancelled) {\n                            reject(err);\n                        }\n                    }, ms));\n            });\n        }\n        if (process.env.NODE_ENV !== 'development') {\n            (0, _requestIdleCallback).requestIdleCallback(()=>setTimeout(()=>{\n                    if (!cancelled) {\n                        reject(err);\n                    }\n                }, ms));\n        }\n    });\n}\nfunction getClientBuildManifest() {\n    if (self.__BUILD_MANIFEST) {\n        return Promise.resolve(self.__BUILD_MANIFEST);\n    }\n    const onBuildManifest = new Promise((resolve)=>{\n        // Mandatory because this is not concurrent safe:\n        const cb = self.__BUILD_MANIFEST_CB;\n        self.__BUILD_MANIFEST_CB = ()=>{\n            resolve(self.__BUILD_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\nfunction getFilesForRoute(assetPrefix, route) {\n    if (process.env.NODE_ENV === 'development') {\n        const scriptUrl = assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute).default(route, '.js'));\n        return Promise.resolve({\n            scripts: [\n                (0, _trustedTypes).__unsafeCreateTrustedScriptURL(scriptUrl)\n            ],\n            // Styles are handled by `style-loader` in development:\n            css: []\n        });\n    }\n    return getClientBuildManifest().then((manifest)=>{\n        if (!(route in manifest)) {\n            throw markAssetError(new Error(`Failed to lookup route: ${route}`));\n        }\n        const allFiles = manifest[route].map((entry)=>assetPrefix + '/_next/' + encodeURI(entry));\n        return {\n            scripts: allFiles.filter((v)=>v.endsWith('.js')).map((v)=>(0, _trustedTypes).__unsafeCreateTrustedScriptURL(v)),\n            css: allFiles.filter((v)=>v.endsWith('.css'))\n        };\n    });\n}\nfunction createRouteLoader(assetPrefix) {\n    const entrypoints = new Map();\n    const loadedScripts = new Map();\n    const styleSheets = new Map();\n    const routes = new Map();\n    function maybeExecuteScript(src) {\n        // With HMR we might need to \"reload\" scripts when they are\n        // disposed and readded. Executing scripts twice has no functional\n        // differences\n        if (process.env.NODE_ENV !== 'development') {\n            let prom = loadedScripts.get(src.toString());\n            if (prom) {\n                return prom;\n            }\n            // Skip executing script if it's already in the DOM:\n            if (document.querySelector(`script[src^=\"${src}\"]`)) {\n                return Promise.resolve();\n            }\n            loadedScripts.set(src.toString(), prom = appendScript(src));\n            return prom;\n        } else {\n            return appendScript(src);\n        }\n    }\n    function fetchStyleSheet(href) {\n        let prom = styleSheets.get(href);\n        if (prom) {\n            return prom;\n        }\n        styleSheets.set(href, prom = fetch(href).then((res)=>{\n            if (!res.ok) {\n                throw new Error(`Failed to load stylesheet: ${href}`);\n            }\n            return res.text().then((text)=>({\n                    href: href,\n                    content: text\n                }));\n        }).catch((err)=>{\n            throw markAssetError(err);\n        }));\n        return prom;\n    }\n    return {\n        whenEntrypoint (route) {\n            return withFuture(route, entrypoints);\n        },\n        onEntrypoint (route, execute) {\n            (execute ? Promise.resolve().then(()=>execute()).then((exports)=>({\n                    component: exports && exports.default || exports,\n                    exports: exports\n                }), (err)=>({\n                    error: err\n                })) : Promise.resolve(undefined)).then((input)=>{\n                const old = entrypoints.get(route);\n                if (old && 'resolve' in old) {\n                    if (input) {\n                        entrypoints.set(route, input);\n                        old.resolve(input);\n                    }\n                } else {\n                    if (input) {\n                        entrypoints.set(route, input);\n                    } else {\n                        entrypoints.delete(route);\n                    }\n                    // when this entrypoint has been resolved before\n                    // the route is outdated and we want to invalidate\n                    // this cache entry\n                    routes.delete(route);\n                }\n            });\n        },\n        loadRoute (route, prefetch) {\n            return withFuture(route, routes, ()=>{\n                let devBuildPromiseResolve;\n                if (process.env.NODE_ENV === 'development') {\n                    devBuildPromise = new Promise((resolve)=>{\n                        devBuildPromiseResolve = resolve;\n                    });\n                }\n                return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(({ scripts , css  })=>{\n                    return Promise.all([\n                        entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),\n                        Promise.all(css.map(fetchStyleSheet)), \n                    ]);\n                }).then((res)=>{\n                    return this.whenEntrypoint(route).then((entrypoint)=>({\n                            entrypoint,\n                            styles: res[1]\n                        }));\n                }), MS_MAX_IDLE_DELAY, markAssetError(new Error(`Route did not complete loading: ${route}`))).then(({ entrypoint , styles  })=>{\n                    const res = Object.assign({\n                        styles: styles\n                    }, entrypoint);\n                    return 'error' in entrypoint ? entrypoint : res;\n                }).catch((err)=>{\n                    if (prefetch) {\n                        // we don't want to cache errors during prefetch\n                        throw err;\n                    }\n                    return {\n                        error: err\n                    };\n                }).finally(()=>{\n                    return devBuildPromiseResolve == null ? void 0 : devBuildPromiseResolve();\n                });\n            });\n        },\n        prefetch (route) {\n            // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n            // License: Apache 2.0\n            let cn;\n            if (cn = navigator.connection) {\n                // Don't prefetch if using 2G or if Save-Data is enabled.\n                if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n            }\n            return getFilesForRoute(assetPrefix, route).then((output)=>Promise.all(canPrefetch ? output.scripts.map((script)=>prefetchViaDom(script.toString(), 'script')) : [])).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>this.loadRoute(route, true).catch(()=>{}));\n            }).catch(// swallow prefetch errors\n            ()=>{});\n        }\n    };\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=route-loader.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"Router\", {\n    enumerable: true,\n    get: function() {\n        return _router.default;\n    }\n});\nObject.defineProperty(exports, \"withRouter\", {\n    enumerable: true,\n    get: function() {\n        return _withRouter.default;\n    }\n});\nexports.useRouter = useRouter;\nexports.createRouter = createRouter;\nexports.makePublicRouterInstance = makePublicRouterInstance;\nexports.default = void 0;\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\nvar _react = _interop_require_default(require(\"react\"));\nvar _router = _interop_require_default(require(\"../shared/lib/router/router\"));\nvar _routerContext = require(\"../shared/lib/router-context\");\nvar _isError = _interop_require_default(require(\"../lib/is-error\"));\nvar _withRouter = _interop_require_default(require(\"./with-router\"));\nconst singletonRouter = {\n    router: null,\n    readyCallbacks: [],\n    ready (cb) {\n        if (this.router) return cb();\n        if (typeof window !== 'undefined') {\n            this.readyCallbacks.push(cb);\n        }\n    }\n};\n// Create public properties and methods of the router in the singletonRouter\nconst urlPropertyFields = [\n    'pathname',\n    'route',\n    'query',\n    'asPath',\n    'components',\n    'isFallback',\n    'basePath',\n    'locale',\n    'locales',\n    'defaultLocale',\n    'isReady',\n    'isPreview',\n    'isLocaleDomain',\n    'domainLocales', \n];\nconst routerEvents = [\n    'routeChangeStart',\n    'beforeHistoryChange',\n    'routeChangeComplete',\n    'routeChangeError',\n    'hashChangeStart',\n    'hashChangeComplete', \n];\nconst coreMethodFields = [\n    'push',\n    'replace',\n    'reload',\n    'back',\n    'prefetch',\n    'beforePopState', \n];\n// Events is a static property on the router, the router doesn't have to be initialized to use it\nObject.defineProperty(singletonRouter, 'events', {\n    get () {\n        return _router.default.events;\n    }\n});\nfunction getRouter() {\n    if (!singletonRouter.router) {\n        const message = 'No router instance found.\\n' + 'You should only use \"next/router\" on the client side of your app.\\n';\n        throw new Error(message);\n    }\n    return singletonRouter.router;\n}\nurlPropertyFields.forEach((field)=>{\n    // Here we need to use Object.defineProperty because we need to return\n    // the property assigned to the actual router\n    // The value might get changed as we change routes and this is the\n    // proper way to access it\n    Object.defineProperty(singletonRouter, field, {\n        get () {\n            const router = getRouter();\n            return router[field];\n        }\n    });\n});\ncoreMethodFields.forEach((field)=>{\n    singletonRouter[field] = (...args)=>{\n        const router = getRouter();\n        return router[field](...args);\n    };\n});\nrouterEvents.forEach((event)=>{\n    singletonRouter.ready(()=>{\n        _router.default.events.on(event, (...args)=>{\n            const eventField = `on${event.charAt(0).toUpperCase()}${event.substring(1)}`;\n            const _singletonRouter = singletonRouter;\n            if (_singletonRouter[eventField]) {\n                try {\n                    _singletonRouter[eventField](...args);\n                } catch (err) {\n                    console.error(`Error when running the Router event: ${eventField}`);\n                    console.error((0, _isError).default(err) ? `${err.message}\\n${err.stack}` : err + '');\n                }\n            }\n        });\n    });\n});\nvar _default = singletonRouter;\nexports.default = _default;\nfunction useRouter() {\n    const router = _react.default.useContext(_routerContext.RouterContext);\n    if (!router) {\n        throw new Error('NextRouter was not mounted. https://nextjs.org/docs/messages/next-router-not-mounted');\n    }\n    return router;\n}\nfunction createRouter(...args) {\n    singletonRouter.router = new _router.default(...args);\n    singletonRouter.readyCallbacks.forEach((cb)=>cb());\n    singletonRouter.readyCallbacks = [];\n    return singletonRouter.router;\n}\nfunction makePublicRouterInstance(router) {\n    const scopedRouter = router;\n    const instance = {};\n    for (const property of urlPropertyFields){\n        if (typeof scopedRouter[property] === 'object') {\n            instance[property] = Object.assign(Array.isArray(scopedRouter[property]) ? [] : {}, scopedRouter[property]) // makes sure query is not stateful\n            ;\n            continue;\n        }\n        instance[property] = scopedRouter[property];\n    }\n    // Events is a static property on the router, the router doesn't have to be initialized to use it\n    instance.events = _router.default.events;\n    coreMethodFields.forEach((field)=>{\n        instance[field] = (...args)=>{\n            return scopedRouter[field](...args);\n        };\n    });\n    return instance;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=router.js.map","\"use client\";\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.handleClientScriptLoad = handleClientScriptLoad;\nexports.initScriptLoader = initScriptLoader;\nexports.default = void 0;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\nvar _interop_require_wildcard = require(\"@swc/helpers/lib/_interop_require_wildcard.js\").default;\nvar _object_without_properties_loose = require(\"@swc/helpers/lib/_object_without_properties_loose.js\").default;\nvar _reactDom = _interop_require_default(require(\"react-dom\"));\nvar _react = _interop_require_wildcard(require(\"react\"));\nvar _headManagerContext = require(\"../shared/lib/head-manager-context\");\nvar _headManager = require(\"./head-manager\");\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n\nconst ScriptCache = new Map();\nconst LoadCache = new Set();\nconst ignoreProps = [\n    'onLoad',\n    'onReady',\n    'dangerouslySetInnerHTML',\n    'children',\n    'onError',\n    'strategy', \n];\nconst loadScript = (props)=>{\n    const { src , id , onLoad =()=>{} , onReady =null , dangerouslySetInnerHTML , children ='' , strategy ='afterInteractive' , onError ,  } = props;\n    const cacheKey = id || src;\n    // Script has already loaded\n    if (cacheKey && LoadCache.has(cacheKey)) {\n        return;\n    }\n    // Contents of this script are already loading/loaded\n    if (ScriptCache.has(src)) {\n        LoadCache.add(cacheKey);\n        // It is possible that multiple `next/script` components all have same \"src\", but has different \"onLoad\"\n        // This is to make sure the same remote script will only load once, but \"onLoad\" are executed in order\n        ScriptCache.get(src).then(onLoad, onError);\n        return;\n    }\n    /** Execute after the script first loaded */ const afterLoad = ()=>{\n        // Run onReady for the first time after load event\n        if (onReady) {\n            onReady();\n        }\n        // add cacheKey to LoadCache when load successfully\n        LoadCache.add(cacheKey);\n    };\n    const el = document.createElement('script');\n    const loadPromise = new Promise((resolve, reject)=>{\n        el.addEventListener('load', function(e) {\n            resolve();\n            if (onLoad) {\n                onLoad.call(this, e);\n            }\n            afterLoad();\n        });\n        el.addEventListener('error', function(e) {\n            reject(e);\n        });\n    }).catch(function(e) {\n        if (onError) {\n            onError(e);\n        }\n    });\n    if (dangerouslySetInnerHTML) {\n        el.innerHTML = dangerouslySetInnerHTML.__html || '';\n        afterLoad();\n    } else if (children) {\n        el.textContent = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';\n        afterLoad();\n    } else if (src) {\n        el.src = src;\n        // do not add cacheKey into LoadCache for remote script here\n        // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)\n        ScriptCache.set(src, loadPromise);\n    }\n    for (const [k, value] of Object.entries(props)){\n        if (value === undefined || ignoreProps.includes(k)) {\n            continue;\n        }\n        const attr = _headManager.DOMAttributeNames[k] || k.toLowerCase();\n        el.setAttribute(attr, value);\n    }\n    if (strategy === 'worker') {\n        el.setAttribute('type', 'text/partytown');\n    }\n    el.setAttribute('data-nscript', strategy);\n    document.body.appendChild(el);\n};\nfunction handleClientScriptLoad(props) {\n    const { strategy ='afterInteractive'  } = props;\n    if (strategy === 'lazyOnload') {\n        window.addEventListener('load', ()=>{\n            (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));\n        });\n    } else {\n        loadScript(props);\n    }\n}\nfunction loadLazyScript(props) {\n    if (document.readyState === 'complete') {\n        (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));\n    } else {\n        window.addEventListener('load', ()=>{\n            (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));\n        });\n    }\n}\nfunction addBeforeInteractiveToCache() {\n    const scripts = [\n        ...document.querySelectorAll('[data-nscript=\"beforeInteractive\"]'),\n        ...document.querySelectorAll('[data-nscript=\"beforePageRender\"]'), \n    ];\n    scripts.forEach((script)=>{\n        const cacheKey = script.id || script.getAttribute('src');\n        LoadCache.add(cacheKey);\n    });\n}\nfunction initScriptLoader(scriptLoaderItems) {\n    scriptLoaderItems.forEach(handleClientScriptLoad);\n    addBeforeInteractiveToCache();\n}\nfunction Script(props) {\n    const { id , src ='' , onLoad =()=>{} , onReady =null , strategy ='afterInteractive' , onError  } = props, restProps = _object_without_properties_loose(props, [\n        \"id\",\n        \"src\",\n        \"onLoad\",\n        \"onReady\",\n        \"strategy\",\n        \"onError\"\n    ]);\n    // Context is available only during SSR\n    const { updateScripts , scripts , getIsSsr , appDir , nonce  } = (0, _react).useContext(_headManagerContext.HeadManagerContext);\n    /**\n   * - First mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)\n   *      onReady is skipped, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. hasLoadScriptEffectCalled.current is false, loadScript executes\n   *      Once the script is loaded, the onLoad and onReady will be called by then\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   *\n   * - Second mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)\n   *      onReady is called, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. The script is already loaded, loadScript bails out\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   */ const hasOnReadyEffectCalled = (0, _react).useRef(false);\n    (0, _react).useEffect(()=>{\n        const cacheKey = id || src;\n        if (!hasOnReadyEffectCalled.current) {\n            // Run onReady if script has loaded before but component is re-mounted\n            if (onReady && cacheKey && LoadCache.has(cacheKey)) {\n                onReady();\n            }\n            hasOnReadyEffectCalled.current = true;\n        }\n    }, [\n        onReady,\n        id,\n        src\n    ]);\n    const hasLoadScriptEffectCalled = (0, _react).useRef(false);\n    (0, _react).useEffect(()=>{\n        if (!hasLoadScriptEffectCalled.current) {\n            if (strategy === 'afterInteractive') {\n                loadScript(props);\n            } else if (strategy === 'lazyOnload') {\n                loadLazyScript(props);\n            }\n            hasLoadScriptEffectCalled.current = true;\n        }\n    }, [\n        props,\n        strategy\n    ]);\n    if (strategy === 'beforeInteractive' || strategy === 'worker') {\n        if (updateScripts) {\n            scripts[strategy] = (scripts[strategy] || []).concat([\n                _extends({\n                    id,\n                    src,\n                    onLoad,\n                    onReady,\n                    onError\n                }, restProps), \n            ]);\n            updateScripts(scripts);\n        } else if (getIsSsr && getIsSsr()) {\n            // Script has already loaded during SSR\n            LoadCache.add(id || src);\n        } else if (getIsSsr && !getIsSsr()) {\n            loadScript(props);\n        }\n    }\n    // For the app directory, we need React Float to preload these scripts.\n    if (appDir) {\n        // Before interactive scripts need to be loaded by Next.js' runtime instead\n        // of native <script> tags, because they no longer have `defer`.\n        if (strategy === 'beforeInteractive') {\n            if (!src) {\n                // For inlined scripts, we put the content in `children`.\n                if (restProps.dangerouslySetInnerHTML) {\n                    restProps.children = restProps.dangerouslySetInnerHTML.__html;\n                    delete restProps.dangerouslySetInnerHTML;\n                }\n                return /*#__PURE__*/ _react.default.createElement(\"script\", {\n                    nonce: nonce,\n                    dangerouslySetInnerHTML: {\n                        __html: `(self.__next_s=self.__next_s||[]).push(${JSON.stringify([\n                            0,\n                            _extends({}, restProps), \n                        ])})`\n                    }\n                });\n            }\n            // @ts-ignore\n            _reactDom.default.preload(src, restProps.integrity ? {\n                as: 'script',\n                integrity: restProps.integrity\n            } : {\n                as: 'script'\n            });\n            return /*#__PURE__*/ _react.default.createElement(\"script\", {\n                nonce: nonce,\n                dangerouslySetInnerHTML: {\n                    __html: `(self.__next_s=self.__next_s||[]).push(${JSON.stringify([\n                        src, \n                    ])})`\n                }\n            });\n        } else if (strategy === 'afterInteractive') {\n            if (src) {\n                // @ts-ignore\n                _reactDom.default.preload(src, restProps.integrity ? {\n                    as: 'script',\n                    integrity: restProps.integrity\n                } : {\n                    as: 'script'\n                });\n            }\n        }\n    }\n    return null;\n}\nObject.defineProperty(Script, '__nextScript', {\n    value: true\n});\nvar _default = Script;\nexports.default = _default;\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=script.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.__unsafeCreateTrustedScriptURL = __unsafeCreateTrustedScriptURL;\n/**\n * Stores the Trusted Types Policy. Starts as undefined and can be set to null\n * if Trusted Types is not supported in the browser.\n */ let policy;\n/**\n * Getter for the Trusted Types Policy. If it is undefined, it is instantiated\n * here or set to null if Trusted Types is not supported in the browser.\n */ function getPolicy() {\n    if (typeof policy === 'undefined' && typeof window !== 'undefined') {\n        var ref;\n        policy = ((ref = window.trustedTypes) == null ? void 0 : ref.createPolicy('nextjs', {\n            createHTML: (input)=>input,\n            createScript: (input)=>input,\n            createScriptURL: (input)=>input\n        })) || null;\n    }\n    return policy;\n}\nfunction __unsafeCreateTrustedScriptURL(url) {\n    var ref;\n    return ((ref = getPolicy()) == null ? void 0 : ref.createScriptURL(url)) || url;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=trusted-types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = withRouter;\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\nvar _react = _interop_require_default(require(\"react\"));\nvar _router = require(\"./router\");\nfunction withRouter(ComposedComponent) {\n    function WithRouterWrapper(props) {\n        return /*#__PURE__*/ _react.default.createElement(ComposedComponent, Object.assign({\n            router: (0, _router).useRouter()\n        }, props));\n    }\n    WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps;\n    WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;\n    if (process.env.NODE_ENV !== 'production') {\n        const name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';\n        WithRouterWrapper.displayName = `withRouter(${name})`;\n    }\n    return WithRouterWrapper;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=with-router.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: \"\",\n                suffix: \"\",\n                modifier: \"\",\n                pattern: \"\"\n            });\n        }\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\nexports.pathToRegexp = pathToRegexp;\n//# sourceMappingURL=index.js.map","/**\n * @license React\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n          case REACT_SUSPENSE_LIST_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_SERVER_CONTEXT_TYPE:\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n}\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar SuspenseList = REACT_SUSPENSE_LIST_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false;\nvar hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n    }\n  }\n\n  return false;\n}\nfunction isConcurrentMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n    }\n  }\n\n  return false;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\nfunction isSuspenseList(object) {\n  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n}\n\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.SuspenseList = SuspenseList;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isSuspenseList = isSuspenseList;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-is.production.min.js');\n} else {\n  module.exports = require('./cjs/react-is.development.js');\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isAPIRoute = isAPIRoute;\nfunction isAPIRoute(value) {\n    return value === \"/api\" || Boolean(value == null ? void 0 : value.startsWith(\"/api/\"));\n}\n\n//# sourceMappingURL=is-api-route.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = isError;\nexports.getProperError = getProperError;\nvar _isPlainObject = require(\"../shared/lib/is-plain-object\");\nfunction isError(err) {\n    return typeof err === \"object\" && err !== null && \"name\" in err && \"message\" in err;\n}\nfunction getProperError(err) {\n    if (isError(err)) {\n        return err;\n    }\n    if (process.env.NODE_ENV === \"development\") {\n        // provide better error for case where `throw undefined`\n        // is called in development\n        if (typeof err === \"undefined\") {\n            return new Error(\"An undefined error was thrown, \" + \"see here for more info: https://nextjs.org/docs/messages/threw-undefined\");\n        }\n        if (err === null) {\n            return new Error(\"A null error was thrown, \" + \"see here for more info: https://nextjs.org/docs/messages/threw-undefined\");\n        }\n    }\n    return new Error((0, _isPlainObject).isPlainObject(err) ? JSON.stringify(err) : err + \"\");\n}\n\n//# sourceMappingURL=is-error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = void 0;\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\nvar _hashing = _interop_require_default(require(\"./hashing\"));\nvar _utils = require(\"./utils\");\nfunction randomInt32() {\n    if (typeof window === 'undefined' && process.env.NEXT_RUNTIME === 'nodejs') {\n        return require('crypto').randomBytes(4).readUInt32BE(0);\n    }\n    return crypto.getRandomValues(new Uint32Array(1))[0];\n}\nfunction seedrandom() {\n    return {\n        int32: randomInt32,\n        quick: randomInt32\n    };\n}\nclass BaseFilter {\n    /**\n   * Get the seed used in this structure\n   */ get seed() {\n        return this._seed;\n    }\n    /**\n   * Set the seed for this structure\n   * @param  seed the new seed that will be used in this structure\n   */ set seed(seed) {\n        this._seed = seed;\n        this._rng = seedrandom();\n    }\n    /**\n   * Get a function used to draw random number\n   * @return A factory function used to draw random integer\n   */ get random() {\n        return this._rng;\n    }\n    /**\n   * Return a next random seeded int32 integer\n   * @returns\n   */ nextInt32() {\n        return this._rng.int32();\n    }\n    /**\n   * Save the current structure as a JSON\n   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    saveAsJSON() {\n        throw new Error('not-implemented');\n    }\n    /**\n   * Load an Object from a provided JSON object\n   * @param json the JSON object to load\n   * @return Return the Object loaded from the provided JSON object\n   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars\n    static fromJSON(json) {\n        throw new Error(`not-implemented`);\n    }\n    constructor(){\n        this._seed = (0, _utils).getDefaultSeed();\n        this._rng = seedrandom();\n        this._hashing = new _hashing.default();\n    }\n}\nexports.default = BaseFilter;\n\n//# sourceMappingURL=base-filter.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.decode = exports.encode = void 0;\n// original source: https://github.com/niklasvh/base64-arraybuffer/blob/master/src/index.ts\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nconst lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor(let i = 0; i < chars.length; i++){\n    lookup[chars.charCodeAt(i)] = i;\n}\nconst encode = (arraybuffer)=>{\n    let bytes = new Uint8Array(arraybuffer), i1, len = bytes.length, base64 = '';\n    for(i1 = 0; i1 < len; i1 += 3){\n        base64 += chars[bytes[i1] >> 2];\n        base64 += chars[(bytes[i1] & 3) << 4 | bytes[i1 + 1] >> 4];\n        base64 += chars[(bytes[i1 + 1] & 15) << 2 | bytes[i1 + 2] >> 6];\n        base64 += chars[bytes[i1 + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    } else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nexports.encode = encode;\nconst decode = (base64)=>{\n    let bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for(i2 = 0; i2 < len; i2 += 4){\n        encoded1 = lookup[base64.charCodeAt(i2)];\n        encoded2 = lookup[base64.charCodeAt(i2 + 1)];\n        encoded3 = lookup[base64.charCodeAt(i2 + 2)];\n        encoded4 = lookup[base64.charCodeAt(i2 + 3)];\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return arraybuffer;\n};\nexports.decode = decode;\n\n//# sourceMappingURL=base64-arraybuffer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = void 0;\nvar _base64Arraybuffer = require(\"./base64-arraybuffer\");\nconst bitsPerWord = 8;\nclass BitSet {\n    /**\n   * Returns the value of the bit at the given index\n   * @param index position of the bit, zero-indexed\n   */ has(index) {\n        const wordIndex = Math.floor(index / bitsPerWord);\n        const mask = 1 << index % bitsPerWord;\n        return (this.array[wordIndex] & mask) !== 0;\n    }\n    /**\n   * Set the bit to true\n   * @param index position of the bit, zero-indexed\n   */ add(index) {\n        const wordIndex = Math.floor(index / bitsPerWord);\n        const mask = 1 << index % bitsPerWord;\n        this.array[wordIndex] = this.array[wordIndex] | mask;\n    }\n    /**\n   * Returns the maximum true bit.\n   */ max() {\n        for(let i = this.array.length - 1; i >= 0; i--){\n            const bits = this.array[i];\n            if (bits) {\n                return BitSet.highBit(bits) + i * bitsPerWord;\n            }\n        }\n        return 0;\n    }\n    /**\n   * Returns the number of true bits.\n   */ bitCount() {\n        let result = 0;\n        for(let i = 0; i < this.array.length; i++){\n            result += BitSet.countBits(this.array[i]) // Assumes we never have bits set beyond the end\n            ;\n        }\n        return result;\n    }\n    /**\n   * Returns true if the size and contents are identical.\n   * @param other another BitSet\n   */ equals(other) {\n        if (other.size !== this.size) {\n            return false;\n        }\n        for(let i = 0; i < this.array.length; i++){\n            if (this.array[i] !== other.array[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n   * Returns a JSON-encodable object readable by {@link import}.\n   */ export() {\n        return {\n            size: this.size,\n            content: (0, _base64Arraybuffer).encode(this.array)\n        };\n    }\n    /**\n   * Returns an object written by {@link export}.\n   * @param data an object written by {@link export}\n   */ static import(data) {\n        if (typeof data.size !== 'number') {\n            throw Error('BitSet missing size');\n        }\n        if (typeof data.content !== 'string') {\n            throw Error('BitSet: missing content');\n        }\n        const result = new BitSet(data.size);\n        const buffer = (0, _base64Arraybuffer).decode(data.content);\n        result.array = new Uint8Array(buffer);\n        return result;\n    }\n    /**\n   * Returns the index of the maximum bit in the number, or -1 for 0\n   * @bits an unsigned 8-bit number\n   * ```js\n   * @example\n   * BitSet.highBit(0) // returns -1\n   * BitSet.highBit(5) // returns 2\n   * ```\n   */ static highBit(bits) {\n        let result = bitsPerWord - 1;\n        let mask = 1 << result;\n        while(result >= 0 && (mask & bits) !== mask){\n            mask >>>= 1;\n            result--;\n        }\n        return result;\n    }\n    /**\n   * Returns the number of true bits in the number\n   * @bits an unsigned 8-bit number\n   * @example\n   * ```js\n   * BitSet.countBits(0) // returns 0\n   * BitSet.countBits(3) // returns 2\n   * ```\n   */ static countBits(bits) {\n        let result = bits & 1;\n        while(bits !== 0){\n            bits = bits >>> 1;\n            result += bits & 1;\n        }\n        return result;\n    }\n    /**\n   * Constructor. All bits are initially set to false.\n   * @param size the number of bits that can be stored. (This is NOT required to be a multiple of 8.)\n   */ constructor(size){\n        const diff = bitsPerWord - size % bitsPerWord;\n        this.size = size + ([\n            0,\n            8\n        ].includes(diff) ? 0 : diff);\n        this.array = new Uint8Array(Math.ceil(this.size / bitsPerWord));\n    }\n}\nexports.default = BitSet;\n\n//# sourceMappingURL=bit-set.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.optimalFilterSize = optimalFilterSize;\nexports.optimalHashes = optimalHashes;\nfunction optimalFilterSize(length, errorRate) {\n    return Math.ceil(-(length * Math.log(errorRate) / Math.pow(Math.log(2), 2)));\n}\nfunction optimalHashes(size, length) {\n    return Math.ceil(size / length * Math.log(2));\n}\n\n//# sourceMappingURL=formulas.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = void 0;\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\nvar _fnv1A = _interop_require_default(require(\"../fnv1a\"));\nvar _utils = require(\"./utils\");\nclass Hashing {\n    /**\n   * Apply enhanced Double Hashing to produce a n-hash\n   * @see {@link http://peterd.org/pcd-diss.pdf} s6.5.4\n   * @param  n - The indice of the hash function we want to produce\n   * @param  hashA - The result of the first hash function applied to a value.\n   * @param  hashB - The result of the second hash function applied to a value.\n   * @param  size - The size of the datastructures associated to the hash context (ex: the size of a Bloom Filter)\n   * @return The result of hash_n applied to a value.\n   * @memberof Hashing\n   * @author Thomas Minier\n   * @author Arnaud Grall\n   */ doubleHashing(n, hashA, hashB, size) {\n        return Math.abs((hashA + n * hashB + Math.floor((n ** 3 - n) / 6)) % size);\n    }\n    /**\n   * Generate a set of distinct indexes on interval [0, size) using the double hashing technique\n   * For generating efficiently distinct indexes we re-hash after detecting a cycle by changing slightly the seed.\n   * It has the effect of generating faster distinct indexes without loosing entirely the utility of the double hashing.\n   * For small number of indexes it will work perfectly. For a number close to the size, and size very large\n   * Advise: do not generate `size` indexes for a large interval. In practice, size should be equal\n   * to the number of hash functions used and is often low.\n   *\n   * @param  element  - The element to hash\n   * @param  size     - the range on which we can generate an index [0, size) = size\n   * @param  number   - The number of indexes desired\n   * @param  seed     - The seed used\n   * @return Array<number>\n   * @author Arnaud Grall\n   * @author Simon Woolf (SimonWoolf)\n   */ getDistinctIndexes(element, size, number, seed) {\n        if (seed === undefined) {\n            seed = (0, _utils).getDefaultSeed();\n        }\n        let n = 0;\n        const indexes = new Set();\n        let hashes = this.hashTwice(element, seed);\n        // let cycle = 0\n        while(indexes.size < number){\n            const ind = hashes.first % size;\n            if (!indexes.has(ind)) {\n                indexes.add(ind);\n            }\n            hashes.first = (hashes.first + hashes.second) % size;\n            hashes.second = (hashes.second + n) % size;\n            n++;\n            if (n > size) {\n                // Enhanced double hashing stops cycles of length less than `size` in the case where\n                // size is coprime with the second hash. But you still get cycles of length `size`.\n                // So if we reach there and haven't finished, append a prime to the input and\n                // rehash.\n                seed++;\n                hashes = this.hashTwice(element, seed);\n            }\n        }\n        return [\n            ...indexes.values()\n        ];\n    }\n    /**\n   * Generate N indexes on range [0, size)\n   * It uses the double hashing technique to generate the indexes.\n   * It hash twice the value only once before generating the indexes.\n   * Warning: you can have a lot of modulo collisions.\n   * @param  element    - The element to hash\n   * @param  size       - The range on which we can generate the index, exclusive\n   * @param  hashCount  - The number of indexes we want\n   * @return An array of indexes on range [0, size)\n   */ getIndexes(element, size, hashCount, seed) {\n        if (seed === undefined) {\n            seed = (0, _utils).getDefaultSeed();\n        }\n        const arr = [];\n        const hashes = this.hashTwice(element, seed);\n        for(let i = 0; i < hashCount; i++){\n            arr.push(this.doubleHashing(i, hashes.first, hashes.second, size));\n        }\n        return arr;\n    }\n    /**\n   * @internal\n   * Hash an element of type {@link HashableInput} into {@link Number}\n   * Can be overrided as long as you return a value of type {@link Number}\n   * Don't forget to use the seed when hashing, otherwise if some kind of randomness is in the process\n   * you may have inconsistent behaviors between 2 runs.\n   * @param element\n   * @param seed\n   * @returns A 64bits floating point {@link Number}\n   */ serialize(element, seed) {\n        if (!seed) {\n            seed = (0, _utils).getDefaultSeed();\n        }\n        return Number((0, _fnv1A).default(element, {\n            seed\n        }));\n    }\n    /**\n   * (64-bits only) Hash a value into two values (in hex or integer format)\n   * @param  value - The value to hash\n   * @param  asInt - (optional) If True, the values will be returned as an integer. Otherwise, as hexadecimal values.\n   * @param seed the seed used for hashing\n   * @return The results of the hash functions applied to the value (in hex or integer)\n   * @author Arnaud Grall & Thomas Minier\n   */ hashTwice(value, seed) {\n        if (seed === undefined) {\n            seed = (0, _utils).getDefaultSeed();\n        }\n        return {\n            first: this.serialize(value, seed + 1),\n            second: this.serialize(value, seed + 2)\n        };\n    }\n    /**\n   * Hash twice an element into their HEX string representations\n   * @param value\n   * @param seed\n   * @returns TwoHashesTemplated<string>\n   */ hashTwiceAsString(value, seed) {\n        const { first , second  } = this.hashTwice(value, seed);\n        return {\n            first: (0, _utils).numberToHex(first),\n            second: (0, _utils).numberToHex(second)\n        };\n    }\n    /**\n   * (64-bits only) Same as hashTwice but return Numbers and String equivalent\n   * @param  val the value to hash\n   * @param  seed the seed to change when hashing\n   * @return TwoHashesIntAndString\n   * @author Arnaud Grall\n   */ hashTwiceIntAndString(val, seed) {\n        if (seed === undefined) {\n            seed = (0, _utils).getDefaultSeed();\n        }\n        const one = this.hashIntAndString(val, seed + 1);\n        const two = this.hashIntAndString(val, seed + 2);\n        return {\n            int: {\n                first: one.int,\n                second: two.int\n            },\n            string: {\n                first: one.string,\n                second: two.string\n            }\n        };\n    }\n    /**\n   * Hash an item as an unsigned int\n   * @param  elem - Element to hash\n   * @param  seed - The hash seed. If its is UINT32 make sure to set the length to 32\n   * @param  length - The length of hashes (defaults to 32 bits)\n   * @return The hash value as an unsigned int\n   * @author Arnaud Grall\n   */ hashAsInt(elem, seed) {\n        if (seed === undefined) {\n            seed = (0, _utils).getDefaultSeed();\n        }\n        return this.serialize(elem, seed);\n    }\n    /**\n   * Hash an item and return its number and HEX string representation\n   * @param  elem - Element to hash\n   * @param  seed - The hash seed. If its is UINT32 make sure to set the length to 32\n   * @param  base - The base in which the string will be returned, default: 16\n   * @param  length - The length of hashes (defaults to 32 bits)\n   * @return The item hased as an int and a string\n   * @author Arnaud Grall\n   */ hashIntAndString(elem, seed) {\n        const hash = this.hashAsInt(elem, seed);\n        return {\n            int: hash,\n            string: (0, _utils).numberToHex(hash)\n        };\n    }\n}\nexports.default = Hashing;\n\n//# sourceMappingURL=hashing.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\nvar _baseFilter = _interop_require_default(require(\"./base-filter\"));\nvar _bitSet = _interop_require_default(require(\"./bit-set\"));\nvar _formulas = require(\"./formulas\");\nclass BloomFilter extends _baseFilter.default {\n    /**\n   * Create an optimal bloom filter providing the maximum of elements stored and the error rate desired\n   * @param  nbItems      - The maximum number of item to store\n   * @param  errorRate  - The error rate desired for a maximum of items inserted\n   * @return A new {@link BloomFilter}\n   */ static create(nbItems, errorRate) {\n        const size = (0, _formulas).optimalFilterSize(nbItems, errorRate);\n        const hashes = (0, _formulas).optimalHashes(size, nbItems);\n        return new this(size, hashes);\n    }\n    /**\n   * Build a new Bloom Filter from an existing iterable with a fixed error rate\n   * @param items - The iterable used to populate the filter\n   * @param errorRate - The error rate, i.e. 'false positive' rate, targeted by the filter\n   * @param seed - The random number seed (optional)\n   * @return A new Bloom Filter filled with the iterable's elements\n   * @example\n   * ```js\n   * // create a filter with a false positive rate of 0.1\n   * const filter = BloomFilter.from(['alice', 'bob', 'carl'], 0.1);\n   * ```\n   */ static from(items, errorRate, seed) {\n        const array = Array.from(items);\n        const filter = BloomFilter.create(array.length, errorRate);\n        if (typeof seed === 'number') {\n            filter.seed = seed;\n        }\n        array.forEach((element)=>filter.add(element));\n        return filter;\n    }\n    /**\n   * Get the optimal size of the filter\n   * @return The size of the filter\n   */ get size() {\n        return this._size;\n    }\n    /**\n   * Get the number of bits currently set in the filter\n   * @return The filter length\n   */ get length() {\n        return this._filter.bitCount();\n    }\n    /**\n   * Add an element to the filter\n   * @param element - The element to add\n   * @example\n   * ```js\n   * const filter = new BloomFilter(15, 0.1);\n   * filter.add('foo');\n   * ```\n   */ add(element) {\n        const indexes = this._hashing.getIndexes(element, this._size, this._nbHashes, this.seed);\n        for(let i = 0; i < indexes.length; i++){\n            this._filter.add(indexes[i]);\n        }\n    }\n    /**\n   * Test an element for membership\n   * @param element - The element to look for in the filter\n   * @return False if the element is definitively not in the filter, True is the element might be in the filter\n   * @example\n   * ```js\n   * const filter = new BloomFilter(15, 0.1);\n   * filter.add('foo');\n   * console.log(filter.has('foo')); // output: true\n   * console.log(filter.has('bar')); // output: false\n   * ```\n   */ has(element) {\n        const indexes = this._hashing.getIndexes(element, this._size, this._nbHashes, this.seed);\n        for(let i = 0; i < indexes.length; i++){\n            if (!this._filter.has(indexes[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n   * Get the current false positive rate (or error rate) of the filter\n   * @return The current false positive rate of the filter\n   * @example\n   * ```js\n   * const filter = new BloomFilter(15, 0.1);\n   * console.log(filter.rate()); // output: something around 0.1\n   * ```\n   */ rate() {\n        return Math.pow(1 - Math.exp(-this.length / this._size), this._nbHashes);\n    }\n    /**\n   * Check if another Bloom Filter is equal to this one\n   * @param  other - The filter to compare to this one\n   * @return True if they are equal, false otherwise\n   */ equals(other) {\n        if (this._size !== other._size || this._nbHashes !== other._nbHashes) {\n            return false;\n        }\n        return this._filter.equals(other._filter);\n    }\n    export() {\n        return {\n            bitset: this._filter.export(),\n            hashes: this._nbHashes,\n            size: this._size\n        };\n    }\n    import(data) {\n        this._filter = _bitSet.default.import(data.bitset);\n    }\n    /**\n   * Constructor\n   * @param size - The number of cells\n   * @param nbHashes - The number of hash functions used\n   */ constructor(size, nbHashes){\n        super();\n        if (nbHashes < 1) {\n            throw new Error(`A BloomFilter cannot uses less than one hash function, while you tried to use ${nbHashes}.`);\n        }\n        this._size = size;\n        this._nbHashes = nbHashes;\n        this._filter = new _bitSet.default(size);\n    }\n}\nexports.BloomFilter = BloomFilter;\n\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.numberToHex = numberToHex;\nexports.randomInt = randomInt;\nexports.getDefaultSeed = getDefaultSeed;\nfunction numberToHex(elem) {\n    let e = Number(elem).toString(16);\n    if (e.length % 4 !== 0) {\n        e = '0'.repeat(4 - e.length % 4) + e;\n    }\n    return e;\n}\nfunction randomInt(min, max, random) {\n    if (random === undefined) {\n        random = Math.random;\n    }\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    const rn = random();\n    return Math.floor(rn * (max - min + 1)) + min;\n}\nfunction getDefaultSeed() {\n    return 0x1234567890;\n}\n\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.escapeStringRegexp = escapeStringRegexp;\n// regexp is based on https://github.com/sindresorhus/escape-string-regexp\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, '\\\\$&');\n    }\n    return str;\n}\n\n//# sourceMappingURL=escape-regexp.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = fnv1a;\nfunction fnv1a(inputString, { size =32 , seed =0  } = {}) {\n    if (!FNV_PRIMES[size]) {\n        throw new Error('The `size` option must be one of 32, 64, 128, 256, 512, or 1024');\n    }\n    let hash = FNV_OFFSETS[size] ^ BigInt(seed);\n    const fnvPrime = FNV_PRIMES[size];\n    // Handle Unicode code points > 0x7f\n    let isUnicoded = false;\n    for(let index = 0; index < inputString.length; index++){\n        let characterCode = inputString.charCodeAt(index);\n        // Non-ASCII characters trigger the Unicode escape logic\n        if (characterCode > 0x7f && !isUnicoded) {\n            inputString = unescape(encodeURIComponent(inputString));\n            characterCode = inputString.charCodeAt(index);\n            isUnicoded = true;\n        }\n        hash ^= BigInt(characterCode);\n        hash = BigInt.asUintN(size, hash * fnvPrime);\n    }\n    return hash;\n}\n// source: https://github.com/sindresorhus/fnv1a\n// FNV_PRIMES and FNV_OFFSETS from\n// http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param\nconst FNV_PRIMES = {\n    32: BigInt(16777619),\n    64: BigInt(1099511628211),\n    128: BigInt(309485009821345068724781371),\n    256: BigInt(374144419156711147060143317175368453031918731002211),\n    512: BigInt(35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759),\n    1024: BigInt(5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573)\n};\nconst FNV_OFFSETS = {\n    32: BigInt(2166136261),\n    64: BigInt(14695981039346656037),\n    128: BigInt(144066263297769815596495629667062367629),\n    256: BigInt(100029257958052580907070968620625704837092796014241193945225284501741471925557),\n    512: BigInt(9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785),\n    1024: BigInt(14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915)\n};\n\n//# sourceMappingURL=fnv1a.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.detectDomainLocale = detectDomainLocale;\nfunction detectDomainLocale(domainItems, hostname, detectedLocale) {\n    let domainItem;\n    if (domainItems) {\n        if (detectedLocale) {\n            detectedLocale = detectedLocale.toLowerCase();\n        }\n        for (const item of domainItems){\n            var ref, ref1;\n            // remove port if present\n            const domainHostname = (ref = item.domain) == null ? void 0 : ref.split(':')[0].toLowerCase();\n            if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || ((ref1 = item.locales) == null ? void 0 : ref1.some((locale)=>locale.toLowerCase() === detectedLocale))) {\n                domainItem = item;\n                break;\n            }\n        }\n    }\n    return domainItem;\n}\n\n//# sourceMappingURL=detect-domain-locale.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.normalizeLocalePath = normalizeLocalePath;\nfunction normalizeLocalePath(pathname, locales) {\n    let detectedLocale;\n    // first item will be empty string from splitting at first char\n    const pathnameParts = pathname.split('/');\n    (locales || []).some((locale)=>{\n        if (pathnameParts[1] && pathnameParts[1].toLowerCase() === locale.toLowerCase()) {\n            detectedLocale = locale;\n            pathnameParts.splice(1, 1);\n            pathname = pathnameParts.join('/') || '/';\n            return true;\n        }\n        return false;\n    });\n    return {\n        pathname,\n        detectedLocale\n    };\n}\n\n//# sourceMappingURL=normalize-locale-path.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getObjectClassLabel = getObjectClassLabel;\nexports.isPlainObject = isPlainObject;\nfunction getObjectClassLabel(value) {\n    return Object.prototype.toString.call(value);\n}\nfunction isPlainObject(value) {\n    if (getObjectClassLabel(value) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    /**\n   * this used to be previously:\n   *\n   * `return prototype === null || prototype === Object.prototype`\n   *\n   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.\n   *\n   * It was changed to the current implementation since it's resilient to serialization.\n   */ return prototype === null || prototype.hasOwnProperty('isPrototypeOf');\n}\n\n//# sourceMappingURL=is-plain-object.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = mitt;\nfunction mitt() {\n    const all = Object.create(null);\n    return {\n        on (type, handler) {\n            (all[type] || (all[type] = [])).push(handler);\n        },\n        off (type, handler) {\n            if (all[type]) {\n                all[type].splice(all[type].indexOf(handler) >>> 0, 1);\n            }\n        },\n        emit (type, ...evts) {\n            (all[type] || []).slice().map((handler)=>{\n                handler(...evts);\n            });\n        }\n    };\n}\n\n//# sourceMappingURL=mitt.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.denormalizePagePath = denormalizePagePath;\nvar _utils = require(\"../router/utils\");\nvar _normalizePathSep = require(\"./normalize-path-sep\");\nfunction denormalizePagePath(page) {\n    let _page = (0, _normalizePathSep).normalizePathSep(page);\n    return _page.startsWith('/index/') && !(0, _utils).isDynamicRoute(_page) ? _page.slice(6) : _page !== '/index' ? _page : '/';\n}\n\n//# sourceMappingURL=denormalize-page-path.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.normalizePathSep = normalizePathSep;\nfunction normalizePathSep(path) {\n    return path.replace(/\\\\/g, '/');\n}\n\n//# sourceMappingURL=normalize-path-sep.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.matchesMiddleware = matchesMiddleware;\nexports.createKey = createKey;\nexports.default = void 0;\nvar _async_to_generator = require(\"@swc/helpers/lib/_async_to_generator.js\").default;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _interop_require_default = require(\"@swc/helpers/lib/_interop_require_default.js\").default;\nvar _interop_require_wildcard = require(\"@swc/helpers/lib/_interop_require_wildcard.js\").default;\nvar _removeTrailingSlash = require(\"./utils/remove-trailing-slash\");\nvar _routeLoader = require(\"../../../client/route-loader\");\nvar _script = require(\"../../../client/script\");\nvar _isError = _interop_require_wildcard(require(\"../../../lib/is-error\"));\nvar _denormalizePagePath = require(\"../page-path/denormalize-page-path\");\nvar _normalizeLocalePath = require(\"../i18n/normalize-locale-path\");\nvar _mitt = _interop_require_default(require(\"../mitt\"));\nvar _utils = require(\"../utils\");\nvar _isDynamic = require(\"./utils/is-dynamic\");\nvar _parseRelativeUrl = require(\"./utils/parse-relative-url\");\nvar _resolveRewrites = _interop_require_default(require(\"./utils/resolve-rewrites\"));\nvar _routeMatcher = require(\"./utils/route-matcher\");\nvar _routeRegex = require(\"./utils/route-regex\");\nvar _formatUrl = require(\"./utils/format-url\");\nvar _detectDomainLocale = require(\"../../../client/detect-domain-locale\");\nvar _parsePath = require(\"./utils/parse-path\");\nvar _addLocale = require(\"../../../client/add-locale\");\nvar _removeLocale = require(\"../../../client/remove-locale\");\nvar _removeBasePath = require(\"../../../client/remove-base-path\");\nvar _addBasePath = require(\"../../../client/add-base-path\");\nvar _hasBasePath = require(\"../../../client/has-base-path\");\nvar _isApiRoute = require(\"../../../lib/is-api-route\");\nvar _getNextPathnameInfo = require(\"./utils/get-next-pathname-info\");\nvar _formatNextPathnameInfo = require(\"./utils/format-next-pathname-info\");\nvar _compareStates = require(\"./utils/compare-states\");\nvar _isLocalUrl = require(\"./utils/is-local-url\");\nvar _isBot = require(\"./utils/is-bot\");\nvar _omit = require(\"./utils/omit\");\nvar _resolveHref = require(\"./utils/resolve-href\");\nvar _interpolateAs = require(\"./utils/interpolate-as\");\nvar _handleSmoothScroll = require(\"./utils/handle-smooth-scroll\");\nfunction buildCancellationError() {\n    return Object.assign(new Error('Route Cancelled'), {\n        cancelled: true\n    });\n}\nfunction matchesMiddleware(options) {\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction _matchesMiddleware() {\n    _matchesMiddleware = _async_to_generator(function*(options) {\n        const matchers = yield Promise.resolve(options.router.pageLoader.getMiddleware());\n        if (!matchers) return false;\n        const { pathname: asPathname  } = (0, _parsePath).parsePath(options.asPath);\n        // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n        const cleanedAs = (0, _hasBasePath).hasBasePath(asPathname) ? (0, _removeBasePath).removeBasePath(asPathname) : asPathname;\n        const asWithBasePathAndLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, options.locale));\n        // Check only path match on client. Matching \"has\" should be done on server\n        // where we can access more info such as headers, HttpOnly cookie, etc.\n        return matchers.some((m)=>new RegExp(m.regexp).test(asWithBasePathAndLocale));\n    });\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = (0, _resolveHref).resolveHref(router, url, true);\n    const origin = (0, _utils).getLocationOrigin();\n    const hrefWasAbsolute = resolvedHref.startsWith(origin);\n    const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addBasePath).addBasePath(resolvedHref);\n    const preparedAs = as ? stripOrigin((0, _resolveHref).resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addBasePath).addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    const nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH)\n    };\n    const rewriteHeader = response.headers.get('x-nextjs-rewrite');\n    let rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');\n    const matchedPath = response.headers.get('x-matched-path');\n    if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith('/') || process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE) {\n            const parsedRewriteTarget = (0, _parseRelativeUrl).parseRelativeUrl(rewriteTarget);\n            const pathnameInfo = (0, _getNextPathnameInfo).getNextPathnameInfo(parsedRewriteTarget.pathname, {\n                nextConfig,\n                parseData: true\n            });\n            let fsPathname = (0, _removeTrailingSlash).removeTrailingSlash(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeLoader).getClientBuildManifest(), \n            ]).then(([pages, { __rewrites: rewrites  }])=>{\n                let as = (0, _addLocale).addLocale(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isDynamic).isDynamicRoute(as) || !rewriteHeader && pages.includes((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(as), options.router.locales).pathname)) {\n                    const parsedSource = (0, _getNextPathnameInfo).getNextPathnameInfo((0, _parseRelativeUrl).parseRelativeUrl(source).pathname, {\n                        parseData: true\n                    });\n                    as = (0, _addBasePath).addBasePath(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (process.env.__NEXT_HAS_REWRITES) {\n                    const result = (0, _resolveRewrites).default(as, pages, rewrites, parsedRewriteTarget.query, (path)=>resolveDynamicRoute(path, pages), options.router.locales);\n                    if (result.matchedPage) {\n                        parsedRewriteTarget.pathname = result.parsedAs.pathname;\n                        as = parsedRewriteTarget.pathname;\n                        Object.assign(parsedRewriteTarget.query, result.parsedAs.query);\n                    }\n                } else if (!pages.includes(fsPathname)) {\n                    const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isDynamic).isDynamicRoute(resolvedHref)) {\n                    const matches = (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: 'rewrite',\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref\n                };\n            });\n        }\n        const src = (0, _parsePath).parsePath(source);\n        const pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {\n            nextConfig,\n            parseData: true\n        }), {\n            defaultLocale: options.router.defaultLocale,\n            buildId: ''\n        }));\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: `${pathname}${src.query}${src.hash}`\n        });\n    }\n    const redirectTarget = response.headers.get('x-nextjs-redirect');\n    if (redirectTarget) {\n        if (redirectTarget.startsWith('/')) {\n            const src = (0, _parsePath).parsePath(redirectTarget);\n            const pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {\n                nextConfig,\n                parseData: true\n            }), {\n                defaultLocale: options.router.defaultLocale,\n                buildId: ''\n            }));\n            return Promise.resolve({\n                type: 'redirect-internal',\n                newAs: `${pathname}${src.query}${src.hash}`,\n                newUrl: `${pathname}${src.query}${src.hash}`\n            });\n        }\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: 'next'\n    });\n}\nfunction withMiddlewareEffects(options) {\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nfunction _withMiddlewareEffects() {\n    _withMiddlewareEffects = _async_to_generator(function*(options) {\n        const matches = yield matchesMiddleware(options);\n        if (!matches || !options.fetchData) {\n            return null;\n        }\n        try {\n            const data = yield options.fetchData();\n            const effect = yield getMiddlewareData(data.dataHref, data.response, options);\n            return {\n                dataHref: data.dataHref,\n                json: data.json,\n                response: data.response,\n                text: data.text,\n                cacheKey: data.cacheKey,\n                effect\n            };\n        } catch (e) {\n            /**\n     * TODO: Revisit this in the future.\n     * For now we will not consider middleware data errors to be fatal.\n     * maybe we should revisit in the future.\n     */ return null;\n        }\n    });\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function() {\n    try {\n        let v = '__next';\n        // eslint-disable-next-line no-sequences\n        return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n    } catch (n) {}\n}();\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` won’t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin',\n        method: options.method || 'GET',\n        headers: Object.assign({}, options.headers, {\n            'x-nextjs-data': '1'\n        })\n    }).then((response)=>{\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData({ dataHref , inflightCache , isPrefetch , hasMiddleware , isServerRender , parseJSON , persistCache , isBackground , unstable_skipClientCache  }) {\n    const { href: cacheKey  } = new URL(dataHref, window.location.href);\n    var ref1;\n    const getData = (params)=>{\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: 'prefetch'\n            } : {}, isPrefetch && hasMiddleware ? {\n                'x-middleware-prefetch': '1'\n            } : {}),\n            method: (ref1 = params == null ? void 0 : params.method) != null ? ref1 : 'GET'\n        }).then((response)=>{\n            if (response.ok && (params == null ? void 0 : params.method) === 'HEAD') {\n                return {\n                    dataHref,\n                    response,\n                    text: '',\n                    json: {},\n                    cacheKey\n                };\n            }\n            return response.text().then((text)=>{\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref,\n                            response,\n                            text,\n                            json: {},\n                            cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        var ref;\n                        if ((ref = tryToParseAsJSON(text)) == null ? void 0 : ref.notFound) {\n                            return {\n                                dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response,\n                                text,\n                                cacheKey\n                            };\n                        }\n                    }\n                    const error = new Error(`Failed to load static props`);\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeLoader).markAssetError(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response,\n                    text,\n                    cacheKey\n                };\n            });\n        }).then((data)=>{\n            if (!persistCache || process.env.NODE_ENV !== 'production' || data.response.headers.get('x-middleware-cache') === 'no-cache') {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch((err)=>{\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (// chrome\n            err.message === 'Failed to fetch' || // firefox\n            err.message === 'NetworkError when attempting to fetch resource.' || // safari\n            err.message === 'Load failed') {\n                (0, _routeLoader).markAssetError(err);\n            }\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then((data)=>{\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: 'HEAD'\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation({ url , router  }) {\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addBasePath).addBasePath((0, _addLocale).addLocale(router.asPath, router.locale))) {\n        throw new Error(`Invariant: attempted to hard navigate to the same URL ${url} ${location.href}`);\n    }\n    window.location.href = url;\n}\nconst getCancelledHandler = ({ route , router  })=>{\n    let cancelled = false;\n    const cancel = router.clc = ()=>{\n        cancelled = true;\n    };\n    const handleCancelled = ()=>{\n        if (cancelled) {\n            const error = new Error(`Abort fetching component for route: \"${route}\"`);\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nclass Router {\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Go forward in history\n   */ forward() {\n        window.history.forward();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options = {}) {\n        if (process.env.__NEXT_SCROLL_RESTORATION) {\n            // TODO: remove in the future when we update history before route change\n            // is complete, as the popstate event should handle this capture.\n            if (manualScrollRestoration) {\n                try {\n                    // Snapshot scroll position right before navigating to a new page:\n                    sessionStorage.setItem('__next_scroll_' + this._key, JSON.stringify({\n                        x: self.pageXOffset,\n                        y: self.pageYOffset\n                    }));\n                } catch (e) {}\n            }\n        }\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change('pushState', url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options = {}) {\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change('replaceState', url, as, options);\n    }\n    _bfl(as, resolvedAs, locale) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {\n                let matchesBflStatic = false;\n                let matchesBflDynamic = false;\n                for (const curAs of [\n                    as,\n                    resolvedAs\n                ]){\n                    if (curAs) {\n                        const asNoSlash = (0, _removeTrailingSlash).removeTrailingSlash(new URL(curAs, 'http://n').pathname);\n                        const asNoSlashLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(asNoSlash, locale || _this.locale));\n                        if (asNoSlash !== (0, _removeTrailingSlash).removeTrailingSlash(new URL(_this.asPath, 'http://n').pathname)) {\n                            var ref, ref2;\n                            matchesBflStatic = matchesBflStatic || !!((ref = _this._bfl_s) == null ? void 0 : ref.has(asNoSlash)) || !!((ref2 = _this._bfl_s) == null ? void 0 : ref2.has(asNoSlashLocale));\n                            for (const normalizedAS of [\n                                asNoSlash,\n                                asNoSlashLocale\n                            ]){\n                                // if any sub-path of as matches a dynamic filter path\n                                // it should be hard navigated\n                                const curAsParts = normalizedAS.split('/');\n                                for(let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                    var ref3;\n                                    const currentPart = curAsParts.slice(0, i).join('/');\n                                    if (currentPart && ((ref3 = _this._bfl_d) == null ? void 0 : ref3.has(currentPart))) {\n                                        matchesBflDynamic = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            // if the client router filter is matched then we trigger\n                            // a hard navigation\n                            if (matchesBflStatic || matchesBflDynamic) {\n                                handleHardNavigation({\n                                    url: (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, locale || _this.locale)),\n                                    router: _this\n                                });\n                                return new Promise(()=>{});\n                            }\n                        }\n                    }\n                }\n            }\n        })();\n    }\n    change(method, url, as, options, forcedScroll) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            if (!(0, _isLocalUrl).isLocalURL(url)) {\n                handleHardNavigation({\n                    url,\n                    router: _this\n                });\n                return false;\n            }\n            // WARNING: `_h` is an internal option for handing Next.js client-side\n            // hydration. Your app should _never_ use this property. It may change at\n            // any time without notice.\n            const isQueryUpdating = options._h === 1;\n            if (!isQueryUpdating && !options.shallow) {\n                yield _this._bfl(as, undefined, options.locale);\n            }\n            let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsePath).parsePath(url).pathname === (0, _parsePath).parsePath(as).pathname;\n            const nextState = _extends({}, _this.state);\n            // for static pages with query params in the URL we delay\n            // marking the router ready until after the query is updated\n            // or a navigation has occurred\n            const readyStateChange = _this.isReady !== true;\n            _this.isReady = true;\n            const isSsr = _this.isSsr;\n            if (!isQueryUpdating) {\n                _this.isSsr = false;\n            }\n            // if a route transition is already in progress before\n            // the query updating is triggered ignore query updating\n            if (isQueryUpdating && _this.clc) {\n                return false;\n            }\n            const prevLocale = nextState.locale;\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                nextState.locale = options.locale === false ? _this.defaultLocale : options.locale || nextState.locale;\n                if (typeof options.locale === 'undefined') {\n                    options.locale = nextState.locale;\n                }\n                const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as);\n                const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);\n                if (localePathResult.detectedLocale) {\n                    nextState.locale = localePathResult.detectedLocale;\n                    parsedAs.pathname = (0, _addBasePath).addBasePath(parsedAs.pathname);\n                    as = (0, _formatUrl).formatWithValidation(parsedAs);\n                    url = (0, _addBasePath).addBasePath((0, _normalizeLocalePath).normalizeLocalePath((0, _hasBasePath).hasBasePath(url) ? (0, _removeBasePath).removeBasePath(url) : url, _this.locales).pathname);\n                }\n                let didNavigate = false;\n                // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                    var ref;\n                    // if the locale isn't configured hard navigate to show 404 page\n                    if (!((ref = _this.locales) == null ? void 0 : ref.includes(nextState.locale))) {\n                        parsedAs.pathname = (0, _addLocale).addLocale(parsedAs.pathname, nextState.locale);\n                        handleHardNavigation({\n                            url: (0, _formatUrl).formatWithValidation(parsedAs),\n                            router: _this\n                        });\n                        // this was previously a return but was removed in favor\n                        // of better dead code elimination with regenerator runtime\n                        didNavigate = true;\n                    }\n                }\n                const detectedDomain = (0, _detectDomainLocale).detectDomainLocale(_this.domainLocales, undefined, nextState.locale);\n                // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                    // if we are navigating to a domain locale ensure we redirect to the\n                    // correct domain\n                    if (!didNavigate && detectedDomain && _this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n                        const asNoBasePath = (0, _removeBasePath).removeBasePath(as);\n                        handleHardNavigation({\n                            url: `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${(0, _addBasePath).addBasePath(`${nextState.locale === detectedDomain.defaultLocale ? '' : `/${nextState.locale}`}${asNoBasePath === '/' ? '' : asNoBasePath}` || '/')}`,\n                            router: _this\n                        });\n                        // this was previously a return but was removed in favor\n                        // of better dead code elimination with regenerator runtime\n                        didNavigate = true;\n                    }\n                }\n                if (didNavigate) {\n                    return new Promise(()=>{});\n                }\n            }\n            // marking route changes as a navigation start entry\n            if (_utils.ST) {\n                performance.mark('routeChange');\n            }\n            const { shallow =false , scroll =true  } = options;\n            const routeProps = {\n                shallow\n            };\n            if (_this._inFlightRoute && _this.clc) {\n                if (!isSsr) {\n                    Router.events.emit('routeChangeError', buildCancellationError(), _this._inFlightRoute, routeProps);\n                }\n                _this.clc();\n                _this.clc = null;\n            }\n            as = (0, _addBasePath).addBasePath((0, _addLocale).addLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, options.locale, _this.defaultLocale));\n            const cleanedAs = (0, _removeLocale).removeLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, nextState.locale);\n            _this._inFlightRoute = as;\n            const localeChange = prevLocale !== nextState.locale;\n            // If the url change is only related to a hash change\n            // We should not proceed. We should only change the state.\n            if (!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange) {\n                nextState.asPath = cleanedAs;\n                Router.events.emit('hashChangeStart', as, routeProps);\n                // TODO: do we need the resolved href when only a hash change?\n                _this.changeState(method, url, as, _extends({}, options, {\n                    scroll: false\n                }));\n                if (scroll) {\n                    _this.scrollToHash(cleanedAs);\n                }\n                try {\n                    yield _this.set(nextState, _this.components[nextState.route], null);\n                } catch (err) {\n                    if ((0, _isError).default(err) && err.cancelled) {\n                        Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n                    }\n                    throw err;\n                }\n                Router.events.emit('hashChangeComplete', as, routeProps);\n                return true;\n            }\n            let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            let { pathname , query  } = parsed;\n            // The build manifest needs to be loaded before auto-static dynamic pages\n            // get their query parameters to allow ensuring they can be parsed properly\n            // when rewritten to\n            let pages, rewrites;\n            try {\n                [pages, { __rewrites: rewrites  }] = yield Promise.all([\n                    _this.pageLoader.getPageList(),\n                    (0, _routeLoader).getClientBuildManifest(),\n                    _this.pageLoader.getMiddleware(), \n                ]);\n            } catch (err) {\n                // If we fail to resolve the page list or client-build manifest, we must\n                // do a server-side transition:\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                return false;\n            }\n            // If asked to change the current URL we should reload the current page\n            // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n            // We also need to set the method = replaceState always\n            // as this should not go into the history (That's how browsers work)\n            // We should compare the new asPath to the current asPath, not the url\n            if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                method = 'replaceState';\n            }\n            // we need to resolve the as value using rewrites for dynamic SSG\n            // pages to allow building the data URL correctly\n            let resolvedAs = as;\n            // url and as should always be prefixed with basePath by this\n            // point by either next/link or router.push/replace so strip the\n            // basePath from the pathname to match the pages dir 1-to-1\n            pathname = pathname ? (0, _removeTrailingSlash).removeTrailingSlash((0, _removeBasePath).removeBasePath(pathname)) : pathname;\n            let route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n            const parsedAsPathname = as.startsWith('/') && (0, _parseRelativeUrl).parseRelativeUrl(as).pathname;\n            const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isDynamic).isDynamicRoute(route) || !(0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(route))(parsedAsPathname)));\n            // we don't attempt resolve asPath when we need to execute\n            // middleware as the resolving will occur server-side\n            const isMiddlewareMatch = !options.shallow && (yield matchesMiddleware({\n                asPath: as,\n                locale: nextState.locale,\n                router: _this\n            }));\n            if (isQueryUpdating && isMiddlewareMatch) {\n                shouldResolveHref = false;\n            }\n            if (shouldResolveHref && pathname !== '/_error') {\n                options._shouldResolveHref = true;\n                if (process.env.__NEXT_HAS_REWRITES && as.startsWith('/')) {\n                    const rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, nextState.locale), true), pages, rewrites, query, (p)=>resolveDynamicRoute(p, pages), _this.locales);\n                    if (rewritesResult.externalDest) {\n                        handleHardNavigation({\n                            url: as,\n                            router: _this\n                        });\n                        return true;\n                    }\n                    if (!isMiddlewareMatch) {\n                        resolvedAs = rewritesResult.asPath;\n                    }\n                    if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                        // if this directly matches a page we need to update the href to\n                        // allow the correct page chunk to be loaded\n                        pathname = rewritesResult.resolvedHref;\n                        parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n                        if (!isMiddlewareMatch) {\n                            url = (0, _formatUrl).formatWithValidation(parsed);\n                        }\n                    }\n                } else {\n                    parsed.pathname = resolveDynamicRoute(pathname, pages);\n                    if (parsed.pathname !== pathname) {\n                        pathname = parsed.pathname;\n                        parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n                        if (!isMiddlewareMatch) {\n                            url = (0, _formatUrl).formatWithValidation(parsed);\n                        }\n                    }\n                }\n            }\n            if (!(0, _isLocalUrl).isLocalURL(as)) {\n                if (process.env.NODE_ENV !== 'production') {\n                    throw new Error(`Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` + `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`);\n                }\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                return false;\n            }\n            resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(resolvedAs), nextState.locale);\n            route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n            let routeMatch = false;\n            if ((0, _isDynamic).isDynamicRoute(route)) {\n                const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                const asPathname = parsedAs.pathname;\n                const routeRegex = (0, _routeRegex).getRouteRegex(route);\n                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                const shouldInterpolate = route === asPathname;\n                const interpolatedAs = shouldInterpolate ? (0, _interpolateAs).interpolateAs(route, asPathname, query) : {};\n                if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                    const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param] && !routeRegex.groups[param].optional);\n                    if (missingParams.length > 0 && !isMiddlewareMatch) {\n                        if (process.env.NODE_ENV !== 'production') {\n                            console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n                        }\n                        throw new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);\n                    }\n                } else if (shouldInterpolate) {\n                    as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs, {\n                        pathname: interpolatedAs.result,\n                        query: (0, _omit).omit(query, interpolatedAs.params)\n                    }));\n                } else {\n                    // Merge params into `query`, overwriting any specified in search\n                    Object.assign(query, routeMatch);\n                }\n            }\n            if (!isQueryUpdating) {\n                Router.events.emit('routeChangeStart', as, routeProps);\n            }\n            const isErrorRoute = _this.pathname === '/404' || _this.pathname === '/_error';\n            try {\n                var ref4, ref5, ref6;\n                let routeInfo = yield _this.getRouteInfo({\n                    route,\n                    pathname,\n                    query,\n                    as,\n                    resolvedAs,\n                    routeProps,\n                    locale: nextState.locale,\n                    isPreview: nextState.isPreview,\n                    hasMiddleware: isMiddlewareMatch,\n                    unstable_skipClientCache: options.unstable_skipClientCache,\n                    isQueryUpdating: isQueryUpdating && !_this.isFallback,\n                    isMiddlewareRewrite\n                });\n                if (!isQueryUpdating && !options.shallow) {\n                    yield _this._bfl(as, 'resolvedAs' in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n                }\n                if ('route' in routeInfo && isMiddlewareMatch) {\n                    pathname = routeInfo.route || route;\n                    route = pathname;\n                    if (!routeProps.shallow) {\n                        query = Object.assign({}, routeInfo.query || {}, query);\n                    }\n                    const cleanedParsedPathname = (0, _hasBasePath).hasBasePath(parsed.pathname) ? (0, _removeBasePath).removeBasePath(parsed.pathname) : parsed.pathname;\n                    if (routeMatch && pathname !== cleanedParsedPathname) {\n                        Object.keys(routeMatch).forEach((key)=>{\n                            if (routeMatch && query[key] === routeMatch[key]) {\n                                delete query[key];\n                            }\n                        });\n                    }\n                    if ((0, _isDynamic).isDynamicRoute(pathname)) {\n                        const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addBasePath).addBasePath((0, _addLocale).addLocale(new URL(as, location.href).pathname, nextState.locale), true);\n                        let rewriteAs = prefixedAs;\n                        if ((0, _hasBasePath).hasBasePath(rewriteAs)) {\n                            rewriteAs = (0, _removeBasePath).removeBasePath(rewriteAs);\n                        }\n                        if (process.env.__NEXT_I18N_SUPPORT) {\n                            const localeResult = (0, _normalizeLocalePath).normalizeLocalePath(rewriteAs, _this.locales);\n                            nextState.locale = localeResult.detectedLocale || nextState.locale;\n                            rewriteAs = localeResult.pathname;\n                        }\n                        const routeRegex = (0, _routeRegex).getRouteRegex(pathname);\n                        const curRouteMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(new URL(rewriteAs, location.href).pathname);\n                        if (curRouteMatch) {\n                            Object.assign(query, curRouteMatch);\n                        }\n                    }\n                }\n                // If the routeInfo brings a redirect we simply apply it.\n                if ('type' in routeInfo) {\n                    if (routeInfo.type === 'redirect-internal') {\n                        return _this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n                    } else {\n                        handleHardNavigation({\n                            url: routeInfo.destination,\n                            router: _this\n                        });\n                        return new Promise(()=>{});\n                    }\n                }\n                const component = routeInfo.Component;\n                if (component && component.unstable_scriptLoader) {\n                    const scripts = [].concat(component.unstable_scriptLoader());\n                    scripts.forEach((script)=>{\n                        (0, _script).handleClientScriptLoad(script.props);\n                    });\n                }\n                // handle redirect on client-transition\n                if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n                    if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                        // Use the destination from redirect without adding locale\n                        options.locale = false;\n                        const destination = routeInfo.props.pageProps.__N_REDIRECT;\n                        // check if destination is internal (resolves to a page) and attempt\n                        // client-navigation if it is falling back to hard navigation if\n                        // it's not\n                        if (destination.startsWith('/') && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                            const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                            const { url: newUrl , as: newAs  } = prepareUrlAs(_this, destination, destination);\n                            return _this.change(method, newUrl, newAs, options);\n                        }\n                        handleHardNavigation({\n                            url: destination,\n                            router: _this\n                        });\n                        return new Promise(()=>{});\n                    }\n                    nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                    // handle SSG data 404\n                    if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n                        let notFoundRoute;\n                        try {\n                            yield _this.fetchComponent('/404');\n                            notFoundRoute = '/404';\n                        } catch (_) {\n                            notFoundRoute = '/_error';\n                        }\n                        routeInfo = yield _this.getRouteInfo({\n                            route: notFoundRoute,\n                            pathname: notFoundRoute,\n                            query,\n                            as,\n                            resolvedAs,\n                            routeProps: {\n                                shallow: false\n                            },\n                            locale: nextState.locale,\n                            isPreview: nextState.isPreview,\n                            isNotFound: true\n                        });\n                        if ('type' in routeInfo) {\n                            throw new Error(`Unexpected middleware effect on /404`);\n                        }\n                    }\n                }\n                if (isQueryUpdating && _this.pathname === '/_error' && ((ref4 = self.__NEXT_DATA__.props) == null ? void 0 : (ref5 = ref4.pageProps) == null ? void 0 : ref5.statusCode) === 500 && ((ref6 = routeInfo.props) == null ? void 0 : ref6.pageProps)) {\n                    // ensure statusCode is still correct for static 500 page\n                    // when updating query information\n                    routeInfo.props.pageProps.statusCode = 500;\n                }\n                var _route;\n                // shallow routing is only allowed for same page URL changes.\n                const isValidShallowRoute = options.shallow && nextState.route === ((_route = routeInfo.route) != null ? _route : route);\n                var _scroll;\n                const shouldScroll = (_scroll = options.scroll) != null ? _scroll : !isQueryUpdating && !isValidShallowRoute;\n                const resetScroll = shouldScroll ? {\n                    x: 0,\n                    y: 0\n                } : null;\n                const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n                // the new state that the router gonna set\n                const upcomingRouterState = _extends({}, nextState, {\n                    route,\n                    pathname,\n                    query,\n                    asPath: cleanedAs,\n                    isFallback: false\n                });\n                // When the page being rendered is the 404 page, we should only update the\n                // query parameters. Route changes here might add the basePath when it\n                // wasn't originally present. This is also why this block is before the\n                // below `changeState` call which updates the browser's history (changing\n                // the URL).\n                if (isQueryUpdating && isErrorRoute) {\n                    var ref7, ref8, ref9;\n                    routeInfo = yield _this.getRouteInfo({\n                        route: _this.pathname,\n                        pathname: _this.pathname,\n                        query,\n                        as,\n                        resolvedAs,\n                        routeProps: {\n                            shallow: false\n                        },\n                        locale: nextState.locale,\n                        isPreview: nextState.isPreview,\n                        isQueryUpdating: isQueryUpdating && !_this.isFallback\n                    });\n                    if ('type' in routeInfo) {\n                        throw new Error(`Unexpected middleware effect on ${_this.pathname}`);\n                    }\n                    if (_this.pathname === '/_error' && ((ref7 = self.__NEXT_DATA__.props) == null ? void 0 : (ref8 = ref7.pageProps) == null ? void 0 : ref8.statusCode) === 500 && ((ref9 = routeInfo.props) == null ? void 0 : ref9.pageProps)) {\n                        // ensure statusCode is still correct for static 500 page\n                        // when updating query information\n                        routeInfo.props.pageProps.statusCode = 500;\n                    }\n                    try {\n                        yield _this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                    } catch (err) {\n                        if ((0, _isError).default(err) && err.cancelled) {\n                            Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n                        }\n                        throw err;\n                    }\n                    return true;\n                }\n                Router.events.emit('beforeHistoryChange', as, routeProps);\n                _this.changeState(method, url, as, options);\n                // for query updates we can skip it if the state is unchanged and we don't\n                // need to scroll\n                // https://github.com/vercel/next.js/issues/37139\n                const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _compareStates).compareRouterStates(upcomingRouterState, _this.state);\n                if (!canSkipUpdating) {\n                    try {\n                        yield _this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                    } catch (e) {\n                        if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                        else throw e;\n                    }\n                    if (routeInfo.error) {\n                        if (!isQueryUpdating) {\n                            Router.events.emit('routeChangeError', routeInfo.error, cleanedAs, routeProps);\n                        }\n                        throw routeInfo.error;\n                    }\n                    if (process.env.__NEXT_I18N_SUPPORT) {\n                        if (nextState.locale) {\n                            document.documentElement.lang = nextState.locale;\n                        }\n                    }\n                    if (!isQueryUpdating) {\n                        Router.events.emit('routeChangeComplete', as, routeProps);\n                    }\n                    // A hash mark # is the optional last part of a URL\n                    const hashRegex = /#.+$/;\n                    if (shouldScroll && hashRegex.test(as)) {\n                        _this.scrollToHash(as);\n                    }\n                }\n                return true;\n            } catch (err1) {\n                if ((0, _isError).default(err1) && err1.cancelled) {\n                    return false;\n                }\n                throw err1;\n            }\n        })();\n    }\n    changeState(method, url, as, options = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (typeof window.history === 'undefined') {\n                console.error(`Warning: window.history is not available.`);\n                return;\n            }\n            if (typeof window.history[method] === 'undefined') {\n                console.error(`Warning: window.history.${method} is not available`);\n                return;\n            }\n        }\n        if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                key: this._key = method !== 'pushState' ? this._key : createKey()\n            }, // Most browsers currently ignores this parameter, although they may use it in the future.\n            // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n            '', as);\n        }\n    }\n    handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            console.error(err);\n            if (err.cancelled) {\n                // bubble up cancellation errors\n                throw err;\n            }\n            if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {\n                Router.events.emit('routeChangeError', err, as, routeProps);\n                // If we can't load the page it could be one of following reasons\n                //  1. Page doesn't exists\n                //  2. Page does exist in a different zone\n                //  3. Internal error while loading the page\n                // So, doing a hard reload is the proper way to deal with this.\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                // Changing the URL doesn't block executing the current code path.\n                // So let's throw a cancellation error stop the routing logic.\n                throw buildCancellationError();\n            }\n            try {\n                let props;\n                const { page: Component , styleSheets  } = yield _this.fetchComponent('/_error');\n                const routeInfo = {\n                    props,\n                    Component,\n                    styleSheets,\n                    err,\n                    error: err\n                };\n                if (!routeInfo.props) {\n                    try {\n                        routeInfo.props = yield _this.getInitialProps(Component, {\n                            err,\n                            pathname,\n                            query\n                        });\n                    } catch (gipErr) {\n                        console.error('Error in error page `getInitialProps`: ', gipErr);\n                        routeInfo.props = {};\n                    }\n                }\n                return routeInfo;\n            } catch (routeInfoErr) {\n                return _this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ''), pathname, query, as, routeProps, true);\n            }\n        })();\n    }\n    getRouteInfo({ route: requestedRoute , pathname , query , as , resolvedAs , routeProps , locale , hasMiddleware , isPreview , unstable_skipClientCache , isQueryUpdating , isMiddlewareRewrite , isNotFound  }) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ let route = requestedRoute;\n            try {\n                var ref, ref10, ref11, ref12;\n                const handleCancelled = getCancelledHandler({\n                    route,\n                    router: _this\n                });\n                let existingInfo = _this.components[route];\n                if (routeProps.shallow && existingInfo && _this.route === route) {\n                    return existingInfo;\n                }\n                if (hasMiddleware) {\n                    existingInfo = undefined;\n                }\n                let cachedRouteInfo = existingInfo && !('initial' in existingInfo) && process.env.NODE_ENV !== 'development' ? existingInfo : undefined;\n                const isBackground = isQueryUpdating;\n                const fetchNextDataParams = {\n                    dataHref: _this.pageLoader.getDataHref({\n                        href: (0, _formatUrl).formatWithValidation({\n                            pathname,\n                            query\n                        }),\n                        skipInterpolation: true,\n                        asPath: isNotFound ? '/404' : resolvedAs,\n                        locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: _this.isSsr,\n                    parseJSON: true,\n                    inflightCache: isBackground ? _this.sbc : _this.sdc,\n                    persistCache: !isPreview,\n                    isPrefetch: false,\n                    unstable_skipClientCache,\n                    isBackground\n                };\n                let data = isQueryUpdating && !isMiddlewareRewrite ? null : yield withMiddlewareEffects({\n                    fetchData: ()=>fetchNextData(fetchNextDataParams),\n                    asPath: isNotFound ? '/404' : resolvedAs,\n                    locale: locale,\n                    router: _this\n                }).catch((err)=>{\n                    // we don't hard error during query updating\n                    // as it's un-necessary and doesn't need to be fatal\n                    // unless it is a fallback route and the props can't\n                    // be loaded\n                    if (isQueryUpdating) {\n                        return null;\n                    }\n                    throw err;\n                });\n                // when rendering error routes we don't apply middleware\n                // effects\n                if (data && (pathname === '/_error' || pathname === '/404')) {\n                    data.effect = undefined;\n                }\n                if (isQueryUpdating) {\n                    if (!data) {\n                        data = {\n                            json: self.__NEXT_DATA__.props\n                        };\n                    } else {\n                        data.json = self.__NEXT_DATA__.props;\n                    }\n                }\n                handleCancelled();\n                if ((data == null ? void 0 : (ref = data.effect) == null ? void 0 : ref.type) === 'redirect-internal' || (data == null ? void 0 : (ref10 = data.effect) == null ? void 0 : ref10.type) === 'redirect-external') {\n                    return data.effect;\n                }\n                if ((data == null ? void 0 : (ref11 = data.effect) == null ? void 0 : ref11.type) === 'rewrite') {\n                    const resolvedRoute = (0, _removeTrailingSlash).removeTrailingSlash(data.effect.resolvedHref);\n                    const pages = yield _this.pageLoader.getPageList();\n                    // during query updating the page must match although during\n                    // client-transition a redirect that doesn't match a page\n                    // can be returned and this should trigger a hard navigation\n                    // which is valid for incremental migration\n                    if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                        route = resolvedRoute;\n                        pathname = data.effect.resolvedHref;\n                        query = _extends({}, query, data.effect.parsedAs.query);\n                        resolvedAs = (0, _removeBasePath).removeBasePath((0, _normalizeLocalePath).normalizeLocalePath(data.effect.parsedAs.pathname, _this.locales).pathname);\n                        // Check again the cache with the new destination.\n                        existingInfo = _this.components[route];\n                        if (routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware) {\n                            // If we have a match with the current route due to rewrite,\n                            // we can copy the existing information to the rewritten one.\n                            // Then, we return the information along with the matched route.\n                            return _extends({}, existingInfo, {\n                                route\n                            });\n                        }\n                    }\n                }\n                if ((0, _isApiRoute).isAPIRoute(route)) {\n                    handleHardNavigation({\n                        url: as,\n                        router: _this\n                    });\n                    return new Promise(()=>{});\n                }\n                const routeInfo = cachedRouteInfo || (yield _this.fetchComponent(route).then((res)=>({\n                        Component: res.page,\n                        styleSheets: res.styleSheets,\n                        __N_SSG: res.mod.__N_SSG,\n                        __N_SSP: res.mod.__N_SSP\n                    })));\n                if (process.env.NODE_ENV !== 'production') {\n                    const { isValidElementType  } = require('next/dist/compiled/react-is');\n                    if (!isValidElementType(routeInfo.Component)) {\n                        throw new Error(`The default export is not a React Component in page: \"${pathname}\"`);\n                    }\n                }\n                const wasBailedPrefetch = data == null ? void 0 : (ref12 = data.response) == null ? void 0 : ref12.headers.get('x-middleware-skip');\n                const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n                // For non-SSG prefetches that bailed before sending data\n                // we clear the cache to fetch full response\n                if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                    delete _this.sdc[data.dataHref];\n                }\n                const { props , cacheKey  } = yield _this._getData(_async_to_generator(function*() {\n                    if (shouldFetchData) {\n                        if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n                            return {\n                                cacheKey: data.cacheKey,\n                                props: data.json\n                            };\n                        }\n                        const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this.pageLoader.getDataHref({\n                            href: (0, _formatUrl).formatWithValidation({\n                                pathname,\n                                query\n                            }),\n                            asPath: resolvedAs,\n                            locale\n                        });\n                        const fetched = yield fetchNextData({\n                            dataHref,\n                            isServerRender: _this.isSsr,\n                            parseJSON: true,\n                            inflightCache: wasBailedPrefetch ? {} : _this.sdc,\n                            persistCache: !isPreview,\n                            isPrefetch: false,\n                            unstable_skipClientCache\n                        });\n                        return {\n                            cacheKey: fetched.cacheKey,\n                            props: fetched.json || {}\n                        };\n                    }\n                    return {\n                        headers: {},\n                        props: yield _this.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`\n                        {\n                            pathname,\n                            query,\n                            asPath: as,\n                            locale,\n                            locales: _this.locales,\n                            defaultLocale: _this.defaultLocale\n                        })\n                    };\n                }));\n                // Only bust the data cache for SSP routes although\n                // middleware can skip cache per request with\n                // x-middleware-cache: no-cache as well\n                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                    delete _this.sdc[cacheKey];\n                }\n                // we kick off a HEAD request in the background\n                // when a non-prefetch request is made to signal revalidation\n                if (!_this.isPreview && routeInfo.__N_SSG && process.env.NODE_ENV !== 'development' && !isQueryUpdating) {\n                    fetchNextData(Object.assign({}, fetchNextDataParams, {\n                        isBackground: true,\n                        persistCache: false,\n                        inflightCache: _this.sbc\n                    })).catch(()=>{});\n                }\n                props.pageProps = Object.assign({}, props.pageProps);\n                routeInfo.props = props;\n                routeInfo.route = route;\n                routeInfo.query = query;\n                routeInfo.resolvedAs = resolvedAs;\n                _this.components[route] = routeInfo;\n                return routeInfo;\n            } catch (err) {\n                return _this.handleRouteInfoError((0, _isError).getProperError(err), pathname, query, as, routeProps);\n            }\n        })();\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split('#');\n        const [newUrlNoHash, newHash] = as.split('#');\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = ''] = as.split('#');\n        // Scroll to top if the hash is just `#` with no value or `#top`\n        // To mirror browsers\n        if (hash === '' || hash === 'top') {\n            (0, _handleSmoothScroll).handleSmoothScroll(()=>window.scrollTo(0, 0));\n            return;\n        }\n        // Decode hash to make non-latin anchor works.\n        const rawHash = decodeURIComponent(hash);\n        // First we check if the element by id is found\n        const idEl = document.getElementById(rawHash);\n        if (idEl) {\n            (0, _handleSmoothScroll).handleSmoothScroll(()=>idEl.scrollIntoView());\n            return;\n        }\n        // If there's no element with the id, we check the `name` property\n        // To mirror browsers\n        const nameEl = document.getElementsByName(rawHash)[0];\n        if (nameEl) {\n            (0, _handleSmoothScroll).handleSmoothScroll(()=>nameEl.scrollIntoView());\n        }\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ prefetch(url, asPath = url, options = {}) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            // Prefetch is not supported in development mode because it would trigger on-demand-entries\n            if (process.env.NODE_ENV !== 'production') {\n                return;\n            }\n            if (typeof window !== 'undefined' && (0, _isBot).isBot(window.navigator.userAgent)) {\n                // No prefetches for bots that render the link since they are typically navigating\n                // links via the equivalent of a hard navigation and hence never utilize these\n                // prefetches.\n                return;\n            }\n            let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            let { pathname , query  } = parsed;\n            const originalPathname = pathname;\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                if (options.locale === false) {\n                    pathname = (0, _normalizeLocalePath).normalizeLocalePath(pathname, _this.locales).pathname;\n                    parsed.pathname = pathname;\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                    let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n                    const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);\n                    parsedAs.pathname = localePathResult.pathname;\n                    options.locale = localePathResult.detectedLocale || _this.defaultLocale;\n                    asPath = (0, _formatUrl).formatWithValidation(parsedAs);\n                }\n            }\n            const pages = yield _this.pageLoader.getPageList();\n            let resolvedAs = asPath;\n            const locale = typeof options.locale !== 'undefined' ? options.locale || undefined : _this.locale;\n            const isMiddlewareMatch = yield matchesMiddleware({\n                asPath: asPath,\n                locale: locale,\n                router: _this\n            });\n            if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/')) {\n                let rewrites;\n                ({ __rewrites: rewrites  } = yield (0, _routeLoader).getClientBuildManifest());\n                const rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(asPath, _this.locale), true), pages, rewrites, parsed.query, (p)=>resolveDynamicRoute(p, pages), _this.locales);\n                if (rewritesResult.externalDest) {\n                    return;\n                }\n                if (!isMiddlewareMatch) {\n                    resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(rewritesResult.asPath), _this.locale);\n                }\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                    // if this directly matches a page we need to update the href to\n                    // allow the correct page chunk to be loaded\n                    pathname = rewritesResult.resolvedHref;\n                    parsed.pathname = pathname;\n                    if (!isMiddlewareMatch) {\n                        url = (0, _formatUrl).formatWithValidation(parsed);\n                    }\n                }\n            }\n            parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n            if ((0, _isDynamic).isDynamicRoute(parsed.pathname)) {\n                pathname = parsed.pathname;\n                parsed.pathname = pathname;\n                Object.assign(query, (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(parsed.pathname))((0, _parsePath).parsePath(asPath).pathname) || {});\n                if (!isMiddlewareMatch) {\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                }\n            }\n            const data = process.env.__NEXT_MIDDLEWARE_PREFETCH === 'strict' ? null : yield withMiddlewareEffects({\n                fetchData: ()=>fetchNextData({\n                        dataHref: _this.pageLoader.getDataHref({\n                            href: (0, _formatUrl).formatWithValidation({\n                                pathname: originalPathname,\n                                query\n                            }),\n                            skipInterpolation: true,\n                            asPath: resolvedAs,\n                            locale\n                        }),\n                        hasMiddleware: true,\n                        isServerRender: _this.isSsr,\n                        parseJSON: true,\n                        inflightCache: _this.sdc,\n                        persistCache: !_this.isPreview,\n                        isPrefetch: true\n                    }),\n                asPath: asPath,\n                locale: locale,\n                router: _this\n            });\n            /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if ((data == null ? void 0 : data.effect.type) === 'rewrite') {\n                parsed.pathname = data.effect.resolvedHref;\n                pathname = data.effect.resolvedHref;\n                query = _extends({}, query, data.effect.parsedAs.query);\n                resolvedAs = data.effect.parsedAs.pathname;\n                url = (0, _formatUrl).formatWithValidation(parsed);\n            }\n            /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if ((data == null ? void 0 : data.effect.type) === 'redirect-external') {\n                return;\n            }\n            const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n            yield Promise.all([\n                _this.pageLoader._isSsg(route).then((isSsg)=>{\n                    return isSsg ? fetchNextData({\n                        dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this.pageLoader.getDataHref({\n                            href: url,\n                            asPath: resolvedAs,\n                            locale: locale\n                        }),\n                        isServerRender: false,\n                        parseJSON: true,\n                        inflightCache: _this.sdc,\n                        persistCache: !_this.isPreview,\n                        isPrefetch: true,\n                        unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE\n                    }).then(()=>false) : false;\n                }),\n                _this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route), \n            ]);\n        })();\n    }\n    fetchComponent(route) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            const handleCancelled = getCancelledHandler({\n                route,\n                router: _this\n            });\n            try {\n                const componentResult = yield _this.pageLoader.loadPage(route);\n                handleCancelled();\n                return componentResult;\n            } catch (err) {\n                handleCancelled();\n                throw err;\n            }\n        })();\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = new Error('Loading initial props cancelled');\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    _getFlightData(dataHref) {\n        // Do not cache RSC flight response since it's not a static resource\n        return fetchNextData({\n            dataHref,\n            isServerRender: true,\n            parseJSON: false,\n            inflightCache: this.sdc,\n            persistCache: false,\n            isPrefetch: false\n        }).then(({ text  })=>({\n                data: text\n            }));\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App  } = this.components['/_app'];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils).loadGetInitialProps(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n    constructor(pathname1, query1, as1, { initialProps , pageLoader , App , wrapApp , Component , err , subscription , isFallback , locale , locales , defaultLocale , domainLocales , isPreview  }){\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = (e)=>{\n            const { isFirstPopStateEvent  } = this;\n            this.isFirstPopStateEvent = false;\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname , query  } = this;\n                this.changeState('replaceState', (0, _formatUrl).formatWithValidation({\n                    pathname: (0, _addBasePath).addBasePath(pathname),\n                    query\n                }), (0, _utils).getURL());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n                return;\n            }\n            let forcedScroll;\n            const { url , as , options , key  } = state;\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    if (this._key !== key) {\n                        // Snapshot current scroll position:\n                        try {\n                            sessionStorage.setItem('__next_scroll_' + this._key, JSON.stringify({\n                                x: self.pageXOffset,\n                                y: self.pageYOffset\n                            }));\n                        } catch (e) {}\n                        // Restore old scroll position:\n                        try {\n                            const v = sessionStorage.getItem('__next_scroll_' + key);\n                            forcedScroll = JSON.parse(v);\n                        } catch (e1) {\n                            forcedScroll = {\n                                x: 0,\n                                y: 0\n                            };\n                        }\n                    }\n                }\n            }\n            this._key = key;\n            const { pathname  } = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === (0, _addBasePath).addBasePath(this.asPath) && pathname === (0, _addBasePath).addBasePath(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change('replaceState', url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname1);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname1 !== '/_error') {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {\n            const { BloomFilter  } = require('../../lib/bloom-filter');\n            const staticFilterData = process.env.__NEXT_CLIENT_ROUTER_S_FILTER;\n            const dynamicFilterData = process.env.__NEXT_CLIENT_ROUTER_D_FILTER;\n            if (staticFilterData == null ? void 0 : staticFilterData.hashes) {\n                this._bfl_s = new BloomFilter(staticFilterData.size, staticFilterData.hashes);\n                this._bfl_s.import(staticFilterData);\n            }\n            if (dynamicFilterData == null ? void 0 : dynamicFilterData.hashes) {\n                this._bfl_d = new BloomFilter(dynamicFilterData.size, dynamicFilterData.hashes);\n                this._bfl_d.import(dynamicFilterData);\n            }\n        }\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;\n        this.basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            this.locales = locales;\n            this.defaultLocale = defaultLocale;\n            this.domainLocales = domainLocales;\n            this.isLocaleDomain = !!(0, _detectDomainLocale).detectDomainLocale(domainLocales, self.location.hostname);\n        }\n        this.state = {\n            route,\n            pathname: pathname1,\n            query: query1,\n            asPath: autoExportDynamic ? pathname1 : as1,\n            isPreview: !!isPreview,\n            locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n            isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (typeof window !== 'undefined') {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as1.startsWith('//')) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                const asPath = (0, _utils).getURL();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale,\n                    asPath\n                }).then((matches)=>{\n                    options._shouldResolveHref = as1 !== pathname1;\n                    this.changeState('replaceState', matches ? asPath : (0, _formatUrl).formatWithValidation({\n                        pathname: (0, _addBasePath).addBasePath(pathname1),\n                        query: query1\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    window.history.scrollRestoration = 'manual';\n                }\n            }\n        }\n    }\n}\nRouter.events = (0, _mitt).default();\nexports.default = Router;\n\n//# sourceMappingURL=router.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.addLocale = addLocale;\nvar _addPathPrefix = require(\"./add-path-prefix\");\nvar _pathHasPrefix = require(\"./path-has-prefix\");\nfunction addLocale(path, locale, defaultLocale, ignorePrefix) {\n    if (locale && locale !== defaultLocale && (ignorePrefix || !(0, _pathHasPrefix).pathHasPrefix(path.toLowerCase(), `/${locale.toLowerCase()}`) && !(0, _pathHasPrefix).pathHasPrefix(path.toLowerCase(), '/api'))) {\n        return (0, _addPathPrefix).addPathPrefix(path, `/${locale}`);\n    }\n    return path;\n}\n\n//# sourceMappingURL=add-locale.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.addPathPrefix = addPathPrefix;\nvar _parsePath = require(\"./parse-path\");\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith('/') || !prefix) {\n        return path;\n    }\n    const { pathname , query , hash  } = (0, _parsePath).parsePath(path);\n    return `${prefix}${pathname}${query}${hash}`;\n}\n\n//# sourceMappingURL=add-path-prefix.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.addPathSuffix = addPathSuffix;\nvar _parsePath = require(\"./parse-path\");\nfunction addPathSuffix(path, suffix) {\n    if (!path.startsWith('/') || !suffix) {\n        return path;\n    }\n    const { pathname , query , hash  } = (0, _parsePath).parsePath(path);\n    return `${pathname}${suffix}${query}${hash}`;\n}\n\n//# sourceMappingURL=add-path-suffix.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.compareRouterStates = compareRouterStates;\nfunction compareRouterStates(a, b) {\n    const stateKeys = Object.keys(a);\n    if (stateKeys.length !== Object.keys(b).length) return false;\n    for(let i = stateKeys.length; i--;){\n        const key = stateKeys[i];\n        if (key === 'query') {\n            const queryKeys = Object.keys(a.query);\n            if (queryKeys.length !== Object.keys(b.query).length) {\n                return false;\n            }\n            for(let j = queryKeys.length; j--;){\n                const queryKey = queryKeys[j];\n                if (!b.query.hasOwnProperty(queryKey) || a.query[queryKey] !== b.query[queryKey]) {\n                    return false;\n                }\n            }\n        } else if (!b.hasOwnProperty(key) || a[key] !== b[key]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//# sourceMappingURL=compare-states.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.formatNextPathnameInfo = formatNextPathnameInfo;\nvar _removeTrailingSlash = require(\"./remove-trailing-slash\");\nvar _addPathPrefix = require(\"./add-path-prefix\");\nvar _addPathSuffix = require(\"./add-path-suffix\");\nvar _addLocale = require(\"./add-locale\");\nfunction formatNextPathnameInfo(info) {\n    let pathname = (0, _addLocale).addLocale(info.pathname, info.locale, info.buildId ? undefined : info.defaultLocale, info.ignorePrefix);\n    if (info.buildId || !info.trailingSlash) {\n        pathname = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n    }\n    if (info.buildId) {\n        pathname = (0, _addPathSuffix).addPathSuffix((0, _addPathPrefix).addPathPrefix(pathname, `/_next/data/${info.buildId}`), info.pathname === '/' ? 'index.json' : '.json');\n    }\n    pathname = (0, _addPathPrefix).addPathPrefix(pathname, info.basePath);\n    return !info.buildId && info.trailingSlash ? !pathname.endsWith('/') ? (0, _addPathSuffix).addPathSuffix(pathname, '/') : pathname : (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n}\n\n//# sourceMappingURL=format-next-pathname-info.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.formatUrl = formatUrl;\nexports.formatWithValidation = formatWithValidation;\nexports.urlObjectKeys = void 0;\nvar _interop_require_wildcard = require(\"@swc/helpers/lib/_interop_require_wildcard.js\").default;\nvar querystring = _interop_require_wildcard(require(\"./querystring\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth , hostname  } = urlObj;\n    let protocol = urlObj.protocol || '';\n    let pathname = urlObj.pathname || '';\n    let hash = urlObj.hash || '';\n    let query = urlObj.query || '';\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname);\n        if (urlObj.port) {\n            host += ':' + urlObj.port;\n        }\n    }\n    if (query && typeof query === 'object') {\n        query = String(querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && `?${query}` || '';\n    if (protocol && !protocol.endsWith(':')) protocol += ':';\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n    } else if (!host) {\n        host = '';\n    }\n    if (hash && hash[0] !== '#') hash = '#' + hash;\n    if (search && search[0] !== '?') search = '?' + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace('#', '%23');\n    return `${protocol}${host}${pathname}${search}${hash}`;\n}\nconst urlObjectKeys = [\n    'auth',\n    'hash',\n    'host',\n    'hostname',\n    'href',\n    'path',\n    'pathname',\n    'port',\n    'protocol',\n    'query',\n    'search',\n    'slashes', \n];\nexports.urlObjectKeys = urlObjectKeys;\nfunction formatWithValidation(url) {\n    if (process.env.NODE_ENV === 'development') {\n        if (url !== null && typeof url === 'object') {\n            Object.keys(url).forEach((key)=>{\n                if (urlObjectKeys.indexOf(key) === -1) {\n                    console.warn(`Unknown key passed via urlObject into url.format: ${key}`);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n}\n\n//# sourceMappingURL=format-url.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = getAssetPathFromRoute;\nfunction getAssetPathFromRoute(route, ext = '') {\n    const path = route === '/' ? '/index' : /^\\/index(\\/|$)/.test(route) ? `/index${route}` : `${route}`;\n    return path + ext;\n}\n\n//# sourceMappingURL=get-asset-path-from-route.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getNextPathnameInfo = getNextPathnameInfo;\nvar _normalizeLocalePath = require(\"../../i18n/normalize-locale-path\");\nvar _removePathPrefix = require(\"./remove-path-prefix\");\nvar _pathHasPrefix = require(\"./path-has-prefix\");\nfunction getNextPathnameInfo(pathname, options) {\n    var _nextConfig;\n    const { basePath , i18n , trailingSlash  } = (_nextConfig = options.nextConfig) != null ? _nextConfig : {};\n    const info = {\n        pathname: pathname,\n        trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash\n    };\n    if (basePath && (0, _pathHasPrefix).pathHasPrefix(info.pathname, basePath)) {\n        info.pathname = (0, _removePathPrefix).removePathPrefix(info.pathname, basePath);\n        info.basePath = basePath;\n    }\n    if (options.parseData === true && info.pathname.startsWith('/_next/data/') && info.pathname.endsWith('.json')) {\n        const paths = info.pathname.replace(/^\\/_next\\/data\\//, '').replace(/\\.json$/, '').split('/');\n        const buildId = paths[0];\n        info.pathname = paths[1] !== 'index' ? `/${paths.slice(1).join('/')}` : '/';\n        info.buildId = buildId;\n    }\n    if (i18n) {\n        const pathLocale = (0, _normalizeLocalePath).normalizeLocalePath(info.pathname, i18n.locales);\n        info.locale = pathLocale == null ? void 0 : pathLocale.detectedLocale;\n        info.pathname = (pathLocale == null ? void 0 : pathLocale.pathname) || info.pathname;\n    }\n    return info;\n}\n\n//# sourceMappingURL=get-next-pathname-info.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.handleSmoothScroll = handleSmoothScroll;\nfunction handleSmoothScroll(fn, options = {}) {\n    const htmlElement = document.documentElement;\n    const existing = htmlElement.style.scrollBehavior;\n    htmlElement.style.scrollBehavior = 'auto';\n    if (!options.dontForceLayout) {\n        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n        // Otherwise it will not pickup the change in scrollBehavior\n        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n        htmlElement.getClientRects();\n    }\n    fn();\n    htmlElement.style.scrollBehavior = existing;\n}\n\n//# sourceMappingURL=handle-smooth-scroll.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"getSortedRoutes\", {\n    enumerable: true,\n    get: function() {\n        return _sortedRoutes.getSortedRoutes;\n    }\n});\nObject.defineProperty(exports, \"isDynamicRoute\", {\n    enumerable: true,\n    get: function() {\n        return _isDynamic.isDynamicRoute;\n    }\n});\nvar _sortedRoutes = require(\"./sorted-routes\");\nvar _isDynamic = require(\"./is-dynamic\");\n\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.interpolateAs = interpolateAs;\nvar _routeMatcher = require(\"./route-matcher\");\nvar _routeRegex = require(\"./route-regex\");\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = '';\n    const dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = // Try to match the dynamic route against the asPath\n    (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || '';\n        const { repeat , optional  } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = `[${repeat ? '...' : ''}${param}]`;\n        if (optional) {\n            replaced = `${!value ? '/' : ''}[${replaced}]`;\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// these values should be fully encoded instead of just\n        // path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');\n    })) {\n        interpolatedRoute = '' // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n}\n\n//# sourceMappingURL=interpolate-as.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isBot = isBot;\nfunction isBot(userAgent) {\n    return /Googlebot|Mediapartners-Google|AdsBot-Google|googleweblight|Storebot-Google|Google-PageRenderer|Bingbot|BingPreview|Slurp|DuckDuckBot|baiduspider|yandex|sogou|LinkedInBot|bitlybot|tumblr|vkShare|quora link preview|facebookexternalhit|facebookcatalog|Twitterbot|applebot|redditbot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|ia_archiver/i.test(userAgent);\n}\n\n//# sourceMappingURL=is-bot.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isDynamicRoute = isDynamicRoute;\n// Identify /[param]/ in route string\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    return TEST_ROUTE.test(route);\n}\n\n//# sourceMappingURL=is-dynamic.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isLocalURL = isLocalURL;\nvar _utils = require(\"../../utils\");\nvar _hasBasePath = require(\"../../../../client/has-base-path\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils).isAbsoluteUrl(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils).getLocationOrigin();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasBasePath).hasBasePath(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\n\n//# sourceMappingURL=is-local-url.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.omit = omit;\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n}\n\n//# sourceMappingURL=omit.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.parseRelativeUrl = parseRelativeUrl;\nvar _utils = require(\"../../utils\");\nvar _querystring = require(\"./querystring\");\nfunction parseRelativeUrl(url, base) {\n    const globalBase = new URL(typeof window === 'undefined' ? 'http://n' : (0, _utils).getLocationOrigin());\n    const resolvedBase = base ? new URL(base, globalBase) : url.startsWith('.') ? new URL(typeof window === 'undefined' ? 'http://n' : window.location.href) : globalBase;\n    const { pathname , searchParams , search , hash , href , origin  } = new URL(url, resolvedBase);\n    if (origin !== globalBase.origin) {\n        throw new Error(`invariant: invalid relative URL, router received ${url}`);\n    }\n    return {\n        pathname,\n        query: (0, _querystring).searchParamsToUrlQuery(searchParams),\n        search,\n        hash,\n        href: href.slice(globalBase.origin.length)\n    };\n}\n\n//# sourceMappingURL=parse-relative-url.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.parseUrl = parseUrl;\nvar _querystring = require(\"./querystring\");\nvar _parseRelativeUrl = require(\"./parse-relative-url\");\nfunction parseUrl(url) {\n    if (url.startsWith('/')) {\n        return (0, _parseRelativeUrl).parseRelativeUrl(url);\n    }\n    const parsedURL = new URL(url);\n    return {\n        hash: parsedURL.hash,\n        hostname: parsedURL.hostname,\n        href: parsedURL.href,\n        pathname: parsedURL.pathname,\n        port: parsedURL.port,\n        protocol: parsedURL.protocol,\n        query: (0, _querystring).searchParamsToUrlQuery(parsedURL.searchParams),\n        search: parsedURL.search\n    };\n}\n\n//# sourceMappingURL=parse-url.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.pathHasPrefix = pathHasPrefix;\nvar _parsePath = require(\"./parse-path\");\nfunction pathHasPrefix(path, prefix) {\n    if (typeof path !== 'string') {\n        return false;\n    }\n    const { pathname  } = (0, _parsePath).parsePath(path);\n    return pathname === prefix || pathname.startsWith(prefix + '/');\n}\n\n//# sourceMappingURL=path-has-prefix.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getPathMatch = getPathMatch;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\nfunction getPathMatch(path, options) {\n    const keys = [];\n    const regexp = (0, _pathToRegexp).pathToRegexp(path, keys, {\n        delimiter: '/',\n        sensitive: false,\n        strict: options == null ? void 0 : options.strict\n    });\n    const matcher = (0, _pathToRegexp).regexpToFunction((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);\n    /**\n   * A matcher function that will check if a given pathname matches the path\n   * given in the builder function. When the path does not match it will return\n   * `false` but if it does it will return an object with the matched params\n   * merged with the params provided in the second argument.\n   */ return (pathname, params)=>{\n        const res = pathname == null ? false : matcher(pathname);\n        if (!res) {\n            return false;\n        }\n        /**\n     * If unnamed params are not allowed they must be removed from\n     * the matched parameters. path-to-regexp uses \"string\" for named and\n     * \"number\" for unnamed parameters.\n     */ if (options == null ? void 0 : options.removeUnnamedParams) {\n            for (const key of keys){\n                if (typeof key.name === 'number') {\n                    delete res.params[key.name];\n                }\n            }\n        }\n        return _extends({}, params, res.params);\n    };\n}\n\n//# sourceMappingURL=path-match.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.matchHas = matchHas;\nexports.compileNonPath = compileNonPath;\nexports.prepareDestination = prepareDestination;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\nvar _escapeRegexp = require(\"../../escape-regexp\");\nvar _parseUrl = require(\"./parse-url\");\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */ function getSafeParamName(paramName) {\n    let newParamName = '';\n    for(let i = 0; i < paramName.length; i++){\n        const charCode = paramName.charCodeAt(i);\n        if (charCode > 64 && charCode < 91 || charCode > 96 && charCode < 123 // a-z\n        ) {\n            newParamName += paramName[i];\n        }\n    }\n    return newParamName;\n}\nfunction escapeSegment(str, segmentName) {\n    return str.replace(new RegExp(`:${(0, _escapeRegexp).escapeStringRegexp(segmentName)}`, 'g'), `__ESC_COLON_${segmentName}`);\n}\nfunction unescapeSegments(str) {\n    return str.replace(/__ESC_COLON_/gi, ':');\n}\nfunction matchHas(req, query, has = [], missing = []) {\n    const params = {};\n    const hasMatch = (hasItem)=>{\n        let value;\n        let key = hasItem.key;\n        switch(hasItem.type){\n            case 'header':\n                {\n                    key = key.toLowerCase();\n                    value = req.headers[key];\n                    break;\n                }\n            case 'cookie':\n                {\n                    value = req.cookies[hasItem.key];\n                    break;\n                }\n            case 'query':\n                {\n                    value = query[key];\n                    break;\n                }\n            case 'host':\n                {\n                    const { host  } = (req == null ? void 0 : req.headers) || {};\n                    // remove port from host if present\n                    const hostname = host == null ? void 0 : host.split(':')[0].toLowerCase();\n                    value = hostname;\n                    break;\n                }\n            default:\n                {\n                    break;\n                }\n        }\n        if (!hasItem.value && value) {\n            params[getSafeParamName(key)] = value;\n            return true;\n        } else if (value) {\n            const matcher = new RegExp(`^${hasItem.value}$`);\n            const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);\n            if (matches) {\n                if (Array.isArray(matches)) {\n                    if (matches.groups) {\n                        Object.keys(matches.groups).forEach((groupKey)=>{\n                            params[groupKey] = matches.groups[groupKey];\n                        });\n                    } else if (hasItem.type === 'host' && matches[0]) {\n                        params.host = matches[0];\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    const allMatch = has.every((item)=>hasMatch(item)) && !missing.some((item)=>hasMatch(item));\n    if (allMatch) {\n        return params;\n    }\n    return false;\n}\nfunction compileNonPath(value, params) {\n    if (!value.includes(':')) {\n        return value;\n    }\n    for (const key of Object.keys(params)){\n        if (value.includes(`:${key}`)) {\n            value = value.replace(new RegExp(`:${key}\\\\*`, 'g'), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\\\?`, 'g'), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\\\w)`, 'g'), `--ESCAPED_PARAM_COLON${key}`);\n        }\n    }\n    value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*');\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    return (0, _pathToRegexp).compile(`/${value}`, {\n        validate: false\n    })(params).slice(1);\n}\nfunction prepareDestination(args) {\n    const query = Object.assign({}, args.query);\n    delete query.__nextLocale;\n    delete query.__nextDefaultLocale;\n    delete query.__nextDataReq;\n    let escapedDestination = args.destination;\n    for (const param of Object.keys(_extends({}, args.params, query))){\n        escapedDestination = escapeSegment(escapedDestination, param);\n    }\n    const parsedDestination = (0, _parseUrl).parseUrl(escapedDestination);\n    const destQuery = parsedDestination.query;\n    const destPath = unescapeSegments(`${parsedDestination.pathname}${parsedDestination.hash || ''}`);\n    const destHostname = unescapeSegments(parsedDestination.hostname || '');\n    const destPathParamKeys = [];\n    const destHostnameParamKeys = [];\n    (0, _pathToRegexp).pathToRegexp(destPath, destPathParamKeys);\n    (0, _pathToRegexp).pathToRegexp(destHostname, destHostnameParamKeys);\n    const destParams = [];\n    destPathParamKeys.forEach((key)=>destParams.push(key.name));\n    destHostnameParamKeys.forEach((key)=>destParams.push(key.name));\n    const destPathCompiler = (0, _pathToRegexp).compile(destPath, // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    {\n        validate: false\n    });\n    const destHostnameCompiler = (0, _pathToRegexp).compile(destHostname, {\n        validate: false\n    });\n    // update any params in query values\n    for (const [key1, strOrArray] of Object.entries(destQuery)){\n        // the value needs to start with a forward-slash to be compiled\n        // correctly\n        if (Array.isArray(strOrArray)) {\n            destQuery[key1] = strOrArray.map((value)=>compileNonPath(unescapeSegments(value), args.params));\n        } else if (typeof strOrArray === 'string') {\n            destQuery[key1] = compileNonPath(unescapeSegments(strOrArray), args.params);\n        }\n    }\n    // add path params to query if it's not a redirect and not\n    // already defined in destination query or path\n    let paramKeys = Object.keys(args.params).filter((name)=>name !== 'nextInternalLocale');\n    if (args.appendParamsToQuery && !paramKeys.some((key)=>destParams.includes(key))) {\n        for (const key of paramKeys){\n            if (!(key in destQuery)) {\n                destQuery[key] = args.params[key];\n            }\n        }\n    }\n    let newUrl;\n    try {\n        newUrl = destPathCompiler(args.params);\n        const [pathname, hash] = newUrl.split('#');\n        parsedDestination.hostname = destHostnameCompiler(args.params);\n        parsedDestination.pathname = pathname;\n        parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n        delete parsedDestination.search;\n    } catch (err) {\n        if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n            throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`);\n        }\n        throw err;\n    }\n    // Query merge order lowest priority to highest\n    // 1. initial URL query values\n    // 2. path segment values\n    // 3. destination specified query values\n    parsedDestination.query = _extends({}, query, parsedDestination.query);\n    return {\n        newUrl,\n        destQuery,\n        parsedDestination\n    };\n}\n\n//# sourceMappingURL=prepare-destination.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.searchParamsToUrlQuery = searchParamsToUrlQuery;\nexports.urlQueryToSearchParams = urlQueryToSearchParams;\nexports.assign = assign;\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === 'undefined') {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {\n        return String(param);\n    } else {\n        return '';\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach(([key, value])=>{\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target, ...searchParamsList) {\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n}\n\n//# sourceMappingURL=querystring.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.removePathPrefix = removePathPrefix;\nvar _pathHasPrefix = require(\"./path-has-prefix\");\nfunction removePathPrefix(path, prefix) {\n    if ((0, _pathHasPrefix).pathHasPrefix(path, prefix)) {\n        const withoutPrefix = path.slice(prefix.length);\n        return withoutPrefix.startsWith('/') ? withoutPrefix : `/${withoutPrefix}`;\n    }\n    return path;\n}\n\n//# sourceMappingURL=remove-path-prefix.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.resolveHref = resolveHref;\nvar _querystring = require(\"./querystring\");\nvar _formatUrl = require(\"./format-url\");\nvar _omit = require(\"./omit\");\nvar _utils = require(\"../../utils\");\nvar _normalizeTrailingSlash = require(\"../../../../client/normalize-trailing-slash\");\nvar _isLocalUrl = require(\"./is-local-url\");\nvar _isDynamic = require(\"./is-dynamic\");\nvar _interpolateAs = require(\"./interpolate-as\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === 'string' ? href : (0, _formatUrl).formatWithValidation(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split('?');\n    if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n        console.error(`Invalid href '${urlAsString}' passed to next/router in page: '${router.pathname}'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.`);\n        const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _isLocalUrl).isLocalURL(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL('/', 'http://n');\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n        let interpolatedAs = '';\n        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n            const { result , params  } = (0, _interpolateAs).interpolateAs(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formatUrl).formatWithValidation({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit).omit(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_1) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\n\n//# sourceMappingURL=resolve-href.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = resolveRewrites;\nvar _pathMatch = require(\"./path-match\");\nvar _prepareDestination = require(\"./prepare-destination\");\nvar _removeTrailingSlash = require(\"./remove-trailing-slash\");\nvar _normalizeLocalePath = require(\"../../i18n/normalize-locale-path\");\nvar _removeBasePath = require(\"../../../../client/remove-base-path\");\nvar _parseRelativeUrl = require(\"./parse-relative-url\");\nfunction resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {\n    let matchedPage = false;\n    let externalDest = false;\n    let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n    let fsPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedAs.pathname), locales).pathname);\n    let resolvedHref;\n    const handleRewrite = (rewrite)=>{\n        const matcher = (0, _pathMatch).getPathMatch(rewrite.source + (process.env.__NEXT_TRAILING_SLASH ? '(/)?' : ''), {\n            removeUnnamedParams: true,\n            strict: true\n        });\n        let params = matcher(parsedAs.pathname);\n        if ((rewrite.has || rewrite.missing) && params) {\n            const hasParams = (0, _prepareDestination).matchHas({\n                headers: {\n                    host: document.location.hostname\n                },\n                cookies: document.cookie.split('; ').reduce((acc, item)=>{\n                    const [key, ...value] = item.split('=');\n                    acc[key] = value.join('=');\n                    return acc;\n                }, {})\n            }, parsedAs.query, rewrite.has, rewrite.missing);\n            if (hasParams) {\n                Object.assign(params, hasParams);\n            } else {\n                params = false;\n            }\n        }\n        if (params) {\n            if (!rewrite.destination) {\n                // this is a proxied rewrite which isn't handled on the client\n                externalDest = true;\n                return true;\n            }\n            const destRes = (0, _prepareDestination).prepareDestination({\n                appendParamsToQuery: true,\n                destination: rewrite.destination,\n                params: params,\n                query: query\n            });\n            parsedAs = destRes.parsedDestination;\n            asPath = destRes.newUrl;\n            Object.assign(query, destRes.parsedDestination.query);\n            fsPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(asPath), locales).pathname);\n            if (pages.includes(fsPathname)) {\n                // check if we now match a page as this means we are done\n                // resolving the rewrites\n                matchedPage = true;\n                resolvedHref = fsPathname;\n                return true;\n            }\n            // check if we match a dynamic-route, if so we break the rewrites chain\n            resolvedHref = resolveHref(fsPathname);\n            if (resolvedHref !== asPath && pages.includes(resolvedHref)) {\n                matchedPage = true;\n                return true;\n            }\n        }\n    };\n    let finished = false;\n    for(let i = 0; i < rewrites.beforeFiles.length; i++){\n        // we don't end after match in beforeFiles to allow\n        // continuing through all beforeFiles rewrites\n        handleRewrite(rewrites.beforeFiles[i]);\n    }\n    matchedPage = pages.includes(fsPathname);\n    if (!matchedPage) {\n        if (!finished) {\n            for(let i = 0; i < rewrites.afterFiles.length; i++){\n                if (handleRewrite(rewrites.afterFiles[i])) {\n                    finished = true;\n                    break;\n                }\n            }\n        }\n        // check dynamic route before processing fallback rewrites\n        if (!finished) {\n            resolvedHref = resolveHref(fsPathname);\n            matchedPage = pages.includes(resolvedHref);\n            finished = matchedPage;\n        }\n        if (!finished) {\n            for(let i = 0; i < rewrites.fallback.length; i++){\n                if (handleRewrite(rewrites.fallback[i])) {\n                    finished = true;\n                    break;\n                }\n            }\n        }\n    }\n    return {\n        asPath,\n        parsedAs,\n        matchedPage,\n        resolvedHref,\n        externalDest\n    };\n}\n\n//# sourceMappingURL=resolve-rewrites.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getRouteMatcher = getRouteMatcher;\nvar _utils = require(\"../../utils\");\nfunction getRouteMatcher({ re , groups  }) {\n    return (pathname)=>{\n        const routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        const decode = (param)=>{\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError('failed to decode param');\n            }\n        };\n        const params = {};\n        Object.keys(groups).forEach((slugName)=>{\n            const g = groups[slugName];\n            const m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf('/') ? m.split('/').map((entry)=>decode(entry)) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n}\n\n//# sourceMappingURL=route-matcher.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getRouteRegex = getRouteRegex;\nexports.getNamedRouteRegex = getNamedRouteRegex;\nexports.getNamedMiddlewareRegex = getNamedMiddlewareRegex;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _escapeRegexp = require(\"../../escape-regexp\");\nvar _removeTrailingSlash = require(\"./remove-trailing-slash\");\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ name: 'slug', repeat: true, optional: true }`\n *   - `[foo]` -> `{ name: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ name: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    const optional = param.startsWith('[') && param.endsWith(']');\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith('...');\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            if (segment.startsWith('[') && segment.endsWith(']')) {\n                const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n            } else {\n                return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;\n            }\n        }).join(''),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute , groups  } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let routeKeyCharCode = 97;\n    let routeKeyCharLength = 1;\n    return ()=>{\n        let routeKey = '';\n        for(let i = 0; i < routeKeyCharLength; i++){\n            routeKey += String.fromCharCode(routeKeyCharCode);\n            routeKeyCharCode++;\n            if (routeKeyCharCode > 122) {\n                routeKeyCharLength++;\n                routeKeyCharCode = 97;\n            }\n        }\n        return routeKey;\n    };\n}\nfunction getNamedParametrizedRoute(route) {\n    const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            if (segment.startsWith('[') && segment.endsWith(']')) {\n                const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));\n                // replace any non-word characters since they can break\n                // the named regex\n                let cleanedKey = key.replace(/\\W/g, '');\n                let invalidKey = false;\n                // check if the key is still invalid and fallback to using a known\n                // safe key\n                if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n                    invalidKey = true;\n                }\n                if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n                    invalidKey = true;\n                }\n                if (invalidKey) {\n                    cleanedKey = getSafeRouteKey();\n                }\n                routeKeys[cleanedKey] = key;\n                return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;\n            } else {\n                return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;\n            }\n        }).join(''),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute) {\n    const result = getNamedParametrizedRoute(normalizedRoute);\n    return _extends({}, getRouteRegex(normalizedRoute), {\n        namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`,\n        routeKeys: result.routeKeys\n    });\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute  } = getParametrizedRoute(normalizedRoute);\n    const { catchAll =true  } = options;\n    if (parameterizedRoute === '/') {\n        let catchAllRegex = catchAll ? '.*' : '';\n        return {\n            namedRegex: `^/${catchAllRegex}$`\n        };\n    }\n    const { namedParameterizedRoute  } = getNamedParametrizedRoute(normalizedRoute);\n    let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';\n    return {\n        namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`\n    };\n}\n\n//# sourceMappingURL=route-regex.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getSortedRoutes = getSortedRoutes;\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split('/').filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix = '/') {\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[]'), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(`${prefix}${c}/`)).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get('[]')._smoosh(`${prefix}[${this.slugName}]/`));\n        }\n        if (!this.placeholder) {\n            const r = prefix === '/' ? '/' : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error(`You cannot define a route with the same specificity as a optional catch-all route (\"${r}\" and \"${r}[[...${this.optionalRestSlugName}]]\").`);\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get('[...]')._smoosh(`${prefix}[...${this.restSlugName}]/`));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get('[[...]]')._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(`Catch-all must be the last part of the URL.`);\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith('[') && segmentName.endsWith(']')) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith('...')) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith('[') || segmentName.endsWith(']')) {\n                throw new Error(`Segment names may not start or end with extra brackets ('${segmentName}').`);\n            }\n            if (segmentName.startsWith('.')) {\n                throw new Error(`Segment names may not start with erroneous periods ('${segmentName}').`);\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`);\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error(`You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`);\n                    }\n                    if (slug.replace(/\\W/g, '') === nextSegment.replace(/\\W/g, '')) {\n                        throw new Error(`You cannot have the slug names \"${slug}\" and \"${nextSlug}\" differ only by non-word symbols within a single dynamic path`);\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error(`You cannot use both an required and optional catch-all route at the same level (\"[...${this.restSlugName}]\" and \"${urlPaths[0]}\" ).`);\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = '[[...]]';\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error(`You cannot use both an optional and required catch-all route at the same level (\"[[...${this.optionalRestSlugName}]]\" and \"${urlPaths[0]}\").`);\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = '[...]';\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error(`Optional route parameters are not yet supported (\"${urlPaths[0]}\").`);\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = '[]';\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n}\n\n//# sourceMappingURL=sorted-routes.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.execOnce = execOnce;\nexports.getLocationOrigin = getLocationOrigin;\nexports.getURL = getURL;\nexports.getDisplayName = getDisplayName;\nexports.isResSent = isResSent;\nexports.normalizeRepeatedSlashes = normalizeRepeatedSlashes;\nexports.loadGetInitialProps = loadGetInitialProps;\nexports.ST = exports.SP = exports.isAbsoluteUrl = exports.WEB_VITALS = void 0;\nvar _async_to_generator = require(\"@swc/helpers/lib/_async_to_generator.js\").default;\nconst WEB_VITALS = [\n    'CLS',\n    'FCP',\n    'FID',\n    'INP',\n    'LCP',\n    'TTFB'\n];\nexports.WEB_VITALS = WEB_VITALS;\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return (...args)=>{\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nexports.isAbsoluteUrl = isAbsoluteUrl;\nfunction getLocationOrigin() {\n    const { protocol , hostname , port  } = window.location;\n    return `${protocol}//${hostname}${port ? ':' + port : ''}`;\n}\nfunction getURL() {\n    const { href  } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split('?');\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery// first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, '/').replace(/\\/\\/+/g, '/') + (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '');\n}\nfunction loadGetInitialProps(App, ctx) {\n    return _loadGetInitialProps.apply(this, arguments);\n}\nfunction _loadGetInitialProps() {\n    _loadGetInitialProps = _async_to_generator(function*(App, ctx) {\n        if (process.env.NODE_ENV !== 'production') {\n            var ref;\n            if ((ref = App.prototype) == null ? void 0 : ref.getInitialProps) {\n                const message = `\"${getDisplayName(App)}.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`;\n                throw new Error(message);\n            }\n        }\n        // when called from _app `ctx` is nested in `ctx`\n        const res = ctx.res || ctx.ctx && ctx.ctx.res;\n        if (!App.getInitialProps) {\n            if (ctx.ctx && ctx.Component) {\n                // @ts-ignore pageProps default\n                return {\n                    pageProps: yield loadGetInitialProps(ctx.Component, ctx.ctx)\n                };\n            }\n            return {};\n        }\n        const props = yield App.getInitialProps(ctx);\n        if (res && isResSent(res)) {\n            return props;\n        }\n        if (!props) {\n            const message = `\"${getDisplayName(App)}.getInitialProps()\" should resolve to an object. But found \"${props}\" instead.`;\n            throw new Error(message);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (Object.keys(props).length === 0 && !ctx.ctx) {\n                console.warn(`${getDisplayName(App)} returned an empty object from \\`getInitialProps\\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`);\n            }\n        }\n        return props;\n    });\n    return _loadGetInitialProps.apply(this, arguments);\n}\nconst SP = typeof performance !== 'undefined';\nexports.SP = SP;\nconst ST = SP && [\n    'mark',\n    'measure',\n    'getEntriesByName'\n].every((method)=>typeof performance[method] === 'function');\nexports.ST = ST;\nclass DecodeError extends Error {\n}\nexports.DecodeError = DecodeError;\nclass NormalizeError extends Error {\n}\nexports.NormalizeError = NormalizeError;\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = 'ENOENT';\n        this.message = `Cannot find module for page: ${page}`;\n    }\n}\nexports.PageNotFoundError = PageNotFoundError;\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = `Failed to load static file for page: ${page} ${message}`;\n    }\n}\nexports.MissingStaticPage = MissingStaticPage;\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = 'ENOENT';\n        this.message = `Cannot find the middleware module`;\n    }\n}\nexports.MiddlewareNotFoundError = MiddlewareNotFoundError;\n\n//# sourceMappingURL=utils.js.map","module.exports = require('./dist/client/link')\n","module.exports = require('./dist/client/router')\n","\"use strict\";var __assign=this&&this.__assign||function(){return(__assign=Object.assign||function(e){for(var r,t=1,n=arguments.length;t<n;t++)for(var o in r=arguments[t])Object.prototype.hasOwnProperty.call(r,o)&&(e[o]=r[o]);return e}).apply(this,arguments)},defaultConfig=(Object.defineProperty(exports,\"__esModule\",{value:!0}),{id:\"id\",parentId:\"parentId\",dataField:\"data\",childrenField:\"children\",throwIfOrphans:!1,rootParentIds:{\"\":!(exports.countNodes=exports.arrayToTree=void 0)},nestedIds:!0,assign:!1});function arrayToTree(c,e){void 0===e&&(e={});for(var r,t=__assign(__assign({},defaultConfig),e),n=[],o={},a=t.throwIfOrphans?new Set:null,s=0,h=c;s<h.length;s++){var i=h[s],d=t.nestedIds?getNestedProperty(i,t.id):i[t.id],l=t.nestedIds?getNestedProperty(i,t.parentId):i[t.parentId];if(t.rootParentIds[d])throw new Error(\"The item array contains a node whose parentId both exists in another node and is in \"+'`rootParentIds` (`itemId`: \"'.concat(d,'\", `rootParentIds`: ').concat(Object.keys(t.rootParentIds).map(function(e){return'\"'.concat(e,'\"')}).join(\", \"),\").\"));Object.prototype.hasOwnProperty.call(o,d)||(o[d]=((r={})[t.childrenField]=[],r)),a&&a.delete(d),t.dataField?o[d][t.dataField]=i:t.assign?o[d]=Object.assign(i,((r={})[t.childrenField]=o[d][t.childrenField],r)):o[d]=__assign(__assign({},i),((i={})[t.childrenField]=o[d][t.childrenField],i));i=o[d];null==l||t.rootParentIds[l]?n.push(i):(Object.prototype.hasOwnProperty.call(o,l)||(o[l]=((d={})[t.childrenField]=[],d),a&&a.add(l)),o[l][t.childrenField].push(i))}if(null!=a&&a.size)throw new Error(\"The items array contains orphans that point to the following parentIds: \"+\"[\".concat(Array.from(a),\"]. These parentIds do not exist in the items array. Hint: prevent orphans to result \")+\"in an error by passing the following option: { throwIfOrphans: false }\");if(t.throwIfOrphans&&countNodes(n,t.childrenField)<Object.keys(o).length)throw new Error(\"The items array contains nodes with a circular parent/child relationship.\");return n}function countNodes(e,t){return e.reduce(function(e,r){return e+1+(r[t]&&countNodes(r[t],t))},0)}function getNestedProperty(e,r){return r.split(\".\").reduce(function(e,r){return e&&e[r]},e)}exports.arrayToTree=arrayToTree,exports.countNodes=countNodes;","import * as React from 'react';\nimport { styleSingleton } from 'react-style-singleton';\nimport { fullWidthClassName, zeroRightClassName, noScrollbarsClassName, removedBarSizeVariable } from './constants';\nimport { getGapWidth } from './utils';\nvar Style = styleSingleton();\n// important tip - once we measure scrollBar width and remove them\n// we could not repeat this operation\n// thus we are using style-singleton - only the first \"yet correct\" style will be applied.\nvar getStyles = function (_a, allowRelative, gapMode, important) {\n    var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;\n    if (gapMode === void 0) { gapMode = 'margin'; }\n    return \"\\n  .\".concat(noScrollbarsClassName, \" {\\n   overflow: hidden \").concat(important, \";\\n   padding-right: \").concat(gap, \"px \").concat(important, \";\\n  }\\n  body {\\n    overflow: hidden \").concat(important, \";\\n    overscroll-behavior: contain;\\n    \").concat([\n        allowRelative && \"position: relative \".concat(important, \";\"),\n        gapMode === 'margin' &&\n            \"\\n    padding-left: \".concat(left, \"px;\\n    padding-top: \").concat(top, \"px;\\n    padding-right: \").concat(right, \"px;\\n    margin-left:0;\\n    margin-top:0;\\n    margin-right: \").concat(gap, \"px \").concat(important, \";\\n    \"),\n        gapMode === 'padding' && \"padding-right: \".concat(gap, \"px \").concat(important, \";\"),\n    ]\n        .filter(Boolean)\n        .join(''), \"\\n  }\\n  \\n  .\").concat(zeroRightClassName, \" {\\n    right: \").concat(gap, \"px \").concat(important, \";\\n  }\\n  \\n  .\").concat(fullWidthClassName, \" {\\n    margin-right: \").concat(gap, \"px \").concat(important, \";\\n  }\\n  \\n  .\").concat(zeroRightClassName, \" .\").concat(zeroRightClassName, \" {\\n    right: 0 \").concat(important, \";\\n  }\\n  \\n  .\").concat(fullWidthClassName, \" .\").concat(fullWidthClassName, \" {\\n    margin-right: 0 \").concat(important, \";\\n  }\\n  \\n  body {\\n    \").concat(removedBarSizeVariable, \": \").concat(gap, \"px;\\n  }\\n\");\n};\n/**\n * Removes page scrollbar and blocks page scroll when mounted\n */\nexport var RemoveScrollBar = function (props) {\n    var noRelative = props.noRelative, noImportant = props.noImportant, _a = props.gapMode, gapMode = _a === void 0 ? 'margin' : _a;\n    /*\n     gap will be measured on every component mount\n     however it will be used only by the \"first\" invocation\n     due to singleton nature of <Style\n     */\n    var gap = React.useMemo(function () { return getGapWidth(gapMode); }, [gapMode]);\n    return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? '!important' : '') });\n};\n","export var zeroRightClassName = 'right-scroll-bar-position';\nexport var fullWidthClassName = 'width-before-scroll-bar';\nexport var noScrollbarsClassName = 'with-scroll-bars-hidden';\n/**\n * Name of a CSS variable containing the amount of \"hidden\" scrollbar\n * ! might be undefined ! use will fallback!\n */\nexport var removedBarSizeVariable = '--removed-body-scroll-bar-size';\n","import { RemoveScrollBar } from './component';\nimport { zeroRightClassName, fullWidthClassName, noScrollbarsClassName, removedBarSizeVariable } from './constants';\nimport { getGapWidth } from './utils';\nexport { RemoveScrollBar, zeroRightClassName, fullWidthClassName, noScrollbarsClassName, removedBarSizeVariable, getGapWidth, };\n","export var zeroGap = {\n    left: 0,\n    top: 0,\n    right: 0,\n    gap: 0,\n};\nvar parse = function (x) { return parseInt(x || '', 10) || 0; };\nvar getOffset = function (gapMode) {\n    var cs = window.getComputedStyle(document.body);\n    var left = cs[gapMode === 'padding' ? 'paddingLeft' : 'marginLeft'];\n    var top = cs[gapMode === 'padding' ? 'paddingTop' : 'marginTop'];\n    var right = cs[gapMode === 'padding' ? 'paddingRight' : 'marginRight'];\n    return [parse(left), parse(top), parse(right)];\n};\nexport var getGapWidth = function (gapMode) {\n    if (gapMode === void 0) { gapMode = 'margin'; }\n    if (typeof window === 'undefined') {\n        return zeroGap;\n    }\n    var offsets = getOffset(gapMode);\n    var documentWidth = document.documentElement.clientWidth;\n    var windowWidth = window.innerWidth;\n    return {\n        left: offsets[0],\n        top: offsets[1],\n        right: offsets[2],\n        gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0]),\n    };\n};\n","import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { RemoveScroll } from './UI';\nimport SideCar from './sidecar';\nvar ReactRemoveScroll = React.forwardRef(function (props, ref) { return (React.createElement(RemoveScroll, __assign({}, props, { ref: ref, sideCar: SideCar }))); });\nReactRemoveScroll.classNames = RemoveScroll.classNames;\nexport default ReactRemoveScroll;\n","import { __spreadArray } from \"tslib\";\nimport * as React from 'react';\nimport { RemoveScrollBar } from 'react-remove-scroll-bar';\nimport { styleSingleton } from 'react-style-singleton';\nimport { nonPassive } from './aggresiveCapture';\nimport { handleScroll, locationCouldBeScrolled } from './handleScroll';\nexport var getTouchXY = function (event) {\n    return 'changedTouches' in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];\n};\nexport var getDeltaXY = function (event) { return [event.deltaX, event.deltaY]; };\nvar extractRef = function (ref) {\n    return ref && 'current' in ref ? ref.current : ref;\n};\nvar deltaCompare = function (x, y) { return x[0] === y[0] && x[1] === y[1]; };\nvar generateStyle = function (id) { return \"\\n  .block-interactivity-\".concat(id, \" {pointer-events: none;}\\n  .allow-interactivity-\").concat(id, \" {pointer-events: all;}\\n\"); };\nvar idCounter = 0;\nvar lockStack = [];\nexport function RemoveScrollSideCar(props) {\n    var shouldPreventQueue = React.useRef([]);\n    var touchStartRef = React.useRef([0, 0]);\n    var activeAxis = React.useRef();\n    var id = React.useState(idCounter++)[0];\n    var Style = React.useState(function () { return styleSingleton(); })[0];\n    var lastProps = React.useRef(props);\n    React.useEffect(function () {\n        lastProps.current = props;\n    }, [props]);\n    React.useEffect(function () {\n        if (props.inert) {\n            document.body.classList.add(\"block-interactivity-\".concat(id));\n            var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);\n            allow_1.forEach(function (el) { return el.classList.add(\"allow-interactivity-\".concat(id)); });\n            return function () {\n                document.body.classList.remove(\"block-interactivity-\".concat(id));\n                allow_1.forEach(function (el) { return el.classList.remove(\"allow-interactivity-\".concat(id)); });\n            };\n        }\n        return;\n    }, [props.inert, props.lockRef.current, props.shards]);\n    var shouldCancelEvent = React.useCallback(function (event, parent) {\n        if ('touches' in event && event.touches.length === 2) {\n            return !lastProps.current.allowPinchZoom;\n        }\n        var touch = getTouchXY(event);\n        var touchStart = touchStartRef.current;\n        var deltaX = 'deltaX' in event ? event.deltaX : touchStart[0] - touch[0];\n        var deltaY = 'deltaY' in event ? event.deltaY : touchStart[1] - touch[1];\n        var currentAxis;\n        var target = event.target;\n        var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'h' : 'v';\n        // allow horizontal touch move on Range inputs. They will not cause any scroll\n        if ('touches' in event && moveDirection === 'h' && target.type === 'range') {\n            return false;\n        }\n        var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);\n        if (!canBeScrolledInMainDirection) {\n            return true;\n        }\n        if (canBeScrolledInMainDirection) {\n            currentAxis = moveDirection;\n        }\n        else {\n            currentAxis = moveDirection === 'v' ? 'h' : 'v';\n            canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);\n            // other axis might be not scrollable\n        }\n        if (!canBeScrolledInMainDirection) {\n            return false;\n        }\n        if (!activeAxis.current && 'changedTouches' in event && (deltaX || deltaY)) {\n            activeAxis.current = currentAxis;\n        }\n        if (!currentAxis) {\n            return true;\n        }\n        var cancelingAxis = activeAxis.current || currentAxis;\n        return handleScroll(cancelingAxis, parent, event, cancelingAxis === 'h' ? deltaX : deltaY, true);\n    }, []);\n    var shouldPrevent = React.useCallback(function (_event) {\n        var event = _event;\n        if (!lockStack.length || lockStack[lockStack.length - 1] !== Style) {\n            // not the last active\n            return;\n        }\n        var delta = 'deltaY' in event ? getDeltaXY(event) : getTouchXY(event);\n        var sourceEvent = shouldPreventQueue.current.filter(function (e) { return e.name === event.type && e.target === event.target && deltaCompare(e.delta, delta); })[0];\n        // self event, and should be canceled\n        if (sourceEvent && sourceEvent.should) {\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            return;\n        }\n        // outside or shard event\n        if (!sourceEvent) {\n            var shardNodes = (lastProps.current.shards || [])\n                .map(extractRef)\n                .filter(Boolean)\n                .filter(function (node) { return node.contains(event.target); });\n            var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;\n            if (shouldStop) {\n                if (event.cancelable) {\n                    event.preventDefault();\n                }\n            }\n        }\n    }, []);\n    var shouldCancel = React.useCallback(function (name, delta, target, should) {\n        var event = { name: name, delta: delta, target: target, should: should };\n        shouldPreventQueue.current.push(event);\n        setTimeout(function () {\n            shouldPreventQueue.current = shouldPreventQueue.current.filter(function (e) { return e !== event; });\n        }, 1);\n    }, []);\n    var scrollTouchStart = React.useCallback(function (event) {\n        touchStartRef.current = getTouchXY(event);\n        activeAxis.current = undefined;\n    }, []);\n    var scrollWheel = React.useCallback(function (event) {\n        shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));\n    }, []);\n    var scrollTouchMove = React.useCallback(function (event) {\n        shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));\n    }, []);\n    React.useEffect(function () {\n        lockStack.push(Style);\n        props.setCallbacks({\n            onScrollCapture: scrollWheel,\n            onWheelCapture: scrollWheel,\n            onTouchMoveCapture: scrollTouchMove,\n        });\n        document.addEventListener('wheel', shouldPrevent, nonPassive);\n        document.addEventListener('touchmove', shouldPrevent, nonPassive);\n        document.addEventListener('touchstart', scrollTouchStart, nonPassive);\n        return function () {\n            lockStack = lockStack.filter(function (inst) { return inst !== Style; });\n            document.removeEventListener('wheel', shouldPrevent, nonPassive);\n            document.removeEventListener('touchmove', shouldPrevent, nonPassive);\n            document.removeEventListener('touchstart', scrollTouchStart, nonPassive);\n        };\n    }, []);\n    var removeScrollBar = props.removeScrollBar, inert = props.inert;\n    return (React.createElement(React.Fragment, null,\n        inert ? React.createElement(Style, { styles: generateStyle(id) }) : null,\n        removeScrollBar ? React.createElement(RemoveScrollBar, { gapMode: \"margin\" }) : null));\n}\n","import { __assign, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { fullWidthClassName, zeroRightClassName } from 'react-remove-scroll-bar/constants';\nimport { useMergeRefs } from 'use-callback-ref';\nimport { effectCar } from './medium';\nvar nothing = function () {\n    return;\n};\n/**\n * Removes scrollbar from the page and contain the scroll within the Lock\n */\nvar RemoveScroll = React.forwardRef(function (props, parentRef) {\n    var ref = React.useRef(null);\n    var _a = React.useState({\n        onScrollCapture: nothing,\n        onWheelCapture: nothing,\n        onTouchMoveCapture: nothing,\n    }), callbacks = _a[0], setCallbacks = _a[1];\n    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? 'div' : _b, rest = __rest(props, [\"forwardProps\", \"children\", \"className\", \"removeScrollBar\", \"enabled\", \"shards\", \"sideCar\", \"noIsolation\", \"inert\", \"allowPinchZoom\", \"as\"]);\n    var SideCar = sideCar;\n    var containerRef = useMergeRefs([ref, parentRef]);\n    var containerProps = __assign(__assign({}, rest), callbacks);\n    return (React.createElement(React.Fragment, null,\n        enabled && (React.createElement(SideCar, { sideCar: effectCar, removeScrollBar: removeScrollBar, shards: shards, noIsolation: noIsolation, inert: inert, setCallbacks: setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref })),\n        forwardProps ? (React.cloneElement(React.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef }))) : (React.createElement(Container, __assign({}, containerProps, { className: className, ref: containerRef }), children))));\n});\nRemoveScroll.defaultProps = {\n    enabled: true,\n    removeScrollBar: true,\n    inert: false,\n};\nRemoveScroll.classNames = {\n    fullWidth: fullWidthClassName,\n    zeroRight: zeroRightClassName,\n};\nexport { RemoveScroll };\n","var passiveSupported = false;\nif (typeof window !== 'undefined') {\n    try {\n        var options = Object.defineProperty({}, 'passive', {\n            get: function () {\n                passiveSupported = true;\n                return true;\n            },\n        });\n        // @ts-ignore\n        window.addEventListener('test', options, options);\n        // @ts-ignore\n        window.removeEventListener('test', options, options);\n    }\n    catch (err) {\n        passiveSupported = false;\n    }\n}\nexport var nonPassive = passiveSupported ? { passive: false } : false;\n","var alwaysContainsScroll = function (node) {\n    // textarea will always _contain_ scroll inside self. It only can be hidden\n    return node.tagName === 'TEXTAREA';\n};\nvar elementCanBeScrolled = function (node, overflow) {\n    var styles = window.getComputedStyle(node);\n    return (\n    // not-not-scrollable\n    styles[overflow] !== 'hidden' &&\n        // contains scroll inside self\n        !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible'));\n};\nvar elementCouldBeVScrolled = function (node) { return elementCanBeScrolled(node, 'overflowY'); };\nvar elementCouldBeHScrolled = function (node) { return elementCanBeScrolled(node, 'overflowX'); };\nexport var locationCouldBeScrolled = function (axis, node) {\n    var current = node;\n    do {\n        // Skip over shadow root\n        if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {\n            current = current.host;\n        }\n        var isScrollable = elementCouldBeScrolled(axis, current);\n        if (isScrollable) {\n            var _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];\n            if (s > d) {\n                return true;\n            }\n        }\n        current = current.parentNode;\n    } while (current && current !== document.body);\n    return false;\n};\nvar getVScrollVariables = function (_a) {\n    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\n    return [\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n    ];\n};\nvar getHScrollVariables = function (_a) {\n    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;\n    return [\n        scrollLeft,\n        scrollWidth,\n        clientWidth,\n    ];\n};\nvar elementCouldBeScrolled = function (axis, node) {\n    return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);\n};\nvar getScrollVariables = function (axis, node) {\n    return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);\n};\nvar getDirectionFactor = function (axis, direction) {\n    /**\n     * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,\n     * and then increasingly negative as you scroll towards the end of the content.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n     */\n    return axis === 'h' && direction === 'rtl' ? -1 : 1;\n};\nexport var handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {\n    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);\n    var delta = directionFactor * sourceDelta;\n    // find scrollable target\n    var target = event.target;\n    var targetInLock = endTarget.contains(target);\n    var shouldCancelScroll = false;\n    var isDeltaPositive = delta > 0;\n    var availableScroll = 0;\n    var availableScrollTop = 0;\n    do {\n        var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];\n        var elementScroll = scroll_1 - capacity - directionFactor * position;\n        if (position || elementScroll) {\n            if (elementCouldBeScrolled(axis, target)) {\n                availableScroll += elementScroll;\n                availableScrollTop += position;\n            }\n        }\n        target = target.parentNode;\n    } while (\n    // portaled content\n    (!targetInLock && target !== document.body) ||\n        // self content\n        (targetInLock && (endTarget.contains(target) || endTarget === target)));\n    if (isDeltaPositive && ((noOverscroll && availableScroll === 0) || (!noOverscroll && delta > availableScroll))) {\n        shouldCancelScroll = true;\n    }\n    else if (!isDeltaPositive &&\n        ((noOverscroll && availableScrollTop === 0) || (!noOverscroll && -delta > availableScrollTop))) {\n        shouldCancelScroll = true;\n    }\n    return shouldCancelScroll;\n};\n","import { createSidecarMedium } from 'use-sidecar';\nexport var effectCar = createSidecarMedium();\n","import { exportSidecar } from 'use-sidecar';\nimport { RemoveScrollSideCar } from './SideEffect';\nimport { effectCar } from './medium';\nexport default exportSidecar(effectCar, RemoveScrollSideCar);\n","import { styleHookSingleton } from './hook';\n/**\n * create a Component to add styles on demand\n * - styles are added when first instance is mounted\n * - styles are removed when the last instance is unmounted\n * - changing styles in runtime does nothing unless dynamic is set. But with multiple components that can lead to the undefined behavior\n */\nexport var styleSingleton = function () {\n    var useStyle = styleHookSingleton();\n    var Sheet = function (_a) {\n        var styles = _a.styles, dynamic = _a.dynamic;\n        useStyle(styles, dynamic);\n        return null;\n    };\n    return Sheet;\n};\n","import * as React from 'react';\nimport { stylesheetSingleton } from './singleton';\n/**\n * creates a hook to control style singleton\n * @see {@link styleSingleton} for a safer component version\n * @example\n * ```tsx\n * const useStyle = styleHookSingleton();\n * ///\n * useStyle('body { overflow: hidden}');\n */\nexport var styleHookSingleton = function () {\n    var sheet = stylesheetSingleton();\n    return function (styles, isDynamic) {\n        React.useEffect(function () {\n            sheet.add(styles);\n            return function () {\n                sheet.remove();\n            };\n        }, [styles && isDynamic]);\n    };\n};\n","export { styleSingleton } from './component';\nexport { stylesheetSingleton } from './singleton';\nexport { styleHookSingleton } from './hook';\n","import { getNonce } from 'get-nonce';\nfunction makeStyleTag() {\n    if (!document)\n        return null;\n    var tag = document.createElement('style');\n    tag.type = 'text/css';\n    var nonce = getNonce();\n    if (nonce) {\n        tag.setAttribute('nonce', nonce);\n    }\n    return tag;\n}\nfunction injectStyles(tag, css) {\n    // @ts-ignore\n    if (tag.styleSheet) {\n        // @ts-ignore\n        tag.styleSheet.cssText = css;\n    }\n    else {\n        tag.appendChild(document.createTextNode(css));\n    }\n}\nfunction insertStyleTag(tag) {\n    var head = document.head || document.getElementsByTagName('head')[0];\n    head.appendChild(tag);\n}\nexport var stylesheetSingleton = function () {\n    var counter = 0;\n    var stylesheet = null;\n    return {\n        add: function (style) {\n            if (counter == 0) {\n                if ((stylesheet = makeStyleTag())) {\n                    injectStyles(stylesheet, style);\n                    insertStyleTag(stylesheet);\n                }\n            }\n            counter++;\n        },\n        remove: function () {\n            counter--;\n            if (!counter && stylesheet) {\n                stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);\n                stylesheet = null;\n            }\n        },\n    };\n};\n","// src/use-indexed-children.tsx\nimport * as React3 from \"react\";\n\n// src/contexts.ts\nimport * as React from \"react\";\nvar PrerenderContext = React.createContext(false);\nPrerenderContext.displayName = \"PrerenderContext\";\nvar MaxIndexContext = React.createContext([]);\nMaxIndexContext.displayName = \"MaxIndexContext\";\nvar IndexContext = React.createContext(null);\nIndexContext.displayName = \"IndexContext\";\nvar TreeStateContext = React.createContext(null);\nTreeStateContext.displayName = \"TreeStateContext\";\n\n// src/utils.ts\nimport * as React2 from \"react\";\nimport { arrayToTree } from \"performant-array-to-tree\";\nvar isServer = typeof window === \"undefined\";\nvar useIsomorphicLayoutEffect = isServer ? React2.useEffect : React2.useLayoutEffect;\nfunction parseIndexPath(indexPathString) {\n  return indexPathString.split(\".\").map((index) => parseInt(index, 10));\n}\nfunction compareIndexPaths(a = \"\", b = \"\") {\n  var _a, _b;\n  let aArray = a.split(\".\").map(Number);\n  let bArray = b.split(\".\").map(Number);\n  if (aArray.includes(NaN) || bArray.includes(NaN)) {\n    throw new Error(\"Version contains parts that are not numbers\");\n  }\n  const maxLength = Math.max(a.length, b.length);\n  for (let index = 0; index < maxLength; index++) {\n    const difference = ((_a = aArray[index]) != null ? _a : 0) - ((_b = bArray[index]) != null ? _b : 0);\n    if (difference === 0) {\n      continue;\n    }\n    return difference > 0 ? 1 : -1;\n  }\n  return 0;\n}\nfunction cleanAndSortTree(tree) {\n  var _a;\n  if (((_a = tree.children) == null ? void 0 : _a.length) > 0) {\n    tree.children.sort((a, b) => compareIndexPaths(a.indexPathString, b.indexPathString));\n    return {\n      ...tree.data,\n      children: tree.children.map(cleanAndSortTree)\n    };\n  }\n  return tree.data;\n}\nfunction mapToChildren(dataMap) {\n  const parsedValues = Array.from(dataMap.entries()).map(([indexPathString, data]) => {\n    const parentIndexPathString = parseIndexPath(indexPathString).slice(0, -1).join(\".\");\n    return {\n      data,\n      parentId: parentIndexPathString,\n      id: indexPathString\n    };\n  });\n  const tree = arrayToTree(parsedValues, { dataField: null });\n  const cleanedTree = cleanAndSortTree({ children: tree });\n  return cleanedTree ? cleanedTree.children : [];\n}\nfunction sortMapByIndexPath(treeMap) {\n  const sortedEntries = Array.from(treeMap.entries()).sort((a, b) => compareIndexPaths(a[0], b[0]));\n  return new Map(sortedEntries);\n}\nfunction flattenChildren(children) {\n  const flatChildren = children.flatMap(\n    (child) => child.children ? flattenChildren(child.children) : [child]\n  );\n  return flatChildren;\n}\n\n// src/use-indexed-children.tsx\nfunction useIndex() {\n  const maxIndexPath = React3.useContext(MaxIndexContext);\n  const indexPathString = React3.useContext(IndexContext);\n  return React3.useMemo(() => {\n    if (indexPathString === null) {\n      return null;\n    }\n    const indexPath = parseIndexPath(indexPathString);\n    const maxIndex = maxIndexPath[maxIndexPath.length - 1];\n    const index = indexPath[indexPath.length - 1];\n    return {\n      maxIndex,\n      maxIndexPath,\n      index,\n      indexPath,\n      indexPathString,\n      isFirst: index === 0,\n      isLast: index === maxIndex,\n      isEven: index % 2 === 0,\n      isOdd: Math.abs(index % 2) === 1\n    };\n  }, [maxIndexPath, indexPathString]);\n}\nfunction useIndexedChildren(children) {\n  const parentMaxIndexPath = React3.useContext(MaxIndexContext);\n  const indexPathString = React3.useContext(IndexContext);\n  const childrenCount = React3.Children.count(children);\n  const maxIndexPath = React3.useMemo(\n    () => parentMaxIndexPath.concat(childrenCount - 1),\n    [childrenCount]\n  );\n  return /* @__PURE__ */ React3.createElement(MaxIndexContext.Provider, { value: maxIndexPath }, React3.Children.map(\n    children,\n    (child, index) => React3.isValidElement(child) ? /* @__PURE__ */ React3.createElement(\n      IndexContext.Provider,\n      {\n        key: child.key,\n        value: indexPathString ? `${indexPathString}.${index.toString()}` : index.toString()\n      },\n      child\n    ) : child\n  ));\n}\n\n// src/use-roving-index.ts\nimport * as React4 from \"react\";\nfunction useRovingIndex({\n  contain = true,\n  defaultIndex = 0,\n  maxIndex = Infinity,\n  wrap = false\n}) {\n  const [activeIndex, setLocalActiveIndex] = React4.useState(defaultIndex);\n  const getNextIndex = React4.useCallback(\n    (nextIndex) => {\n      if (wrap) {\n        return (nextIndex % maxIndex + maxIndex) % maxIndex;\n      }\n      if (contain) {\n        return nextIndex > maxIndex ? maxIndex : nextIndex < 0 ? 0 : nextIndex;\n      }\n      return nextIndex;\n    },\n    [maxIndex, wrap]\n  );\n  const moveActiveIndex = React4.useCallback(\n    (amountToMove) => {\n      setLocalActiveIndex((currentIndex) => getNextIndex(currentIndex + amountToMove));\n    },\n    [getNextIndex]\n  );\n  const setActiveIndex = React4.useCallback(\n    (nextIndex) => {\n      setLocalActiveIndex(getNextIndex(nextIndex));\n    },\n    [getNextIndex]\n  );\n  const moveBackward = React4.useCallback(() => moveActiveIndex(-1), [moveActiveIndex]);\n  const moveForward = React4.useCallback(() => moveActiveIndex(1), [moveActiveIndex]);\n  return {\n    activeIndex,\n    moveActiveIndex,\n    setActiveIndex,\n    moveBackward,\n    moveForward,\n    moveBackwardDisabled: activeIndex <= 0,\n    moveForwardDisabled: activeIndex >= maxIndex\n  };\n}\n\n// src/use-tree.tsx\nimport * as React5 from \"react\";\nimport { create } from \"zustand\";\nfunction useTreeState(selector) {\n  const treeStateContext = React5.useContext(TreeStateContext);\n  const [treeState] = React5.useState(\n    () => treeStateContext || create((set, get) => ({\n      treeMap: /* @__PURE__ */ new Map(),\n      prerenderedTreeIds: /* @__PURE__ */ new Map(),\n      shouldPrerender: true,\n      setTreeData: (id, data) => {\n        const { treeMap } = get();\n        treeMap.set(id, data);\n        set({ treeMap: sortMapByIndexPath(treeMap) });\n      },\n      deleteTreeData: (id) => {\n        const { treeMap } = get();\n        treeMap.delete(id);\n        set({ treeMap: sortMapByIndexPath(treeMap) });\n      }\n    }))\n  );\n  return selector ? treeState(selector) : treeState;\n}\nfunction PrerenderTree({ children }) {\n  const treeState = useTreeState();\n  const shouldPrerender = treeState((state) => state.shouldPrerender);\n  useIsomorphicLayoutEffect(() => {\n    treeState.setState({\n      prerenderedTreeIds: /* @__PURE__ */ new Map(),\n      shouldPrerender: false\n    });\n  }, []);\n  return shouldPrerender ? /* @__PURE__ */ React5.createElement(PrerenderContext.Provider, { value: true }, children) : null;\n}\nfunction useTree(children, treeState) {\n  const treeStateContext = React5.useContext(TreeStateContext);\n  const treeStateLocal = useTreeState();\n  const parsedTreeState = treeStateContext || treeState || treeStateLocal;\n  const isPrerender = React5.useContext(PrerenderContext);\n  const isRoot = treeStateContext === null;\n  const indexedChildren = useIndexedChildren(children);\n  const childrenToRender = isRoot ? /* @__PURE__ */ React5.createElement(TreeStateContext.Provider, { value: parsedTreeState }, /* @__PURE__ */ React5.createElement(PrerenderTree, null, indexedChildren), indexedChildren) : indexedChildren;\n  return {\n    children: childrenToRender,\n    useStore: parsedTreeState,\n    isPrerender,\n    isRoot\n  };\n}\nfunction useTreeNode(getData, dependencies = []) {\n  const isPrerender = React5.useContext(PrerenderContext);\n  const treeStateContext = React5.useContext(TreeStateContext);\n  if (treeStateContext === null) {\n    throw new Error(\"useTreeNode must be used in a descendant component of useTree.\");\n  }\n  const { deleteTreeData, prerenderedTreeIds, setTreeData, treeMap } = treeStateContext.getState();\n  const { indexPathString } = useIndex();\n  const generatedId = React5.useId().slice(1, -1);\n  const treeId = prerenderedTreeIds.get(indexPathString) || generatedId;\n  const treeData = React5.useMemo(\n    () => Object.assign({ treeId }, getData()),\n    dependencies.concat(treeId)\n  );\n  if (isPrerender) {\n    treeMap.set(indexPathString, treeData);\n    prerenderedTreeIds.set(indexPathString, treeId);\n  } else {\n    React5.useEffect(() => {\n      setTreeData(indexPathString, treeData);\n      return () => {\n        deleteTreeData(indexPathString);\n      };\n    }, [indexPathString, treeData]);\n  }\n  return {\n    id: treeId,\n    data: treeData,\n    indexPathString,\n    isPrerender\n  };\n}\nexport {\n  cleanAndSortTree,\n  compareIndexPaths,\n  flattenChildren,\n  mapToChildren,\n  parseIndexPath,\n  sortMapByIndexPath,\n  useIndex,\n  useIndexedChildren,\n  useRovingIndex,\n  useTree,\n  useTreeNode,\n  useTreeState\n};\n","/*!\n* tabbable 6.0.1\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  return element.getRootNode();\n} : function (element) {\n  return element.ownerDocument;\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      var shadowRoot = element.shadowRoot ||\n      // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n  return candidates;\n};\nvar getTabindex = function getTabindex(node, isScope) {\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    //\n    // isScope is positive for custom element with shadow root or slot that by default\n    // have tabIndex -1, but need to be sorted by document order in order for their\n    // content to be inserted in the correct position\n    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  var radioScope = node.form || getRootNode(node);\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n  var radioSet;\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nvar isNodeAttached = function isNodeAttached(node) {\n  var _nodeRootHost;\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  var nodeRootHost = getRootNode(node).host;\n  var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));\n  while (!attached && nodeRootHost) {\n    var _nodeRootHost2;\n    // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n    //  which means we need to get the host's host and check if that parent host is contained\n    //  in (i.e. attached to) the document\n    nodeRootHost = getRootNode(nodeRootHost).host;\n    attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));\n  }\n  return attached;\n};\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    width = _node$getBoundingClie.width,\n    height = _node$getBoundingClie.height;\n  return width === 0 && height === 0;\n};\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n    getShadowRoot = _ref.getShadowRoot;\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options) ||\n  // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n  return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n  return true;\n};\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scopeParent;\n    var element = isScope ? item.scopeParent : item;\n    var candidateTabindex = getTabindex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n  return sortByOrder(candidates);\n};\nvar focusable = function focusable(el, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n  return candidates;\n};\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","import { getVariableValue, isWeb } from \"@tamagui/core\";\nimport { getButtonSized } from \"@tamagui/get-button-sized\";\nimport { getFontSized } from \"@tamagui/get-font-sized\";\nimport { stepTokenUpOrDown } from \"@tamagui/get-size\";\nconst inputSizeVariant = (val = \"$true\", extras) => {\n  if (extras.props.multiline || extras.props.numberOfLines > 1) {\n    return textAreaSizeVariant(val, extras);\n  }\n  const buttonStyles = getButtonSized(val, extras);\n  const paddingHorizontal = stepTokenUpOrDown(\"space\", val, -1, [2]);\n  const fontStyle = getFontSized(val, extras);\n  if (!isWeb && fontStyle) {\n    delete fontStyle[\"lineHeight\"];\n  }\n  return {\n    ...fontStyle,\n    ...buttonStyles,\n    paddingHorizontal\n  };\n};\nconst textAreaSizeVariant = (val = \"$true\", extras) => {\n  const { props } = extras;\n  const buttonStyles = getButtonSized(val, extras);\n  const fontStyle = getFontSized(val, extras);\n  const height = props.numberOfLines ? (props.numberOfLines || 1) * getVariableValue(fontStyle.lineHeight) : \"auto\";\n  const paddingVertical = stepTokenUpOrDown(\"space\", val, -2, [2]);\n  const paddingHorizontal = stepTokenUpOrDown(\"space\", val, -1, [2]);\n  return {\n    ...buttonStyles,\n    ...fontStyle,\n    paddingVertical,\n    paddingHorizontal,\n    height\n  };\n};\nexport {\n  inputSizeVariant,\n  textAreaSizeVariant\n};\n//# sourceMappingURL=inputHelpers.mjs.map\n","export * from \"./setup\";\nexport * from \"@tamagui/adapt\";\nexport * from \"@tamagui/alert-dialog\";\nexport * from \"@tamagui/animate-presence\";\nexport * from \"@tamagui/avatar\";\nexport * from \"@tamagui/button\";\nexport * from \"@tamagui/card\";\nexport * from \"@tamagui/checkbox\";\nexport * from \"@tamagui/compose-refs\";\nexport * from \"@tamagui/create-context\";\nexport * from \"@tamagui/dialog\";\nexport * from \"@tamagui/font-size\";\nexport * from \"@tamagui/form\";\nexport * from \"@tamagui/group\";\nexport * from \"@tamagui/helpers-tamagui\";\nexport * from \"@tamagui/image\";\nexport * from \"@tamagui/label\";\nexport * from \"@tamagui/list-item\";\nexport * from \"@tamagui/popover\";\nexport * from \"@tamagui/popper\";\nexport * from \"@tamagui/portal\";\nexport * from \"@tamagui/progress\";\nexport * from \"@tamagui/radio-group\";\nexport * from \"@tamagui/scroll-view\";\nexport * from \"@tamagui/select\";\nexport * from \"@tamagui/separator\";\nexport * from \"@tamagui/shapes\";\nexport * from \"@tamagui/sheet\";\nexport * from \"@tamagui/slider\";\nexport * from \"@tamagui/stacks\";\nexport * from \"@tamagui/switch\";\nexport * from \"@tamagui/tabs\";\nexport * from \"@tamagui/text\";\nexport * from \"@tamagui/theme\";\nexport * from \"@tamagui/toggle-group\";\nexport * from \"@tamagui/tooltip\";\nexport * from \"@tamagui/use-controllable-state\";\nexport * from \"@tamagui/use-debounce\";\nexport * from \"@tamagui/use-force-update\";\nexport * from \"@tamagui/use-window-dimensions\";\nexport * from \"@tamagui/visually-hidden\";\nexport * from \"./createTamagui\";\nexport * from \"./views/TamaguiProvider\";\nexport * from \"./viewTypes\";\nexport * from \"./views/Anchor\";\nexport * from \"./views/EnsureFlexed\";\nexport * from \"./views/Fieldset\";\nexport * from \"./views/Grid\";\nexport * from \"./views/Input\";\nexport * from \"./views/Layouts\";\nexport * from \"./views/Spinner\";\nexport * from \"./views/TextArea\";\nimport {\n  Spacer,\n  Stack,\n  Text,\n  Theme,\n  FontLanguage,\n  Unspaced,\n  TextAncestorContext,\n  AnimationDriverProvider,\n  isChrome,\n  isClient,\n  isServer,\n  isTouchable,\n  isWeb,\n  isWebTouchable,\n  mediaQueryConfig,\n  createComponent,\n  createFont,\n  createShorthands,\n  createTheme,\n  createTokens,\n  createVariable,\n  getConfig,\n  getAnimationDriver,\n  getMedia,\n  getStylesAtomic,\n  getThemes,\n  getTokens,\n  getVariable,\n  variableToString,\n  getVariableValue,\n  getVariableName,\n  insertFont,\n  isTamaguiElement,\n  isTamaguiComponent,\n  isVariable,\n  matchMedia,\n  mediaObjectToString,\n  mediaState,\n  spacedChildren,\n  styled,\n  themeable,\n  useStyle,\n  withStaticProperties,\n  useGet,\n  useEvent,\n  useDidFinishSSR,\n  useIsomorphicLayoutEffect,\n  useIsTouchDevice,\n  useMedia,\n  useTheme,\n  useThemeName,\n  useSafeRef\n} from \"@tamagui/core\";\nfunction LinearGradient(props) {\n  if (process.env.NODE_ENV === \"development\") {\n    console.warn(`LinearGradient has been moved to tamagui/linear-gradient as of 1.1`);\n  }\n  return null;\n}\nexport {\n  AnimationDriverProvider,\n  FontLanguage,\n  LinearGradient,\n  Spacer,\n  Stack,\n  Text,\n  TextAncestorContext,\n  Theme,\n  Unspaced,\n  createComponent,\n  createFont,\n  createShorthands,\n  createTheme,\n  createTokens,\n  createVariable,\n  getAnimationDriver,\n  getConfig,\n  getMedia,\n  getStylesAtomic,\n  getThemes,\n  getTokens,\n  getVariable,\n  getVariableName,\n  getVariableValue,\n  insertFont,\n  isChrome,\n  isClient,\n  isServer,\n  isTamaguiComponent,\n  isTamaguiElement,\n  isTouchable,\n  isVariable,\n  isWeb,\n  isWebTouchable,\n  matchMedia,\n  mediaObjectToString,\n  mediaQueryConfig,\n  mediaState,\n  spacedChildren,\n  styled,\n  themeable,\n  useDidFinishSSR,\n  useEvent,\n  useGet,\n  useIsTouchDevice,\n  useIsomorphicLayoutEffect,\n  useMedia,\n  useSafeRef,\n  useStyle,\n  useTheme,\n  useThemeName,\n  variableToString,\n  withStaticProperties\n};\n//# sourceMappingURL=index.mjs.map\n","import { setupReactNative } from \"@tamagui/core\";\nimport * as React from \"react\";\nimport { Text, View } from \"react-native\";\nglobalThis.React = React;\nsetupReactNative({\n  View,\n  Text\n});\nif (typeof requestAnimationFrame === \"undefined\") {\n  globalThis[\"requestAnimationFrame\"] = setImmediate;\n}\nconst cancelAnimationFrame = globalThis.cancelAnimationFrame;\nglobal.cancelAnimationFrame = (x) => {\n  try {\n    cancelAnimationFrame(x);\n  } catch {\n  }\n};\nconst idFn = () => {\n};\nexport {\n  idFn\n};\n//# sourceMappingURL=setup.mjs.map\n","//# sourceMappingURL=viewTypes.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { isWeb, styled } from \"@tamagui/core\";\nimport { SizableText } from \"@tamagui/text\";\nimport { forwardRef } from \"react\";\nimport { Linking } from \"react-native\";\nconst AnchorFrame = styled(SizableText, {\n  name: \"Anchor\",\n  tag: \"a\",\n  accessibilityRole: \"link\"\n});\nconst Anchor = AnchorFrame.extractable(\n  forwardRef(({ href, target, ...props }, ref) => {\n    return /* @__PURE__ */ jsx(\n      AnchorFrame,\n      {\n        ...props,\n        ...isWeb ? {\n          href,\n          target\n        } : {\n          onPress: (event) => {\n            var _a;\n            (_a = props.onPress) == null ? void 0 : _a.call(props, event);\n            if (href !== void 0) {\n              Linking.openURL(href);\n            }\n          }\n        },\n        ref\n      }\n    );\n  })\n);\nexport {\n  Anchor\n};\n//# sourceMappingURL=Anchor.mjs.map\n","import { Text, styled } from \"@tamagui/core\";\nconst EnsureFlexed = styled(Text, {\n  opacity: 0,\n  lineHeight: 0,\n  height: 0,\n  display: \"flex\",\n  fontSize: 200,\n  children: \"wwwwwwwwwwwwwwwwwww\",\n  hoverStyle: {\n    backgroundColor: \"red\"\n  },\n  pointerEvents: \"none\"\n});\nEnsureFlexed[\"isVisuallyHidden\"] = true;\nexport {\n  EnsureFlexed\n};\n//# sourceMappingURL=EnsureFlexed.mjs.map\n","import { styled } from \"@tamagui/core\";\nimport { YStack } from \"@tamagui/stacks\";\nconst Fieldset = styled(YStack, {\n  name: \"Fieldset\",\n  tag: \"fieldset\",\n  variants: {\n    horizontal: {\n      true: {\n        flexDirection: \"row\",\n        alignItems: \"center\"\n      }\n    }\n  }\n});\nexport {\n  Fieldset\n};\n//# sourceMappingURL=Fieldset.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { isWeb } from \"@tamagui/core\";\nimport { XStack } from \"@tamagui/stacks\";\nimport React from \"react\";\nfunction Grid({ children, columns, itemMinWidth = 200, gap }) {\n  if (isWeb) {\n    return /* @__PURE__ */ jsx(\n      \"div\",\n      {\n        style: {\n          gap,\n          display: \"grid\",\n          justifyContent: \"stretch\",\n          // gridTemplateRows: 'repeat(4, 1fr)',\n          gridTemplateColumns: `repeat( auto-fit, minmax(${itemMinWidth}px, 1fr) )`\n          // gridTemplateColumns: '1fr 1fr',\n        },\n        children\n      }\n    );\n  }\n  const childrenList = React.Children.toArray(children);\n  return /* @__PURE__ */ jsx(XStack, { alignItems: \"center\", justifyContent: \"center\", flexWrap: \"wrap\", children: childrenList.map((child, i) => {\n    if (!child) {\n      return null;\n    }\n    return /* @__PURE__ */ jsx(\n      XStack,\n      {\n        flex: 1,\n        minWidth: itemMinWidth,\n        marginRight: gap,\n        marginBottom: gap,\n        children: child\n      },\n      i\n    );\n  }) });\n}\nexport {\n  Grid\n};\n//# sourceMappingURL=Grid.mjs.map\n","import { setupReactNative, styled } from \"@tamagui/core\";\nimport { focusableInputHOC } from \"@tamagui/focusable\";\nimport { TextInput } from \"react-native\";\nimport { inputSizeVariant } from \"../helpers/inputHelpers\";\nsetupReactNative({\n  TextInput\n});\nconst defaultStyles = {\n  size: \"$true\",\n  fontFamily: \"$body\",\n  borderWidth: 1,\n  outlineWidth: 0,\n  color: \"$color\",\n  focusable: true,\n  borderColor: \"$borderColor\",\n  backgroundColor: \"$background\",\n  placeholderTextColor: \"$placeholderColor\",\n  // this fixes a flex bug where it overflows container\n  minWidth: 0,\n  hoverStyle: {\n    borderColor: \"$borderColorHover\"\n  },\n  focusStyle: {\n    outlineColor: \"$borderColorFocus\",\n    outlineWidth: 2,\n    outlineStyle: \"solid\",\n    borderColor: \"$borderColorFocus\"\n  }\n};\nconst InputFrame = styled(\n  TextInput,\n  {\n    name: \"Input\",\n    variants: {\n      unstyled: {\n        false: defaultStyles\n      },\n      size: {\n        \"...size\": inputSizeVariant\n      }\n    },\n    defaultVariants: {\n      unstyled: false\n    }\n  },\n  {\n    isInput: true\n  }\n);\nconst Input = focusableInputHOC(InputFrame);\nexport {\n  Input,\n  InputFrame,\n  defaultStyles\n};\n//# sourceMappingURL=Input.mjs.map\n","import { Stack, styled } from \"@tamagui/core\";\nconst Section = styled(Stack, {\n  name: \"Section\",\n  tag: \"section\",\n  flexDirection: \"column\",\n  accessibilityRole: \"summary\"\n});\nconst Article = styled(Stack, {\n  name: \"Article\",\n  tag: \"article\",\n  flexDirection: \"column\"\n});\nconst Main = styled(Stack, {\n  name: \"Main\",\n  tag: \"main\",\n  flexDirection: \"column\"\n});\nconst Header = styled(Stack, {\n  name: \"Header\",\n  tag: \"header\",\n  accessibilityRole: \"header\",\n  flexDirection: \"column\"\n});\nconst Aside = styled(Stack, {\n  name: \"Aside\",\n  tag: \"aside\",\n  flexDirection: \"column\"\n  // accessibilityRole: 'complementary',\n});\nconst Footer = styled(Stack, {\n  name: \"Footer\",\n  tag: \"footer\",\n  flexDirection: \"column\"\n  // accessibilityRole: 'contentinfo',\n});\nconst Nav = styled(Stack, {\n  name: \"Nav\",\n  tag: \"nav\",\n  flexDirection: \"column\"\n  // accessibilityRole: 'navigation',\n});\nexport {\n  Article,\n  Aside,\n  Footer,\n  Header,\n  Main,\n  Nav,\n  Section\n};\n//# sourceMappingURL=Layouts.mjs.map\n","import { jsx } from \"react/jsx-runtime\";\nimport {\n  themeable,\n  useTheme,\n  variableToString\n} from \"@tamagui/core\";\nimport { YStack } from \"@tamagui/stacks\";\nimport * as React from \"react\";\nimport { ActivityIndicator } from \"react-native\";\nconst Spinner = YStack.extractable(\n  themeable(\n    React.forwardRef((props, ref) => {\n      const { size, color: colorProp, ...stackProps } = props;\n      const theme = useTheme();\n      let color = colorProp;\n      if (color && color[0] === \"$\") {\n        color = variableToString(theme[color]);\n      }\n      return /* @__PURE__ */ jsx(YStack, { ref, ...stackProps, children: /* @__PURE__ */ jsx(ActivityIndicator, { size, color }) });\n    }),\n    {\n      componentName: \"Spinner\"\n    }\n  )\n);\nexport {\n  Spinner\n};\n//# sourceMappingURL=Spinner.mjs.map\n","import { styled } from \"@tamagui/core\";\nimport { focusableInputHOC } from \"@tamagui/focusable\";\nimport { textAreaSizeVariant } from \"../helpers/inputHelpers\";\nimport { InputFrame, defaultStyles } from \"./Input\";\nconst TextAreaFrame = styled(InputFrame, {\n  name: \"TextArea\",\n  multiline: true,\n  variants: {\n    unstyled: {\n      false: {\n        ...defaultStyles,\n        height: \"auto\",\n        numberOfLines: 4\n      }\n    },\n    size: {\n      \"...size\": textAreaSizeVariant\n    }\n  },\n  defaultVariants: {\n    unstyled: false\n  }\n});\nconst TextArea = focusableInputHOC(TextAreaFrame);\nexport {\n  TextArea,\n  TextAreaFrame\n};\n//# sourceMappingURL=TextArea.mjs.map\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","/**\n * Assigns a value for a given ref, no matter of the ref format\n * @param {RefObject} ref - a callback function or ref object\n * @param value - a new value\n *\n * @see https://github.com/theKashey/use-callback-ref#assignref\n * @example\n * const refObject = useRef();\n * const refFn = (ref) => {....}\n *\n * assignRef(refObject, \"refValue\");\n * assignRef(refFn, \"refValue\");\n */\nexport function assignRef(ref, value) {\n    if (typeof ref === 'function') {\n        ref(value);\n    }\n    else if (ref) {\n        ref.current = value;\n    }\n    return ref;\n}\n","import { assignRef } from './assignRef';\nimport { useCallbackRef } from './useRef';\n/**\n * Merges two or more refs together providing a single interface to set their value\n * @param {RefObject|Ref} refs\n * @returns {MutableRefObject} - a new ref, which translates all changes to {refs}\n *\n * @see {@link mergeRefs} a version without buit-in memoization\n * @see https://github.com/theKashey/use-callback-ref#usemergerefs\n * @example\n * const Component = React.forwardRef((props, ref) => {\n *   const ownRef = useRef();\n *   const domRef = useMergeRefs([ref, ownRef]); // 👈 merge together\n *   return <div ref={domRef}>...</div>\n * }\n */\nexport function useMergeRefs(refs, defaultValue) {\n    return useCallbackRef(defaultValue || null, function (newValue) { return refs.forEach(function (ref) { return assignRef(ref, newValue); }); });\n}\n","import { useState } from 'react';\n/**\n * creates a MutableRef with ref change callback\n * @param initialValue - initial ref value\n * @param {Function} callback - a callback to run when value changes\n *\n * @example\n * const ref = useCallbackRef(0, (newValue, oldValue) => console.log(oldValue, '->', newValue);\n * ref.current = 1;\n * // prints 0 -> 1\n *\n * @see https://reactjs.org/docs/hooks-reference.html#useref\n * @see https://github.com/theKashey/use-callback-ref#usecallbackref---to-replace-reactuseref\n * @returns {MutableRefObject}\n */\nexport function useCallbackRef(initialValue, callback) {\n    var ref = useState(function () { return ({\n        // value\n        value: initialValue,\n        // last callback\n        callback: callback,\n        // \"memoized\" public interface\n        facade: {\n            get current() {\n                return ref.value;\n            },\n            set current(value) {\n                var last = ref.value;\n                if (last !== value) {\n                    ref.value = value;\n                    ref.callback(value, last);\n                }\n            },\n        },\n    }); })[0];\n    // update callback\n    ref.callback = callback;\n    return ref.facade;\n}\n","import { __assign, __rest } from \"tslib\";\nimport * as React from 'react';\nvar SideCar = function (_a) {\n    var sideCar = _a.sideCar, rest = __rest(_a, [\"sideCar\"]);\n    if (!sideCar) {\n        throw new Error('Sidecar: please provide `sideCar` property to import the right car');\n    }\n    var Target = sideCar.read();\n    if (!Target) {\n        throw new Error('Sidecar medium not found');\n    }\n    return React.createElement(Target, __assign({}, rest));\n};\nSideCar.isSideCarExport = true;\nexport function exportSidecar(medium, exported) {\n    medium.useMedium(exported);\n    return SideCar;\n}\n","import { __assign } from \"tslib\";\nfunction ItoI(a) {\n    return a;\n}\nfunction innerCreateMedium(defaults, middleware) {\n    if (middleware === void 0) { middleware = ItoI; }\n    var buffer = [];\n    var assigned = false;\n    var medium = {\n        read: function () {\n            if (assigned) {\n                throw new Error('Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.');\n            }\n            if (buffer.length) {\n                return buffer[buffer.length - 1];\n            }\n            return defaults;\n        },\n        useMedium: function (data) {\n            var item = middleware(data, assigned);\n            buffer.push(item);\n            return function () {\n                buffer = buffer.filter(function (x) { return x !== item; });\n            };\n        },\n        assignSyncMedium: function (cb) {\n            assigned = true;\n            while (buffer.length) {\n                var cbs = buffer;\n                buffer = [];\n                cbs.forEach(cb);\n            }\n            buffer = {\n                push: function (x) { return cb(x); },\n                filter: function () { return buffer; },\n            };\n        },\n        assignMedium: function (cb) {\n            assigned = true;\n            var pendingQueue = [];\n            if (buffer.length) {\n                var cbs = buffer;\n                buffer = [];\n                cbs.forEach(cb);\n                pendingQueue = buffer;\n            }\n            var executeQueue = function () {\n                var cbs = pendingQueue;\n                pendingQueue = [];\n                cbs.forEach(cb);\n            };\n            var cycle = function () { return Promise.resolve().then(executeQueue); };\n            cycle();\n            buffer = {\n                push: function (x) {\n                    pendingQueue.push(x);\n                    cycle();\n                },\n                filter: function (filter) {\n                    pendingQueue = pendingQueue.filter(filter);\n                    return buffer;\n                },\n            };\n        },\n    };\n    return medium;\n}\nexport function createMedium(defaults, middleware) {\n    if (middleware === void 0) { middleware = ItoI; }\n    return innerCreateMedium(defaults, middleware);\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function createSidecarMedium(options) {\n    if (options === void 0) { options = {}; }\n    var medium = innerCreateMedium(null);\n    medium.options = __assign({ async: true, ssr: false }, options);\n    return medium;\n}\n","/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = require('react');\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n// dispatch for CommonJS interop named imports.\n\nvar useState = React.useState,\n    useEffect = React.useEffect,\n    useLayoutEffect = React.useLayoutEffect,\n    useDebugValue = React.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  {\n    if (!didWarnOld18Alpha) {\n      if (React.startTransition !== undefined) {\n        didWarnOld18Alpha = true;\n\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  var value = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedValue = getSnapshot();\n\n      if (!objectIs(value, cachedValue)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _useState = useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _useState[0].inst,\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  useLayoutEffect(function () {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n\n    var handleStoreChange = function () {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\nvar isServerEnvironment = !canUseDOM;\n\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n\nexports.useSyncExternalStore = useSyncExternalStore$2;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = require('react');\nvar shim = require('use-sync-external-store/shim');\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\nvar useSyncExternalStore = shim.useSyncExternalStore;\n\n// for CommonJS interop.\n\nvar useRef = React.useRef,\n    useEffect = React.useEffect,\n    useMemo = React.useMemo,\n    useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n\nfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n  // Use this to track the rendered snapshot.\n  var instRef = useRef(null);\n  var inst;\n\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n\n  var _useMemo = useMemo(function () {\n    // Track the memoized state using closure variables that are local to this\n    // memoized instance of a getSnapshot function. Intentionally not using a\n    // useRef hook, because that state would be shared across all concurrent\n    // copies of the hook/component.\n    var hasMemo = false;\n    var memoizedSnapshot;\n    var memoizedSelection;\n\n    var memoizedSelector = function (nextSnapshot) {\n      if (!hasMemo) {\n        // The first time the hook is called, there is no memoized result.\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n\n        var _nextSelection = selector(nextSnapshot);\n\n        if (isEqual !== undefined) {\n          // Even if the selector has changed, the currently rendered selection\n          // may be equal to the new selection. We should attempt to reuse the\n          // current value if possible, to preserve downstream memoizations.\n          if (inst.hasValue) {\n            var currentSelection = inst.value;\n\n            if (isEqual(currentSelection, _nextSelection)) {\n              memoizedSelection = currentSelection;\n              return currentSelection;\n            }\n          }\n        }\n\n        memoizedSelection = _nextSelection;\n        return _nextSelection;\n      } // We may be able to reuse the previous invocation's result.\n\n\n      // We may be able to reuse the previous invocation's result.\n      var prevSnapshot = memoizedSnapshot;\n      var prevSelection = memoizedSelection;\n\n      if (objectIs(prevSnapshot, nextSnapshot)) {\n        // The snapshot is the same as last time. Reuse the previous selection.\n        return prevSelection;\n      } // The snapshot has changed, so we need to compute a new selection.\n\n\n      // The snapshot has changed, so we need to compute a new selection.\n      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n\n      // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n        return prevSelection;\n      }\n\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    }; // Assigning this to a constant so that Flow knows it can't change.\n\n\n    // Assigning this to a constant so that Flow knows it can't change.\n    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n\n    var getSnapshotWithSelector = function () {\n      return memoizedSelector(getSnapshot());\n    };\n\n    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\n      return memoizedSelector(maybeGetServerSnapshot());\n    };\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]),\n      getSelection = _useMemo[0],\n      getServerSelection = _useMemo[1];\n\n  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n  useEffect(function () {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n  useDebugValue(value);\n  return value;\n}\n\nexports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","import { createStore } from 'zustand/vanilla';\nexport * from 'zustand/vanilla';\nimport { useDebugValue } from 'react';\nimport useSyncExternalStoreExports from 'use-sync-external-store/shim/with-selector.js';\n\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;\nfunction useStore(api, selector = api.getState, equalityFn) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\nexport { create, react as default, useStore };\n","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\") ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, subscribe, destroy };\n  state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n"],"names":[],"sourceRoot":""}