(self["webpackChunknext_app"] = self["webpackChunknext_app"] || []).push([["vendors-node_modules_tamagui_lucide-icons_dist_esm_themed_mjs-node_modules_react-native-svg_l-609481"],{

/***/ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var objectWithoutPropertiesLoose = __webpack_require__(/*! ./objectWithoutPropertiesLoose.js */ "../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js");
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../../node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs":
/*!******************************************************************************!*\
  !*** ../../node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrow": () => (/* binding */ arrow),
/* harmony export */   "autoPlacement": () => (/* binding */ autoPlacement),
/* harmony export */   "computePosition": () => (/* binding */ computePosition),
/* harmony export */   "detectOverflow": () => (/* binding */ detectOverflow),
/* harmony export */   "flip": () => (/* binding */ flip),
/* harmony export */   "hide": () => (/* binding */ hide),
/* harmony export */   "inline": () => (/* binding */ inline),
/* harmony export */   "limitShift": () => (/* binding */ limitShift),
/* harmony export */   "offset": () => (/* binding */ offset),
/* harmony export */   "rectToClientRect": () => (/* binding */ rectToClientRect),
/* harmony export */   "shift": () => (/* binding */ shift),
/* harmony export */   "size": () => (/* binding */ size)
/* harmony export */ });
function getAlignment(placement) {
  return placement.split('-')[1];
}

function getLengthFromAxis(axis) {
  return axis === 'y' ? 'height' : 'width';
}

function getSide(placement) {
  return placement.split('-')[0];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === 'x';
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain positioning strategy.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  {
    if (platform == null) {
      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));
    }
    if (validMiddleware.filter(_ref => {
      let {
        name
      } = _ref;
      return name === 'autoPlacement' || name === 'flip';
    }).length > 1) {
      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement` middleware', 'detected. This will lead to an infinite loop. Ensure only one of', 'either has been passed to the `middleware` array.'].join(' '));
    }
    if (!reference || !floating) {
      console.error(['Floating UI: The reference and/or floating element was not defined', 'when `computePosition()` was called. Ensure that both elements have', 'been created and can be measured.'].join(' '));
    }
  }
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    {
      if (resetCount > 50) {
        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));
      }
    }
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}

function getSideObjectFromPadding(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}

function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

const min = Math.min;
const max = Math.max;

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = options => ({
  name: 'arrow',
  options,
  async fn(state) {
    // Since `element` is required, we don't Partial<> the type.
    const {
      element,
      padding = 0
    } = options || {};
    const {
      x,
      y,
      placement,
      rects,
      platform
    } = state;
    if (element == null) {
      {
        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');
      }
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const minProp = axis === 'y' ? 'top' : 'left';
    const maxProp = axis === 'y' ? 'bottom' : 'right';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    if (clientSize === 0) {
      clientSize = rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;

    // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds.
    const min = paddingObject[minProp];
    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = within(min, center, max);

    // If the reference is small enough that the arrow's padding causes it to
    // to point to nothing for an aligned placement, adjust the offset of the
    // floating element itself. This stops `shift()` from taking action, but can
    // be worked around by calling it again after the `arrow()` if desired.
    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset
      }
    };
  }
});

const sides = ['top', 'right', 'bottom', 'left'];
const allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);

const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}

function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}

const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}

function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter(placement => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'autoPlacement',
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = allPlacements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = options;
      const placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const {
        main,
        cross
      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));

      // Make `computeCoords` start from the right place.
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];
      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements[currentIndex + 1];

      // There are more placements to check.
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map(d => {
        const alignment = getAlignment(d.placement);
        return [d.placement, alignment && crossAxis ?
        // Check along the mainAxis and main crossAxis side.
        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :
        // Check only the mainAxis.
        d.overflows[0], d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,
      // Aligned placements should not check their opposite crossAxis
      // side.
      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};

function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}

function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          // Try next placement and re-run the lifecycle.
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$map$so;
                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some(side => overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'hide',
    options,
    async fn(state) {
      const {
        strategy = 'referenceHidden',
        ...detectOverflowOptions
      } = options;
      const {
        rects
      } = state;
      switch (strategy) {
        case 'referenceHidden':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: 'reference'
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
        case 'escaped':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
        default:
          {
            return {};
          }
      }
    }
  };
};

/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const inline = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'inline',
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform,
        strategy
      } = state;
      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
      // ClientRect's bounds, despite the event listener being triggered. A
      // padding of 2 seems to handle this issue.
      const {
        padding = 2,
        x,
        y
      } = options;
      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: rects.reference,
        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),
        strategy
      }) : rects.reference);
      const clientRects = (await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || [];
      const paddingObject = getSideObjectFromPadding(padding);
      function getBoundingClientRect() {
        // There are two rects and they are disjoined.
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
          // Find the first rect in which the point is fully inside.
          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        }

        // There are 2 or more connected rects.
        if (clientRects.length >= 2) {
          if (getMainAxisFromPlacement(placement) === 'x') {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === 'top';
            const top = firstRect.top;
            const bottom = lastRect.bottom;
            const left = isTop ? firstRect.left : lastRect.left;
            const right = isTop ? firstRect.right : lastRect.right;
            const width = right - left;
            const height = bottom - top;
            return {
              top,
              bottom,
              left,
              right,
              width,
              height,
              x: left,
              y: top
            };
          }
          const isLeftSide = getSide(placement) === 'left';
          const maxRight = max(...clientRects.map(rect => rect.right));
          const minLeft = min(...clientRects.map(rect => rect.left));
          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform.getElementRects({
        reference: {
          getBoundingClientRect
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};

async function convertValueToCoords(state, value) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === 'x';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === 'function' ? value(state) : value;

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = function (value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: 'offset',
    options: value,
    async fn(state) {
      const {
        x,
        y
      } = state;
      const diffCoords = await convertValueToCoords(state, value);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};

function getCrossAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = options;
      const coords = {
        x,
        y
      };
      const mainAxis = getMainAxisFromPlacement(placement);
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = typeof offset === 'function' ? offset(state) : offset;
      const computedOffset = typeof rawOffset === 'number' ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === 'y' ? 'height' : 'width';
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === 'y' ? 'width' : 'height';
        const isOriginSide = ['top', 'left'].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};

/**
 * Provides data that allows you to change the size of the floating element —
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'size',
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = options;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const axis = getMainAxisFromPlacement(placement);
      const isXAxis = axis === 'x';
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isXAxis) {
        availableWidth = min(
        // Maximum clipping viewport width
        width - overflow.right - overflow.left, overflowAvailableWidth);
      } else {
        availableHeight = min(
        // Maximum clipping viewport height
        height - overflow.bottom - overflow.top, overflowAvailableHeight);
      }
      if (!state.middlewareData.shift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isXAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};




/***/ }),

/***/ "../../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs":
/*!****************************************************************************!*\
  !*** ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrow": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow),
/* harmony export */   "autoPlacement": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),
/* harmony export */   "autoUpdate": () => (/* binding */ autoUpdate),
/* harmony export */   "computePosition": () => (/* binding */ computePosition),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),
/* harmony export */   "flip": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip),
/* harmony export */   "getOverflowAncestors": () => (/* binding */ getOverflowAncestors),
/* harmony export */   "hide": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide),
/* harmony export */   "inline": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline),
/* harmony export */   "limitShift": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift),
/* harmony export */   "offset": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset),
/* harmony export */   "platform": () => (/* binding */ platform),
/* harmony export */   "shift": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift),
/* harmony export */   "size": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size)
/* harmony export */ });
/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ "../../node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs");



function getWindow(node) {
  var _node$ownerDocument;
  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

const min = Math.min;
const max = Math.max;
const round = Math.round;

function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width);
  let height = parseFloat(css.height);
  const offsetWidth = element.offsetWidth;
  const offsetHeight = element.offsetHeight;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    fallback: shouldFallback
  };
}

function getNodeName(node) {
  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';
}

let uaString;
function getUAString() {
  if (uaString) {
    return uaString;
  }
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    uaString = uaData.brands.map(item => item.brand + "/" + item.version).join(' ');
    return uaString;
  }
  return navigator.userAgent;
}

function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  // Browsers without `ShadowRoot` support.
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isContainingBlock(element) {
  // TODO: Try to use feature detection here instead.
  const isFirefox = /firefox/i.test(getUAString());
  const css = getComputedStyle$1(element);
  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;

  // This is non-exhaustive but covers the most common CSS properties that
  // create a containing block.
  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => {
    // Add type check for old browsers.
    const contain = css.contain;
    return contain != null ? contain.includes(value) : false;
  });
}

/**
 * Determines whether or not `.getBoundingClientRect()` is affected by visual
 * viewport offsets. In Safari, the `x`/`y` offsets are values relative to the
 * visual viewport, while in other engines, they are values relative to the
 * layout viewport.
 */
function isClientRectVisualViewportBased() {
  // TODO: Try to use feature detection here instead. Feature detection for
  // this can fail in various ways, making the userAgent check the most
  // reliable:
  // • Always-visible scrollbar or not
  // • Width of <html>

  // Is Safari.
  return /^((?!chrome|android).)*safari/i.test(getUAString());
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}

function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}

const FALLBACK_SCALE = {
  x: 1,
  y: 1
};
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return FALLBACK_SCALE;
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    fallback
  } = getCssDimensions(domElement);
  let x = (fallback ? round(rect.width) : rect.width) / width;
  let y = (fallback ? round(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  var _win$visualViewport, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = FALLBACK_SCALE;
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const win = domElement ? getWindow(domElement) : window;
  const addVisualOffsets = isClientRectVisualViewportBased() && isFixedStrategy;
  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;
  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += iframeRect.x;
      y += iframeRect.y;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}

function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = {
    x: 1,
    y: 1
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === 'rtl') {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}

function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    // `getParentNode` will never return a `Document` due to the fallback
    // check, so it's either the <html> or <body> element.
    return parentNode.ownerDocument.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}

function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}

function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isClientRectVisualViewportBased();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : {
    x: 1,
    y: 1
  };
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const mutableRect = {
      ...clippingAncestor
    };
    if (isClientRectVisualViewportBased()) {
      var _win$visualViewport, _win$visualViewport2;
      const win = getWindow(element);
      mutableRect.x -= ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0;
      mutableRect.y -= ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0;
    }
    rect = mutableRect;
  }
  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(rect);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';
  let currentNode = elementIsFixed ? getParentNode(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const containingBlock = isContainingBlock(currentNode);
    const shouldIgnoreCurrentNode = computedStyle.position === 'fixed';
    if (shouldIgnoreCurrentNode) {
      currentContainingBlockComputedStyle = null;
    } else {
      const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);
      if (shouldDropCurrentNode) {
        // Drop non-containing blocks.
        result = result.filter(ancestor => ancestor !== currentNode);
      } else {
        // Record last containing block for next iteration.
        currentContainingBlockComputedStyle = computedStyle;
      }
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

function getDimensions(element) {
  if (isHTMLElement(element)) {
    return getCssDimensions(element);
  }
  return element.getBoundingClientRect();
}

function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  const window = getWindow(element);
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

const platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getScale,
  async getElementRects(_ref) {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
      floating: {
        x: 0,
        y: 0,
        ...(await getDimensionsFn(floating))
      }
    };
  },
  getClientRects: element => Array.from(element.getClientRects()),
  isRTL: element => getComputedStyle$1(element).direction === 'rtl'
};

/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize = true,
    elementResize = true,
    animationFrame = false
  } = options;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  let observer = null;
  if (elementResize) {
    let initialUpdate = true;
    observer = new ResizeObserver(() => {
      if (!initialUpdate) {
        update();
      }
      initialUpdate = false;
    });
    isElement(reference) && !animationFrame && observer.observe(reference);
    if (!isElement(reference) && reference.contextElement && !animationFrame) {
      observer.observe(reference.contextElement);
    }
    observer.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _observer;
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain CSS positioning
 * strategy.
 */
const computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};




/***/ }),

/***/ "../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrow": () => (/* binding */ arrow),
/* harmony export */   "autoPlacement": () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),
/* harmony export */   "autoUpdate": () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.autoUpdate),
/* harmony export */   "computePosition": () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.computePosition),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),
/* harmony export */   "flip": () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip),
/* harmony export */   "getOverflowAncestors": () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),
/* harmony export */   "hide": () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide),
/* harmony export */   "inline": () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline),
/* harmony export */   "limitShift": () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift),
/* harmony export */   "offset": () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.offset),
/* harmony export */   "platform": () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.platform),
/* harmony export */   "shift": () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift),
/* harmony export */   "size": () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size),
/* harmony export */   "useFloating": () => (/* binding */ useFloating)
/* harmony export */ });
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ "../../node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs");
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ "../../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ "../../node_modules/react-dom/index.js");






/**
 * A data provider that provides data to position an inner element of the
 * floating element (usually a triangle or caret) so that it is centered to the
 * reference element.
 * This wraps the core `arrow` middleware to allow React refs as the element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = options => {
  const {
    element,
    padding
  } = options;
  function isRef(value) {
    return Object.prototype.hasOwnProperty.call(value, 'current');
  }
  return {
    name: 'arrow',
    options,
    fn(args) {
      if (isRef(element)) {
        if (element.current != null) {
          return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({
            element: element.current,
            padding
          }).fn(args);
        }
        return {};
      } else if (element) {
        return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({
          element,
          padding
        }).fn(args);
      }
      return {};
    }
  };
};

var index = typeof document !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_2__.useEffect;

// Fork of `fast-deep-equal` that only does the comparisons we need and compares
// functions
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === 'function' && a.toString() === b.toString()) {
    return true;
  }
  let length, i, keys;
  if (a && b && typeof a == 'object') {
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0;) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0;) {
      const key = keys[i];
      if (key === '_owner' && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}

function useLatestRef(value) {
  const ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}

/**
 * Provides data to position a floating element.
 * @see https://floating-ui.com/docs/react
 */
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = react__WEBPACK_IMPORTED_MODULE_2__.useState({
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_2__.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const referenceRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);
  const floatingRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);
  const dataRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform);
  const [reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);
  const [floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);
  const setReference = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(node => {
    if (referenceRef.current !== node) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(node => {
    if (floatingRef.current !== node) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const update = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.computePosition)(referenceRef.current, floatingRef.current, config).then(data => {
      const fullData = {
        ...data,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        react_dom__WEBPACK_IMPORTED_MODULE_3__.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData(data => ({
        ...data,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (reference && floating) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(reference, floating, update);
      } else {
        update();
      }
    }
  }, [reference, floating, update, whileElementsMountedRef]);
  const refs = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ({
    reference,
    floating
  }), [reference, floating]);
  return react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    reference: setReference,
    floating: setFloating
  }), [data, update, refs, elements, setReference, setFloating]);
}




/***/ }),

/***/ "../../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FloatingDelayGroup": () => (/* binding */ FloatingDelayGroup),
/* harmony export */   "FloatingFocusManager": () => (/* binding */ FloatingFocusManager),
/* harmony export */   "FloatingNode": () => (/* binding */ FloatingNode),
/* harmony export */   "FloatingOverlay": () => (/* binding */ FloatingOverlay),
/* harmony export */   "FloatingPortal": () => (/* binding */ FloatingPortal),
/* harmony export */   "FloatingTree": () => (/* binding */ FloatingTree),
/* harmony export */   "arrow": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.arrow),
/* harmony export */   "autoPlacement": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.autoPlacement),
/* harmony export */   "autoUpdate": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.autoUpdate),
/* harmony export */   "computePosition": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.computePosition),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow),
/* harmony export */   "flip": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.flip),
/* harmony export */   "getOverflowAncestors": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors),
/* harmony export */   "hide": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.hide),
/* harmony export */   "inline": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.inline),
/* harmony export */   "inner": () => (/* binding */ inner),
/* harmony export */   "limitShift": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.limitShift),
/* harmony export */   "offset": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.offset),
/* harmony export */   "platform": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.platform),
/* harmony export */   "safePolygon": () => (/* binding */ safePolygon),
/* harmony export */   "shift": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.shift),
/* harmony export */   "size": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.size),
/* harmony export */   "useClick": () => (/* binding */ useClick),
/* harmony export */   "useDelayGroup": () => (/* binding */ useDelayGroup),
/* harmony export */   "useDelayGroupContext": () => (/* binding */ useDelayGroupContext),
/* harmony export */   "useDismiss": () => (/* binding */ useDismiss),
/* harmony export */   "useFloating": () => (/* binding */ useFloating),
/* harmony export */   "useFloatingNodeId": () => (/* binding */ useFloatingNodeId),
/* harmony export */   "useFloatingParentNodeId": () => (/* binding */ useFloatingParentNodeId),
/* harmony export */   "useFloatingPortalNode": () => (/* binding */ useFloatingPortalNode),
/* harmony export */   "useFloatingTree": () => (/* binding */ useFloatingTree),
/* harmony export */   "useFocus": () => (/* binding */ useFocus),
/* harmony export */   "useHover": () => (/* binding */ useHover),
/* harmony export */   "useId": () => (/* binding */ useId),
/* harmony export */   "useInnerOffset": () => (/* binding */ useInnerOffset),
/* harmony export */   "useInteractions": () => (/* binding */ useInteractions),
/* harmony export */   "useListNavigation": () => (/* binding */ useListNavigation),
/* harmony export */   "useMergeRefs": () => (/* binding */ useMergeRefs),
/* harmony export */   "useRole": () => (/* binding */ useRole),
/* harmony export */   "useTransitionStatus": () => (/* binding */ useTransitionStatus),
/* harmony export */   "useTransitionStyles": () => (/* binding */ useTransitionStyles),
/* harmony export */   "useTypeahead": () => (/* binding */ useTypeahead)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var aria_hidden__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! aria-hidden */ "../../node_modules/aria-hidden/dist/es2015/index.js");
/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tabbable */ "../../node_modules/tabbable/dist/index.esm.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "../../node_modules/react-dom/index.js");
/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/react-dom */ "../../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs");
/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/react-dom */ "../../node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs");
/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/react-dom */ "../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js");








var index = typeof document !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;

let serverHandoffComplete = false;
let count = 0;
const genId = () => "floating-ui-" + count++;
function useFloatingId() {
  const [id, setId] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => serverHandoffComplete ? genId() : undefined);
  index(() => {
    if (id == null) {
      setId(genId());
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!serverHandoffComplete) {
      serverHandoffComplete = true;
    }
  }, []);
  return id;
}

// `toString()` prevents bundlers from trying to `import { useId } from 'react'`
const useReactId = react__WEBPACK_IMPORTED_MODULE_0__[/*#__PURE__*/'useId'.toString()];

/**
 * Uses React 18's built-in `useId()` when available, or falls back to a
 * slightly less performant (requiring a double render) implementation for
 * earlier React versions.
 * @see https://floating-ui.com/docs/useId
 */
const useId = useReactId || useFloatingId;

function createPubSub() {
  const map = new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach(handler => handler(data));
    },
    on(event, listener) {
      map.set(event, [...(map.get(event) || []), listener]);
    },
    off(event, listener) {
      map.set(event, (map.get(event) || []).filter(l => l !== listener));
    }
  };
}

const FloatingNodeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
const FloatingTreeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
const useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
const useFloatingTree = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingTreeContext);

/**
 * Registers a node into the floating tree, returning its id.
 */
const useFloatingNodeId = customParentId => {
  const id = useId();
  const tree = useFloatingTree();
  const reactParentId = useFloatingParentNodeId();
  const parentId = customParentId || reactParentId;
  index(() => {
    const node = {
      id,
      parentId
    };
    tree == null ? void 0 : tree.addNode(node);
    return () => {
      tree == null ? void 0 : tree.removeNode(node);
    };
  }, [tree, id, parentId]);
  return id;
};

/**
 * Provides parent node context for nested floating elements.
 * @see https://floating-ui.com/docs/FloatingTree
 */
const FloatingNode = _ref => {
  let {
    children,
    id
  } = _ref;
  const parentId = useFloatingParentNodeId();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingNodeContext.Provider, {
    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
      id,
      parentId
    }), [id, parentId])
  }, children);
};

/**
 * Provides context for nested floating elements when they are not children of
 * each other on the DOM (i.e. portalled to a common node, rather than their
 * respective parent).
 * @see https://floating-ui.com/docs/FloatingTree
 */
const FloatingTree = _ref2 => {
  let {
    children
  } = _ref2;
  const nodesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);
  const addNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {
    nodesRef.current = [...nodesRef.current, node];
  }, []);
  const removeNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {
    nodesRef.current = nodesRef.current.filter(n => n !== node);
  }, []);
  const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => createPubSub())[0];
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingTreeContext.Provider, {
    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
      nodesRef,
      addNode,
      removeNode,
      events
    }), [nodesRef, addNode, removeNode, events])
  }, children);
};

function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}

// Avoid Chrome DevTools blue warning.
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map(_ref => {
      let {
        brand,
        version
      } = _ref;
      return brand + "/" + version;
    }).join(' ');
  }
  return navigator.userAgent;
}

function getWindow(value) {
  return getDocument(value).defaultView || window;
}
function isElement(value) {
  return value ? value instanceof getWindow(value).Element : false;
}
function isHTMLElement(value) {
  return value ? value instanceof getWindow(value).HTMLElement : false;
}
function isShadowRoot(node) {
  // Browsers without `ShadowRoot` support
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }
  const androidRe = /Android/i;
  if ((androidRe.test(getPlatform()) || androidRe.test(getUserAgent())) && event.pointerType) {
    return event.type === 'click' && event.buttons === 1;
  }
  return event.detail === 0 && !event.pointerType;
}
function isVirtualPointerEvent(event) {
  return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType !== 'mouse' ||
  // iOS VoiceOver returns 0.333• for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;
}
function isSafari() {
  // Chrome DevTools does not complain about navigator.vendor
  return /apple/i.test(navigator.vendor);
}
function isMac() {
  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;
}
function isMouseLikePointerType(pointerType, strict) {
  // On some Linux machines with Chromium, mouse inputs return a `pointerType`
  // of "pen": https://github.com/floating-ui/floating-ui/issues/2015
  const values = ['mouse', 'pen'];
  if (!strict) {
    values.push('', undefined);
  }
  return values.includes(pointerType);
}

function useLatestRef(value) {
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}

const safePolygonIdentifier = 'data-floating-ui-safe-polygon';
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === 'number') {
    return value;
  }
  return value == null ? void 0 : value[prop];
}
/**
 * Opens the floating element while hovering over the reference element, like
 * CSS `:hover`.
 * @see https://floating-ui.com/docs/useHover
 */
const useHover = function (context, _temp) {
  let {
    enabled = true,
    delay = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = _temp === void 0 ? {} : _temp;
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements: {
      domReference,
      floating
    },
    refs
  } = context;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef(handleClose);
  const delayRef = useLatestRef(delay);
  const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const handlerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const restTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const blockMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);
  const performedPointerEventsMutationRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const unbindMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(() => {});
  const isHoverOpen = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';
  }, [dataRef]);

  // When dismissing before opening, clear the delay timeouts to cancel it
  // from showing.
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onDismiss() {
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      blockMouseMoveRef.current = true;
    }
    events.on('dismiss', onDismiss);
    return () => {
      events.off('dismiss', onDismiss);
    };
  }, [enabled, events]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!enabled || !handleCloseRef.current || !open) {
      return;
    }
    function onLeave() {
      if (isHoverOpen()) {
        onOpenChange(false);
      }
    }
    const html = getDocument(floating).documentElement;
    html.addEventListener('mouseleave', onLeave);
    return () => {
      html.removeEventListener('mouseleave', onLeave);
    };
  }, [floating, open, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);
  const closeWithDelay = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (runElseBranch) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }
    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = setTimeout(() => onOpenChange(false), closeDelay);
    } else if (runElseBranch) {
      clearTimeout(timeoutRef.current);
      onOpenChange(false);
    }
  }, [delayRef, onOpenChange]);
  const cleanupMouseMoveHandler = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = undefined;
  }, []);
  const clearPointerEvents = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(refs.floating.current).body;
      body.style.pointerEvents = '';
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  }, [refs]);

  // Registering the mouse events on the reference directly to bypass React's
  // delegation system. If the cursor was on a disabled element and then entered
  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!enabled) {
      return;
    }
    function isClickLikeOpenEvent() {
      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;
    }
    function onMouseEnter(event) {
      clearTimeout(timeoutRef.current);
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {
        return;
      }
      dataRef.current.openEvent = event;
      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = setTimeout(() => {
          onOpenChange(true);
        }, openDelay);
      } else {
        onOpenChange(true);
      }
    }
    function onMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }
      unbindMouseMoveRef.current();
      const doc = getDocument(floating);
      clearTimeout(restTimeoutRef.current);
      if (handleCloseRef.current) {
        // Prevent clearing `onScrollMouseLeave` timeout.
        if (!open) {
          clearTimeout(timeoutRef.current);
        }
        handlerRef.current = handleCloseRef.current({
          ...context,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            closeWithDelay();
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener('mousemove', handler);
        unbindMouseMoveRef.current = () => {
          doc.removeEventListener('mousemove', handler);
        };
        return;
      }
      closeWithDelay();
    }

    // Ensure the floating element closes after scrolling even if the pointer
    // did not move.
    // https://github.com/floating-ui/floating-ui/discussions/1692
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }
      handleCloseRef.current == null ? void 0 : handleCloseRef.current({
        ...context,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents();
          cleanupMouseMoveHandler();
          closeWithDelay();
        }
      })(event);
    }
    if (isElement(domReference)) {
      const ref = domReference;
      open && ref.addEventListener('mouseleave', onScrollMouseLeave);
      floating == null ? void 0 : floating.addEventListener('mouseleave', onScrollMouseLeave);
      move && ref.addEventListener('mousemove', onMouseEnter, {
        once: true
      });
      ref.addEventListener('mouseenter', onMouseEnter);
      ref.addEventListener('mouseleave', onMouseLeave);
      return () => {
        open && ref.removeEventListener('mouseleave', onScrollMouseLeave);
        floating == null ? void 0 : floating.removeEventListener('mouseleave', onScrollMouseLeave);
        move && ref.removeEventListener('mousemove', onMouseEnter);
        ref.removeEventListener('mouseenter', onMouseEnter);
        ref.removeEventListener('mouseleave', onMouseLeave);
      };
    }
  }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);

  // Block pointer-events of every element other than the reference and floating
  // while the floating element is open and has a `handleClose` handler. Also
  // handles nested floating elements.
  // https://github.com/floating-ui/floating-ui/issues/1722
  index(() => {
    var _handleCloseRef$curre;
    if (!enabled) {
      return;
    }
    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
      const body = getDocument(floating).body;
      body.setAttribute(safePolygonIdentifier, '');
      body.style.pointerEvents = 'none';
      performedPointerEventsMutationRef.current = true;
      if (isElement(domReference) && floating) {
        var _tree$nodesRef$curren, _tree$nodesRef$curren2;
        const ref = domReference;
        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;
        if (parentFloating) {
          parentFloating.style.pointerEvents = '';
        }
        ref.style.pointerEvents = 'auto';
        floating.style.pointerEvents = 'auto';
        return () => {
          ref.style.pointerEvents = '';
          floating.style.pointerEvents = '';
        };
      }
    }
  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, dataRef, isHoverOpen]);
  index(() => {
    if (!open) {
      pointerTypeRef.current = undefined;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      clearPointerEvents();
    };
  }, [enabled, cleanupMouseMoveHandler, clearPointerEvents]);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!enabled) {
      return {};
    }
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      reference: {
        onPointerDown: setPointerRef,
        onPointerEnter: setPointerRef,
        onMouseMove() {
          if (open || restMs === 0) {
            return;
          }
          clearTimeout(restTimeoutRef.current);
          restTimeoutRef.current = setTimeout(() => {
            if (!blockMouseMoveRef.current) {
              onOpenChange(true);
            }
          }, restMs);
        }
      },
      floating: {
        onMouseEnter() {
          clearTimeout(timeoutRef.current);
        },
        onMouseLeave() {
          events.emit('dismiss', {
            type: 'mouseLeave',
            data: {
              returnFocus: false
            }
          });
          closeWithDelay(false);
        }
      }
    };
  }, [events, enabled, restMs, open, onOpenChange, closeWithDelay]);
};

const FloatingDelayGroupContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: () => {},
  setState: () => {},
  isInstantPhase: false
});
const useDelayGroupContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingDelayGroupContext);

/**
 * Provides context for a group of floating elements that should share a
 * `delay`.
 * @see https://floating-ui.com/docs/FloatingDelayGroup
 */
const FloatingDelayGroup = _ref => {
  let {
    children,
    delay,
    timeoutMs = 0
  } = _ref;
  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer((prev, next) => ({
    ...prev,
    ...next
  }), {
    delay,
    timeoutMs,
    initialDelay: delay,
    currentId: null,
    isInstantPhase: false
  });
  const initialCurrentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const setCurrentId = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(currentId => {
    setState({
      currentId
    });
  }, []);
  index(() => {
    if (state.currentId) {
      if (initialCurrentIdRef.current === null) {
        initialCurrentIdRef.current = state.currentId;
      } else {
        setState({
          isInstantPhase: true
        });
      }
    } else {
      setState({
        isInstantPhase: false
      });
      initialCurrentIdRef.current = null;
    }
  }, [state.currentId]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingDelayGroupContext.Provider, {
    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
      ...state,
      setState,
      setCurrentId
    }), [state, setState, setCurrentId])
  }, children);
};
const useDelayGroup = (_ref2, _ref3) => {
  let {
    open,
    onOpenChange
  } = _ref2;
  let {
    id
  } = _ref3;
  const {
    currentId,
    setCurrentId,
    initialDelay,
    setState,
    timeoutMs
  } = useDelayGroupContext();
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (currentId) {
      setState({
        delay: {
          open: 1,
          close: getDelay(initialDelay, 'close')
        }
      });
      if (currentId !== id) {
        onOpenChange(false);
      }
    }
  }, [id, onOpenChange, setState, currentId, initialDelay]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    function unset() {
      onOpenChange(false);
      setState({
        delay: initialDelay,
        currentId: null
      });
    }
    if (!open && currentId === id) {
      if (timeoutMs) {
        const timeout = window.setTimeout(unset, timeoutMs);
        return () => {
          clearTimeout(timeout);
        };
      } else {
        unset();
      }
    }
  }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (open) {
      setCurrentId(id);
    }
  }, [open, setCurrentId, id]);
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

/**
 * Find the real active element. Traverses into shadowRoots.
 */
function activeElement$1(doc) {
  let activeElement = doc.activeElement;
  while (((_activeElement = activeElement) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {
    var _activeElement, _activeElement$shadow;
    activeElement = activeElement.shadowRoot.activeElement;
  }
  return activeElement;
}

function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode && child.getRootNode();

  // First, attempt with faster native method
  if (parent.contains(child)) {
    return true;
  }
  // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      // @ts-ignore
      next = next.parentNode || next.host;
    } while (next);
  }

  // Give up, the result is false
  return false;
}

let rafId = 0;
function enqueueFocus(el, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    preventScroll = false,
    cancelPrevious = true,
    sync = false
  } = options;
  cancelPrevious && cancelAnimationFrame(rafId);
  const exec = () => el == null ? void 0 : el.focus({
    preventScroll
  });
  if (sync) {
    exec();
  } else {
    rafId = requestAnimationFrame(exec);
  }
}

function getAncestors(nodes, id) {
  var _nodes$find;
  let allAncestors = [];
  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;
  while (currentParentId) {
    const currentNode = nodes.find(node => node.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId;
    if (currentNode) {
      allAncestors = allAncestors.concat(currentNode);
    }
  }
  return allAncestors;
}

function getChildren(nodes, id) {
  let allChildren = nodes.filter(node => {
    var _node$context;
    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);
  }) || [];
  let currentChildren = allChildren;
  while (currentChildren.length) {
    currentChildren = nodes.filter(node => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {
        var _node$context2;
        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);
      });
    }) || [];
    allChildren = allChildren.concat(currentChildren);
  }
  return allChildren;
}

function getTarget(event) {
  if ('composedPath' in event) {
    return event.composedPath()[0];
  }

  // TS thinks `event` is of type never as it assumes all browsers support
  // `composedPath()`, but browsers without shadow DOM don't.
  return event.target;
}

const TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled])," + "[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}

function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}

const getTabbableOptions = () => ({
  getShadowRoot: true,
  displayCheck:
  // JSDOM does not support the `tabbable` library. To solve this we can
  // check if `ResizeObserver` is a real function (not polyfilled), which
  // determines if the current environment is JSDOM-like.
  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'
});
function getTabbableIn(container, direction) {
  const allTabbable = (0,tabbable__WEBPACK_IMPORTED_MODULE_5__.tabbable)(container, getTabbableOptions());
  if (direction === 'prev') {
    allTabbable.reverse();
  }
  const activeIndex = allTabbable.indexOf(activeElement$1(getDocument(container)));
  const nextTabbableElements = allTabbable.slice(activeIndex + 1);
  return nextTabbableElements[0];
}
function getNextTabbable() {
  return getTabbableIn(document.body, 'next');
}
function getPreviousTabbable() {
  return getTabbableIn(document.body, 'prev');
}
function isOutsideEvent(event, container) {
  const containerElement = container || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}
function disableFocusInside(container) {
  const tabbableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_5__.tabbable)(container, getTabbableOptions());
  tabbableElements.forEach(element => {
    element.dataset.tabindex = element.getAttribute('tabindex') || '';
    element.setAttribute('tabindex', '-1');
  });
}
function enableFocusInside(container) {
  const elements = container.querySelectorAll('[data-tabindex]');
  elements.forEach(element => {
    const tabindex = element.dataset.tabindex;
    delete element.dataset.tabindex;
    if (tabindex) {
      element.setAttribute('tabindex', tabindex);
    } else {
      element.removeAttribute('tabindex');
    }
  });
}

// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`
const useInsertionEffect = react__WEBPACK_IMPORTED_MODULE_0__[/*#__PURE__*/'useInsertionEffect'.toString()];
const useSafeInsertionEffect = useInsertionEffect || (fn => fn());
function useEvent(callback) {
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(() => {
    if (true) {
      throw new Error('Cannot call an event handler while rendering.');
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}

// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:
// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx

const HIDDEN_STYLES = {
  border: 0,
  clip: 'rect(0 0 0 0)',
  height: '1px',
  margin: '-1px',
  overflow: 'hidden',
  padding: 0,
  position: 'fixed',
  whiteSpace: 'nowrap',
  width: '1px',
  top: 0,
  left: 0
};
let activeElement;
let timeoutId;
function setActiveElementOnTab(event) {
  if (event.key === 'Tab') {
    activeElement = event.target;
    clearTimeout(timeoutId);
  }
}
function isTabFocus(event) {
  const result = activeElement === event.relatedTarget;
  activeElement = event.relatedTarget;
  clearTimeout(timeoutId);
  return result;
}
const FocusGuard = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FocusGuard(props, ref) {
  const onFocus = useEvent(props.onFocus);
  const [role, setRole] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  index(() => {
    if (isSafari()) {
      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor
      // on VoiceOver does trigger the onFocus event, so we can use the focus
      // trap element. On Safari, only buttons trigger the onFocus event.
      // NB: "group" role in the Sandbox no longer appears to work, must be a
      // button role.
      setRole('button');
    }
    document.addEventListener('keydown', setActiveElementOnTab);
    return () => {
      document.removeEventListener('keydown', setActiveElementOnTab);
    };
  }, []);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", _extends({}, props, {
    ref: ref,
    tabIndex: 0
    // Role is only for VoiceOver
    ,
    role: role,
    "aria-hidden": role ? undefined : true,
    "data-floating-ui-focus-guard": "",
    style: HIDDEN_STYLES,
    onFocus: event => {
      if (isSafari() && isMac() && !isTabFocus(event)) {
        // On macOS we need to wait a little bit before moving
        // focus again.
        event.persist();
        timeoutId = window.setTimeout(() => {
          onFocus(event);
        }, 50);
      } else {
        onFocus(event);
      }
    }
  }));
});

const PortalContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
const useFloatingPortalNode = function (_temp) {
  let {
    id,
    enabled = true
  } = _temp === void 0 ? {} : _temp;
  const [portalEl, setPortalEl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
  const uniqueId = useId();
  const portalContext = usePortalContext();
  index(() => {
    if (!enabled) {
      return;
    }
    const rootNode = id ? document.getElementById(id) : null;
    if (rootNode) {
      rootNode.setAttribute('data-floating-ui-portal', '');
      setPortalEl(rootNode);
    } else {
      const newPortalEl = document.createElement('div');
      if (id !== '') {
        newPortalEl.id = id || uniqueId;
      }
      newPortalEl.setAttribute('data-floating-ui-portal', '');
      setPortalEl(newPortalEl);
      const container = (portalContext == null ? void 0 : portalContext.portalNode) || document.body;
      container.appendChild(newPortalEl);
      return () => {
        container.removeChild(newPortalEl);
      };
    }
  }, [id, portalContext, uniqueId, enabled]);
  return portalEl;
};

/**
 * Portals the floating element into a given container element — by default,
 * outside of the app root and into the body.
 * @see https://floating-ui.com/docs/FloatingPortal
 */
const FloatingPortal = _ref => {
  let {
    children,
    id,
    root = null,
    preserveTabOrder = true
  } = _ref;
  const portalNode = useFloatingPortalNode({
    id,
    enabled: !root
  });
  const [focusManagerState, setFocusManagerState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
  const beforeOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const afterOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const beforeInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const afterInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const shouldRenderGuards =
  // The FocusManager and therefore floating element are currently open/
  // rendered.
  !!focusManagerState &&
  // Guards are only for non-modal focus management.
  !focusManagerState.modal && !!(root || portalNode) && preserveTabOrder;

  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {
      return;
    }

    // Make sure elements inside the portal element are tabbable only when the
    // portal has already been focused, either by tabbing into a focus trap
    // element outside or using the mouse.
    function onFocus(event) {
      if (portalNode && isOutsideEvent(event)) {
        const focusing = event.type === 'focusin';
        const manageFocus = focusing ? enableFocusInside : disableFocusInside;
        manageFocus(portalNode);
      }
    }
    // Listen to the event on the capture phase so they run before the focus
    // trap elements onFocus prop is called.
    portalNode.addEventListener('focusin', onFocus, true);
    portalNode.addEventListener('focusout', onFocus, true);
    return () => {
      portalNode.removeEventListener('focusin', onFocus, true);
      portalNode.removeEventListener('focusout', onFocus, true);
    };
  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(PortalContext.Provider, {
    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
      preserveTabOrder,
      beforeOutsideRef,
      afterOutsideRef,
      beforeInsideRef,
      afterInsideRef,
      portalNode,
      setFocusManagerState
    }), [preserveTabOrder, portalNode])
  }, shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {
    "data-type": "outside",
    ref: beforeOutsideRef,
    onFocus: event => {
      if (isOutsideEvent(event, portalNode)) {
        var _beforeInsideRef$curr;
        (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();
      } else {
        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        prevTabbable == null ? void 0 : prevTabbable.focus();
      }
    }
  }), shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    "aria-owns": portalNode.id,
    style: HIDDEN_STYLES
  }), root ? /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, root) : portalNode ? /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, portalNode) : null, shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {
    "data-type": "outside",
    ref: afterOutsideRef,
    onFocus: event => {
      if (isOutsideEvent(event, portalNode)) {
        var _afterInsideRef$curre;
        (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();
      } else {
        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        nextTabbable == null ? void 0 : nextTabbable.focus();
        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false));
      }
    }
  }));
};
const usePortalContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(PortalContext);

const VisuallyHiddenDismiss = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function VisuallyHiddenDismiss(props, ref) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", _extends({}, props, {
    type: "button",
    ref: ref,
    tabIndex: -1,
    style: HIDDEN_STYLES
  }));
});
/**
 * Provides focus management for the floating element.
 * @see https://floating-ui.com/docs/FloatingFocusManager
 */
function FloatingFocusManager(_ref) {
  let {
    context,
    children,
    order = ['content'],
    guards = true,
    initialFocus = 0,
    returnFocus = true,
    modal = true,
    visuallyHiddenDismiss = false,
    closeOnFocusOut = true
  } = _ref;
  const {
    refs,
    nodeId,
    onOpenChange,
    events,
    dataRef,
    elements: {
      domReference,
      floating
    }
  } = context;
  const orderRef = useLatestRef(order);
  const tree = useFloatingTree();
  const portalContext = usePortalContext();
  const [tabbableContentLength, setTabbableContentLength] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);

  // Controlled by `useListNavigation`.
  const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;
  const startDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const endDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const preventReturnFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const previouslyFocusedElementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const isInsidePortal = portalContext != null;

  // If the reference is a combobox and is typeable (e.g. input/textarea),
  // there are different focus semantics. The guards should not be rendered, but
  // aria-hidden should be applied to all nodes still. Further, the visually
  // hidden dismiss button should only appear at the end of the list, not the
  // start.
  const isTypeableCombobox = domReference && domReference.getAttribute('role') === 'combobox' && isTypeableElement(domReference);
  const getTabbableContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (container) {
    if (container === void 0) {
      container = floating;
    }
    return container ? (0,tabbable__WEBPACK_IMPORTED_MODULE_5__.tabbable)(container, getTabbableOptions()) : [];
  }, [floating]);
  const getTabbableElements = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(container => {
    const content = getTabbableContent(container);
    return orderRef.current.map(type => {
      if (domReference && type === 'reference') {
        return domReference;
      }
      if (floating && type === 'floating') {
        return floating;
      }
      return content;
    }).filter(Boolean).flat();
  }, [domReference, floating, orderRef, getTabbableContent]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!modal) {
      return;
    }
    function onKeyDown(event) {
      if (event.key === 'Tab') {
        // The focus guards have nothing to focus, so we need to stop the event.
        if (getTabbableContent().length === 0 && !isTypeableCombobox) {
          stopEvent(event);
        }
        const els = getTabbableElements();
        const target = getTarget(event);
        if (orderRef.current[0] === 'reference' && target === domReference) {
          stopEvent(event);
          if (event.shiftKey) {
            enqueueFocus(els[els.length - 1]);
          } else {
            enqueueFocus(els[1]);
          }
        }
        if (orderRef.current[1] === 'floating' && target === floating && event.shiftKey) {
          stopEvent(event);
          enqueueFocus(els[0]);
        }
      }
    }
    const doc = getDocument(floating);
    doc.addEventListener('keydown', onKeyDown);
    return () => {
      doc.removeEventListener('keydown', onKeyDown);
    };
  }, [domReference, floating, modal, orderRef, refs, isTypeableCombobox, getTabbableContent, getTabbableElements]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!closeOnFocusOut) {
      return;
    }

    // In Safari, buttons lose focus when pressing them.
    function handlePointerDown() {
      isPointerDownRef.current = true;
      setTimeout(() => {
        isPointerDownRef.current = false;
      });
    }
    function handleFocusOutside(event) {
      const relatedTarget = event.relatedTarget;
      const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute('data-floating-ui-focus-guard') || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {
        var _node$context, _node$context2;
        return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);
      }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {
        var _node$context3, _node$context4;
        return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;
      })));

      // Focus did not move inside the floating tree, and there are no tabbable
      // portal guards to handle closing.
      if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&
      // Fix React 18 Strict Mode returnFocus due to double rendering.
      relatedTarget !== previouslyFocusedElementRef.current) {
        preventReturnFocusRef.current = true;
        // On iOS VoiceOver, dismissing the nested submenu will cause the
        // first item of the list to receive focus. Delaying it appears to fix
        // the issue.
        setTimeout(() => onOpenChange(false));
      }
    }
    if (floating && isHTMLElement(domReference)) {
      domReference.addEventListener('focusout', handleFocusOutside);
      domReference.addEventListener('pointerdown', handlePointerDown);
      !modal && floating.addEventListener('focusout', handleFocusOutside);
      return () => {
        domReference.removeEventListener('focusout', handleFocusOutside);
        domReference.removeEventListener('pointerdown', handlePointerDown);
        !modal && floating.removeEventListener('focusout', handleFocusOutside);
      };
    }
  }, [domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    var _portalContext$portal;
    // Don't hide portals nested within the parent portal.
    const portalNodes = Array.from((portalContext == null ? void 0 : (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll('[data-floating-ui-portal]')) || []);
    function getDismissButtons() {
      return [startDismissButtonRef.current, endDismissButtonRef.current].filter(Boolean);
    }
    if (floating && modal) {
      const insideNodes = [floating, ...portalNodes, ...getDismissButtons()];
      const cleanup = (0,aria_hidden__WEBPACK_IMPORTED_MODULE_6__.hideOthers)(orderRef.current.includes('reference') || isTypeableCombobox ? insideNodes.concat(domReference || []) : insideNodes);
      return () => {
        cleanup();
      };
    }
  }, [domReference, floating, modal, orderRef, portalContext, isTypeableCombobox]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (modal && !guards && floating) {
      const tabIndexValues = [];
      const options = getTabbableOptions();
      const allTabbable = (0,tabbable__WEBPACK_IMPORTED_MODULE_5__.tabbable)(getDocument(floating).body, options);
      const floatingTabbable = getTabbableElements();

      // Exclude all tabbable elements that are part of the order
      const elements = allTabbable.filter(el => !floatingTabbable.includes(el));
      elements.forEach((el, i) => {
        tabIndexValues[i] = el.getAttribute('tabindex');
        el.setAttribute('tabindex', '-1');
      });
      return () => {
        elements.forEach((el, i) => {
          const value = tabIndexValues[i];
          if (value == null) {
            el.removeAttribute('tabindex');
          } else {
            el.setAttribute('tabindex', value);
          }
        });
      };
    }
  }, [floating, modal, guards, getTabbableElements]);
  index(() => {
    if (!floating) return;
    const doc = getDocument(floating);
    let returnFocusValue = returnFocus;
    let preventReturnFocusScroll = false;
    const previouslyFocusedElement = activeElement$1(doc);
    const contextData = dataRef.current;
    previouslyFocusedElementRef.current = previouslyFocusedElement;
    const focusableElements = getTabbableElements(floating);
    const elToFocus = (typeof initialFocus === 'number' ? focusableElements[initialFocus] : initialFocus.current) || floating;

    // If the `useListNavigation` hook is active, always ignore `initialFocus`
    // because it has its own handling of the initial focus.
    !ignoreInitialFocus && enqueueFocus(elToFocus, {
      preventScroll: elToFocus === floating
    });

    // Dismissing via outside press should always ignore `returnFocus` to
    // prevent unwanted scrolling.
    function onDismiss(payload) {
      if (payload.type === 'escapeKey' && refs.domReference.current) {
        previouslyFocusedElementRef.current = refs.domReference.current;
      }
      if (['referencePress', 'escapeKey'].includes(payload.type)) {
        return;
      }
      const returnFocus = payload.data.returnFocus;
      if (typeof returnFocus === 'object') {
        returnFocusValue = true;
        preventReturnFocusScroll = returnFocus.preventScroll;
      } else {
        returnFocusValue = returnFocus;
      }
    }
    events.on('dismiss', onDismiss);
    return () => {
      events.off('dismiss', onDismiss);
      if (contains(floating, activeElement$1(doc)) && refs.domReference.current) {
        previouslyFocusedElementRef.current = refs.domReference.current;
      }
      if (returnFocusValue && isHTMLElement(previouslyFocusedElementRef.current) && !preventReturnFocusRef.current) {
        // `isPointerDownRef.current` to avoid the focus ring from appearing on
        // the reference element when click-toggling it.
        if (!refs.domReference.current || isPointerDownRef.current) {
          enqueueFocus(previouslyFocusedElementRef.current, {
            // When dismissing nested floating elements, by the time the rAF has
            // executed, the menus will all have been unmounted. When they try
            // to get focused, the calls get ignored — leaving the root
            // reference focused as desired.
            cancelPrevious: false,
            preventScroll: preventReturnFocusScroll
          });
        } else {
          var _previouslyFocusedEle;
          // If the user has specified a `keydown` listener that calls
          // setOpen(false) (e.g. selecting an item and closing the floating
          // element), then sync return focus causes `useClick` to immediately
          // re-open it, unless they call `event.preventDefault()` in the
          // `keydown` listener. This helps keep backwards compatibility with
          // older examples.
          contextData.__syncReturnFocus = true;

          // In Safari, `useListNavigation` moves focus sync, so making this
          // sync ensures the initial item remains focused despite this being
          // invoked in Strict Mode due to double-invoked useEffects. This also
          // has the positive side effect of closing a modally focus-managed
          // <Menu> on `Tab` keydown to move naturally to the next focusable
          // element.
          (_previouslyFocusedEle = previouslyFocusedElementRef.current) == null ? void 0 : _previouslyFocusedEle.focus({
            preventScroll: preventReturnFocusScroll
          });
          setTimeout(() => {
            // This isn't an actual property the user should access, make sure
            // it doesn't persist.
            delete contextData.__syncReturnFocus;
          });
        }
      }
    };
  }, [floating, getTabbableElements, initialFocus, returnFocus, dataRef, refs, events, ignoreInitialFocus]);

  // Synchronize the `context` & `modal` value to the FloatingPortal context.
  // It will decide whether or not it needs to render its own guards.
  index(() => {
    if (!portalContext) return;
    portalContext.setFocusManagerState({
      ...context,
      modal,
      closeOnFocusOut
      // Not concerned about the <RT> generic type.
    });

    return () => {
      portalContext.setFocusManagerState(null);
    };
  }, [portalContext, modal, closeOnFocusOut, context]);
  index(() => {
    if (ignoreInitialFocus || !floating) return;
    function setState() {
      setTabbableContentLength(getTabbableContent().length);
    }
    setState();
    if (typeof MutationObserver === 'function') {
      const observer = new MutationObserver(setState);
      observer.observe(floating, {
        childList: true,
        subtree: true
      });
      return () => {
        observer.disconnect();
      };
    }
  }, [floating, getTabbableContent, ignoreInitialFocus, refs]);
  const shouldRenderGuards = guards && (isInsidePortal || modal) && !isTypeableCombobox;
  function renderDismissButton(location) {
    return visuallyHiddenDismiss && modal ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(VisuallyHiddenDismiss, {
      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,
      onClick: () => onOpenChange(false)
    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss') : null;
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, shouldRenderGuards && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,
    onFocus: event => {
      if (modal) {
        const els = getTabbableElements();
        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        preventReturnFocusRef.current = false;
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const nextTabbable = getNextTabbable() || domReference;
          nextTabbable == null ? void 0 : nextTabbable.focus();
        } else {
          var _portalContext$before;
          (_portalContext$before = portalContext.beforeOutsideRef.current) == null ? void 0 : _portalContext$before.focus();
        }
      }
    }
  }), isTypeableCombobox ? null : renderDismissButton('start'), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(children, tabbableContentLength === 0 || order.includes('floating') ? {
    tabIndex: 0
  } : {}), renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,
    onFocus: event => {
      if (modal) {
        enqueueFocus(getTabbableElements()[0]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        preventReturnFocusRef.current = true;
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const prevTabbable = getPreviousTabbable() || domReference;
          prevTabbable == null ? void 0 : prevTabbable.focus();
        } else {
          var _portalContext$afterO;
          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null ? void 0 : _portalContext$afterO.focus();
        }
      }
    }
  }));
}

const identifier = 'data-floating-ui-scroll-lock';

/**
 * Provides base styling for a fixed overlay element to dim content or block
 * pointer events behind a floating element.
 * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.
 * @see https://floating-ui.com/docs/FloatingOverlay
 */
const FloatingOverlay = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingOverlay(_ref, ref) {
  let {
    lockScroll = false,
    ...rest
  } = _ref;
  index(() => {
    var _window$visualViewpor, _window$visualViewpor2;
    if (!lockScroll) {
      return;
    }
    const alreadyLocked = document.body.hasAttribute(identifier);
    if (alreadyLocked) {
      return;
    }
    document.body.setAttribute(identifier, '');

    // RTL <body> scrollbar
    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;

    // Only iOS doesn't respect `overflow: hidden` on document.body, and this
    // technique has fewer side effects.
    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {
      Object.assign(document.body.style, {
        overflow: 'hidden',
        [paddingProp]: scrollbarWidth + "px"
      });
      return () => {
        document.body.removeAttribute(identifier);
        Object.assign(document.body.style, {
          overflow: '',
          [paddingProp]: ''
        });
      };
    }

    // iOS 12 does not support `visualViewport`.
    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
    const scrollX = window.pageXOffset;
    const scrollY = window.pageYOffset;
    Object.assign(document.body.style, {
      position: 'fixed',
      overflow: 'hidden',
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: '0',
      [paddingProp]: scrollbarWidth + "px"
    });
    return () => {
      Object.assign(document.body.style, {
        position: '',
        overflow: '',
        top: '',
        left: '',
        right: '',
        [paddingProp]: ''
      });
      document.body.removeAttribute(identifier);
      window.scrollTo(scrollX, scrollY);
    };
  }, [lockScroll]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", _extends({
    ref: ref
  }, rest, {
    style: {
      position: 'fixed',
      overflow: 'auto',
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  }));
});

function isButtonTarget(event) {
  return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';
}
function isSpaceIgnored(element) {
  return isTypeableElement(element);
}
/**
 * Opens or closes the floating element when clicking the reference element.
 * @see https://floating-ui.com/docs/useClick
 */
const useClick = function (_ref, _temp) {
  let {
    open,
    onOpenChange,
    dataRef,
    elements: {
      domReference
    }
  } = _ref;
  let {
    enabled = true,
    event: eventOption = 'click',
    toggle = true,
    ignoreMouse = false,
    keyboardHandlers = true
  } = _temp === void 0 ? {} : _temp;
  const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!enabled) {
      return {};
    }
    return {
      reference: {
        onPointerDown(event) {
          pointerTypeRef.current = event.pointerType;
        },
        onMouseDown(event) {
          // Ignore all buttons except for the "main" button.
          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
          if (event.button !== 0) {
            return;
          }
          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {
            return;
          }
          if (eventOption === 'click') {
            return;
          }
          if (open) {
            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {
              onOpenChange(false);
            }
          } else {
            // Prevent stealing focus from the floating element
            event.preventDefault();
            onOpenChange(true);
          }
          dataRef.current.openEvent = event.nativeEvent;
        },
        onClick(event) {
          if (dataRef.current.__syncReturnFocus) {
            return;
          }
          if (eventOption === 'mousedown' && pointerTypeRef.current) {
            pointerTypeRef.current = undefined;
            return;
          }
          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {
            return;
          }
          if (open) {
            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {
              onOpenChange(false);
            }
          } else {
            onOpenChange(true);
          }
          dataRef.current.openEvent = event.nativeEvent;
        },
        onKeyDown(event) {
          pointerTypeRef.current = undefined;
          if (!keyboardHandlers) {
            return;
          }
          if (isButtonTarget(event)) {
            return;
          }
          if (event.key === ' ' && !isSpaceIgnored(domReference)) {
            // Prevent scrolling
            event.preventDefault();
          }
          if (event.key === 'Enter') {
            if (open) {
              if (toggle) {
                onOpenChange(false);
              }
            } else {
              onOpenChange(true);
            }
          }
        },
        onKeyUp(event) {
          if (!keyboardHandlers) {
            return;
          }
          if (isButtonTarget(event) || isSpaceIgnored(domReference)) {
            return;
          }
          if (event.key === ' ') {
            if (open) {
              if (toggle) {
                onOpenChange(false);
              }
            } else {
              onOpenChange(true);
            }
          }
        }
      }
    };
  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);
};

/**
 * Check whether the event.target is within the provided node. Uses event.composedPath if available for custom element support.
 *
 * @param event The event whose target/composedPath to check
 * @param node The node to check against
 * @returns Whether the event.target/composedPath is within the node.
 */
function isEventTargetWithin(event, node) {
  if (node == null) {
    return false;
  }
  if ('composedPath' in event) {
    return event.composedPath().includes(node);
  }

  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't
  const e = event;
  return e.target != null && node.contains(e.target);
}

const bubbleHandlerKeys = {
  pointerdown: 'onPointerDown',
  mousedown: 'onMouseDown',
  click: 'onClick'
};
const captureHandlerKeys = {
  pointerdown: 'onPointerDownCapture',
  mousedown: 'onMouseDownCapture',
  click: 'onClickCapture'
};
const normalizeBubblesProp = function (bubbles) {
  var _bubbles$escapeKey, _bubbles$outsidePress;
  if (bubbles === void 0) {
    bubbles = true;
  }
  return {
    escapeKeyBubbles: typeof bubbles === 'boolean' ? bubbles : (_bubbles$escapeKey = bubbles.escapeKey) != null ? _bubbles$escapeKey : true,
    outsidePressBubbles: typeof bubbles === 'boolean' ? bubbles : (_bubbles$outsidePress = bubbles.outsidePress) != null ? _bubbles$outsidePress : true
  };
};
/**
 * Closes the floating element when a dismissal is requested — by default, when
 * the user presses the `escape` key or outside of the floating element.
 * @see https://floating-ui.com/docs/useDismiss
 */
const useDismiss = function (_ref, _temp) {
  let {
    open,
    onOpenChange,
    events,
    nodeId,
    elements: {
      reference,
      domReference,
      floating
    },
    dataRef
  } = _ref;
  let {
    enabled = true,
    escapeKey = true,
    outsidePress: unstable_outsidePress = true,
    outsidePressEvent = 'pointerdown',
    referencePress = false,
    referencePressEvent = 'pointerdown',
    ancestorScroll = false,
    bubbles = true
  } = _temp === void 0 ? {} : _temp;
  const tree = useFloatingTree();
  const nested = useFloatingParentNodeId() != null;
  const outsidePressFn = useEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);
  const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;
  const insideReactTreeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const {
    escapeKeyBubbles,
    outsidePressBubbles
  } = normalizeBubblesProp(bubbles);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!open || !enabled) {
      return;
    }
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
    dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    function onKeyDown(event) {
      if (event.key === 'Escape') {
        const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
        if (children.length > 0) {
          let shouldDismiss = true;
          children.forEach(child => {
            var _child$context;
            if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
              shouldDismiss = false;
              return;
            }
          });
          if (!shouldDismiss) {
            return;
          }
        }
        events.emit('dismiss', {
          type: 'escapeKey',
          data: {
            returnFocus: {
              preventScroll: false
            }
          }
        });
        onOpenChange(false);
      }
    }
    function onOutsidePress(event) {
      // Given developers can stop the propagation of the synthetic event,
      // we can only be confident with a positive value.
      const insideReactTree = insideReactTreeRef.current;
      insideReactTreeRef.current = false;
      if (insideReactTree) {
        return;
      }
      if (typeof outsidePress === 'function' && !outsidePress(event)) {
        return;
      }
      const target = getTarget(event);

      // Check if the click occurred on the scrollbar
      if (isHTMLElement(target) && floating) {
        const win = floating.ownerDocument.defaultView || window;
        const canScrollX = target.scrollWidth > target.clientWidth;
        const canScrollY = target.scrollHeight > target.clientHeight;
        let xCond = canScrollY && event.offsetX > target.clientWidth;

        // In some browsers it is possible to change the <body> (or window)
        // scrollbar to the left side, but is very rare and is difficult to
        // check for. Plus, for modal dialogs with backdrops, it is more
        // important that the backdrop is checked but not so much the window.
        if (canScrollY) {
          const isRTL = win.getComputedStyle(target).direction === 'rtl';
          if (isRTL) {
            xCond = event.offsetX <= target.offsetWidth - target.clientWidth;
          }
        }
        if (xCond || canScrollX && event.offsetY > target.clientHeight) {
          return;
        }
      }
      const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {
        var _node$context;
        return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
      });
      if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {
        return;
      }
      const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
      if (children.length > 0) {
        let shouldDismiss = true;
        children.forEach(child => {
          var _child$context2;
          if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
            shouldDismiss = false;
            return;
          }
        });
        if (!shouldDismiss) {
          return;
        }
      }
      events.emit('dismiss', {
        type: 'outsidePress',
        data: {
          returnFocus: nested ? {
            preventScroll: true
          } : isVirtualClick(event) || isVirtualPointerEvent(event)
        }
      });
      onOpenChange(false);
    }
    function onScroll() {
      onOpenChange(false);
    }
    const doc = getDocument(floating);
    escapeKey && doc.addEventListener('keydown', onKeyDown);
    outsidePress && doc.addEventListener(outsidePressEvent, onOutsidePress);
    let ancestors = [];
    if (ancestorScroll) {
      if (isElement(domReference)) {
        ancestors = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(domReference);
      }
      if (isElement(floating)) {
        ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(floating));
      }
      if (!isElement(reference) && reference && reference.contextElement) {
        ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(reference.contextElement));
      }
    }

    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)
    ancestors = ancestors.filter(ancestor => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    });
    ancestors.forEach(ancestor => {
      ancestor.addEventListener('scroll', onScroll, {
        passive: true
      });
    });
    return () => {
      escapeKey && doc.removeEventListener('keydown', onKeyDown);
      outsidePress && doc.removeEventListener(outsidePressEvent, onOutsidePress);
      ancestors.forEach(ancestor => {
        ancestor.removeEventListener('scroll', onScroll);
      });
    };
  }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, events, tree, nodeId, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, nested]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    insideReactTreeRef.current = false;
  }, [outsidePress, outsidePressEvent]);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!enabled) {
      return {};
    }
    return {
      reference: {
        [bubbleHandlerKeys[referencePressEvent]]: () => {
          if (referencePress) {
            events.emit('dismiss', {
              type: 'referencePress',
              data: {
                returnFocus: false
              }
            });
            onOpenChange(false);
          }
        }
      },
      floating: {
        [captureHandlerKeys[outsidePressEvent]]: () => {
          insideReactTreeRef.current = true;
        }
      }
    };
  }, [enabled, events, referencePress, outsidePressEvent, referencePressEvent, onOpenChange]);
};

/**
 * Opens the floating element while the reference element has focus, like CSS
 * `:focus`.
 * @see https://floating-ui.com/docs/useFocus
 */
const useFocus = function (_ref, _temp) {
  let {
    open,
    onOpenChange,
    dataRef,
    events,
    refs,
    elements: {
      floating,
      domReference
    }
  } = _ref;
  let {
    enabled = true,
    keyboardOnly = true
  } = _temp === void 0 ? {} : _temp;
  const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef('');
  const blockFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!enabled) {
      return;
    }
    const doc = getDocument(floating);
    const win = doc.defaultView || window;

    // If the reference was focused and the user left the tab/window, and the
    // floating element was not open, the focus should be blocked when they
    // return to the tab/window.
    function onBlur() {
      if (!open && isHTMLElement(domReference) && domReference === activeElement$1(getDocument(domReference))) {
        blockFocusRef.current = true;
      }
    }
    win.addEventListener('blur', onBlur);
    return () => {
      win.removeEventListener('blur', onBlur);
    };
  }, [floating, domReference, open, enabled]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onDismiss(payload) {
      if (payload.type === 'referencePress' || payload.type === 'escapeKey') {
        blockFocusRef.current = true;
      }
    }
    events.on('dismiss', onDismiss);
    return () => {
      events.off('dismiss', onDismiss);
    };
  }, [events, enabled]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    return () => {
      clearTimeout(timeoutRef.current);
    };
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!enabled) {
      return {};
    }
    return {
      reference: {
        onPointerDown(_ref2) {
          let {
            pointerType
          } = _ref2;
          pointerTypeRef.current = pointerType;
          blockFocusRef.current = !!(pointerType && keyboardOnly);
        },
        onMouseLeave() {
          blockFocusRef.current = false;
        },
        onFocus(event) {
          var _dataRef$current$open;
          if (blockFocusRef.current) {
            return;
          }

          // Dismiss with click should ignore the subsequent `focus` trigger,
          // but only if the click originated inside the reference element.
          if (event.type === 'focus' && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === 'mousedown' && dataRef.current.openEvent && isEventTargetWithin(dataRef.current.openEvent, domReference)) {
            return;
          }
          dataRef.current.openEvent = event.nativeEvent;
          onOpenChange(true);
        },
        onBlur(event) {
          blockFocusRef.current = false;
          const relatedTarget = event.relatedTarget;

          // Hit the non-modal focus management portal guard. Focus will be
          // moved into the floating element immediately after.
          const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute('data-floating-ui-focus-guard') && relatedTarget.getAttribute('data-type') === 'outside';

          // Wait for the window blur listener to fire.
          timeoutRef.current = setTimeout(() => {
            // When focusing the reference element (e.g. regular click), then
            // clicking into the floating element, prevent it from hiding.
            // Note: it must be focusable, e.g. `tabindex="-1"`.
            if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {
              return;
            }
            onOpenChange(false);
          });
        }
      }
    };
  }, [enabled, keyboardOnly, domReference, refs, dataRef, onOpenChange]);
};

let isPreventScrollSupported = false;
const ARROW_UP = 'ArrowUp';
const ARROW_DOWN = 'ArrowDown';
const ARROW_LEFT = 'ArrowLeft';
const ARROW_RIGHT = 'ArrowRight';
function isDifferentRow(index, cols, prevRow) {
  return Math.floor(index / cols) !== prevRow;
}
function isIndexOutOfBounds(listRef, index) {
  return index < 0 || index >= listRef.current.length;
}
function findNonDisabledIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  const list = listRef.current;
  let index = startingIndex;
  do {
    var _list$index, _list$index2;
    index = index + (decrement ? -amount : amount);
  } while (index >= 0 && index <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index) : list[index] == null || ((_list$index = list[index]) == null ? void 0 : _list$index.hasAttribute('disabled')) || ((_list$index2 = list[index]) == null ? void 0 : _list$index2.getAttribute('aria-disabled')) === 'true'));
  return index;
}
function doSwitch(orientation, vertical, horizontal) {
  switch (orientation) {
    case 'vertical':
      return vertical;
    case 'horizontal':
      return horizontal;
    default:
      return vertical || horizontal;
  }
}
function isMainOrientationKey(key, orientation) {
  const vertical = key === ARROW_UP || key === ARROW_DOWN;
  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal);
}
function isMainOrientationToEndKey(key, orientation, rtl) {
  const vertical = key === ARROW_DOWN;
  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key == ' ' || key === '';
}
function isCrossOrientationOpenKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  const horizontal = key === ARROW_DOWN;
  return doSwitch(orientation, vertical, horizontal);
}
function isCrossOrientationCloseKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;
  const horizontal = key === ARROW_UP;
  return doSwitch(orientation, vertical, horizontal);
}
function getMinIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    disabledIndices
  });
}
function getMaxIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
/**
 * Adds arrow key-based navigation of a list of items, either using real DOM
 * focus or virtual focus.
 * @see https://floating-ui.com/docs/useListNavigation
 */
const useListNavigation = function (_ref, _temp2) {
  let {
    open,
    onOpenChange,
    refs,
    elements: {
      domReference
    }
  } = _ref;
  let {
    listRef,
    activeIndex,
    onNavigate: unstable_onNavigate = () => {},
    enabled = true,
    selectedIndex = null,
    allowEscape = false,
    loop = false,
    nested = false,
    rtl = false,
    virtual = false,
    focusItemOnOpen = 'auto',
    focusItemOnHover = true,
    openOnArrowKeyDown = true,
    disabledIndices = undefined,
    orientation = 'vertical',
    cols = 1,
    scrollItemIntoView = true
  } = _temp2 === void 0 ? {
    listRef: {
      current: []
    },
    activeIndex: null,
    onNavigate: () => {}
  } : _temp2;
  if (true) {
    if (allowEscape) {
      if (!loop) {
        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));
      }
      if (!virtual) {
        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));
      }
    }
    if (orientation === 'vertical' && cols > 1) {
      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either "horizontal" or "both".'].join(' '));
    }
  }
  const parentId = useFloatingParentNodeId();
  const tree = useFloatingTree();
  const onNavigate = useEvent(unstable_onNavigate);
  const focusItemOnOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusItemOnOpen);
  const indexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selectedIndex != null ? selectedIndex : -1);
  const keyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const isPointerModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);
  const previousOnNavigateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onNavigate);
  const previousOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(open);
  const forceSyncFocus = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const forceScrollIntoViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const disabledIndicesRef = useLatestRef(disabledIndices);
  const latestOpenRef = useLatestRef(open);
  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);
  const [activeId, setActiveId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const focusItem = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (listRef, indexRef, forceScrollIntoView) {
    if (forceScrollIntoView === void 0) {
      forceScrollIntoView = false;
    }
    const item = listRef.current[indexRef.current];
    if (virtual) {
      setActiveId(item == null ? void 0 : item.id);
    } else {
      enqueueFocus(item, {
        preventScroll: true,
        // Mac Safari does not move the virtual cursor unless the focus call
        // is sync. However, for the very first focus call, we need to wait
        // for the position to be ready in order to prevent unwanted
        // scrolling. This means the virtual cursor will not move to the first
        // item when first opening the floating element, but will on
        // subsequent calls. `preventScroll` is supported in modern Safari,
        // so we can use that instead.
        // iOS Safari must be async or the first item will not be focused.
        sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false
      });
    }
    requestAnimationFrame(() => {
      const scrollIntoViewOptions = scrollItemIntoViewRef.current;
      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);
      if (shouldScrollIntoView) {
        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported
        // by all browsers.
        item.scrollIntoView == null ? void 0 : item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {
          block: 'nearest',
          inline: 'nearest'
        } : scrollIntoViewOptions);
      }
    });
  }, [virtual, scrollItemIntoViewRef]);
  index(() => {
    document.createElement('div').focus({
      get preventScroll() {
        isPreventScrollSupported = true;
        return false;
      }
    });
  }, []);

  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating
  // element. Also, reset `activeIndex` upon closing the floating element.
  index(() => {
    if (!enabled) {
      return;
    }
    if (open) {
      if (focusItemOnOpenRef.current && selectedIndex != null) {
        // Regardless of the pointer modality, we want to ensure the selected
        // item comes into view when the floating element is opened.
        forceScrollIntoViewRef.current = true;
        onNavigate(selectedIndex);
      }
    } else if (previousOpenRef.current) {
      // Since the user can specify `onNavigate` conditionally
      // (onNavigate: open ? setActiveIndex : setSelectedIndex),
      // we store and call the previous function.
      indexRef.current = -1;
      previousOnNavigateRef.current(null);
    }
  }, [enabled, open, selectedIndex, onNavigate]);

  // Sync `activeIndex` to be the focused item while the floating element is
  // open.
  index(() => {
    if (!enabled) {
      return;
    }
    if (open) {
      if (activeIndex == null) {
        forceSyncFocus.current = false;
        if (selectedIndex != null) {
          return;
        }

        // Reset while the floating element was open (e.g. the list changed).
        if (previousOpenRef.current) {
          indexRef.current = -1;
          focusItem(listRef, indexRef);
        }

        // Initial sync.
        if (!previousOpenRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {
          indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);
          onNavigate(indexRef.current);
        }
      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {
        indexRef.current = activeIndex;
        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);
        forceScrollIntoViewRef.current = false;
      }
    }
  }, [enabled, open, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);

  // Ensure the parent floating element has focus when a nested child closes
  // to allow arrow key navigation to work after the pointer leaves the child.
  index(() => {
    if (!enabled) {
      return;
    }
    if (previousOpenRef.current && !open) {
      var _tree$nodesRef$curren, _tree$nodesRef$curren2;
      const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;
      if (parentFloating && !contains(parentFloating, activeElement$1(getDocument(parentFloating)))) {
        parentFloating.focus({
          preventScroll: true
        });
      }
    }
  }, [enabled, open, tree, parentId]);
  index(() => {
    keyRef.current = null;
    previousOnNavigateRef.current = onNavigate;
    previousOpenRef.current = open;
  });
  const hasActiveIndex = activeIndex != null;
  const item = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    function syncCurrentTarget(currentTarget) {
      if (!open) return;
      const index = listRef.current.indexOf(currentTarget);
      if (index !== -1) {
        onNavigate(index);
      }
    }
    const props = {
      onFocus(_ref2) {
        let {
          currentTarget
        } = _ref2;
        syncCurrentTarget(currentTarget);
      },
      onClick: _ref3 => {
        let {
          currentTarget
        } = _ref3;
        return currentTarget.focus({
          preventScroll: true
        });
      },
      // Safari
      ...(focusItemOnHover && {
        onMouseMove(_ref4) {
          let {
            currentTarget
          } = _ref4;
          syncCurrentTarget(currentTarget);
        },
        onPointerLeave() {
          if (!isPointerModalityRef.current) {
            return;
          }
          indexRef.current = -1;
          focusItem(listRef, indexRef);

          // Virtual cursor with VoiceOver on iOS needs this to be flushed
          // synchronously or there is a glitch that prevents nested
          // submenus from being accessible.
          (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => onNavigate(null));
          if (!virtual) {
            var _refs$floating$curren;
            // This also needs to be sync to prevent fast mouse movements
            // from leaving behind a stale active item when landing on a
            // disabled button item.
            (_refs$floating$curren = refs.floating.current) == null ? void 0 : _refs$floating$curren.focus({
              preventScroll: true
            });
          }
        }
      })
    };
    return props;
  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!enabled) {
      return {};
    }
    const disabledIndices = disabledIndicesRef.current;
    function onKeyDown(event) {
      isPointerModalityRef.current = false;
      forceSyncFocus.current = true;

      // If the floating element is animating out, ignore navigation. Otherwise,
      // the `activeIndex` gets set to 0 despite not being open so the next time
      // the user ArrowDowns, the first item won't be focused.
      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {
        return;
      }
      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {
        stopEvent(event);
        onOpenChange(false);
        if (isHTMLElement(domReference)) {
          domReference.focus();
        }
        return;
      }
      const currentIndex = indexRef.current;
      const minIndex = getMinIndex(listRef, disabledIndices);
      const maxIndex = getMaxIndex(listRef, disabledIndices);
      if (event.key === 'Home') {
        indexRef.current = minIndex;
        onNavigate(indexRef.current);
      }
      if (event.key === 'End') {
        indexRef.current = maxIndex;
        onNavigate(indexRef.current);
      }

      // Grid navigation.
      if (cols > 1) {
        const prevIndex = indexRef.current;
        if (event.key === ARROW_UP) {
          stopEvent(event);
          if (prevIndex === -1) {
            indexRef.current = maxIndex;
          } else {
            indexRef.current = findNonDisabledIndex(listRef, {
              startingIndex: prevIndex,
              amount: cols,
              decrement: true,
              disabledIndices
            });
            if (loop && (prevIndex - cols < minIndex || indexRef.current < 0)) {
              const col = prevIndex % cols;
              const maxCol = maxIndex % cols;
              const offset = maxIndex - (maxCol - col);
              if (maxCol === col) {
                indexRef.current = maxIndex;
              } else {
                indexRef.current = maxCol > col ? offset : offset - cols;
              }
            }
          }
          if (isIndexOutOfBounds(listRef, indexRef.current)) {
            indexRef.current = prevIndex;
          }
          onNavigate(indexRef.current);
        }
        if (event.key === ARROW_DOWN) {
          stopEvent(event);
          if (prevIndex === -1) {
            indexRef.current = minIndex;
          } else {
            indexRef.current = findNonDisabledIndex(listRef, {
              startingIndex: prevIndex,
              amount: cols,
              disabledIndices
            });
            if (loop && prevIndex + cols > maxIndex) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex % cols - cols,
                amount: cols,
                disabledIndices
              });
            }
          }
          if (isIndexOutOfBounds(listRef, indexRef.current)) {
            indexRef.current = prevIndex;
          }
          onNavigate(indexRef.current);
        }

        // Remains on the same row/column.
        if (orientation === 'both') {
          const prevRow = Math.floor(prevIndex / cols);
          if (event.key === ARROW_RIGHT) {
            stopEvent(event);
            if (prevIndex % cols !== cols - 1) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex,
                disabledIndices
              });
              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {
                indexRef.current = findNonDisabledIndex(listRef, {
                  startingIndex: prevIndex - prevIndex % cols - 1,
                  disabledIndices
                });
              }
            } else if (loop) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex - prevIndex % cols - 1,
                disabledIndices
              });
            }
            if (isDifferentRow(indexRef.current, cols, prevRow)) {
              indexRef.current = prevIndex;
            }
          }
          if (event.key === ARROW_LEFT) {
            stopEvent(event);
            if (prevIndex % cols !== 0) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex,
                disabledIndices,
                decrement: true
              });
              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {
                indexRef.current = findNonDisabledIndex(listRef, {
                  startingIndex: prevIndex + (cols - prevIndex % cols),
                  decrement: true,
                  disabledIndices
                });
              }
            } else if (loop) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex + (cols - prevIndex % cols),
                decrement: true,
                disabledIndices
              });
            }
            if (isDifferentRow(indexRef.current, cols, prevRow)) {
              indexRef.current = prevIndex;
            }
          }
          const lastRow = Math.floor(maxIndex / cols) === prevRow;
          if (isIndexOutOfBounds(listRef, indexRef.current)) {
            if (loop && lastRow) {
              indexRef.current = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(listRef, {
                startingIndex: prevIndex - prevIndex % cols - 1,
                disabledIndices
              });
            } else {
              indexRef.current = prevIndex;
            }
          }
          onNavigate(indexRef.current);
          return;
        }
      }
      if (isMainOrientationKey(event.key, orientation)) {
        stopEvent(event);

        // Reset the index if no item is focused.
        if (open && !virtual && activeElement$1(event.currentTarget.ownerDocument) === event.currentTarget) {
          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;
          onNavigate(indexRef.current);
          return;
        }
        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {
          if (loop) {
            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              disabledIndices
            });
          } else {
            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              disabledIndices
            }));
          }
        } else {
          if (loop) {
            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              decrement: true,
              disabledIndices
            });
          } else {
            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              decrement: true,
              disabledIndices
            }));
          }
        }
        if (isIndexOutOfBounds(listRef, indexRef.current)) {
          onNavigate(null);
        } else {
          onNavigate(indexRef.current);
        }
      }
    }
    function checkVirtualMouse(event) {
      if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    function checkVirtualPointer(event) {
      // `pointerdown` fires first, reset the state then perform the checks.
      focusItemOnOpenRef.current = focusItemOnOpen;
      if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {
      'aria-activedescendant': activeId
    };
    return {
      reference: {
        ...ariaActiveDescendantProp,
        onKeyDown(event) {
          isPointerModalityRef.current = false;
          const isArrowKey = event.key.indexOf('Arrow') === 0;
          if (virtual && open) {
            return onKeyDown(event);
          }

          // If a floating element should not open on arrow key down, avoid
          // setting `activeIndex` while it's closed.
          if (!open && !openOnArrowKeyDown && isArrowKey) {
            return;
          }
          const isNavigationKey = isArrowKey || event.key === 'Enter' || event.key === ' ' || event.key === '';
          if (isNavigationKey) {
            keyRef.current = event.key;
          }
          if (nested) {
            if (isCrossOrientationOpenKey(event.key, orientation, rtl)) {
              stopEvent(event);
              if (open) {
                indexRef.current = getMinIndex(listRef, disabledIndices);
                onNavigate(indexRef.current);
              } else {
                onOpenChange(true);
              }
            }
            return;
          }
          if (isMainOrientationKey(event.key, orientation)) {
            if (selectedIndex != null) {
              indexRef.current = selectedIndex;
            }
            stopEvent(event);
            if (!open && openOnArrowKeyDown) {
              onOpenChange(true);
            } else {
              onKeyDown(event);
            }
            if (open) {
              onNavigate(indexRef.current);
            }
          }
        },
        onFocus() {
          if (open) {
            onNavigate(null);
          }
        },
        onPointerDown: checkVirtualPointer,
        onMouseDown: checkVirtualMouse,
        onClick: checkVirtualMouse
      },
      floating: {
        'aria-orientation': orientation === 'both' ? undefined : orientation,
        ...ariaActiveDescendantProp,
        onKeyDown,
        onPointerMove() {
          isPointerModalityRef.current = true;
        }
      },
      item
    };
  }, [domReference, refs, activeId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item]);
};

/**
 * Merges an array of refs into a single memoized callback ref or `null`.
 * @see https://floating-ui.com/docs/useMergeRefs
 */
function useMergeRefs(refs) {
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (refs.every(ref => ref == null)) {
      return null;
    }
    return value => {
      refs.forEach(ref => {
        if (typeof ref === 'function') {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, refs);
}

/**
 * Adds base screen reader props to the reference and floating elements for a
 * given floating element `role`.
 * @see https://floating-ui.com/docs/useRole
 */
const useRole = function (_ref, _temp) {
  let {
    open
  } = _ref;
  let {
    enabled = true,
    role = 'dialog'
  } = _temp === void 0 ? {} : _temp;
  const rootId = useId();
  const referenceId = useId();
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    const floatingProps = {
      id: rootId,
      role
    };
    if (!enabled) {
      return {};
    }
    if (role === 'tooltip') {
      return {
        reference: {
          'aria-describedby': open ? rootId : undefined
        },
        floating: floatingProps
      };
    }
    return {
      reference: {
        'aria-expanded': open ? 'true' : 'false',
        'aria-haspopup': role === 'alertdialog' ? 'dialog' : role,
        'aria-controls': open ? rootId : undefined,
        ...(role === 'listbox' && {
          role: 'combobox'
        }),
        ...(role === 'menu' && {
          id: referenceId
        })
      },
      floating: {
        ...floatingProps,
        ...(role === 'menu' && {
          'aria-labelledby': referenceId
        })
      }
    };
  }, [enabled, role, open, rootId, referenceId]);
};

// Converts a JS style key like `backgroundColor` to a CSS transition-property
// like `background-color`.
const camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());
function useDelayUnmount(open, durationMs) {
  const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(open);
  if (open && !isMounted) {
    setIsMounted(true);
  }
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!open) {
      const timeout = setTimeout(() => setIsMounted(false), durationMs);
      return () => clearTimeout(timeout);
    }
  }, [open, durationMs]);
  return isMounted;
}
/**
 * Provides a status string to apply CSS transitions to a floating element,
 * correctly handling placement-aware transitions.
 * @see https://floating-ui.com/docs/useTransition#usetransitionstatus
 */
function useTransitionStatus(_ref, _temp) {
  let {
    open,
    elements: {
      floating
    }
  } = _ref;
  let {
    duration = 250
  } = _temp === void 0 ? {} : _temp;
  const isNumberDuration = typeof duration === 'number';
  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
  const [initiated, setInitiated] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState('unmounted');
  const isMounted = useDelayUnmount(open, closeDuration);

  // `initiated` check prevents this `setState` call from breaking
  // <FloatingPortal />. This call is necessary to ensure subsequent opens
  // after the initial one allows the correct side animation to play when the
  // placement has changed.
  index(() => {
    if (initiated && !isMounted) {
      setStatus('unmounted');
    }
  }, [initiated, isMounted]);
  index(() => {
    if (!floating) return;
    if (open) {
      setStatus('initial');
      const frame = requestAnimationFrame(() => {
        setStatus('open');
      });
      return () => {
        cancelAnimationFrame(frame);
      };
    } else {
      setInitiated(true);
      setStatus('close');
    }
  }, [open, floating]);
  return {
    isMounted,
    status
  };
}
/**
 * Provides styles to apply CSS transitions to a floating element, correctly
 * handling placement-aware transitions. Wrapper around `useTransitionStatus`.
 * @see https://floating-ui.com/docs/useTransition#usetransitionstyles
 */
function useTransitionStyles(context, _temp2) {
  let {
    initial: unstable_initial = {
      opacity: 0
    },
    open: unstable_open,
    close: unstable_close,
    common: unstable_common,
    duration = 250
  } = _temp2 === void 0 ? {} : _temp2;
  const placement = context.placement;
  const side = placement.split('-')[0];
  const [styles, setStyles] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});
  const {
    isMounted,
    status
  } = useTransitionStatus(context, {
    duration
  });
  const initialRef = useLatestRef(unstable_initial);
  const openRef = useLatestRef(unstable_open);
  const closeRef = useLatestRef(unstable_close);
  const commonRef = useLatestRef(unstable_common);
  const isNumberDuration = typeof duration === 'number';
  const openDuration = (isNumberDuration ? duration : duration.open) || 0;
  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
  index(() => {
    const fnArgs = {
      side,
      placement
    };
    const initial = initialRef.current;
    const close = closeRef.current;
    const open = openRef.current;
    const common = commonRef.current;
    const initialStyles = typeof initial === 'function' ? initial(fnArgs) : initial;
    const closeStyles = typeof close === 'function' ? close(fnArgs) : close;
    const commonStyles = typeof common === 'function' ? common(fnArgs) : common;
    const openStyles = (typeof open === 'function' ? open(fnArgs) : open) || Object.keys(initialStyles).reduce((acc, key) => {
      acc[key] = '';
      return acc;
    }, {});
    if (status === 'initial' || status === 'unmounted') {
      setStyles(styles => ({
        transitionProperty: styles.transitionProperty,
        ...commonStyles,
        ...initialStyles
      }));
    }
    if (status === 'open') {
      setStyles({
        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),
        transitionDuration: openDuration + "ms",
        ...commonStyles,
        ...openStyles
      });
    }
    if (status === 'close') {
      const styles = closeStyles || initialStyles;
      setStyles({
        transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),
        transitionDuration: closeDuration + "ms",
        ...commonStyles,
        ...styles
      });
    }
  }, [side, placement, closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status]);
  return {
    isMounted,
    styles
  };
}

/**
 * Provides a matching callback that can be used to focus an item as the user
 * types, often used in tandem with `useListNavigation()`.
 * @see https://floating-ui.com/docs/useTypeahead
 */
const useTypeahead = function (_ref, _temp) {
  var _ref2;
  let {
    open,
    dataRef,
    refs
  } = _ref;
  let {
    listRef,
    activeIndex,
    onMatch: unstable_onMatch = () => {},
    enabled = true,
    findMatch = null,
    resetMs = 1000,
    ignoreKeys = [],
    selectedIndex = null
  } = _temp === void 0 ? {
    listRef: {
      current: []
    },
    activeIndex: null
  } : _temp;
  const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const stringRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef('');
  const prevIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef((_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1);
  const matchIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const onMatch = useEvent(unstable_onMatch);
  const findMatchRef = useLatestRef(findMatch);
  const ignoreKeysRef = useLatestRef(ignoreKeys);
  index(() => {
    if (open) {
      clearTimeout(timeoutIdRef.current);
      matchIndexRef.current = null;
      stringRef.current = '';
    }
  }, [open]);
  index(() => {
    // Sync arrow key navigation but not typeahead navigation.
    if (open && stringRef.current === '') {
      var _ref3;
      prevIndexRef.current = (_ref3 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref3 : -1;
    }
  }, [open, selectedIndex, activeIndex]);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!enabled) {
      return {};
    }
    function onKeyDown(event) {
      var _refs$floating$curren;
      // Correctly scope nested non-portalled floating elements. Since the nested
      // floating element is inside of the another, we find the closest role
      // that indicates the floating element scope.
      const target = getTarget(event.nativeEvent);
      if (isElement(target) && (activeElement$1(getDocument(target)) !== event.currentTarget ? (_refs$floating$curren = refs.floating.current) != null && _refs$floating$curren.contains(target) ? target.closest('[role="dialog"],[role="menu"],[role="listbox"],[role="tree"],[role="grid"]') !== event.currentTarget : false : !event.currentTarget.contains(target))) {
        return;
      }
      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {
        dataRef.current.typing = true;
        if (event.key === ' ') {
          stopEvent(event);
        }
      }
      const listContent = listRef.current;
      if (listContent == null || ignoreKeysRef.current.includes(event.key) ||
      // Character key.
      event.key.length !== 1 ||
      // Modifier key.
      event.ctrlKey || event.metaKey || event.altKey) {
        return;
      }

      // Bail out if the list contains a word like "llama" or "aaron". TODO:
      // allow it in this case, too.
      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {
        var _text$, _text$2;
        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;
      });

      // Allows the user to cycle through items that start with the same letter
      // in rapid succession.
      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {
        stringRef.current = '';
        prevIndexRef.current = matchIndexRef.current;
      }
      stringRef.current += event.key;
      clearTimeout(timeoutIdRef.current);
      timeoutIdRef.current = setTimeout(() => {
        stringRef.current = '';
        prevIndexRef.current = matchIndexRef.current;
        dataRef.current.typing = false;
      }, resetMs);
      const prevIndex = prevIndexRef.current;
      const orderedList = [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)];
      const str = findMatchRef.current ? findMatchRef.current(orderedList, stringRef.current) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(stringRef.current.toLocaleLowerCase())) === 0);
      const index = str ? listContent.indexOf(str) : -1;
      if (index !== -1) {
        onMatch(index);
        matchIndexRef.current = index;
      }
    }
    return {
      reference: {
        onKeyDown
      },
      floating: {
        onKeyDown
      }
    };
  }, [enabled, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, refs]);
};

function getArgsWithCustomFloatingHeight(state, height) {
  return {
    ...state,
    rects: {
      ...state.rects,
      floating: {
        ...state.rects.floating,
        height
      }
    }
  };
}
/**
 * Positions the floating element such that an inner element inside
 * of it is anchored to the reference element.
 * @see https://floating-ui.com/docs/inner
 */
const inner = props => ({
  name: 'inner',
  options: props,
  async fn(state) {
    const {
      listRef,
      overflowRef,
      onFallbackChange,
      offset: innerOffset = 0,
      index = 0,
      minItemsVisible = 4,
      referenceOverflowThreshold = 0,
      scrollRef,
      ...detectOverflowOptions
    } = props;
    const {
      rects,
      elements: {
        floating
      }
    } = state;
    const item = listRef.current[index];
    if (true) {
      if (!state.placement.startsWith('bottom')) {
        console.warn(['Floating UI: `placement` side must be "bottom" when using the', '`inner` middleware.'].join(' '));
      }
    }
    if (!item) {
      return {};
    }
    const nextArgs = {
      ...state,
      ...(await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.offset)(-item.offsetTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))
    };
    const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;
    const overflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);
    const refOverflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(nextArgs, {
      ...detectOverflowOptions,
      elementContext: 'reference'
    });
    const diffY = Math.max(0, overflow.top);
    const nextY = nextArgs.y + diffY;
    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));
    el.style.maxHeight = maxHeight + "px";
    el.scrollTop = diffY;

    // There is not enough space, fallback to standard anchored positioning
    if (onFallbackChange) {
      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {
        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => onFallbackChange(true));
      } else {
        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => onFallbackChange(false));
      }
    }
    if (overflowRef) {
      overflowRef.current = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(getArgsWithCustomFloatingHeight({
        ...nextArgs,
        y: nextY
      }, el.offsetHeight), detectOverflowOptions);
    }
    return {
      y: nextY
    };
  }
});
/**
 * Changes the `inner` middleware's `offset` upon a `wheel` event to
 * expand the floating element's height, revealing more list items.
 * @see https://floating-ui.com/docs/inner
 */
const useInnerOffset = (_ref, _ref2) => {
  let {
    open,
    elements
  } = _ref;
  let {
    enabled = true,
    overflowRef,
    scrollRef,
    onChange: unstable_onChange
  } = _ref2;
  const onChange = useEvent(unstable_onChange);
  const controlledScrollingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const prevScrollTopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const initialOverflowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onWheel(e) {
      if (e.ctrlKey || !el || overflowRef.current == null) {
        return;
      }
      const dY = e.deltaY;
      const isAtTop = overflowRef.current.top >= -0.5;
      const isAtBottom = overflowRef.current.bottom >= -0.5;
      const remainingScroll = el.scrollHeight - el.clientHeight;
      const sign = dY < 0 ? -1 : 1;
      const method = dY < 0 ? 'max' : 'min';
      if (el.scrollHeight <= el.clientHeight) {
        return;
      }
      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {
        e.preventDefault();
        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => {
          onChange(d => d + Math[method](dY, remainingScroll * sign));
        });
      } else if (/firefox/i.test(getUserAgent())) {
        // Needed to propagate scrolling during momentum scrolling phase once
        // it gets limited by the boundary. UX improvement, not critical.
        el.scrollTop += dY;
      }
    }
    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
    if (open && el) {
      el.addEventListener('wheel', onWheel);

      // Wait for the position to be ready.
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;
        if (overflowRef.current != null) {
          initialOverflowRef.current = {
            ...overflowRef.current
          };
        }
      });
      return () => {
        prevScrollTopRef.current = null;
        initialOverflowRef.current = null;
        el.removeEventListener('wheel', onWheel);
      };
    }
  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!enabled) {
      return {};
    }
    return {
      floating: {
        onKeyDown() {
          controlledScrollingRef.current = true;
        },
        onWheel() {
          controlledScrollingRef.current = false;
        },
        onPointerMove() {
          controlledScrollingRef.current = false;
        },
        onScroll() {
          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
          if (!overflowRef.current || !el || !controlledScrollingRef.current) {
            return;
          }
          if (prevScrollTopRef.current !== null) {
            const scrollDiff = el.scrollTop - prevScrollTopRef.current;
            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {
              (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => onChange(d => d + scrollDiff));
            }
          }

          // [Firefox] Wait for the height change to have been applied.
          requestAnimationFrame(() => {
            prevScrollTopRef.current = el.scrollTop;
          });
        }
      }
    };
  }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);
};

function isPointInPolygon(point, polygon) {
  const [x, y] = point;
  let isInside = false;
  const length = polygon.length;
  for (let i = 0, j = length - 1; i < length; j = i++) {
    const [xi, yi] = polygon[i] || [0, 0];
    const [xj, yj] = polygon[j] || [0, 0];
    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) {
      isInside = !isInside;
    }
  }
  return isInside;
}
function isInside(point, rect) {
  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;
}
function safePolygon(_temp) {
  let {
    restMs = 0,
    buffer = 0.5,
    blockPointerEvents = false
  } = _temp === void 0 ? {} : _temp;
  let timeoutId;
  let isInsideRect = false;
  let hasLanded = false;
  const fn = _ref => {
    let {
      x,
      y,
      placement,
      elements,
      onClose,
      nodeId,
      tree
    } = _ref;
    return function onMouseMove(event) {
      function close() {
        clearTimeout(timeoutId);
        onClose();
      }
      clearTimeout(timeoutId);
      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {
        return;
      }
      const {
        clientX,
        clientY
      } = event;
      const clientPoint = [clientX, clientY];
      const target = getTarget(event);
      const isLeave = event.type === 'mouseleave';
      const isOverFloatingEl = contains(elements.floating, target);
      const isOverReferenceEl = contains(elements.domReference, target);
      const refRect = elements.domReference.getBoundingClientRect();
      const rect = elements.floating.getBoundingClientRect();
      const side = placement.split('-')[0];
      const cursorLeaveFromRight = x > rect.right - rect.width / 2;
      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;
      const isOverReferenceRect = isInside(clientPoint, refRect);
      if (isOverFloatingEl) {
        hasLanded = true;
        if (!isLeave) {
          return;
        }
      }
      if (isOverReferenceEl) {
        hasLanded = false;
      }
      if (isOverReferenceEl && !isLeave) {
        hasLanded = true;
        return;
      }

      // Prevent overlapping floating element from being stuck in an open-close
      // loop: https://github.com/floating-ui/floating-ui/issues/1910
      if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {
        return;
      }

      // If any nested child is open, abort.
      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {
        let {
          context
        } = _ref2;
        return context == null ? void 0 : context.open;
      })) {
        return;
      }

      // If the pointer is leaving from the opposite side, the "buffer" logic
      // creates a point where the floating element remains open, but should be
      // ignored.
      // A constant of 1 handles floating point rounding errors.
      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {
        return close();
      }

      // Ignore when the cursor is within the rectangular trough between the
      // two elements. Since the triangle is created from the cursor point,
      // which can start beyond the ref element's edge, traversing back and
      // forth from the ref to the floating element can cause it to close. This
      // ensures it always remains open in that case.
      let rectPoly = [];
      switch (side) {
        case 'top':
          rectPoly = [[rect.left, refRect.top + 1], [rect.left, rect.bottom - 1], [rect.right, rect.bottom - 1], [rect.right, refRect.top + 1]];
          isInsideRect = clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= refRect.top + 1;
          break;
        case 'bottom':
          rectPoly = [[rect.left, rect.top + 1], [rect.left, refRect.bottom - 1], [rect.right, refRect.bottom - 1], [rect.right, rect.top + 1]];
          isInsideRect = clientX >= rect.left && clientX <= rect.right && clientY >= refRect.bottom - 1 && clientY <= rect.bottom;
          break;
        case 'left':
          rectPoly = [[rect.right - 1, rect.bottom], [rect.right - 1, rect.top], [refRect.left + 1, rect.top], [refRect.left + 1, rect.bottom]];
          isInsideRect = clientX >= rect.left && clientX <= refRect.left + 1 && clientY >= rect.top && clientY <= rect.bottom;
          break;
        case 'right':
          rectPoly = [[refRect.right - 1, rect.bottom], [refRect.right - 1, rect.top], [rect.left + 1, rect.top], [rect.left + 1, rect.bottom]];
          isInsideRect = clientX >= refRect.right - 1 && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
          break;
      }
      function getPolygon(_ref3) {
        let [x, y] = _ref3;
        const isFloatingWider = rect.width > refRect.width;
        const isFloatingTaller = rect.height > refRect.height;
        switch (side) {
          case 'top':
            {
              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];
              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];
              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];
              return [cursorPointOne, cursorPointTwo, ...commonPoints];
            }
          case 'bottom':
            {
              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];
              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];
              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];
              return [cursorPointOne, cursorPointTwo, ...commonPoints];
            }
          case 'left':
            {
              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];
              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];
              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];
              return [...commonPoints, cursorPointOne, cursorPointTwo];
            }
          case 'right':
            {
              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];
              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];
              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];
              return [cursorPointOne, cursorPointTwo, ...commonPoints];
            }
        }
      }
      const poly = isInsideRect ? rectPoly : getPolygon([x, y]);
      if (isInsideRect) {
        return;
      } else if (hasLanded && !isOverReferenceRect) {
        return close();
      }
      if (!isPointInPolygon([clientX, clientY], poly)) {
        close();
      } else if (restMs && !hasLanded) {
        timeoutId = setTimeout(close, restMs);
      }
    };
  };
  fn.__options = {
    blockPointerEvents
  };
  return fn;
}

/**
 * Provides data to position a floating element and context to add interactions.
 * @see https://floating-ui.com/docs/react
 */
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    open = false,
    onOpenChange: unstable_onOpenChange,
    nodeId
  } = options;
  const position = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.useFloating)(options);
  const tree = useFloatingTree();
  const domReferenceRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});
  const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => createPubSub())[0];
  const [domReference, setDomReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
  const setPositionReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {
    const positionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    position.refs.setReference(positionReference);
  }, [position.refs]);
  const setReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }

    // Backwards-compatibility for passing a virtual element to `reference`
    // after it has set the DOM reference.
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null ||
    // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    ...position.elements,
    domReference: domReference
  }), [position.elements, domReference]);
  const onOpenChange = useEvent(unstable_onOpenChange);
  const context = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    ...position,
    refs,
    elements,
    dataRef,
    nodeId,
    events,
    open,
    onOpenChange
  }), [position, nodeId, events, open, onOpenChange, refs, elements]);
  index(() => {
    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    ...position,
    context,
    refs,
    reference: setReference,
    positionReference: setPositionReference
  }), [position, refs, context, setReference, setPositionReference]);
}

function mergeProps(userProps, propsList, elementKey) {
  const map = new Map();
  return {
    ...(elementKey === 'floating' && {
      tabIndex: -1
    }),
    ...userProps,
    ...propsList.map(value => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach(_ref => {
        let [key, value] = _ref;
        if (key.indexOf('on') === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === 'function') {
            var _map$get;
            (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);
            acc[key] = function () {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.forEach(fn => fn(...args));
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
const useInteractions = function (propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  // The dependencies are a dynamic array, so we can't use the linter's
  // suggestion to add it to the deps array.
  const deps = propsList;
  const getReferenceProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),
  // eslint-disable-next-line react-hooks/exhaustive-deps
  deps);
  const getFloatingProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),
  // eslint-disable-next-line react-hooks/exhaustive-deps
  deps);
  const getItemProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'item'),
  // Granularly check for `item` changes, because the `getItemProps` getter
  // should be as referentially stable as possible since it may be passed as
  // a prop to many components. All `item` key values must therefore be
  // memoized.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  propsList.map(key => key == null ? void 0 : key.item));
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
};




/***/ }),

/***/ "../../node_modules/@radix-ui/react-use-previous/dist/index.module.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@radix-ui/react-use-previous/dist/index.module.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "usePrevious": () => (/* binding */ usePrevious)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
function usePrevious(r){const u=react__WEBPACK_IMPORTED_MODULE_0__.useRef({value:r,previous:r});return react__WEBPACK_IMPORTED_MODULE_0__.useMemo((()=>(u.current.value!==r&&(u.current.previous=u.current.value,u.current.value=r),u.current.previous)),[r])}
//# sourceMappingURL=index.module.js.map


/***/ }),

/***/ "../../node_modules/@swc/helpers/lib/_async_to_generator.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@swc/helpers/lib/_async_to_generator.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _asyncToGenerator;
    }
}));
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}


/***/ }),

/***/ "../../node_modules/@tamagui/adapt/dist/esm/Adapt.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/@tamagui/adapt/dist/esm/Adapt.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Adapt": () => (/* binding */ Adapt),
/* harmony export */   "AdaptContents": () => (/* binding */ AdaptContents),
/* harmony export */   "AdaptParentContext": () => (/* binding */ AdaptParentContext),
/* harmony export */   "useAdaptParent": () => (/* binding */ useAdaptParent)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);



const AdaptParentContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);
const AdaptContents = (props) => {
  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AdaptParentContext);
  if (!(context == null ? void 0 : context.Contents)) {
    throw new Error("Adapt not supported by this component");
  }
  return (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(context.Contents, props);
};
AdaptContents["shouldForwardSpace"] = true;
const useAdaptParent = ({
  Contents
}) => {
  const [when, setWhen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);
  const AdaptProvider = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
    const context = {
      Contents,
      setWhen
    };
    function AdaptProviderView(props) {
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AdaptParentContext.Provider, { value: context, children: props.children });
    }
    return AdaptProviderView;
  }, [Contents]);
  return {
    AdaptProvider,
    when
  };
};
const Adapt = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.withStaticProperties)(
  function Adapt2({ platform, when, children }) {
    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AdaptParentContext);
    let enabled = !platform;
    if (platform === "touch")
      enabled = _tamagui_core__WEBPACK_IMPORTED_MODULE_3__.isTouchable;
    if (platform === "native")
      enabled = !_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.isWeb;
    if (platform === "web")
      enabled = _tamagui_core__WEBPACK_IMPORTED_MODULE_3__.isWeb;
    (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.useIsomorphicLayoutEffect)(() => {
      if (!enabled)
        return;
      context == null ? void 0 : context.setWhen(when || enabled);
    }, [when, context, enabled]);
    if (!enabled) {
      return null;
    }
    return children;
  },
  {
    Contents: AdaptContents
  }
);

//# sourceMappingURL=Adapt.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/adapt/dist/esm/index.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/@tamagui/adapt/dist/esm/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Adapt": () => (/* reexport safe */ _Adapt__WEBPACK_IMPORTED_MODULE_0__.Adapt),
/* harmony export */   "AdaptContents": () => (/* reexport safe */ _Adapt__WEBPACK_IMPORTED_MODULE_0__.AdaptContents),
/* harmony export */   "AdaptParentContext": () => (/* reexport safe */ _Adapt__WEBPACK_IMPORTED_MODULE_0__.AdaptParentContext),
/* harmony export */   "useAdaptParent": () => (/* reexport safe */ _Adapt__WEBPACK_IMPORTED_MODULE_0__.useAdaptParent)
/* harmony export */ });
/* harmony import */ var _Adapt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Adapt */ "../../node_modules/@tamagui/adapt/dist/esm/Adapt.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/alert-dialog/dist/esm/AlertDialog.mjs":
/*!*************************************************************************!*\
  !*** ../../node_modules/@tamagui/alert-dialog/dist/esm/AlertDialog.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlertDialog": () => (/* binding */ AlertDialog),
/* harmony export */   "AlertDialogAction": () => (/* binding */ AlertDialogAction),
/* harmony export */   "AlertDialogCancel": () => (/* binding */ AlertDialogCancel),
/* harmony export */   "AlertDialogContent": () => (/* binding */ AlertDialogContent),
/* harmony export */   "AlertDialogDescription": () => (/* binding */ AlertDialogDescription),
/* harmony export */   "AlertDialogOverlay": () => (/* binding */ AlertDialogOverlay),
/* harmony export */   "AlertDialogPortal": () => (/* binding */ AlertDialogPortal),
/* harmony export */   "AlertDialogTitle": () => (/* binding */ AlertDialogTitle),
/* harmony export */   "AlertDialogTrigger": () => (/* binding */ AlertDialogTrigger),
/* harmony export */   "createAlertDialogScope": () => (/* binding */ createAlertDialogScope)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/views/Slot.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/dialog */ "../../node_modules/@tamagui/dialog/dist/esm/Dialog.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);









const ROOT_NAME = "AlertDialog";
const [createAlertDialogContext, createAlertDialogScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_2__.createContextScope)(ROOT_NAME, [
  _tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__.createDialogScope
]);
const useDialogScope = (0,_tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__.createDialogScope)();
const TRIGGER_NAME = "AlertDialogTrigger";
const NativeAlertDialogTriggerFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_5__.YStack, {
  name: "DialogTrigger"
});
const AlertDialogTrigger = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
  (props, forwardedRef) => {
    if (props["__native"]) {
      const { __native, onPress, __onPress, ...rest } = props;
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        NativeAlertDialogTriggerFrame,
        {
          ...rest,
          onPress: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_6__.composeEventHandlers)(onPress, __onPress)
        }
      );
    }
    const { __scopeAlertDialog, ...triggerProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__.DialogTrigger, { ...dialogScope, ...triggerProps, ref: forwardedRef });
  }
);
AlertDialogTrigger.displayName = TRIGGER_NAME;
const PORTAL_NAME = "AlertDialogPortal";
const AlertDialogPortal = (props) => {
  const { __scopeAlertDialog, ...portalProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__.DialogPortal, { ...dialogScope, ...portalProps });
};
AlertDialogPortal.displayName = PORTAL_NAME;
const OVERLAY_NAME = "AlertDialogOverlay";
const AlertDialogOverlayFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.styled)(_tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__.DialogOverlayFrame, {
  name: OVERLAY_NAME
});
const AlertDialogOverlay = AlertDialogOverlayFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
    (props, forwardedRef) => {
      const { __scopeAlertDialog, ...overlayProps } = props;
      const dialogScope = useDialogScope(__scopeAlertDialog);
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__.DialogOverlay, { ...dialogScope, ...overlayProps, ref: forwardedRef });
    }
  )
);
AlertDialogOverlay.displayName = OVERLAY_NAME;
const CONTENT_NAME = "AlertDialogContent";
const [AlertDialogContentProvider, useAlertDialogContentContext] = createAlertDialogContext(CONTENT_NAME);
const AlertDialogContent = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, children, ...contentProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const contentRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);
    const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_7__.useComposedRefs)(forwardedRef, contentRef);
    const cancelRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__.DialogWarningProvider,
      {
        contentName: CONTENT_NAME,
        titleName: TITLE_NAME,
        docsSlug: "alert-dialog",
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AlertDialogContentProvider, { scope: __scopeAlertDialog, cancelRef, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(
          _tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__.DialogContent,
          {
            role: "alertdialog",
            ...dialogScope,
            ...contentProps,
            ref: composedRefs,
            onOpenAutoFocus: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_6__.composeEventHandlers)(
              contentProps.onOpenAutoFocus,
              (event) => {
                var _a;
                event.preventDefault();
                if (_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.isWeb) {
                  (_a = cancelRef.current) == null ? void 0 : _a.focus({ preventScroll: true });
                }
              }
            ),
            onPointerDownOutside: (event) => event.preventDefault(),
            onInteractOutside: (event) => event.preventDefault(),
            children: [
              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_core__WEBPACK_IMPORTED_MODULE_9__.Slottable, { children }),
               true && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DescriptionWarning, { contentRef })
            ]
          }
        ) })
      }
    );
  }
);
AlertDialogContent.displayName = CONTENT_NAME;
const TITLE_NAME = "AlertDialogTitle";
const AlertDialogTitle = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...titleProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__.DialogTitle, { ...dialogScope, ...titleProps, ref: forwardedRef });
  }
);
AlertDialogTitle.displayName = TITLE_NAME;
const DESCRIPTION_NAME = "AlertDialogDescription";
const AlertDialogDescription = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, forwardedRef) => {
  const { __scopeAlertDialog, ...descriptionProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__.DialogDescription, { ...dialogScope, ...descriptionProps, ref: forwardedRef });
});
AlertDialogDescription.displayName = DESCRIPTION_NAME;
const ACTION_NAME = "AlertDialogAction";
const AlertDialogAction = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...actionProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__.DialogClose, { ...dialogScope, ...actionProps, ref: forwardedRef });
  }
);
AlertDialogAction.displayName = ACTION_NAME;
const CANCEL_NAME = "AlertDialogCancel";
const AlertDialogCancel = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...cancelProps } = props;
    const { cancelRef } = useAlertDialogContentContext(CANCEL_NAME, __scopeAlertDialog);
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const ref = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_7__.useComposedRefs)(forwardedRef, cancelRef);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__.DialogClose, { ...dialogScope, ...cancelProps, ref });
  }
);
AlertDialogCancel.displayName = CANCEL_NAME;
const DescriptionWarning = ({ contentRef }) => {
  if (true) {
    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
      var _a;
      if (!_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.isWeb)
        return;
      const hasDescription = document.getElementById(
        // @ts-ignore
        // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
        (_a = contentRef.current) == null ? void 0 : _a.getAttribute("aria-describedby")
      );
      if (!hasDescription) {
        console.warn(`\`${CONTENT_NAME}\` requires a description for the component to be accessible for screen reader users.
  
        You can add a description to the \`${CONTENT_NAME}\` by passing a \`${DESCRIPTION_NAME}\` component as a child, which also benefits sighted users by adding visible context to the dialog.
        
        Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${CONTENT_NAME}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.
        
        For more information, see https://tamagui.dev/docs/components/alert-dialog`);
      }
    }, [contentRef]);
  }
  return null;
};
const AlertDialogInner = (props) => {
  const { __scopeAlertDialog, native, ...alertDialogProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  if (false) {}
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_dialog__WEBPACK_IMPORTED_MODULE_3__.Dialog, { ...dialogScope, ...alertDialogProps, modal: true });
};
function forEachChildDeep(children, onChild) {
  for (const child of children) {
    if (!react__WEBPACK_IMPORTED_MODULE_1__.isValidElement(child))
      continue;
    if (!onChild(child))
      continue;
    if (child.props.children) {
      forEachChildDeep(react__WEBPACK_IMPORTED_MODULE_1__.Children.toArray(child.props.children), onChild);
    }
  }
}
function getStringChildren(child) {
  let string = "";
  forEachChildDeep(react__WEBPACK_IMPORTED_MODULE_1__.Children.toArray(child), (child2) => {
    if (typeof child2.props.children === "string") {
      string = child2.props.children;
      return false;
    }
    return true;
  });
  return string;
}
const AlertDialog = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_10__.withStaticProperties)(AlertDialogInner, {
  Trigger: AlertDialogTrigger,
  Portal: AlertDialogPortal,
  Overlay: AlertDialogOverlay,
  Content: AlertDialogContent,
  Action: AlertDialogAction,
  Cancel: AlertDialogCancel,
  Title: AlertDialogTitle,
  Description: AlertDialogDescription
});
AlertDialog.displayName = ROOT_NAME;

//# sourceMappingURL=AlertDialog.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/alert-dialog/dist/esm/index.mjs":
/*!*******************************************************************!*\
  !*** ../../node_modules/@tamagui/alert-dialog/dist/esm/index.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlertDialog": () => (/* reexport safe */ _AlertDialog__WEBPACK_IMPORTED_MODULE_0__.AlertDialog),
/* harmony export */   "AlertDialogAction": () => (/* reexport safe */ _AlertDialog__WEBPACK_IMPORTED_MODULE_0__.AlertDialogAction),
/* harmony export */   "AlertDialogCancel": () => (/* reexport safe */ _AlertDialog__WEBPACK_IMPORTED_MODULE_0__.AlertDialogCancel),
/* harmony export */   "AlertDialogContent": () => (/* reexport safe */ _AlertDialog__WEBPACK_IMPORTED_MODULE_0__.AlertDialogContent),
/* harmony export */   "AlertDialogDescription": () => (/* reexport safe */ _AlertDialog__WEBPACK_IMPORTED_MODULE_0__.AlertDialogDescription),
/* harmony export */   "AlertDialogOverlay": () => (/* reexport safe */ _AlertDialog__WEBPACK_IMPORTED_MODULE_0__.AlertDialogOverlay),
/* harmony export */   "AlertDialogPortal": () => (/* reexport safe */ _AlertDialog__WEBPACK_IMPORTED_MODULE_0__.AlertDialogPortal),
/* harmony export */   "AlertDialogTitle": () => (/* reexport safe */ _AlertDialog__WEBPACK_IMPORTED_MODULE_0__.AlertDialogTitle),
/* harmony export */   "AlertDialogTrigger": () => (/* reexport safe */ _AlertDialog__WEBPACK_IMPORTED_MODULE_0__.AlertDialogTrigger),
/* harmony export */   "createAlertDialogScope": () => (/* reexport safe */ _AlertDialog__WEBPACK_IMPORTED_MODULE_0__.createAlertDialogScope)
/* harmony export */ });
/* harmony import */ var _AlertDialog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlertDialog */ "../../node_modules/@tamagui/alert-dialog/dist/esm/AlertDialog.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/animate-presence/dist/esm/index.mjs":
/*!***********************************************************************!*\
  !*** ../../node_modules/@tamagui/animate-presence/dist/esm/index.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimatePresence": () => (/* reexport safe */ _AnimatePresence__WEBPACK_IMPORTED_MODULE_0__.AnimatePresence),
/* harmony export */   "PresenceContext": () => (/* reexport safe */ _tamagui_use_presence__WEBPACK_IMPORTED_MODULE_1__.PresenceContext),
/* harmony export */   "isPresent": () => (/* reexport safe */ _tamagui_use_presence__WEBPACK_IMPORTED_MODULE_1__.isPresent),
/* harmony export */   "useIsPresent": () => (/* reexport safe */ _tamagui_use_presence__WEBPACK_IMPORTED_MODULE_1__.useIsPresent),
/* harmony export */   "usePresence": () => (/* reexport safe */ _tamagui_use_presence__WEBPACK_IMPORTED_MODULE_1__.usePresence)
/* harmony export */ });
/* harmony import */ var _AnimatePresence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimatePresence */ "../../node_modules/@tamagui/animate-presence/dist/esm/AnimatePresence.mjs");
/* harmony import */ var _tamagui_use_presence__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/use-presence */ "../../node_modules/@tamagui/use-presence/dist/esm/index.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/avatar/dist/esm/Avatar.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/avatar/dist/esm/Avatar.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Avatar": () => (/* binding */ Avatar),
/* harmony export */   "AvatarFallback": () => (/* binding */ AvatarFallback),
/* harmony export */   "AvatarFallbackFrame": () => (/* binding */ AvatarFallbackFrame),
/* harmony export */   "AvatarFrame": () => (/* binding */ AvatarFrame),
/* harmony export */   "AvatarImage": () => (/* binding */ AvatarImage),
/* harmony export */   "createAvatarScope": () => (/* binding */ createAvatarScope)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/getVariantExtras.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_image__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/image */ "../../node_modules/@tamagui/image/dist/esm/Image.mjs");
/* harmony import */ var _tamagui_shapes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/shapes */ "../../node_modules/@tamagui/shapes/dist/esm/getShapeSize.mjs");
/* harmony import */ var _tamagui_shapes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/shapes */ "../../node_modules/@tamagui/shapes/dist/esm/Square.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);







const AVATAR_NAME = "Avatar";
const [createAvatarContext, createAvatarScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_2__.createContextScope)(AVATAR_NAME);
const [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME);
const IMAGE_NAME = "AvatarImage";
const AvatarImage = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
  (props, forwardedRef) => {
    var _a;
    const { __scopeAvatar, src, onLoadingStatusChange = () => {
    }, ...imageProps } = props;
    const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);
    const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_1__.useState("idle");
    const extras = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.getVariantExtras)(props);
    const shapeSize = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.getVariableValue)(
      (_a = (0,_tamagui_shapes__WEBPACK_IMPORTED_MODULE_5__.getShapeSize)(context.size, extras)) == null ? void 0 : _a.width
    );
    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
      setStatus("idle");
    }, [JSON.stringify(src)]);
    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
      onLoadingStatusChange(status);
      context.onImageLoadingStatusChange(status);
    }, [status]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_6__.YStack, { fullscreen: true, zIndex: 1, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _tamagui_image__WEBPACK_IMPORTED_MODULE_7__.Image,
      {
        fullscreen: true,
        ...typeof shapeSize === "number" && !isNaN(shapeSize) && {
          width: shapeSize,
          height: shapeSize
        },
        ...imageProps,
        ref: forwardedRef,
        src,
        onError: () => {
          setStatus("error");
        },
        onLoad: () => {
          setStatus("loaded");
        }
      }
    ) });
  }
);
AvatarImage.displayName = IMAGE_NAME;
const FALLBACK_NAME = "AvatarFallback";
const AvatarFallbackFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_6__.YStack, {
  name: FALLBACK_NAME,
  position: "absolute",
  fullscreen: true,
  zIndex: 0
});
const AvatarFallback = AvatarFallbackFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
    (props, forwardedRef) => {
      const { __scopeAvatar, delayMs, ...fallbackProps } = props;
      const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);
      const [canRender, setCanRender] = react__WEBPACK_IMPORTED_MODULE_1__.useState(delayMs === void 0);
      react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
        if (delayMs !== void 0) {
          const timerId = setTimeout(() => setCanRender(true), delayMs);
          return () => clearTimeout(timerId);
        }
      }, [delayMs]);
      return canRender && context.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AvatarFallbackFrame, { ...fallbackProps, ref: forwardedRef }) : null;
    }
  )
);
AvatarFallback.displayName = FALLBACK_NAME;
const AvatarFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_tamagui_shapes__WEBPACK_IMPORTED_MODULE_9__.Square, {
  name: AVATAR_NAME,
  position: "relative",
  overflow: "hidden"
});
const Avatar = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_10__.withStaticProperties)(
  react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
    (props, forwardedRef) => {
      const { __scopeAvatar, size = "$true", ...avatarProps } = props;
      const [imageLoadingStatus, setImageLoadingStatus] = react__WEBPACK_IMPORTED_MODULE_1__.useState("idle");
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        AvatarProvider,
        {
          size,
          scope: __scopeAvatar,
          imageLoadingStatus,
          onImageLoadingStatusChange: setImageLoadingStatus,
          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AvatarFrame, { size, ...avatarProps, ref: forwardedRef })
        }
      );
    }
  ),
  {
    Image: AvatarImage,
    Fallback: AvatarFallback
  }
);
Avatar.displayName = AVATAR_NAME;

//# sourceMappingURL=Avatar.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/avatar/dist/esm/index.mjs":
/*!*************************************************************!*\
  !*** ../../node_modules/@tamagui/avatar/dist/esm/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Avatar": () => (/* reexport safe */ _Avatar__WEBPACK_IMPORTED_MODULE_0__.Avatar),
/* harmony export */   "AvatarFallback": () => (/* reexport safe */ _Avatar__WEBPACK_IMPORTED_MODULE_0__.AvatarFallback),
/* harmony export */   "AvatarFallbackFrame": () => (/* reexport safe */ _Avatar__WEBPACK_IMPORTED_MODULE_0__.AvatarFallbackFrame),
/* harmony export */   "AvatarFrame": () => (/* reexport safe */ _Avatar__WEBPACK_IMPORTED_MODULE_0__.AvatarFrame),
/* harmony export */   "AvatarImage": () => (/* reexport safe */ _Avatar__WEBPACK_IMPORTED_MODULE_0__.AvatarImage),
/* harmony export */   "createAvatarScope": () => (/* reexport safe */ _Avatar__WEBPACK_IMPORTED_MODULE_0__.createAvatarScope)
/* harmony export */ });
/* harmony import */ var _Avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Avatar */ "../../node_modules/@tamagui/avatar/dist/esm/Avatar.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/button/dist/esm/Button.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/button/dist/esm/Button.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Button": () => (/* binding */ Button2),
/* harmony export */   "ButtonFrame": () => (/* binding */ ButtonFrame),
/* harmony export */   "ButtonText": () => (/* binding */ ButtonTextFrame),
/* harmony export */   "buttonStaticConfig": () => (/* binding */ buttonStaticConfig),
/* harmony export */   "createButtonScope": () => (/* binding */ createButtonScope),
/* harmony export */   "useButton": () => (/* binding */ useButton)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_font_size__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/font-size */ "../../node_modules/@tamagui/font-size/dist/esm/getFontSize.mjs");
/* harmony import */ var _tamagui_get_button_sized__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/get-button-sized */ "../../node_modules/@tamagui/get-button-sized/dist/esm/index.mjs");
/* harmony import */ var _tamagui_helpers_tamagui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/helpers-tamagui */ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/index.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var _tamagui_text__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/text */ "../../node_modules/@tamagui/text/dist/esm/SizableText.mjs");
/* harmony import */ var _tamagui_text__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tamagui/text */ "../../node_modules/@tamagui/text/dist/esm/wrapChildrenInText.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/helpers/themeable.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/contexts/ButtonNestingContext.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/hooks/useMedia.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/createComponent.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);









const BUTTON_NAME = "Button";
const ButtonFrame = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__.ThemeableStack, {
  name: BUTTON_NAME,
  tag: "button",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        justifyContent: "center",
        alignItems: "center",
        flexWrap: "nowrap",
        flexDirection: "row",
        cursor: "pointer",
        focusable: true,
        hoverTheme: true,
        pressTheme: true,
        backgrounded: true,
        borderWidth: 1,
        borderColor: "transparent",
        pressStyle: {
          borderColor: "transparent"
        },
        hoverStyle: {
          borderColor: "transparent"
        },
        focusStyle: {
          borderColor: "$borderColorFocus",
          outlineColor: "$borderColorFocus",
          outlineStyle: "solid",
          outlineWidth: 2
        }
      }
    },
    size: {
      "...size": _tamagui_get_button_sized__WEBPACK_IMPORTED_MODULE_5__.getButtonSized
    },
    active: {
      true: {
        hoverStyle: {
          backgroundColor: "$background"
        }
      }
    },
    disabled: {
      true: {
        pointerEvents: "none"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const BUTTON_TEXT_NAME = "ButtonText";
const ButtonTextFrame = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_text__WEBPACK_IMPORTED_MODULE_6__.SizableText, {
  name: BUTTON_TEXT_NAME,
  variants: {
    unstyled: {
      false: {
        userSelect: "none",
        cursor: "pointer",
        // flexGrow 1 leads to inconsistent native style where text pushes to start of view
        flexGrow: 0,
        flexShrink: 1,
        ellipse: true,
        color: "$color"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const [createButtonContext, createButtonScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_7__.createContextScope)("Button");
const [ButtonProvider, useButtonContext] = createButtonContext("Button");
const ButtonTextComponent = ButtonTextFrame.extractable(
  (0,react__WEBPACK_IMPORTED_MODULE_2__.forwardRef)(
    (props, ref) => {
      const context = useButtonContext(BUTTON_TEXT_NAME, props.__scopeButton);
      (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {
        const unregister = context.registerButtonText();
        return () => unregister();
      }, [context.registerButtonText]);
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ButtonTextFrame, { size: props.size ?? context.size, ...props, ref });
    }
  )
);
const BUTTON_ICON_NAME = "ButtonIcon";
const ButtonIcon = (props) => {
  const { children, scaleIcon = 1 } = props;
  const context = useButtonContext(BUTTON_ICON_NAME, props.__scopeButton);
  const size = context.size;
  const color = context.color;
  const iconSize = (typeof size === "number" ? size * 0.5 : (0,_tamagui_font_size__WEBPACK_IMPORTED_MODULE_8__.getFontSize)(size)) * scaleIcon;
  const getThemedIcon = (0,_tamagui_helpers_tamagui__WEBPACK_IMPORTED_MODULE_1__.useGetThemedIcon)({ size: iconSize, color });
  return getThemedIcon(children);
};
const ButtonComponent = (0,react__WEBPACK_IMPORTED_MODULE_2__.forwardRef)(
  function Button(props, ref) {
    const { props: buttonProps } = useButton(props);
    const [buttonTextCount, setButtonTextCount] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0);
    const registerButtonText = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(() => {
      setButtonTextCount((prev) => prev + 1);
      return () => setButtonTextCount((prev) => prev - 1);
    }, [setButtonTextCount]);
    const hasTextComponent = buttonTextCount > 0;
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      ButtonProvider,
      {
        scope: props.__scopeButton,
        color: props.color,
        hasTextComponent,
        size: props.size ?? "$true",
        registerButtonText,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ButtonFrame, { ...hasTextComponent ? props : buttonProps, ref })
      }
    );
  }
);
const buttonStaticConfig = {
  inlineProps: /* @__PURE__ */ new Set([
    // text props go here (can't really optimize them, but we never fully extract button anyway)
    // may be able to remove this entirely, as the compiler / runtime have gotten better
    "color",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "fontStyle",
    "letterSpacing",
    "textAlign",
    "unstyled"
  ])
};
const Button2 = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_9__.withStaticProperties)(
  ButtonFrame.extractable(
    (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_10__.themeable)(ButtonComponent, ButtonFrame.staticConfig),
    buttonStaticConfig
  ),
  {
    Text: ButtonTextComponent,
    Icon: ButtonIcon
  }
);
function useButton(propsIn, { Text = ButtonTextFrame } = { Text: ButtonTextFrame }) {
  const {
    children,
    icon,
    iconAfter,
    noTextWrap,
    theme: themeName,
    space,
    spaceFlex,
    scaleIcon = 1,
    scaleSpace = 0.66,
    separator,
    // text props
    color,
    fontWeight,
    letterSpacing,
    fontSize,
    fontFamily,
    fontStyle,
    textAlign,
    unstyled = false,
    textProps,
    ...rest
  } = propsIn;
  const isNested = _tamagui_web__WEBPACK_IMPORTED_MODULE_11__.isRSC ? false : (0,react__WEBPACK_IMPORTED_MODULE_2__.useContext)(_tamagui_web__WEBPACK_IMPORTED_MODULE_12__.ButtonNestingContext);
  const propsActive = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_13__.useMediaPropsActive)(propsIn);
  const size = propsActive.size || "$true";
  const iconSize = (typeof size === "number" ? size * 0.5 : (0,_tamagui_font_size__WEBPACK_IMPORTED_MODULE_8__.getFontSize)(size)) * scaleIcon;
  const getThemedIcon = (0,_tamagui_helpers_tamagui__WEBPACK_IMPORTED_MODULE_1__.useGetThemedIcon)({ size: iconSize, color });
  const [themedIcon, themedIconAfter] = [icon, iconAfter].map(getThemedIcon);
  const spaceSize = propsActive.space ?? (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_14__.getVariableValue)(iconSize) * scaleSpace;
  const contents = (0,_tamagui_text__WEBPACK_IMPORTED_MODULE_15__.wrapChildrenInText)(
    Text,
    propsActive,
    Text === ButtonTextFrame ? {
      unstyled
    } : void 0
  );
  const inner = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_16__.spacedChildren)({
    // a bit arbitrary but scaling to font size is necessary so long as button does
    space: spaceSize,
    spaceFlex,
    separator,
    direction: propsActive.flexDirection === "column" || propsActive.flexDirection === "column-reverse" ? "vertical" : "horizontal",
    children: [themedIcon, ...contents, themedIconAfter]
  });
  const tag = isNested ? "span" : (
    // defaults to <a /> when accessibilityRole = link
    // see https://github.com/tamagui/tamagui/issues/505
    propsIn.accessibilityRole === "link" ? "a" : void 0
  );
  const props = {
    ...propsActive.disabled && {
      // in rnw - false still has keyboard tabIndex, undefined = not actually focusable
      focusable: void 0,
      // even with tabIndex unset, it will keep focusStyle on web so disable it here
      focusStyle: {
        borderColor: "$background"
      }
    },
    unstyled,
    tag,
    ...rest,
    children: _tamagui_web__WEBPACK_IMPORTED_MODULE_11__.isRSC ? inner : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_web__WEBPACK_IMPORTED_MODULE_12__.ButtonNestingContext.Provider, { value: true, children: inner })
  };
  return {
    spaceSize,
    isNested,
    props
  };
}

//# sourceMappingURL=Button.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/button/dist/esm/index.mjs":
/*!*************************************************************!*\
  !*** ../../node_modules/@tamagui/button/dist/esm/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Button": () => (/* reexport safe */ _Button__WEBPACK_IMPORTED_MODULE_0__.Button),
/* harmony export */   "ButtonFrame": () => (/* reexport safe */ _Button__WEBPACK_IMPORTED_MODULE_0__.ButtonFrame),
/* harmony export */   "ButtonText": () => (/* reexport safe */ _Button__WEBPACK_IMPORTED_MODULE_0__.ButtonText),
/* harmony export */   "buttonStaticConfig": () => (/* reexport safe */ _Button__WEBPACK_IMPORTED_MODULE_0__.buttonStaticConfig),
/* harmony export */   "createButtonScope": () => (/* reexport safe */ _Button__WEBPACK_IMPORTED_MODULE_0__.createButtonScope),
/* harmony export */   "useButton": () => (/* reexport safe */ _Button__WEBPACK_IMPORTED_MODULE_0__.useButton)
/* harmony export */ });
/* harmony import */ var _Button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button */ "../../node_modules/@tamagui/button/dist/esm/Button.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/card/dist/esm/Card.mjs":
/*!**********************************************************!*\
  !*** ../../node_modules/@tamagui/card/dist/esm/Card.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Card": () => (/* binding */ Card),
/* harmony export */   "CardBackground": () => (/* binding */ CardBackground),
/* harmony export */   "CardFooter": () => (/* binding */ CardFooter),
/* harmony export */   "CardFrame": () => (/* binding */ CardFrame),
/* harmony export */   "CardHeader": () => (/* binding */ CardHeader)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/helpers/isTamaguiElement.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);




const CardFrame = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_2__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_3__.ThemeableStack, {
  name: "Card",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        backgroundColor: "$background",
        position: "relative",
        overflow: "hidden"
      }
    },
    size: {
      "...size": (val, { tokens }) => {
        return {
          borderRadius: tokens.radius[val] ?? val
        };
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const CardHeader = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_2__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_3__.ThemeableStack, {
  name: "CardHeader",
  variants: {
    unstyled: {
      false: {
        zIndex: 10,
        backgroundColor: "transparent",
        marginBottom: "auto"
      }
    },
    size: {
      "...size": (val, { tokens }) => {
        return {
          padding: tokens.space[val] ?? val
        };
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const CardFooter = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_2__.styled)(CardHeader, {
  name: "CardFooter",
  variants: {
    unstyled: {
      false: {
        zIndex: 5,
        flexDirection: "row",
        marginTop: "auto",
        marginBottom: 0
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const CardBackground = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_2__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_3__.ThemeableStack, {
  name: "CardBackground",
  variants: {
    unstyled: {
      false: {
        zIndex: 0,
        fullscreen: true,
        overflow: "hidden",
        pointerEvents: "none",
        padding: 0
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const Card = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_4__.withStaticProperties)(
  CardFrame.extractable(
    (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(
      ({ size, __scopeCard, children, ...props }, ref) => {
        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CardFrame, { ref, ...props, children: react__WEBPACK_IMPORTED_MODULE_1___default().Children.map(children, (child) => {
          if ((0,_tamagui_web__WEBPACK_IMPORTED_MODULE_5__.isTamaguiElement)(child) && !child.props.size) {
            return (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(child, {
              size
            });
          }
          return child;
        }) });
      }
    )
  ),
  {
    Header: CardHeader,
    Footer: CardFooter,
    Background: CardBackground
  }
);

//# sourceMappingURL=Card.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/card/dist/esm/index.mjs":
/*!***********************************************************!*\
  !*** ../../node_modules/@tamagui/card/dist/esm/index.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Card": () => (/* reexport safe */ _Card__WEBPACK_IMPORTED_MODULE_0__.Card),
/* harmony export */   "CardBackground": () => (/* reexport safe */ _Card__WEBPACK_IMPORTED_MODULE_0__.CardBackground),
/* harmony export */   "CardFooter": () => (/* reexport safe */ _Card__WEBPACK_IMPORTED_MODULE_0__.CardFooter),
/* harmony export */   "CardFrame": () => (/* reexport safe */ _Card__WEBPACK_IMPORTED_MODULE_0__.CardFrame),
/* harmony export */   "CardHeader": () => (/* reexport safe */ _Card__WEBPACK_IMPORTED_MODULE_0__.CardHeader)
/* harmony export */ });
/* harmony import */ var _Card__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Card */ "../../node_modules/@tamagui/card/dist/esm/Card.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/checkbox/dist/esm/Checkbox.mjs":
/*!******************************************************************!*\
  !*** ../../node_modules/@tamagui/checkbox/dist/esm/Checkbox.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BubbleInput": () => (/* binding */ BubbleInput),
/* harmony export */   "Checkbox": () => (/* binding */ Checkbox),
/* harmony export */   "CheckboxFrame": () => (/* binding */ CheckboxFrame),
/* harmony export */   "createCheckboxScope": () => (/* binding */ createCheckboxScope),
/* harmony export */   "getState": () => (/* binding */ getState),
/* harmony export */   "isIndeterminate": () => (/* binding */ isIndeterminate)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _radix_ui_react_use_previous__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @radix-ui/react-use-previous */ "../../node_modules/@radix-ui/react-use-previous/dist/index.module.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useTheme.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useMedia.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/index.mjs");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_font_size__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/font-size */ "../../node_modules/@tamagui/font-size/dist/esm/getFontSize.mjs");
/* harmony import */ var _tamagui_get_size__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/get-size */ "../../node_modules/@tamagui/get-size/dist/esm/index.mjs");
/* harmony import */ var _tamagui_helpers_tamagui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/helpers-tamagui */ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/index.mjs");
/* harmony import */ var _tamagui_label__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tamagui/label */ "../../node_modules/@tamagui/label/dist/esm/Label.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);












function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
const BubbleInput = (props) => {
  const { checked, bubbles = true, control, isHidden, ...inputProps } = props;
  const ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);
  const prevChecked = (0,_radix_ui_react_use_previous__WEBPACK_IMPORTED_MODULE_3__.usePrevious)(checked);
  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {
    const input = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(
      inputProto,
      "checked"
    );
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      input.indeterminate = isIndeterminate(checked);
      setChecked.call(input, isIndeterminate(checked) ? false : checked);
      input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    "input",
    {
      type: "checkbox",
      defaultChecked: isIndeterminate(checked) ? false : checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      "aria-hidden": isHidden,
      style: {
        ...isHidden ? {
          // ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        } : {
          appearance: "auto",
          accentColor: "var(--color6)"
        },
        ...props.style
      }
    }
  );
};
const INDICATOR_NAME = "CheckboxIndicator";
const CheckboxIndicatorFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_5__.ThemeableStack, {
  // use Checkbox for easier themes
  name: INDICATOR_NAME
});
const CheckboxIndicator = CheckboxIndicatorFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeCheckbox,
        children: childrenProp,
        forceMount,
        disablePassStyles,
        ...indicatorProps
      } = props;
      const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);
      const iconSize = (typeof context.size === "number" ? context.size * 0.65 : (0,_tamagui_font_size__WEBPACK_IMPORTED_MODULE_6__.getFontSize)(context.size)) * context.scaleIcon;
      const theme = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.useTheme)();
      const getThemedIcon = (0,_tamagui_helpers_tamagui__WEBPACK_IMPORTED_MODULE_1__.useGetThemedIcon)({ size: iconSize, color: theme.color });
      const childrens = react__WEBPACK_IMPORTED_MODULE_2__.Children.toArray(childrenProp);
      const children = childrens.map((child) => {
        if (disablePassStyles || !react__WEBPACK_IMPORTED_MODULE_2__.isValidElement(child)) {
          return child;
        }
        return getThemedIcon(child);
      });
      if (forceMount || isIndeterminate(context.state) || context.state === true)
        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          CheckboxIndicatorFrame,
          {
            "data-state": getState(context.state),
            "data-disabled": context.disabled ? "" : void 0,
            pointerEvents: "none",
            ...indicatorProps,
            ref: forwardedRef,
            children
          }
        );
      return null;
    }
  )
);
CheckboxIndicator.displayName = INDICATOR_NAME;
const CHECKBOX_NAME = "Checkbox";
const CheckboxFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_5__.ThemeableStack, {
  name: CHECKBOX_NAME,
  tag: "button",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        backgroundColor: "$background",
        alignItems: "center",
        justifyContent: "center",
        pressTheme: true,
        focusable: true,
        borderWidth: 1,
        borderColor: "$borderColor",
        hoverStyle: {
          borderColor: "$borderColorHover"
        },
        focusStyle: {
          borderColor: "$borderColorFocus"
        }
      }
    },
    size: {
      "...size": (val, { tokens }) => {
        const radiusToken = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.getVariableValue)((0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_9__.getSize)(val)) / 8;
        return {
          borderRadius: radiusToken
        };
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const [createCheckboxContext, createCheckboxScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_10__.createContextScope)(CHECKBOX_NAME);
const [CheckboxProvider, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
const Checkbox = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.withStaticProperties)(
  CheckboxFrame.extractable(
    react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(
      (props, forwardedRef) => {
        const {
          __scopeCheckbox,
          labelledBy: ariaLabelledby,
          name,
          checked: checkedProp,
          defaultChecked,
          required,
          scaleIcon = 1,
          scaleSize = 0.45,
          sizeAdjust = 0,
          disabled,
          value = "on",
          onCheckedChange,
          native,
          ...checkboxProps
        } = props;
        const [button, setButton] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);
        const composedRefs = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.useComposedRefs)(forwardedRef, (node) => setButton(node));
        const hasConsumerStoppedPropagationRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(false);
        const propsActive = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_13__.useMediaPropsActive)(props);
        const isFormControl = _tamagui_core__WEBPACK_IMPORTED_MODULE_14__.isWeb ? button ? Boolean(button.closest("form")) : true : false;
        const [checked = false, setChecked] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_15__.useControllableState)({
          prop: checkedProp,
          defaultProp: defaultChecked,
          onChange: onCheckedChange
        });
        const adjustedSize = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.getVariableValue)(
          (0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_9__.stepTokenUpOrDown)("size", propsActive.size, sizeAdjust)
        );
        const size = scaleSize ? Math.round(adjustedSize * scaleSize) : adjustedSize;
        const labelId = (0,_tamagui_label__WEBPACK_IMPORTED_MODULE_16__.useLabelContext)(button);
        const labelledBy = ariaLabelledby || labelId;
        if (false) {}
        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          CheckboxProvider,
          {
            scope: __scopeCheckbox,
            state: checked,
            disabled,
            size,
            scaleIcon,
            children: _tamagui_core__WEBPACK_IMPORTED_MODULE_14__.isWeb && native ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
              BubbleInput,
              {
                control: button,
                bubbles: !hasConsumerStoppedPropagationRef.current,
                name,
                value,
                checked,
                required,
                disabled,
                id: props.id
              }
            ) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [
              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
                CheckboxFrame,
                {
                  width: size,
                  height: size,
                  tag: "button",
                  role: "checkbox",
                  "aria-labelledby": labelledBy,
                  "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
                  "aria-required": required,
                  "data-state": getState(checked),
                  "data-disabled": disabled ? "" : void 0,
                  disabled,
                  ...checkboxProps,
                  ref: composedRefs,
                  ..._tamagui_core__WEBPACK_IMPORTED_MODULE_14__.isWeb && {
                    type: "button",
                    value,
                    onKeyDown: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_17__.composeEventHandlers)(
                      props.onKeyDown,
                      (event) => {
                        if (event.key === "Enter")
                          event.preventDefault();
                      }
                    )
                  },
                  onPress: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_17__.composeEventHandlers)(props.onPress, (event) => {
                    setChecked(
                      (prevChecked) => isIndeterminate(prevChecked) ? true : !prevChecked
                    );
                    if (isFormControl) {
                      hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
                      if (!hasConsumerStoppedPropagationRef.current)
                        event.stopPropagation();
                    }
                  })
                }
              ),
              _tamagui_core__WEBPACK_IMPORTED_MODULE_14__.isWeb && isFormControl ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
                BubbleInput,
                {
                  isHidden: true,
                  control: button,
                  bubbles: !hasConsumerStoppedPropagationRef.current,
                  name,
                  value,
                  checked,
                  required,
                  disabled
                }
              ) : null
            ] })
          }
        );
      }
    )
  ),
  {
    Indicator: CheckboxIndicator
  }
);
Checkbox.displayName = CHECKBOX_NAME;

//# sourceMappingURL=Checkbox.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/checkbox/dist/esm/index.mjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@tamagui/checkbox/dist/esm/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BubbleInput": () => (/* reexport safe */ _Checkbox__WEBPACK_IMPORTED_MODULE_0__.BubbleInput),
/* harmony export */   "Checkbox": () => (/* reexport safe */ _Checkbox__WEBPACK_IMPORTED_MODULE_0__.Checkbox),
/* harmony export */   "CheckboxFrame": () => (/* reexport safe */ _Checkbox__WEBPACK_IMPORTED_MODULE_0__.CheckboxFrame),
/* harmony export */   "createCheckboxScope": () => (/* reexport safe */ _Checkbox__WEBPACK_IMPORTED_MODULE_0__.createCheckboxScope),
/* harmony export */   "getState": () => (/* reexport safe */ _Checkbox__WEBPACK_IMPORTED_MODULE_0__.getState),
/* harmony export */   "isIndeterminate": () => (/* reexport safe */ _Checkbox__WEBPACK_IMPORTED_MODULE_0__.isIndeterminate)
/* harmony export */ });
/* harmony import */ var _Checkbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Checkbox */ "../../node_modules/@tamagui/checkbox/dist/esm/Checkbox.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/create-context/dist/esm/index.mjs":
/*!*********************************************************************!*\
  !*** ../../node_modules/@tamagui/create-context/dist/esm/index.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createContext": () => (/* reexport safe */ _create_context__WEBPACK_IMPORTED_MODULE_0__.createContext),
/* harmony export */   "createContextScope": () => (/* reexport safe */ _create_context__WEBPACK_IMPORTED_MODULE_0__.createContextScope)
/* harmony export */ });
/* harmony import */ var _create_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/dialog/dist/esm/Dialog.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/dialog/dist/esm/Dialog.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dialog": () => (/* binding */ Dialog),
/* harmony export */   "DialogClose": () => (/* binding */ DialogClose),
/* harmony export */   "DialogContent": () => (/* binding */ DialogContent),
/* harmony export */   "DialogDescription": () => (/* binding */ DialogDescription),
/* harmony export */   "DialogOverlay": () => (/* binding */ DialogOverlay),
/* harmony export */   "DialogOverlayFrame": () => (/* binding */ DialogOverlayFrame),
/* harmony export */   "DialogPortal": () => (/* binding */ DialogPortal),
/* harmony export */   "DialogPortalFrame": () => (/* binding */ DialogPortalFrame),
/* harmony export */   "DialogSheetContents": () => (/* binding */ DialogSheetContents),
/* harmony export */   "DialogTitle": () => (/* binding */ DialogTitle),
/* harmony export */   "DialogTrigger": () => (/* binding */ DialogTrigger),
/* harmony export */   "DialogWarningProvider": () => (/* binding */ DialogWarningProvider),
/* harmony export */   "createDialogScope": () => (/* binding */ createDialogScope)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/adapt */ "../../node_modules/@tamagui/adapt/dist/esm/index.mjs");
/* harmony import */ var _tamagui_animate_presence__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tamagui/animate-presence */ "../../node_modules/@tamagui/animate-presence/dist/esm/AnimatePresence.mjs");
/* harmony import */ var _tamagui_aria_hidden__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @tamagui/aria-hidden */ "../../node_modules/aria-hidden/dist/es2015/index.js");
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useThemeName.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createComponent.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/views/Theme.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/use-event/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useMedia.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_dismissable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/dismissable */ "../../node_modules/@tamagui/dismissable/dist/esm/index.mjs");
/* harmony import */ var _tamagui_focus_scope__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/focus-scope */ "../../node_modules/@tamagui/focus-scope/dist/esm/index.mjs");
/* harmony import */ var _tamagui_portal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/portal */ "../../node_modules/@tamagui/portal/dist/esm/index.mjs");
/* harmony import */ var _tamagui_remove_scroll__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/remove-scroll */ "../../node_modules/@tamagui/remove-scroll/dist/esm/index.mjs");
/* harmony import */ var _tamagui_sheet__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tamagui/sheet */ "../../node_modules/@tamagui/sheet/dist/esm/Sheet.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var _tamagui_text__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @tamagui/text */ "../../node_modules/@tamagui/text/dist/esm/Headings.mjs");
/* harmony import */ var _tamagui_text__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @tamagui/text */ "../../node_modules/@tamagui/text/dist/esm/Paragraph.mjs");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);
















const DIALOG_NAME = "Dialog";
const [createDialogContext, createDialogScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_7__.createContextScope)(DIALOG_NAME);
const [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
const TRIGGER_NAME = "DialogTrigger";
const DialogTriggerFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_9__.YStack, {
  name: TRIGGER_NAME
});
const DialogTrigger = react__WEBPACK_IMPORTED_MODULE_6__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME, __scopeDialog);
    const composedTriggerRef = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_10__.useComposedRefs)(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      DialogTriggerFrame,
      {
        tag: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onPress: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.composeEventHandlers)(props.onPress, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME;
const PORTAL_NAME = "DialogPortal";
const [PortalProvider, usePortalContext] = createDialogContext(
  PORTAL_NAME,
  {
    forceMount: void 0
  }
);
const DialogPortalFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_9__.YStack, {
  alignItems: "center",
  justifyContent: "center",
  fullscreen: true,
  zIndex: 100,
  ..._tamagui_core__WEBPACK_IMPORTED_MODULE_12__.isWeb && {
    maxHeight: "100vh",
    position: "fixed"
  }
});
const DialogPortalItem = (props) => {
  const themeName = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_13__.useThemeName)();
  const context = useDialogContext(PORTAL_NAME, props.__scopeDialog);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_portal__WEBPACK_IMPORTED_MODULE_4__.PortalItem, { hostName: props.hostName, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DialogPortalItemContent, { ...props, themeName, context }) });
};
function DialogPortalItemContent(props) {
  const {
    __scopeDialog,
    children,
    context,
    themeName,
    space,
    spaceDirection,
    separator
  } = props;
  let childrenSpaced = children;
  if (space || separator) {
    childrenSpaced = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_14__.spacedChildren)({
      children,
      separator,
      space,
      direction: spaceDirection
    });
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DialogProvider, { scope: __scopeDialog, ...context, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_core__WEBPACK_IMPORTED_MODULE_15__.Theme, { name: themeName, children: childrenSpaced }) });
}
const DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, ...frameProps } = props;
  const context = useDialogContext(PORTAL_NAME, __scopeDialog);
  const isShowing = forceMount || context.open;
  const [isFullyHidden, setIsFullyHidden] = react__WEBPACK_IMPORTED_MODULE_6__.useState(!isShowing);
  if (isShowing && isFullyHidden) {
    setIsFullyHidden(false);
  }
  const contents = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    _tamagui_animate_presence__WEBPACK_IMPORTED_MODULE_16__.AnimatePresence,
    {
      onExitComplete: () => {
        setIsFullyHidden(true);
      },
      children: isShowing ? children : null
    }
  );
  const isSheet = useShowDialogSheet(context);
  if (isSheet) {
    return children;
  }
  if (context.modal) {
    if (isFullyHidden) {
      return null;
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DialogPortalItem, { __scopeDialog, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DialogPortalFrame, { pointerEvents: isShowing ? "auto" : "none", ...frameProps, children: contents }) }) });
  }
  return contents;
};
DialogPortal.displayName = PORTAL_NAME;
const OVERLAY_NAME = "DialogOverlay";
const DialogOverlayFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_tamagui_sheet__WEBPACK_IMPORTED_MODULE_17__.SheetOverlayFrame, {
  name: OVERLAY_NAME
});
const DialogOverlay = DialogOverlayFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_6__.forwardRef(
    ({ __scopeDialog, ...props }, forwardedRef) => {
      const portalContext = usePortalContext(OVERLAY_NAME, __scopeDialog);
      const { forceMount = portalContext.forceMount, ...overlayProps } = props;
      const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
      const showSheet = useShowDialogSheet(context);
      if (!forceMount) {
        if (!context.modal || showSheet) {
          return null;
        }
      }
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DialogOverlayImpl, { context, ...overlayProps, ref: forwardedRef });
    }
  )
);
DialogOverlay.displayName = OVERLAY_NAME;
const DialogOverlayImpl = react__WEBPACK_IMPORTED_MODULE_6__.forwardRef(
  (props, forwardedRef) => {
    const { context, ...overlayProps } = props;
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        DialogOverlayFrame,
        {
          "data-state": getState(context.open),
          pointerEvents: context.open ? "auto" : "none",
          ...overlayProps,
          ref: forwardedRef
        }
      )
    );
  }
);
const CONTENT_NAME = "DialogContent";
const DialogContentFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_18__.ThemeableStack, {
  name: CONTENT_NAME,
  tag: "dialog",
  position: "relative",
  backgrounded: true,
  padded: true,
  radiused: true,
  elevate: true,
  variants: {
    size: {
      "...size": (val, extras) => {
        return {};
      }
    }
  },
  defaultVariants: {
    size: "$true"
  }
});
const DialogContent = DialogContentFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_6__.forwardRef(
    ({ __scopeDialog, ...props }, forwardedRef) => {
      const portalContext = usePortalContext(CONTENT_NAME, __scopeDialog);
      const { forceMount = portalContext.forceMount, ...contentProps } = props;
      const context = useDialogContext(CONTENT_NAME, __scopeDialog);
      const contents = context.modal ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DialogContentModal, { context, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DialogContentNonModal, { context, ...contentProps, ref: forwardedRef });
      if (!_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.isWeb || context.disableRemoveScroll) {
        return contents;
      }
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        _tamagui_remove_scroll__WEBPACK_IMPORTED_MODULE_5__.RemoveScroll,
        {
          forwardProps: true,
          enabled: context.open,
          allowPinchZoom: context.allowPinchZoom,
          shards: [context.contentRef],
          removeScrollBar: false,
          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "_dsp_contents", children: contents })
        }
      );
    }
  )
);
DialogContent.displayName = CONTENT_NAME;
const DialogContentModal = react__WEBPACK_IMPORTED_MODULE_6__.forwardRef(
  ({ children, context, ...props }, forwardedRef) => {
    const contentRef = react__WEBPACK_IMPORTED_MODULE_6__.useRef(null);
    const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_10__.useComposedRefs)(forwardedRef, context.contentRef, contentRef);
    if (_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.isWeb) {
      react__WEBPACK_IMPORTED_MODULE_6__.useEffect(() => {
        if (!context.open)
          return;
        const content = contentRef.current;
        if (content)
          return (0,_tamagui_aria_hidden__WEBPACK_IMPORTED_MODULE_19__.hideOthers)(content);
      }, [context.open]);
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      DialogContentImpl,
      {
        ...props,
        context,
        ref: composedRefs,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.composeEventHandlers)(props.onCloseAutoFocus, (event) => {
          var _a;
          event.preventDefault();
          (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
        }),
        onPointerDownOutside: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.composeEventHandlers)(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event["detail"].originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            if (isRightClick)
              event.preventDefault();
          }
        ),
        onFocusOutside: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.composeEventHandlers)(
          props.onFocusOutside,
          (event) => event.preventDefault()
        ),
        children
      }
    );
  }
);
const DialogContentNonModal = react__WEBPACK_IMPORTED_MODULE_6__.forwardRef(
  (props, forwardedRef) => {
    const hasInteractedOutsideRef = react__WEBPACK_IMPORTED_MODULE_6__.useRef(false);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a, _b;
          (_a = props.onCloseAutoFocus) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) {
              (_b = props.context.triggerRef.current) == null ? void 0 : _b.focus();
            }
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a;
          (_a = props.onInteractOutside) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented)
            hasInteractedOutsideRef.current = true;
          const target = event.target;
          const trigger = props.context.triggerRef.current;
          if (!(trigger instanceof HTMLElement))
            return;
          const targetIsTrigger = trigger.contains(target);
          if (targetIsTrigger)
            event.preventDefault();
        }
      }
    );
  }
);
const DialogContentImpl = react__WEBPACK_IMPORTED_MODULE_6__.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeDialog,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      context,
      ...contentProps
    } = props;
    const contentRef = react__WEBPACK_IMPORTED_MODULE_6__.useRef(null);
    const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_10__.useComposedRefs)(forwardedRef, contentRef);
    const showSheet = useShowDialogSheet(context);
    const contents = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      DialogContentFrame,
      {
        id: context.contentId,
        "aria-describedby": context.descriptionId,
        "aria-labelledby": context.titleId,
        "data-state": getState(context.open),
        ...contentProps
      }
    );
    if (showSheet) {
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DialogPortalItem, { hostName: getSheetContentsName(context), children: contentProps.children });
    }
    if (!_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.isWeb) {
      return contents;
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        _tamagui_focus_scope__WEBPACK_IMPORTED_MODULE_3__.FocusScope,
        {
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          forceUnmount: !context.open,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
            _tamagui_dismissable__WEBPACK_IMPORTED_MODULE_2__.Dismissable,
            {
              disableOutsidePointerEvents: context.open && disableOutsidePointerEvents,
              forceUnmount: !context.open,
              onEscapeKeyDown,
              onPointerDownOutside,
              onFocusOutside,
              onInteractOutside,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false),
              children: contents
            }
          )
        }
      ),
       true && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [
        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          DescriptionWarning,
          {
            contentRef,
            descriptionId: context.descriptionId
          }
        )
      ] })
    ] });
  }
);
const TITLE_NAME = "DialogTitle";
const DialogTitleFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_tamagui_text__WEBPACK_IMPORTED_MODULE_20__.H2, {
  name: TITLE_NAME
});
const DialogTitle = react__WEBPACK_IMPORTED_MODULE_6__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DialogTitleFrame, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
const DialogDescriptionFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_tamagui_text__WEBPACK_IMPORTED_MODULE_21__.Paragraph, {
  name: "DialogDescription"
});
const DESCRIPTION_NAME = "DialogDescription";
const DialogDescription = react__WEBPACK_IMPORTED_MODULE_6__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      DialogDescriptionFrame,
      {
        id: context.descriptionId,
        ...descriptionProps,
        ref: forwardedRef
      }
    );
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
const CLOSE_NAME = "DialogClose";
const DialogClose = react__WEBPACK_IMPORTED_MODULE_6__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, displayWhenAdapted, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog, {
      warn: false,
      fallback: {}
    });
    const isSheet = useShowDialogSheet(context);
    if (isSheet && !displayWhenAdapted) {
      return null;
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _tamagui_stacks__WEBPACK_IMPORTED_MODULE_9__.YStack,
      {
        tag: "button",
        accessibilityLabel: "Dialog Close",
        ...closeProps,
        ref: forwardedRef,
        onPress: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.composeEventHandlers)(
          props.onPress,
          () => context.onOpenChange(false)
        )
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
const TITLE_WARNING_NAME = "DialogTitleWarning";
const [DialogWarningProvider, useWarningContext] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_7__.createContext)(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
const TitleWarning = ({ titleId }) => {
  if (true) {
    const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
    const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.`;
    react__WEBPACK_IMPORTED_MODULE_6__.useEffect(() => {
      if (!_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.isWeb)
        return;
      if (titleId) {
        const hasTitle = document.getElementById(titleId);
        if (!hasTitle) {
          console.warn(MESSAGE);
        }
      }
    }, [MESSAGE, titleId]);
  }
  return null;
};
const DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
const DescriptionWarning = ({
  contentRef,
  descriptionId
}) => {
  if (true) {
    const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
    const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
    react__WEBPACK_IMPORTED_MODULE_6__.useEffect(() => {
      if (!_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.isWeb)
        return;
      const contentNode = contentRef.current;
      if (!(contentNode instanceof HTMLElement)) {
        return;
      }
      const describedById = contentNode.getAttribute("aria-describedby");
      if (descriptionId && describedById) {
        const hasDescription = document.getElementById(descriptionId);
        if (!hasDescription) {
          console.warn(MESSAGE);
        }
      }
    }, [MESSAGE, contentRef, descriptionId]);
  }
  return null;
};
const Dialog = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_22__.withStaticProperties)(
  react__WEBPACK_IMPORTED_MODULE_6__.forwardRef(function Dialog2(props, ref) {
    const {
      __scopeDialog,
      children,
      open: openProp,
      defaultOpen = false,
      onOpenChange,
      modal = true,
      allowPinchZoom = false,
      disableRemoveScroll = false
    } = props;
    const baseId = react__WEBPACK_IMPORTED_MODULE_6__.useId();
    const scopeId = `scope-${baseId}`;
    const contentId = `content-${baseId}`;
    const titleId = `title-${baseId}`;
    const descriptionId = `description-${baseId}`;
    const scopeKey = __scopeDialog ? Object.keys(__scopeDialog)[0] : scopeId;
    const sheetContentsName = getSheetContentsName({ scopeKey, contentId });
    const triggerRef = react__WEBPACK_IMPORTED_MODULE_6__.useRef(null);
    const contentRef = react__WEBPACK_IMPORTED_MODULE_6__.useRef(null);
    const [open, setOpen] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_23__.useControllableState)({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    const onOpenToggle = react__WEBPACK_IMPORTED_MODULE_6__.useCallback(() => {
      setOpen((prevOpen) => !prevOpen);
    }, [setOpen]);
    const context = {
      scope: __scopeDialog,
      scopeKey,
      triggerRef,
      contentRef,
      contentId,
      titleId,
      descriptionId,
      open,
      onOpenChange: setOpen,
      onOpenToggle,
      modal,
      allowPinchZoom
    };
    const { when, AdaptProvider } = (0,_tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__.useAdaptParent)({
      Contents: react__WEBPACK_IMPORTED_MODULE_6__.useCallback(
        (props2) => {
          return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_portal__WEBPACK_IMPORTED_MODULE_4__.PortalHost, { forwardProps: props2, name: sheetContentsName });
        },
        [sheetContentsName]
      )
    });
    react__WEBPACK_IMPORTED_MODULE_6__.useImperativeHandle(
      ref,
      () => ({
        open: setOpen
      }),
      [setOpen]
    );
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AdaptProvider, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      DialogProvider,
      {
        ...context,
        sheetBreakpoint: when,
        disableRemoveScroll,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DialogSheetController, { onOpenChange: setOpen, __scopeDialog, children })
      }
    ) });
  }),
  {
    Trigger: DialogTrigger,
    Portal: DialogPortal,
    Overlay: DialogOverlay,
    Content: DialogContent,
    Title: DialogTitle,
    Description: DialogDescription,
    Close: DialogClose,
    Sheet: _tamagui_sheet__WEBPACK_IMPORTED_MODULE_17__.ControlledSheet,
    Adapt: _tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__.Adapt
  }
);
const SHEET_CONTENTS_NAME = "DialogSheetContents";
const DialogSheetContents = ({
  name,
  ...props
}) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_portal__WEBPACK_IMPORTED_MODULE_4__.PortalHost, { forwardProps: props, name });
};
DialogSheetContents.displayName = SHEET_CONTENTS_NAME;
const getSheetContentsName = ({
  scopeKey,
  contentId
}) => `${scopeKey || contentId}SheetContents`;
const DialogSheetController = (props) => {
  const context = useDialogContext("DialogSheetController", props.__scopeDialog);
  const showSheet = useShowDialogSheet(context);
  const breakpointActive = useSheetBreakpointActive(context);
  const getShowSheet = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_24__.useGet)(showSheet);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    _tamagui_sheet__WEBPACK_IMPORTED_MODULE_17__.SheetController,
    {
      onOpenChange: (val) => {
        if (getShowSheet()) {
          props.onOpenChange(val);
        }
      },
      open: context.open,
      hidden: breakpointActive === false,
      children: props.children
    }
  );
};
const useSheetBreakpointActive = (context) => {
  const media = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_25__.useMedia)();
  if (!context.sheetBreakpoint)
    return false;
  if (context.sheetBreakpoint === true)
    return true;
  return media[context.sheetBreakpoint];
};
const useShowDialogSheet = (context) => {
  const breakpointActive = useSheetBreakpointActive(context);
  return context.open === false ? false : breakpointActive;
};

//# sourceMappingURL=Dialog.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/dialog/dist/esm/index.mjs":
/*!*************************************************************!*\
  !*** ../../node_modules/@tamagui/dialog/dist/esm/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dialog": () => (/* reexport safe */ _Dialog__WEBPACK_IMPORTED_MODULE_0__.Dialog),
/* harmony export */   "DialogClose": () => (/* reexport safe */ _Dialog__WEBPACK_IMPORTED_MODULE_0__.DialogClose),
/* harmony export */   "DialogContent": () => (/* reexport safe */ _Dialog__WEBPACK_IMPORTED_MODULE_0__.DialogContent),
/* harmony export */   "DialogDescription": () => (/* reexport safe */ _Dialog__WEBPACK_IMPORTED_MODULE_0__.DialogDescription),
/* harmony export */   "DialogOverlay": () => (/* reexport safe */ _Dialog__WEBPACK_IMPORTED_MODULE_0__.DialogOverlay),
/* harmony export */   "DialogOverlayFrame": () => (/* reexport safe */ _Dialog__WEBPACK_IMPORTED_MODULE_0__.DialogOverlayFrame),
/* harmony export */   "DialogPortal": () => (/* reexport safe */ _Dialog__WEBPACK_IMPORTED_MODULE_0__.DialogPortal),
/* harmony export */   "DialogPortalFrame": () => (/* reexport safe */ _Dialog__WEBPACK_IMPORTED_MODULE_0__.DialogPortalFrame),
/* harmony export */   "DialogSheetContents": () => (/* reexport safe */ _Dialog__WEBPACK_IMPORTED_MODULE_0__.DialogSheetContents),
/* harmony export */   "DialogTitle": () => (/* reexport safe */ _Dialog__WEBPACK_IMPORTED_MODULE_0__.DialogTitle),
/* harmony export */   "DialogTrigger": () => (/* reexport safe */ _Dialog__WEBPACK_IMPORTED_MODULE_0__.DialogTrigger),
/* harmony export */   "DialogWarningProvider": () => (/* reexport safe */ _Dialog__WEBPACK_IMPORTED_MODULE_0__.DialogWarningProvider),
/* harmony export */   "createDialogScope": () => (/* reexport safe */ _Dialog__WEBPACK_IMPORTED_MODULE_0__.createDialogScope)
/* harmony export */ });
/* harmony import */ var _Dialog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dialog */ "../../node_modules/@tamagui/dialog/dist/esm/Dialog.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/floating/dist/esm/Floating.mjs":
/*!******************************************************************!*\
  !*** ../../node_modules/@tamagui/floating/dist/esm/Floating.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrow": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.arrow),
/* harmony export */   "autoPlacement": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),
/* harmony export */   "autoUpdate": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate),
/* harmony export */   "computePosition": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),
/* harmony export */   "flip": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.flip),
/* harmony export */   "getOverflowAncestors": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors),
/* harmony export */   "hide": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.hide),
/* harmony export */   "inline": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.inline),
/* harmony export */   "limitShift": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift),
/* harmony export */   "offset": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.offset),
/* harmony export */   "platform": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.platform),
/* harmony export */   "shift": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.shift),
/* harmony export */   "size": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.size),
/* harmony export */   "useFloating": () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.useFloating)
/* harmony export */ });
/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/react-dom */ "../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js");

//# sourceMappingURL=Floating.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/floating/dist/esm/index.mjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@tamagui/floating/dist/esm/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FloatingOverrideContext": () => (/* reexport safe */ _useFloating__WEBPACK_IMPORTED_MODULE_1__.FloatingOverrideContext),
/* harmony export */   "arrow": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.arrow),
/* harmony export */   "autoPlacement": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),
/* harmony export */   "autoUpdate": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.autoUpdate),
/* harmony export */   "computePosition": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.computePosition),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),
/* harmony export */   "flip": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.flip),
/* harmony export */   "getOverflowAncestors": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors),
/* harmony export */   "hide": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.hide),
/* harmony export */   "inline": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.inline),
/* harmony export */   "limitShift": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.limitShift),
/* harmony export */   "offset": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.offset),
/* harmony export */   "platform": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.platform),
/* harmony export */   "shift": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.shift),
/* harmony export */   "size": () => (/* reexport safe */ _Floating__WEBPACK_IMPORTED_MODULE_0__.size),
/* harmony export */   "useFloating": () => (/* reexport safe */ _useFloating__WEBPACK_IMPORTED_MODULE_1__.useFloating)
/* harmony export */ });
/* harmony import */ var _Floating__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Floating */ "../../node_modules/@tamagui/floating/dist/esm/Floating.mjs");
/* harmony import */ var _useFloating__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useFloating */ "../../node_modules/@tamagui/floating/dist/esm/useFloating.mjs");



//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/floating/dist/esm/useFloating.mjs":
/*!*********************************************************************!*\
  !*** ../../node_modules/@tamagui/floating/dist/esm/useFloating.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FloatingOverrideContext": () => (/* binding */ FloatingOverrideContext),
/* harmony export */   "useFloating": () => (/* binding */ useFloating)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Floating__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Floating */ "../../node_modules/@tamagui/floating/dist/esm/Floating.mjs");


const FloatingOverrideContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
const useFloating = (props) => {
  var _a;
  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FloatingOverrideContext);
  return (_a = context || _Floating__WEBPACK_IMPORTED_MODULE_1__.useFloating) == null ? void 0 : _a(props);
};

//# sourceMappingURL=useFloating.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/focus-scope/dist/esm/FocusScope.mjs":
/*!***********************************************************************!*\
  !*** ../../node_modules/@tamagui/focus-scope/dist/esm/FocusScope.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FocusScope": () => (/* binding */ FocusScope)
/* harmony export */ });
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_use_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/use-event */ "../../node_modules/@tamagui/use-event/dist/esm/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);



const AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
const AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
const EVENT_OPTIONS = { bubbles: false, cancelable: true };
const FOCUS_SCOPE_NAME = "FocusScope";
const FocusScope = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
  (props, forwardedRef) => {
    const {
      loop = false,
      trapped = false,
      onMountAutoFocus: onMountAutoFocusProp,
      onUnmountAutoFocus: onUnmountAutoFocusProp,
      children,
      forceUnmount,
      ...scopeProps
    } = props;
    const [container, setContainer] = react__WEBPACK_IMPORTED_MODULE_1__.useState(null);
    const onMountAutoFocus = (0,_tamagui_use_event__WEBPACK_IMPORTED_MODULE_0__.useEvent)(onMountAutoFocusProp);
    const onUnmountAutoFocus = (0,_tamagui_use_event__WEBPACK_IMPORTED_MODULE_0__.useEvent)(onUnmountAutoFocusProp);
    const lastFocusedElementRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);
    const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_2__.useComposedRefs)(forwardedRef, (node) => setContainer(node));
    const focusScope = react__WEBPACK_IMPORTED_MODULE_1__.useRef({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    }).current;
    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
      if (!trapped)
        return;
      function handleFocusIn(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }
      function handleFocusOut(event) {
        if (focusScope.paused || !container)
          return;
        if (!container.contains(event.relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      return () => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
      };
    }, [trapped, forceUnmount, container, focusScope.paused]);
    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
      if (!container)
        return;
      if (forceUnmount)
        return;
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
        container.dispatchEvent(unmountEvent);
        if (!unmountEvent.defaultPrevented) {
          focus(previouslyFocusedElement ?? document.body, { select: true });
        }
        container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
        focusScopesStack.remove(focusScope);
      };
    }, [container, forceUnmount, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
    const handleKeyDown = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(
      (event) => {
        if (!(loop || trapped))
          return;
        if (focusScope.paused)
          return;
        const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
        const focusedElement = document.activeElement;
        if (isTabKey && focusedElement) {
          const container2 = event.currentTarget;
          const [first, last] = getTabbableEdges(container2);
          const hasTabbableElementsInside = first && last;
          if (!hasTabbableElementsInside) {
            if (focusedElement === container2)
              event.preventDefault();
          } else {
            if (!event.shiftKey && focusedElement === last) {
              event.preventDefault();
              if (loop)
                focus(first, { select: true });
            } else if (event.shiftKey && focusedElement === first) {
              event.preventDefault();
              if (loop)
                focus(last, { select: true });
            }
          }
        }
      },
      [loop, trapped, focusScope.paused]
    );
    const child = react__WEBPACK_IMPORTED_MODULE_1__.Children.only(children);
    return react__WEBPACK_IMPORTED_MODULE_1__.cloneElement(child, {
      tabIndex: -1,
      ...scopeProps,
      ref: composedRefs,
      onKeyDown: handleKeyDown
    });
  }
);
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container }))
      return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element == null ? void 0 : element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
const focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a;
      stack = arrayRemove(stack, focusScope);
      (_a = stack[0]) == null ? void 0 : _a.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index = updatedArray.indexOf(item);
  if (index !== -1) {
    updatedArray.splice(index, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

//# sourceMappingURL=FocusScope.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/focus-scope/dist/esm/index.mjs":
/*!******************************************************************!*\
  !*** ../../node_modules/@tamagui/focus-scope/dist/esm/index.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FocusScope": () => (/* reexport safe */ _FocusScope__WEBPACK_IMPORTED_MODULE_0__.FocusScope)
/* harmony export */ });
/* harmony import */ var _FocusScope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FocusScope */ "../../node_modules/@tamagui/focus-scope/dist/esm/FocusScope.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/focusable/dist/esm/focusableInputHOC.mjs":
/*!****************************************************************************!*\
  !*** ../../node_modules/@tamagui/focusable/dist/esm/focusableInputHOC.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "focusableInputHOC": () => (/* binding */ focusableInputHOC)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/helpers/isTamaguiComponent.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/use-event/dist/esm/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _registerFocusable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./registerFocusable */ "../../node_modules/@tamagui/focusable/dist/esm/registerFocusable.mjs");





function focusableInputHOC(Component) {
  const component = Component.extractable(
    (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(
      (props, ref) => {
        const isInput = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_2__.isTamaguiComponent)(Component) && Component.staticConfig.isInput;
        const inputValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(props.value || props.defaultValue || "");
        const unregisterFocusable = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();
        const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(
          (input) => {
            var _a;
            if (!props.id)
              return;
            if (!input)
              return;
            (_a = unregisterFocusable.current) == null ? void 0 : _a.call(unregisterFocusable);
            unregisterFocusable.current = (0,_registerFocusable__WEBPACK_IMPORTED_MODULE_3__.registerFocusable)(props.id, {
              focus: input.focus,
              ...isInput && {
                // react-native doesn't support programmatic .select()
                focusAndSelect() {
                  input.focus();
                  if (input.setSelection && typeof inputValue.current === "string") {
                    input.setSelection(0, inputValue.current.length);
                  }
                }
              }
            });
          },
          [isInput, props.id]
        );
        const combinedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_4__.composeRefs)(ref, inputRef);
        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
          return () => {
            var _a;
            (_a = unregisterFocusable.current) == null ? void 0 : _a.call(unregisterFocusable);
          };
        }, []);
        const onChangeText = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_5__.useEvent)((value) => {
          var _a;
          inputValue.current = value;
          (_a = props.onChangeText) == null ? void 0 : _a.call(props, value);
        });
        const finalProps = isInput ? {
          ...props,
          onChangeText
        } : props;
        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Component, { ref: combinedRefs, ...finalProps });
      }
    )
  );
  return component;
}

//# sourceMappingURL=focusableInputHOC.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/focusable/dist/esm/registerFocusable.mjs":
/*!****************************************************************************!*\
  !*** ../../node_modules/@tamagui/focusable/dist/esm/registerFocusable.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "focusFocusable": () => (/* binding */ focusFocusable),
/* harmony export */   "registerFocusable": () => (/* binding */ registerFocusable),
/* harmony export */   "unregisterFocusable": () => (/* binding */ unregisterFocusable)
/* harmony export */ });
const registerFocusable = (id, input) => () => {
};
const unregisterFocusable = (id) => {
};
const focusFocusable = (id) => {
};

//# sourceMappingURL=registerFocusable.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/font-size/dist/esm/getFontSize.mjs":
/*!**********************************************************************!*\
  !*** ../../node_modules/@tamagui/font-size/dist/esm/getFontSize.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getFontSize": () => (/* binding */ getFontSize),
/* harmony export */   "getFontSizeToken": () => (/* binding */ getFontSizeToken),
/* harmony export */   "getFontSizeVariable": () => (/* binding */ getFontSizeVariable)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/config.js");

const getFontSize = (inSize, opts) => {
  const res = getFontSizeVariable(inSize, opts);
  if ((0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.isVariable)(res)) {
    return +res.val;
  }
  return res ? +res : 16;
};
const getFontSizeVariable = (inSize, opts) => {
  const token = getFontSizeToken(inSize, opts);
  if (!token) {
    return inSize;
  }
  const conf = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.getConfig)();
  return conf.fontsParsed[(opts == null ? void 0 : opts.font) || "$body"].size[token];
};
const getFontSizeToken = (inSize, opts) => {
  if (typeof inSize === "number") {
    return null;
  }
  const relativeSize = (opts == null ? void 0 : opts.relativeSize) || 0;
  const conf = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.getConfig)();
  const fontSize = conf.fontsParsed[(opts == null ? void 0 : opts.font) || "$body"].size;
  const size = inSize || ("$true" in fontSize ? "$true" : "$4");
  const sizeTokens = Object.keys(fontSize);
  let foundIndex = sizeTokens.indexOf(size);
  if (foundIndex === -1) {
    if (size.endsWith(".5")) {
      foundIndex = sizeTokens.indexOf(size.replace(".5", ""));
    }
  }
  if (true) {
    if (foundIndex === -1) {
      console.warn("No font size found", size, opts, "in size tokens", sizeTokens);
    }
  }
  const tokenIndex = Math.min(
    Math.max(0, foundIndex + relativeSize),
    sizeTokens.length - 1
  );
  return sizeTokens[tokenIndex] ?? size;
};

//# sourceMappingURL=getFontSize.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/font-size/dist/esm/index.mjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@tamagui/font-size/dist/esm/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getFontSize": () => (/* reexport safe */ _getFontSize__WEBPACK_IMPORTED_MODULE_0__.getFontSize),
/* harmony export */   "getFontSizeToken": () => (/* reexport safe */ _getFontSize__WEBPACK_IMPORTED_MODULE_0__.getFontSizeToken),
/* harmony export */   "getFontSizeVariable": () => (/* reexport safe */ _getFontSize__WEBPACK_IMPORTED_MODULE_0__.getFontSizeVariable)
/* harmony export */ });
/* harmony import */ var _getFontSize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFontSize */ "../../node_modules/@tamagui/font-size/dist/esm/getFontSize.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/form/dist/esm/Form.mjs":
/*!**********************************************************!*\
  !*** ../../node_modules/@tamagui/form/dist/esm/Form.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Form": () => (/* binding */ Form),
/* harmony export */   "FormFrame": () => (/* binding */ FormFrame),
/* harmony export */   "FormProvider": () => (/* binding */ FormProvider),
/* harmony export */   "FormTrigger": () => (/* binding */ FormTrigger),
/* harmony export */   "useFormContext": () => (/* binding */ useFormContext)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/core/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);




const FORM_NAME = "Form";
const FormFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.Stack, {
  name: FORM_NAME,
  tag: "form"
});
const [createFormContext] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_4__.createContextScope)(FORM_NAME);
const [FormProvider, useFormContext] = createFormContext(FORM_NAME);
const TRIGGER_NAME = "FormTrigger";
const FormTriggerFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.Stack, {
  name: TRIGGER_NAME
});
const FormTrigger = FormTriggerFrame.extractable(
  (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(
    (props, forwardedRef) => {
      const { __scopeForm, children, ...triggerProps } = props;
      const context = useFormContext(TRIGGER_NAME, __scopeForm);
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        FormTriggerFrame,
        {
          tag: "button",
          ...triggerProps,
          children: triggerProps.asChild ? (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(children, { disabled: triggerProps.disabled }) : children,
          ref: forwardedRef,
          onPress: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.composeEventHandlers)(props.onPress, context.onSubmit)
        }
      );
    }
  )
);
function FormComponent({
  onSubmit,
  ...props
}) {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FormProvider, { scope: props.__scopeForm, onSubmit, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FormFrame, { ...props, onSubmit: (e) => e.preventDefault() }) });
}
const Form = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_6__.withStaticProperties)(FormFrame.extractable(FormComponent), {
  Trigger: FormTrigger
});

//# sourceMappingURL=Form.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/form/dist/esm/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/@tamagui/form/dist/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Form": () => (/* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_0__.Form),
/* harmony export */   "FormFrame": () => (/* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_0__.FormFrame),
/* harmony export */   "FormProvider": () => (/* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_0__.FormProvider),
/* harmony export */   "FormTrigger": () => (/* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_0__.FormTrigger),
/* harmony export */   "useFormContext": () => (/* reexport safe */ _Form__WEBPACK_IMPORTED_MODULE_0__.useFormContext)
/* harmony export */ });
/* harmony import */ var _Form__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Form */ "../../node_modules/@tamagui/form/dist/esm/Form.mjs");

//# sourceMappingURL=index.js.map


/***/ }),

/***/ "../../node_modules/@tamagui/get-button-sized/dist/esm/index.mjs":
/*!***********************************************************************!*\
  !*** ../../node_modules/@tamagui/get-button-sized/dist/esm/index.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getButtonSized": () => (/* binding */ getButtonSized)
/* harmony export */ });
/* harmony import */ var _tamagui_get_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/get-size */ "../../node_modules/@tamagui/get-size/dist/esm/index.mjs");

const getButtonSized = (val, { tokens }) => {
  if (typeof val === "number") {
    return {
      paddingHorizontal: val * 0.25,
      height: val,
      borderRadius: val * 0.2
    };
  }
  const ySize = (0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_0__.getSize)(val, 0);
  const xSize = (0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_0__.stepTokenUpOrDown)("space", val);
  const radiusToken = tokens.radius[val] ?? tokens.radius["$true"];
  return {
    paddingHorizontal: xSize,
    height: ySize,
    borderRadius: radiusToken
  };
};

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/get-size/dist/esm/index.mjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@tamagui/get-size/dist/esm/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSize": () => (/* binding */ getSize),
/* harmony export */   "stepTokenUpOrDown": () => (/* binding */ stepTokenUpOrDown)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/config.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariables.js");

const getSize = (size, shift = 0, bounds = [0]) => {
  return stepTokenUpOrDown("size", size, shift, bounds);
};
const stepTokenUpOrDown = (type, name = "$true", shift = 0, bounds = [0]) => {
  const tokens = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.getTokens)({ prefixed: true })[type];
  const maybeTokenizedKeysOrdered = _tamagui_core__WEBPACK_IMPORTED_MODULE_1__.tokensKeysOrdered.get(tokens) || Object.keys(tokens);
  const keysOrdered = maybeTokenizedKeysOrdered.map((maybeTokenizedKey) => maybeTokenizedKey.charAt(0) === "$" ? maybeTokenizedKey : `$${maybeTokenizedKey}`);
  const min = bounds[0] ?? 0;
  const max = bounds[1] ?? keysOrdered.length - 1;
  const currentIndex = keysOrdered.indexOf(name);
  if (name === "$true") {
    shift += shift === 0 ? 0 : shift > 0 ? 1 : -1;
  }
  const index = Math.min(max, Math.max(min, currentIndex + shift));
  const key = keysOrdered[index];
  return tokens[key] || tokens["$true"];
};

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/group/dist/esm/Group.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/@tamagui/group/dist/esm/Group.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Group": () => (/* binding */ Group),
/* harmony export */   "GroupFrame": () => (/* binding */ GroupFrame),
/* harmony export */   "XGroup": () => (/* binding */ XGroup),
/* harmony export */   "YGroup": () => (/* binding */ YGroup),
/* harmony export */   "useGroupItem": () => (/* binding */ useGroupItem)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useMedia.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/getExpandedShorthands.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/config.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/isTamaguiElement.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createComponent.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/mergeProps.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! react-native */ "../../node_modules/react-native-web/dist/index.js");
/* harmony import */ var reforest__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! reforest */ "../../node_modules/reforest/dist/esm/index.js");








const GROUP_NAME = "Group";
const [createGroupContext, createGroupScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_2__.createContextScope)(GROUP_NAME);
const [GroupProvider, useGroupContext] = createGroupContext(GROUP_NAME);
const GroupFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__.ThemeableStack, {
  name: "GroupFrame",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        y: 0,
        backgroundColor: "$background"
      }
    },
    size: (val, { tokens }) => {
      const borderRadius = tokens.radius[val] ?? val ?? tokens.radius["$true"];
      return {
        borderRadius
      };
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
function createGroup(verticalDefault) {
  return (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.withStaticProperties)(
    (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {
      const activeProps = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_6__.useMediaPropsActive)(props);
      const {
        __scopeGroup,
        children: childrenProp,
        space,
        size = "$true",
        spaceDirection,
        separator,
        scrollable,
        axis = verticalDefault ? "vertical" : "horizontal",
        orientation = axis,
        disabled: disabledProp,
        disablePassBorderRadius: disablePassBorderRadiusProp,
        borderRadius,
        forceUseItem,
        ...restProps
      } = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.getExpandedShorthands)(activeProps);
      const vertical = orientation === "vertical";
      const [itemChildrenCount, setItemChildrenCount] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_8__.useControllableState)({
        defaultProp: forceUseItem ? 1 : 0
      });
      const isUsingItems = true;
      const radius = borderRadius ?? (size ? (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_9__.getVariableValue)((0,_tamagui_core__WEBPACK_IMPORTED_MODULE_10__.getTokens)().radius[size]) - 1 : void 0);
      const hasRadius = radius !== void 0;
      const disablePassBorderRadius = disablePassBorderRadiusProp ?? !hasRadius;
      if (!isUsingItems)
        console.log("screw up!");
      const childrenArray = react__WEBPACK_IMPORTED_MODULE_1__.Children.toArray(childrenProp);
      const children = isUsingItems ? childrenProp : childrenArray.map((child, i) => {
        if (!(0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(child)) {
          return child;
        }
        const disabled = child.props.disabled ?? disabledProp;
        const isFirst = i === 0;
        const isLast = i === childrenArray.length - 1;
        const radiusStyles = disablePassBorderRadius === true ? null : getBorderRadius({
          isFirst,
          isLast,
          radius,
          vertical,
          disable: disablePassBorderRadius
        });
        const props2 = {
          disabled,
          ...(0,_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.isTamaguiElement)(child) ? radiusStyles : { style: radiusStyles }
        };
        return cloneElementWithPropOrder(child, props2);
      });
      const indexedChildren = (0,reforest__WEBPACK_IMPORTED_MODULE_12__.useIndexedChildren)(
        (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_13__.spacedChildren)({
          direction: spaceDirection,
          separator,
          space,
          children
        })
      );
      const onItemMount = react__WEBPACK_IMPORTED_MODULE_1___default().useCallback(
        () => setItemChildrenCount((prev) => prev + 1),
        []
      );
      const onItemUnmount = react__WEBPACK_IMPORTED_MODULE_1___default().useCallback(
        () => setItemChildrenCount((prev) => prev - 1),
        []
      );
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        GroupProvider,
        {
          disablePassBorderRadius,
          vertical: orientation === "vertical",
          radius,
          disabled: disabledProp,
          onItemMount,
          onItemUnmount,
          scope: __scopeGroup,
          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
            GroupFrame,
            {
              ref,
              size,
              flexDirection: orientation === "horizontal" ? "row" : "column",
              borderRadius,
              ...restProps,
              children: wrapScroll({ ...activeProps, orientation }, indexedChildren)
            }
          )
        }
      );
    }),
    {
      Item: GroupItem
    }
  );
}
const GroupItem = (props) => {
  var _a;
  const { __scopeGroup, children } = props;
  const groupItemProps = useGroupItem(
    { disabled: (0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(children) ? children.props.disabled : void 0 },
    __scopeGroup
  );
  if (!(0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(children)) {
    return children;
  }
  if ((0,_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.isTamaguiElement)(children)) {
    return react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(children, groupItemProps);
  }
  return react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(children, {
    style: {
      ...(_a = children.props) == null ? void 0 : _a["style"],
      ...groupItemProps
    }
  });
};
const useGroupItem = (childrenProps, __scopeGroup) => {
  const treeIndex = (0,reforest__WEBPACK_IMPORTED_MODULE_12__.useIndex)();
  const context = useGroupContext("GroupItem", __scopeGroup);
  react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(() => {
    context.onItemMount();
    return () => {
      context.onItemUnmount();
    };
  }, []);
  if (!treeIndex) {
    throw Error("<Group.Item/> should only be used within a <Group/>");
  }
  const isFirst = treeIndex.index === 0;
  const isLast = treeIndex.index === treeIndex.maxIndex;
  const disabled = childrenProps.disabled ?? context.disabled;
  let propsToPass = {
    disabled
  };
  if (context.disablePassBorderRadius !== true) {
    const borderRadius = getBorderRadius({
      radius: context.radius,
      isFirst,
      isLast,
      vertical: context.vertical,
      disable: context.disablePassBorderRadius
    });
    return { ...propsToPass, ...borderRadius };
  }
  return propsToPass;
};
const Group = createGroup(true);
const YGroup = Group;
const XGroup = createGroup(false);
const wrapScroll = ({ scrollable, orientation, showScrollIndicator = false }, children) => {
  if (scrollable)
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      react_native__WEBPACK_IMPORTED_MODULE_14__.ScrollView,
      {
        ...orientation === "vertical" && {
          showsVerticalScrollIndicator: showScrollIndicator
        },
        ...orientation === "horizontal" && {
          horizontal: true,
          showsHorizontalScrollIndicator: showScrollIndicator
        },
        children
      }
    );
  return children;
};
const getBorderRadius = ({
  isFirst,
  isLast,
  radius,
  vertical,
  disable
}) => {
  return {
    borderTopLeftRadius: isFirst && disable !== "top" && disable !== "start" ? radius : 0,
    borderTopRightRadius: disable !== "top" && disable !== "end" && (vertical && isFirst || !vertical && isLast) ? radius : 0,
    borderBottomLeftRadius: disable !== "bottom" && disable !== "start" && (vertical && isLast || !vertical && isFirst) ? radius : 0,
    borderBottomRightRadius: isLast && disable !== "bottom" && disable !== "end" ? radius : 0
  };
};
const cloneElementWithPropOrder = (child, props) => {
  const next = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_15__.mergeProps)(child.props, props, false, (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_10__.getConfig)().shorthands)[0];
  return react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement({ ...child, props: null }, next);
};

//# sourceMappingURL=Group.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/group/dist/esm/index.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/@tamagui/group/dist/esm/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Group": () => (/* reexport safe */ _Group__WEBPACK_IMPORTED_MODULE_0__.Group),
/* harmony export */   "GroupFrame": () => (/* reexport safe */ _Group__WEBPACK_IMPORTED_MODULE_0__.GroupFrame),
/* harmony export */   "XGroup": () => (/* reexport safe */ _Group__WEBPACK_IMPORTED_MODULE_0__.XGroup),
/* harmony export */   "YGroup": () => (/* reexport safe */ _Group__WEBPACK_IMPORTED_MODULE_0__.YGroup),
/* harmony export */   "useGroupItem": () => (/* reexport safe */ _Group__WEBPACK_IMPORTED_MODULE_0__.useGroupItem)
/* harmony export */ });
/* harmony import */ var _Group__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Group */ "../../node_modules/@tamagui/group/dist/esm/Group.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/getSpace.mjs":
/*!*************************************************************************!*\
  !*** ../../node_modules/@tamagui/helpers-tamagui/dist/esm/getSpace.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSpace": () => (/* binding */ getSpace)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/config.js");

const getSpace = (token, sizeUpOrDownBy = 0) => {
  const spaces = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.getTokens)().space;
  const spaceNames = Object.keys(spaces);
  const key = spaceNames[Math.max(0, spaceNames.indexOf(String(token || "$true")) + sizeUpOrDownBy)];
  return spaces[key] || spaces["$true"];
};

//# sourceMappingURL=getSpace.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/index.mjs":
/*!**********************************************************************!*\
  !*** ../../node_modules/@tamagui/helpers-tamagui/dist/esm/index.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSpace": () => (/* reexport safe */ _getSpace__WEBPACK_IMPORTED_MODULE_2__.getSpace),
/* harmony export */   "prevent": () => (/* reexport safe */ _prevent__WEBPACK_IMPORTED_MODULE_1__.prevent),
/* harmony export */   "useCurrentColor": () => (/* reexport safe */ _useCurrentColor__WEBPACK_IMPORTED_MODULE_3__.useCurrentColor),
/* harmony export */   "useGetThemedIcon": () => (/* reexport safe */ _useGetThemedIcon__WEBPACK_IMPORTED_MODULE_4__.useGetThemedIcon)
/* harmony export */ });
/* harmony import */ var _tamagui_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/helpers */ "../../node_modules/@tamagui/helpers/dist/esm/index.mjs");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _tamagui_helpers__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _tamagui_helpers__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _prevent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prevent */ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/prevent.mjs");
/* harmony import */ var _getSpace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getSpace */ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/getSpace.mjs");
/* harmony import */ var _useCurrentColor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useCurrentColor */ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/useCurrentColor.mjs");
/* harmony import */ var _useGetThemedIcon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useGetThemedIcon */ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/useGetThemedIcon.mjs");





//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/prevent.mjs":
/*!************************************************************************!*\
  !*** ../../node_modules/@tamagui/helpers-tamagui/dist/esm/prevent.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "prevent": () => (/* binding */ prevent)
/* harmony export */ });
const prevent = (e) => [e.preventDefault(), e.stopPropagation()];

//# sourceMappingURL=prevent.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/useCurrentColor.mjs":
/*!********************************************************************************!*\
  !*** ../../node_modules/@tamagui/helpers-tamagui/dist/esm/useCurrentColor.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useCurrentColor": () => (/* binding */ useCurrentColor)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useTheme.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");

const useCurrentColor = (colorProp) => {
  const theme = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.useTheme)();
  return (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.variableToString)(theme[colorProp] || colorProp || theme.color);
};

//# sourceMappingURL=useCurrentColor.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/useGetThemedIcon.mjs":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@tamagui/helpers-tamagui/dist/esm/useGetThemedIcon.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useGetThemedIcon": () => (/* binding */ useGetThemedIcon)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _useCurrentColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useCurrentColor */ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/useCurrentColor.mjs");


const useGetThemedIcon = (props) => {
  const color = (0,_useCurrentColor__WEBPACK_IMPORTED_MODULE_1__.useCurrentColor)(props.color);
  return (el) => {
    if (!el)
      return el;
    if ((0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(el)) {
      return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(el, {
        ...props,
        // @ts-expect-error
        ...el.props
      });
    }
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(el, props);
  };
};

//# sourceMappingURL=useGetThemedIcon.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/image/dist/esm/Image.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/@tamagui/image/dist/esm/Image.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Image": () => (/* binding */ Image)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/setupReactNative.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useMedia.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-native */ "../../node_modules/react-native-web/dist/index.js");




(0,_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.setupReactNative)({
  Image: react_native__WEBPACK_IMPORTED_MODULE_3__.Image
});
const StyledImage = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.styled)(react_native__WEBPACK_IMPORTED_MODULE_3__.Image, {
  name: "Image",
  position: "relative",
  source: { uri: "" },
  zIndex: 1
});
let hasWarned = false;
const Image = StyledImage.extractable(
  (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((inProps, ref) => {
    const props = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.useMediaPropsActive)(inProps);
    const { src, source, ...rest } = props;
    if (true) {
      if (typeof src === "string") {
        if (typeof props.width === "string" && props.width[0] !== "$" || typeof props.height === "string" && props.height[0] !== "$") {
          if (!hasWarned) {
            hasWarned = true;
            console.warn(
              `React Native expects a numerical width/height. If you want to use a percent you must define the "source" prop with width, height, and uri.`
            );
          }
        }
      }
    }
    const finalSource = typeof src === "string" ? { uri: src, ..._tamagui_core__WEBPACK_IMPORTED_MODULE_6__.isWeb && { width: props.width, height: props.height } } : source ?? src;
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StyledImage, { ref, source: finalSource, ...rest });
  })
);
Image.getSize = react_native__WEBPACK_IMPORTED_MODULE_3__.Image.getSize;
Image.getSizeWithHeaders = react_native__WEBPACK_IMPORTED_MODULE_3__.Image.getSizeWithHeaders;
Image.prefetch = react_native__WEBPACK_IMPORTED_MODULE_3__.Image.prefetch;
Image.prefetchWithMetadata = react_native__WEBPACK_IMPORTED_MODULE_3__.Image.prefetchWithMetadata;
Image.abortPrefetch = react_native__WEBPACK_IMPORTED_MODULE_3__.Image.abortPrefetch;
Image.queryCache = react_native__WEBPACK_IMPORTED_MODULE_3__.Image.queryCache;

//# sourceMappingURL=Image.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/image/dist/esm/index.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/@tamagui/image/dist/esm/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Image": () => (/* reexport safe */ _Image__WEBPACK_IMPORTED_MODULE_0__.Image)
/* harmony export */ });
/* harmony import */ var _Image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Image */ "../../node_modules/@tamagui/image/dist/esm/Image.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/label/dist/esm/Label.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/@tamagui/label/dist/esm/Label.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Label": () => (/* binding */ Label),
/* harmony export */   "LabelFrame": () => (/* binding */ LabelFrame),
/* harmony export */   "useLabelContext": () => (/* binding */ useLabelContext)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_focusable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/focusable */ "../../node_modules/@tamagui/focusable/dist/esm/registerFocusable.mjs");
/* harmony import */ var _tamagui_get_button_sized__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/get-button-sized */ "../../node_modules/@tamagui/get-button-sized/dist/esm/index.mjs");
/* harmony import */ var _tamagui_get_font_sized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/get-font-sized */ "../../node_modules/@tamagui/get-font-sized/dist/esm/index.mjs");
/* harmony import */ var _tamagui_text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/text */ "../../node_modules/@tamagui/text/dist/esm/SizableText.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/helpers/themeable.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);









const NAME = "Label";
const [LabelProvider, useLabelContextImpl] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_3__.createContext)(NAME, {
  id: void 0,
  controlRef: { current: null }
});
const LabelFrame = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_4__.styled)(_tamagui_text__WEBPACK_IMPORTED_MODULE_5__.SizableText, {
  name: "Label",
  tag: "label",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        color: "$color",
        backgroundColor: "transparent",
        display: "flex",
        alignItems: "center",
        userSelect: "none",
        cursor: "default",
        pressStyle: {
          color: "$colorPress"
        }
      }
    },
    size: {
      "...size": (val, extras) => {
        const buttonStyle = (0,_tamagui_get_button_sized__WEBPACK_IMPORTED_MODULE_6__.getButtonSized)(val, extras);
        return {
          ...(0,_tamagui_get_font_sized__WEBPACK_IMPORTED_MODULE_1__.getFontSized)(val, extras),
          height: buttonStyle.height,
          lineHeight: buttonStyle.height
        };
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const LabelComponent = react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(
  (props, forwardedRef) => {
    const { htmlFor, id: idProp, ...labelProps } = props;
    const controlRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);
    const ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);
    const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_7__.useComposedRefs)(forwardedRef, ref);
    const backupId = react__WEBPACK_IMPORTED_MODULE_2__.useId();
    const id = idProp ?? backupId;
    if (_tamagui_web__WEBPACK_IMPORTED_MODULE_8__.isWeb) {
      react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {
        if (htmlFor) {
          const element = document.getElementById(htmlFor);
          const label = ref.current;
          if (label && element) {
            const getAriaLabel = () => element.getAttribute("aria-labelledby");
            const ariaLabelledBy = [id, getAriaLabel()].filter(Boolean).join(" ");
            element.setAttribute("aria-labelledby", ariaLabelledBy);
            controlRef.current = element;
            return () => {
              var _a;
              if (!id)
                return;
              const ariaLabelledBy2 = (_a = getAriaLabel()) == null ? void 0 : _a.replace(id, "");
              if (ariaLabelledBy2 === "") {
                element.removeAttribute("aria-labelledby");
              } else if (ariaLabelledBy2) {
                element.setAttribute("aria-labelledby", ariaLabelledBy2);
              }
            };
          }
        }
      }, [id, htmlFor]);
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LabelProvider, { id, controlRef, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      LabelFrame,
      {
        role: "heading",
        id,
        htmlFor,
        ...labelProps,
        ref: composedRefs,
        onMouseDown: (event) => {
          var _a;
          (_a = props.onMouseDown) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented && event.detail > 1) {
            event.preventDefault();
          }
        },
        onPress: (event) => {
          var _a;
          (_a = props.onPress) == null ? void 0 : _a.call(props, event);
          if (_tamagui_web__WEBPACK_IMPORTED_MODULE_8__.isWeb) {
            if (htmlFor || !controlRef.current || event.defaultPrevented)
              return;
            const isClickingControl = controlRef.current.contains(
              event.target
            );
            const isUserClick = event.isTrusted === true;
            if (!isClickingControl && isUserClick) {
              controlRef.current.click();
              controlRef.current.focus();
            }
          } else {
            if (props.htmlFor) {
              (0,_tamagui_focusable__WEBPACK_IMPORTED_MODULE_9__.focusFocusable)(props.htmlFor);
            }
          }
        }
      }
    ) });
  }
);
LabelComponent.displayName = NAME;
const Label = LabelFrame.extractable((0,_tamagui_web__WEBPACK_IMPORTED_MODULE_10__.themeable)(LabelComponent), {
  neverFlatten: true
});
const useLabelContext = (element) => {
  const context = useLabelContextImpl("LabelConsumer");
  const { controlRef } = context;
  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {
    if (element)
      controlRef.current = element;
  }, [element, controlRef]);
  return context.id;
};
const Root = Label;

//# sourceMappingURL=Label.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/label/dist/esm/index.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/@tamagui/label/dist/esm/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Label": () => (/* reexport safe */ _Label__WEBPACK_IMPORTED_MODULE_0__.Label),
/* harmony export */   "LabelFrame": () => (/* reexport safe */ _Label__WEBPACK_IMPORTED_MODULE_0__.LabelFrame),
/* harmony export */   "useLabelContext": () => (/* reexport safe */ _Label__WEBPACK_IMPORTED_MODULE_0__.useLabelContext)
/* harmony export */ });
/* harmony import */ var _Label__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Label */ "../../node_modules/@tamagui/label/dist/esm/Label.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/list-item/dist/esm/ListItem.mjs":
/*!*******************************************************************!*\
  !*** ../../node_modules/@tamagui/list-item/dist/esm/ListItem.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ListItem": () => (/* binding */ ListItem),
/* harmony export */   "ListItemFrame": () => (/* binding */ ListItemFrame),
/* harmony export */   "ListItemSubtitle": () => (/* binding */ ListItemSubtitle),
/* harmony export */   "ListItemText": () => (/* binding */ ListItemText),
/* harmony export */   "ListItemTitle": () => (/* binding */ ListItemTitle),
/* harmony export */   "listItemStaticConfig": () => (/* binding */ listItemStaticConfig),
/* harmony export */   "useListItem": () => (/* binding */ useListItem)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useMedia.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/config.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createComponent.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/themeable.js");
/* harmony import */ var _tamagui_font_size__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/font-size */ "../../node_modules/@tamagui/font-size/dist/esm/getFontSize.mjs");
/* harmony import */ var _tamagui_helpers_tamagui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/helpers-tamagui */ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/index.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var _tamagui_text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/text */ "../../node_modules/@tamagui/text/dist/esm/SizableText.mjs");
/* harmony import */ var _tamagui_text__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/text */ "../../node_modules/@tamagui/text/dist/esm/wrapChildrenInText.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);







const NAME = "ListItem";
const ListItemFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__.ThemeableStack, {
  name: NAME,
  tag: "li",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        alignItems: "center",
        flexWrap: "nowrap",
        width: "100%",
        borderColor: "$borderColor",
        maxWidth: "100%",
        overflow: "hidden",
        flexDirection: "row",
        backgroundColor: "$background"
      }
    },
    size: {
      "...size": (val, { tokens }) => {
        return {
          minHeight: tokens.size[val],
          paddingHorizontal: tokens.space[val],
          paddingVertical: (0,_tamagui_helpers_tamagui__WEBPACK_IMPORTED_MODULE_1__.getSpace)(val, -2)
        };
      }
    },
    active: {
      true: {
        hoverStyle: {
          backgroundColor: "$background"
        }
      }
    },
    disabled: {
      true: {
        opacity: 0.5,
        // TODO breaking types
        pointerEvents: "none"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const ListItemText = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_text__WEBPACK_IMPORTED_MODULE_5__.SizableText, {
  name: "ListItemText",
  variants: {
    unstyled: {
      false: {
        color: "$color",
        flexGrow: 1,
        flexShrink: 1,
        ellipse: true,
        cursor: "default"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const ListItemSubtitle = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.styled)(ListItemText, {
  name: "ListItemSubtitle",
  variants: {
    unstyled: {
      false: {
        opacity: 0.6,
        maxWidth: "100%",
        size: "$3",
        color: "$color"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const ListItemTitle = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.styled)(ListItemText, {
  name: "ListItemTitle"
});
const useListItem = (props, {
  Text = ListItemText,
  Subtitle = ListItemSubtitle,
  Title = ListItemTitle
} = { Text: ListItemText, Subtitle: ListItemSubtitle, Title: ListItemTitle }) => {
  const {
    children,
    icon,
    iconAfter,
    noTextWrap,
    theme: themeName,
    space,
    spaceFlex,
    scaleIcon = 1,
    scaleSpace = 1,
    subTitle,
    // text props
    color,
    fontWeight,
    letterSpacing,
    fontSize,
    fontFamily,
    textAlign,
    textProps,
    title,
    ...rest
  } = props;
  const mediaActiveProps = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_6__.useMediaPropsActive)(props);
  const size = mediaActiveProps.size || "$true";
  const subtitleSize = `$${+String(size).replace("$", "") - 1}`;
  const iconSize = (0,_tamagui_font_size__WEBPACK_IMPORTED_MODULE_7__.getFontSize)(size) * scaleIcon;
  const getThemedIcon = (0,_tamagui_helpers_tamagui__WEBPACK_IMPORTED_MODULE_1__.useGetThemedIcon)({ size: iconSize, color });
  const [themedIcon, themedIconAfter] = [icon, iconAfter].map(getThemedIcon);
  const spaceSize = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.getVariableValue)((0,_tamagui_core__WEBPACK_IMPORTED_MODULE_9__.getTokens)().space[mediaActiveProps.space] ?? iconSize) * scaleSpace;
  const contents = (0,_tamagui_text__WEBPACK_IMPORTED_MODULE_10__.wrapChildrenInText)(Text, mediaActiveProps);
  return {
    props: {
      fontFamily,
      ...rest,
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [
        themedIcon ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [
          themedIcon,
          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.Spacer, { size: spaceSize })
        ] }) : null,
        title || subTitle ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_12__.YStack, { flex: 1, children: [
          noTextWrap === "all" ? title : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Title, { size, children: title }),
          subTitle ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: typeof subTitle === "string" && noTextWrap !== "all" ? (
            // TODO can use theme but we need to standardize to alt themes
            // or standardize on subtle colors in themes
            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Subtitle, { size: subtitleSize, children: subTitle })
          ) : subTitle }) : null,
          contents
        ] }) : contents,
        themedIconAfter ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [
          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.Spacer, { size: spaceSize }),
          themedIconAfter
        ] }) : null
      ] })
    }
  };
};
const ListItemComponent = (0,react__WEBPACK_IMPORTED_MODULE_2__.forwardRef)((props, ref) => {
  const { props: listItemProps } = useListItem(props);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ListItemFrame, { ref, justifyContent: "space-between", ...listItemProps });
});
const listItemStaticConfig = {
  inlineProps: /* @__PURE__ */ new Set([
    // text props go here (can't really optimize them, but we never fully extract listItem anyway)
    "color",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "letterSpacing",
    "textAlign"
  ])
};
const ListItem = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_13__.withStaticProperties)(
  ListItemFrame.extractable(
    (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_14__.themeable)(ListItemComponent, { componentName: NAME }),
    listItemStaticConfig
  ),
  {
    Text: ListItemText,
    Subtitle: ListItemSubtitle
  }
);

//# sourceMappingURL=ListItem.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/list-item/dist/esm/index.mjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@tamagui/list-item/dist/esm/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ListItem": () => (/* reexport safe */ _ListItem__WEBPACK_IMPORTED_MODULE_0__.ListItem),
/* harmony export */   "ListItemFrame": () => (/* reexport safe */ _ListItem__WEBPACK_IMPORTED_MODULE_0__.ListItemFrame),
/* harmony export */   "ListItemSubtitle": () => (/* reexport safe */ _ListItem__WEBPACK_IMPORTED_MODULE_0__.ListItemSubtitle),
/* harmony export */   "ListItemText": () => (/* reexport safe */ _ListItem__WEBPACK_IMPORTED_MODULE_0__.ListItemText),
/* harmony export */   "ListItemTitle": () => (/* reexport safe */ _ListItem__WEBPACK_IMPORTED_MODULE_0__.ListItemTitle),
/* harmony export */   "listItemStaticConfig": () => (/* reexport safe */ _ListItem__WEBPACK_IMPORTED_MODULE_0__.listItemStaticConfig),
/* harmony export */   "useListItem": () => (/* reexport safe */ _ListItem__WEBPACK_IMPORTED_MODULE_0__.useListItem)
/* harmony export */ });
/* harmony import */ var _ListItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ListItem */ "../../node_modules/@tamagui/list-item/dist/esm/ListItem.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/lucide-icons/dist/esm/themed.mjs":
/*!********************************************************************!*\
  !*** ../../node_modules/@tamagui/lucide-icons/dist/esm/themed.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "themed": () => (/* binding */ themed)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useMedia.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useTheme.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/config.js");


function themed(Component) {
  const wrapped = (propsIn) => {
    const props = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.useMediaPropsActive)(propsIn);
    const theme = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.useTheme)();
    const color = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.getVariable)(
      (props.color in theme ? theme[props.color] : void 0) || props.color || (!props.disableTheme ? theme.color : null) || "#000"
    );
    const size = typeof props.size === "string" ? (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.getVariableValue)((0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.getTokens)().size[props.size] || props.size) : props.size;
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Component, { ...props, color, size });
  };
  return wrapped;
}

//# sourceMappingURL=themed.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/popover/dist/esm/Popover.mjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@tamagui/popover/dist/esm/Popover.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Popover": () => (/* binding */ Popover),
/* harmony export */   "PopoverAnchor": () => (/* binding */ PopoverAnchor),
/* harmony export */   "PopoverArrow": () => (/* binding */ PopoverArrow),
/* harmony export */   "PopoverClose": () => (/* binding */ PopoverClose),
/* harmony export */   "PopoverContent": () => (/* binding */ PopoverContent),
/* harmony export */   "PopoverTrigger": () => (/* binding */ PopoverTrigger),
/* harmony export */   "__PopoverProviderInternal": () => (/* binding */ __PopoverProviderInternal),
/* harmony export */   "createPopoverScope": () => (/* binding */ createPopoverScope),
/* harmony export */   "usePopoverScope": () => (/* binding */ usePopoverScope)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_polyfill_dev__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/polyfill-dev */ "../../node_modules/@tamagui/polyfill-dev/index.js");
/* harmony import */ var _tamagui_polyfill_dev__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tamagui_polyfill_dev__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _tamagui_adapt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/adapt */ "../../node_modules/@tamagui/adapt/dist/esm/index.mjs");
/* harmony import */ var _tamagui_animate_presence__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @tamagui/animate-presence */ "../../node_modules/@tamagui/animate-presence/dist/esm/AnimatePresence.mjs");
/* harmony import */ var _tamagui_aria_hidden__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tamagui/aria-hidden */ "../../node_modules/aria-hidden/dist/es2015/index.js");
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useThemeName.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/views/Theme.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/core/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/use-event/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useMedia.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_floating__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/floating */ "../../node_modules/@tamagui/floating/dist/esm/index.mjs");
/* harmony import */ var _tamagui_focus_scope__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/focus-scope */ "../../node_modules/@tamagui/focus-scope/dist/esm/index.mjs");
/* harmony import */ var _tamagui_popper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/popper */ "../../node_modules/@tamagui/popper/dist/esm/Popper.mjs");
/* harmony import */ var _tamagui_portal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/portal */ "../../node_modules/@tamagui/portal/dist/esm/index.mjs");
/* harmony import */ var _tamagui_remove_scroll__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/remove-scroll */ "../../node_modules/@tamagui/remove-scroll/dist/esm/index.mjs");
/* harmony import */ var _tamagui_sheet__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @tamagui/sheet */ "../../node_modules/@tamagui/sheet/dist/esm/Sheet.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! react-native */ "../../node_modules/react-native-web/dist/index.js");
/* harmony import */ var _useFloatingContext__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./useFloatingContext */ "../../node_modules/@tamagui/popover/dist/esm/useFloatingContext.mjs");



















const POPOVER_NAME = "Popover";
const [createPopoverContext, createPopoverScopeInternal] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_8__.createContextScope)(
  POPOVER_NAME,
  [_tamagui_popper__WEBPACK_IMPORTED_MODULE_9__.createPopperScope]
);
const usePopoverScope = (0,_tamagui_popper__WEBPACK_IMPORTED_MODULE_9__.createPopperScope)();
const createPopoverScope = createPopoverScopeInternal;
const [PopoverProviderInternal, usePopoverInternalContext] = createPopoverContext(POPOVER_NAME);
const __PopoverProviderInternal = PopoverProviderInternal;
const ANCHOR_NAME = "PopoverAnchor";
const PopoverAnchor = react__WEBPACK_IMPORTED_MODULE_7__.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverInternalContext(ANCHOR_NAME, __scopePopover);
    const popperScope = usePopoverScope(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    react__WEBPACK_IMPORTED_MODULE_7__.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_popper__WEBPACK_IMPORTED_MODULE_9__.PopperAnchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME;
const TRIGGER_NAME = "PopoverTrigger";
const PopoverTrigger = react__WEBPACK_IMPORTED_MODULE_7__.forwardRef((props, forwardedRef) => {
  const { __scopePopover, ...triggerProps } = props;
  const context = usePopoverInternalContext(TRIGGER_NAME, __scopePopover);
  const popperScope = usePopoverScope(__scopePopover);
  const composedTriggerRef = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_10__.useComposedRefs)(forwardedRef, context.triggerRef);
  const trigger = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    _tamagui_stacks__WEBPACK_IMPORTED_MODULE_11__.YStack,
    {
      "aria-haspopup": "dialog",
      "aria-expanded": context.open,
      "data-state": getState(context.open),
      ...triggerProps,
      ref: composedTriggerRef,
      onPress: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.composeEventHandlers)(props.onPress, context.onOpenToggle)
    }
  );
  return context.hasCustomAnchor ? trigger : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_popper__WEBPACK_IMPORTED_MODULE_9__.PopperAnchor, { asChild: true, ...popperScope, children: trigger });
});
PopoverTrigger.displayName = TRIGGER_NAME;
const CONTENT_NAME = "PopoverContent";
const PopoverContent = _tamagui_popper__WEBPACK_IMPORTED_MODULE_9__.PopperContentFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_7__.forwardRef(
    function PopoverContent2(props, forwardedRef) {
      const {
        allowPinchZoom,
        trapFocus,
        disableRemoveScroll = true,
        zIndex,
        ...contentImplProps
      } = props;
      const context = usePopoverInternalContext(CONTENT_NAME, props.__scopePopover);
      const contentRef = react__WEBPACK_IMPORTED_MODULE_7__.useRef(null);
      const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_10__.useComposedRefs)(forwardedRef, contentRef);
      const isRightClickOutsideRef = react__WEBPACK_IMPORTED_MODULE_7__.useRef(false);
      react__WEBPACK_IMPORTED_MODULE_7__.useEffect(() => {
        if (!context.open)
          return;
        const content = contentRef.current;
        if (content)
          return (0,_tamagui_aria_hidden__WEBPACK_IMPORTED_MODULE_13__.hideOthers)(content);
      }, [context.open]);
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PopoverContentPortal, { zIndex, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        PopoverContentImpl,
        {
          ...contentImplProps,
          disableRemoveScroll,
          ref: composedRefs,
          trapFocus: trapFocus ?? context.open,
          disableOutsidePointerEvents: true,
          onCloseAutoFocus: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.composeEventHandlers)(props.onCloseAutoFocus, (event) => {
            var _a;
            event.preventDefault();
            if (!isRightClickOutsideRef.current)
              (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
          }),
          onPointerDownOutside: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.composeEventHandlers)(
            props.onPointerDownOutside,
            (event) => {
              const originalEvent = event.detail.originalEvent;
              const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
              const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
              isRightClickOutsideRef.current = isRightClick;
            },
            { checkDefaultPrevented: false }
          ),
          onFocusOutside: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.composeEventHandlers)(
            props.onFocusOutside,
            (event) => event.preventDefault(),
            { checkDefaultPrevented: false }
          )
        }
      ) });
    }
  )
);
function PopoverContentPortal(props) {
  const themeName = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_14__.useThemeName)();
  const context = usePopoverInternalContext(CONTENT_NAME, props.__scopePopover);
  let contents = props.children;
  if (react_native__WEBPACK_IMPORTED_MODULE_15__.Platform.OS === "android") {
    const popperContext = (0,_tamagui_popper__WEBPACK_IMPORTED_MODULE_9__.usePopperContext)(CONTENT_NAME, context.popperScope);
    contents = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_popper__WEBPACK_IMPORTED_MODULE_9__.PopperProvider, { ...popperContext, scope: context.popperScope, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PopoverProviderInternal, { scope: props.__scopePopover, ...context, children: props.children }) });
  }
  const zIndex = props.zIndex ?? 1e3;
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_portal__WEBPACK_IMPORTED_MODULE_5__.Portal, { zIndex, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_tamagui_core__WEBPACK_IMPORTED_MODULE_16__.Theme, { forceClassName: true, name: themeName, children: [
    !!context.open && !context.breakpointActive && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _tamagui_stacks__WEBPACK_IMPORTED_MODULE_11__.YStack,
      {
        fullscreen: true,
        onPress: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.composeEventHandlers)(props.onPress, context.onOpenToggle)
      }
    ),
    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_core__WEBPACK_IMPORTED_MODULE_17__.Stack, { zIndex: zIndex + 1, children: contents })
  ] }) });
}
const PopoverContentImpl = react__WEBPACK_IMPORTED_MODULE_7__.forwardRef((props, forwardedRef) => {
  const {
    __scopePopover,
    trapFocus,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    children,
    disableRemoveScroll,
    ...contentProps
  } = props;
  const popperScope = usePopoverScope(__scopePopover);
  const context = usePopoverInternalContext(CONTENT_NAME, popperScope.__scopePopover);
  if (context.breakpointActive) {
    const childrenWithoutScrollView = react__WEBPACK_IMPORTED_MODULE_7__.Children.toArray(children).map((child) => {
      if (react__WEBPACK_IMPORTED_MODULE_7__.isValidElement(child)) {
        if (child.type === PopoverScrollView) {
          return child.props.children;
        }
      }
      return child;
    });
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_portal__WEBPACK_IMPORTED_MODULE_5__.PortalItem, { hostName: `${context.scopeKey}PopoverContents`, children: childrenWithoutScrollView });
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_animate_presence__WEBPACK_IMPORTED_MODULE_18__.AnimatePresence, { children: !!context.open && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    _tamagui_popper__WEBPACK_IMPORTED_MODULE_9__.PopperContent,
    {
      "data-state": getState(context.open),
      id: context.contentId,
      pointerEvents: "auto",
      ref: forwardedRef,
      ...popperScope,
      ...contentProps,
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        _tamagui_remove_scroll__WEBPACK_IMPORTED_MODULE_6__.RemoveScroll,
        {
          enabled: disableRemoveScroll ? false : context.open,
          allowPinchZoom: true,
          removeScrollBar: false,
          style: {
            display: "contents"
          },
          children: trapFocus === false ? children : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
            _tamagui_focus_scope__WEBPACK_IMPORTED_MODULE_4__.FocusScope,
            {
              loop: true,
              trapped: trapFocus ?? context.open,
              onMountAutoFocus: onOpenAutoFocus,
              onUnmountAutoFocus: onCloseAutoFocus,
              children: _tamagui_core__WEBPACK_IMPORTED_MODULE_19__.isWeb ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { style: { display: "contents" }, children }) : children
            }
          )
        }
      )
    },
    context.contentId
  ) });
});
const CLOSE_NAME = "PopoverClose";
const PopoverClose = react__WEBPACK_IMPORTED_MODULE_7__.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverInternalContext(CLOSE_NAME, __scopePopover);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _tamagui_stacks__WEBPACK_IMPORTED_MODULE_11__.YStack,
      {
        ...closeProps,
        ref: forwardedRef,
        onPress: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.composeEventHandlers)(
          props.onPress,
          () => context.onOpenChange(false)
        )
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME;
const ARROW_NAME = "PopoverArrow";
const PopoverArrow = react__WEBPACK_IMPORTED_MODULE_7__.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopoverScope(__scopePopover);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_popper__WEBPACK_IMPORTED_MODULE_9__.PopperArrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME;
const PopoverScrollView = react__WEBPACK_IMPORTED_MODULE_7__.forwardRef((props, ref) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_native__WEBPACK_IMPORTED_MODULE_15__.ScrollView, { ref, ...props });
});
const Popover = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_20__.withStaticProperties)(
  function Popover2(props) {
    const {
      __scopePopover,
      children,
      open: openProp,
      defaultOpen,
      onOpenChange,
      ...restProps
    } = props;
    const internalId = react__WEBPACK_IMPORTED_MODULE_7__.useId();
    const id = __scopePopover ? Object.keys(__scopePopover)[0] : internalId;
    const { when, AdaptProvider } = (0,_tamagui_adapt__WEBPACK_IMPORTED_MODULE_2__.useAdaptParent)({
      Contents: react__WEBPACK_IMPORTED_MODULE_7__.useCallback(() => {
        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_portal__WEBPACK_IMPORTED_MODULE_5__.PortalHost, { name: `${id}PopoverContents` });
      }, [])
    });
    const sheetBreakpoint = when;
    const popperScope = usePopoverScope(__scopePopover);
    const triggerRef = react__WEBPACK_IMPORTED_MODULE_7__.useRef(null);
    const [hasCustomAnchor, setHasCustomAnchor] = react__WEBPACK_IMPORTED_MODULE_7__.useState(false);
    const [open, setOpen] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_21__.useControllableState)({
      prop: openProp,
      defaultProp: defaultOpen || false,
      onChange: onOpenChange,
      transition: true
    });
    const breakpointActive = useSheetBreakpointActive(sheetBreakpoint);
    const floatingContext = (0,_useFloatingContext__WEBPACK_IMPORTED_MODULE_22__.useFloatingContext)({ open, setOpen, breakpointActive });
    const popoverContext = {
      scope: __scopePopover,
      scopeKey: id,
      popperScope: popperScope.__scopePopper,
      sheetBreakpoint,
      contentId: react__WEBPACK_IMPORTED_MODULE_7__.useId(),
      triggerRef,
      open,
      breakpointActive,
      onOpenChange: setOpen,
      onOpenToggle: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_23__.useEvent)(() => {
        if (open && breakpointActive) {
          return;
        }
        setOpen(!open);
      }),
      hasCustomAnchor,
      onCustomAnchorAdd: react__WEBPACK_IMPORTED_MODULE_7__.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: react__WEBPACK_IMPORTED_MODULE_7__.useCallback(() => setHasCustomAnchor(false), [])
    };
    const contents = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_popper__WEBPACK_IMPORTED_MODULE_9__.Popper, { ...popperScope, stayInFrame: true, ...restProps, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PopoverProviderInternal, { ...popoverContext, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PopoverSheetController, { onOpenChange: setOpen, __scopePopover, children }) }) });
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AdaptProvider, { children: _tamagui_core__WEBPACK_IMPORTED_MODULE_19__.isWeb ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_floating__WEBPACK_IMPORTED_MODULE_3__.FloatingOverrideContext.Provider, { value: floatingContext, children: contents }) : contents });
  },
  {
    Anchor: PopoverAnchor,
    Arrow: PopoverArrow,
    Trigger: PopoverTrigger,
    Content: PopoverContent,
    Close: PopoverClose,
    Adapt: _tamagui_adapt__WEBPACK_IMPORTED_MODULE_2__.Adapt,
    ScrollView: PopoverScrollView,
    Sheet: _tamagui_sheet__WEBPACK_IMPORTED_MODULE_24__.ControlledSheet
  }
);
function getState(open) {
  return open ? "open" : "closed";
}
const PopoverSheetController = (props) => {
  const context = usePopoverInternalContext(
    "PopoverSheetController",
    props.__scopePopover
  );
  const showSheet = useShowPopoverSheet(context);
  const breakpointActive = context.breakpointActive;
  const getShowSheet = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_23__.useGet)(showSheet);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    _tamagui_sheet__WEBPACK_IMPORTED_MODULE_24__.SheetController,
    {
      onOpenChange: (val) => {
        if (getShowSheet()) {
          props.onOpenChange(val);
        }
      },
      open: context.open,
      hidden: breakpointActive === false,
      children: props.children
    }
  );
};
const useSheetBreakpointActive = (breakpoint) => {
  const media = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_25__.useMedia)();
  if (typeof breakpoint === "boolean" || !breakpoint) {
    return !!breakpoint;
  }
  return media[breakpoint];
};
const useShowPopoverSheet = (context) => {
  const breakpointActive = useSheetBreakpointActive(context.sheetBreakpoint);
  return context.open === false ? false : breakpointActive;
};

//# sourceMappingURL=Popover.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/popover/dist/esm/index.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/popover/dist/esm/index.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Popover": () => (/* reexport safe */ _Popover__WEBPACK_IMPORTED_MODULE_0__.Popover),
/* harmony export */   "PopoverAnchor": () => (/* reexport safe */ _Popover__WEBPACK_IMPORTED_MODULE_0__.PopoverAnchor),
/* harmony export */   "PopoverArrow": () => (/* reexport safe */ _Popover__WEBPACK_IMPORTED_MODULE_0__.PopoverArrow),
/* harmony export */   "PopoverClose": () => (/* reexport safe */ _Popover__WEBPACK_IMPORTED_MODULE_0__.PopoverClose),
/* harmony export */   "PopoverContent": () => (/* reexport safe */ _Popover__WEBPACK_IMPORTED_MODULE_0__.PopoverContent),
/* harmony export */   "PopoverTrigger": () => (/* reexport safe */ _Popover__WEBPACK_IMPORTED_MODULE_0__.PopoverTrigger),
/* harmony export */   "__PopoverProviderInternal": () => (/* reexport safe */ _Popover__WEBPACK_IMPORTED_MODULE_0__.__PopoverProviderInternal),
/* harmony export */   "createPopoverScope": () => (/* reexport safe */ _Popover__WEBPACK_IMPORTED_MODULE_0__.createPopoverScope),
/* harmony export */   "useFloatingContext": () => (/* reexport safe */ _useFloatingContext__WEBPACK_IMPORTED_MODULE_1__.useFloatingContext),
/* harmony export */   "usePopoverScope": () => (/* reexport safe */ _Popover__WEBPACK_IMPORTED_MODULE_0__.usePopoverScope)
/* harmony export */ });
/* harmony import */ var _Popover__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Popover */ "../../node_modules/@tamagui/popover/dist/esm/Popover.mjs");
/* harmony import */ var _useFloatingContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useFloatingContext */ "../../node_modules/@tamagui/popover/dist/esm/useFloatingContext.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/popover/dist/esm/useFloatingContext.mjs":
/*!***************************************************************************!*\
  !*** ../../node_modules/@tamagui/popover/dist/esm/useFloatingContext.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useFloatingContext": () => (/* binding */ useFloatingContext)
/* harmony export */ });
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/react */ "../../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


const useFloatingContext = ({ open, setOpen, breakpointActive }) => (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
  (props) => {
    const floating = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_1__.useFloating)({
      ...props,
      open,
      onOpenChange: setOpen
    });
    const { getReferenceProps, getFloatingProps } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_1__.useInteractions)([
      // useFocus(floating.context, {
      //   enabled: !breakpointActive,
      //   keyboardOnly: true,
      // }),
      (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_1__.useRole)(floating.context, { role: "dialog" }),
      (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_1__.useDismiss)(floating.context, {
        enabled: !breakpointActive
      })
    ]);
    return {
      ...floating,
      getReferenceProps,
      getFloatingProps
    };
  },
  [open, setOpen, breakpointActive]
);

//# sourceMappingURL=useFloatingContext.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/popper/dist/esm/Popper.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/popper/dist/esm/Popper.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Popper": () => (/* binding */ Popper),
/* harmony export */   "PopperAnchor": () => (/* binding */ PopperAnchor),
/* harmony export */   "PopperArrow": () => (/* binding */ PopperArrow),
/* harmony export */   "PopperContent": () => (/* binding */ PopperContent),
/* harmony export */   "PopperContentFrame": () => (/* binding */ PopperContentFrame),
/* harmony export */   "PopperProvider": () => (/* binding */ PopperProvider),
/* harmony export */   "createPopperScope": () => (/* binding */ createPopperScope),
/* harmony export */   "usePopperContext": () => (/* binding */ usePopperContext)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_floating__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/floating */ "../../node_modules/@tamagui/floating/dist/esm/index.mjs");
/* harmony import */ var _tamagui_get_size__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/get-size */ "../../node_modules/@tamagui/get-size/dist/esm/index.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-native */ "../../node_modules/react-native-web/dist/index.js");









const POPPER_NAME = "Popper";
const [createPopperContext, createScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_3__.createContextScope)(POPPER_NAME);
const createPopperScope = createScope;
const [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
function Popper(props) {
  const {
    __scopePopper,
    children,
    size,
    strategy = "absolute",
    placement = "bottom",
    stayInFrame,
    allowFlip
  } = props;
  const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);
  (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.useIsomorphicLayoutEffect)(() => {
    setIsMounted(true);
  }, []);
  const anchorRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef();
  const [arrowEl, setArrow] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);
  const [arrowSize, setArrowSize] = react__WEBPACK_IMPORTED_MODULE_2__.useState(0);
  const arrowRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef();
  const floating = (0,_tamagui_floating__WEBPACK_IMPORTED_MODULE_1__.useFloating)({
    strategy,
    placement,
    sameScrollView: false,
    // this only takes effect on native
    middleware: [
      stayInFrame ? (0,_tamagui_floating__WEBPACK_IMPORTED_MODULE_1__.shift)(typeof stayInFrame === "boolean" ? {} : stayInFrame) : null,
      allowFlip ? (0,_tamagui_floating__WEBPACK_IMPORTED_MODULE_1__.flip)(typeof allowFlip === "boolean" ? {} : allowFlip) : null,
      arrowEl ? (0,_tamagui_floating__WEBPACK_IMPORTED_MODULE_1__.arrow)({ element: arrowEl }) : null,
      arrowSize ? (0,_tamagui_floating__WEBPACK_IMPORTED_MODULE_1__.offset)(arrowSize) : null
    ].filter(Boolean)
  });
  const { refs, middlewareData } = floating;
  const composedArrowRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_5__.useComposedRefs)(arrowRef, setArrow);
  (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.useIsomorphicLayoutEffect)(() => {
    floating.reference(anchorRef.current);
  }, [anchorRef]);
  if (_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.isWeb) {
    react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {
      if (!(refs.reference.current && refs.floating.current)) {
        return;
      }
      return (0,_tamagui_floating__WEBPACK_IMPORTED_MODULE_1__.autoUpdate)(refs.reference.current, refs.floating.current, floating.update);
    }, [floating.update, refs.floating, refs.reference]);
  } else {
    const dimensions = (0,react_native__WEBPACK_IMPORTED_MODULE_6__.useWindowDimensions)();
    const [keyboardOpen, setKeyboardOpen] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);
    react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {
      const showSubscription = react_native__WEBPACK_IMPORTED_MODULE_6__.Keyboard.addListener("keyboardDidShow", () => {
        setKeyboardOpen(true);
      });
      const hideSubscription = react_native__WEBPACK_IMPORTED_MODULE_6__.Keyboard.addListener("keyboardDidHide", () => {
        setKeyboardOpen(false);
      });
      return () => {
        showSubscription.remove();
        hideSubscription.remove();
      };
    }, []);
    (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.useIsomorphicLayoutEffect)(() => {
      floating.update();
    }, [dimensions, keyboardOpen]);
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    PopperProvider,
    {
      scope: __scopePopper,
      anchorRef,
      size,
      arrowRef: composedArrowRefs,
      arrowStyle: middlewareData.arrow,
      onArrowSize: setArrowSize,
      isMounted,
      ...floating,
      children
    }
  );
}
const ANCHOR_NAME = "PopperAnchor";
const PopperAnchor = _tamagui_stacks__WEBPACK_IMPORTED_MODULE_7__.YStack.extractable(
  react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function PopperAnchor2(props, forwardedRef) {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const { anchorRef, getReferenceProps } = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);
    const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_5__.useComposedRefs)(forwardedRef, ref, anchorRef);
    if (virtualRef) {
      return null;
    }
    const stackProps = {
      ref: composedRefs,
      ...anchorProps
    };
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_7__.YStack, { ...getReferenceProps ? getReferenceProps(stackProps) : stackProps });
  })
);
const CONTENT_NAME = "PopperContent";
const PopperContentFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_9__.ThemeableStack, {
  name: "PopperContent",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        backgroundColor: "$background",
        alignItems: "center",
        radiused: true
      }
    },
    size: {
      "...size": (val, { tokens }) => {
        return {
          padding: tokens.space[val],
          borderRadius: tokens.radius[val]
        };
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const PopperContent = react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(
  function PopperContent2(props, forwardedRef) {
    const { __scopePopper, ...contentProps } = props;
    const { strategy, placement, floating, x, y, getFloatingProps, size, isMounted } = usePopperContext(CONTENT_NAME, __scopePopper);
    const contentRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_5__.useComposedRefs)(floating, forwardedRef);
    const contents = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => {
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        PopperContentFrame,
        {
          "data-placement": placement,
          "data-strategy": strategy,
          size: contentProps.size || size,
          ...contentProps
        },
        "popper-content-frame"
      );
    }, [placement, strategy, props]);
    if (!isMounted) {
      return null;
    }
    const frameProps = {
      ref: contentRefs,
      x: x || 0,
      y: y || 0,
      position: strategy
    };
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _tamagui_stacks__WEBPACK_IMPORTED_MODULE_7__.YStack,
      {
        animateOnly: ["transform"],
        ...getFloatingProps ? getFloatingProps(frameProps) : frameProps,
        children: contents
      }
    );
  }
);
const ARROW_NAME = "PopperArrow";
const PopperArrowFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_7__.YStack, {
  name: "PopperArrow",
  variants: {
    unstyled: {
      false: {
        borderColor: "$borderColor",
        backgroundColor: "$background",
        position: "relative"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const PopperArrowOuterFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_7__.YStack, {
  name: "PopperArrowOuter",
  variants: {
    unstyled: {
      false: {
        position: "absolute",
        zIndex: -1,
        pointerEvents: "none",
        overflow: "hidden",
        alignItems: "center",
        justifyContent: "center"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const opposites = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
const PopperArrow = PopperArrowFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function PopperArrow2(props, forwardedRef) {
    var _a, _b;
    const {
      __scopePopper,
      offset: offset2,
      size: sizeProp,
      borderWidth = 0,
      ...arrowProps
    } = props;
    const context = usePopperContext(ARROW_NAME, __scopePopper);
    const sizeVal = sizeProp ?? context.size;
    const sizeValResolved = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_10__.getVariableValue)((0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_11__.stepTokenUpOrDown)("space", sizeVal, -2, [2]));
    const size = +sizeValResolved;
    const { placement } = context;
    const refs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_5__.useComposedRefs)(context.arrowRef, forwardedRef);
    const x = ((_a = context.arrowStyle) == null ? void 0 : _a.x) || 0;
    const y = ((_b = context.arrowStyle) == null ? void 0 : _b.y) || 0;
    const primaryPlacement = placement ? placement.split("-")[0] : "top";
    const arrowStyle = { x, y, width: size, height: size };
    const innerArrowStyle = {};
    const isVertical = primaryPlacement === "bottom" || primaryPlacement === "top";
    if (primaryPlacement) {
      arrowStyle[isVertical ? "width" : "height"] = size * 2;
      const oppSide = opposites[primaryPlacement];
      if (oppSide) {
        arrowStyle[oppSide] = -size;
        innerArrowStyle[oppSide] = size / 2;
      }
      if (oppSide === "top" || oppSide === "bottom") {
        arrowStyle.left = 0;
      }
      if (oppSide === "left" || oppSide === "right") {
        arrowStyle.top = 0;
      }
    }
    (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.useIsomorphicLayoutEffect)(() => {
      var _a2;
      (_a2 = context.onArrowSize) == null ? void 0 : _a2.call(context, size);
    }, [size, context.onArrowSize]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PopperArrowOuterFrame, { ref: refs, ...arrowStyle, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      PopperArrowFrame,
      {
        width: size,
        height: size,
        ...arrowProps,
        ...innerArrowStyle,
        rotate: "45deg",
        ...primaryPlacement === "bottom" && {
          borderBottomWidth: borderWidth,
          borderRightWidth: borderWidth
        },
        ...primaryPlacement === "top" && {
          borderTopWidth: borderWidth,
          borderLeftWidth: borderWidth
        },
        ...primaryPlacement === "right" && {
          borderTopWidth: borderWidth,
          borderRightWidth: borderWidth
        },
        ...primaryPlacement === "left" && {
          borderBottomWidth: borderWidth,
          borderLeftWidth: borderWidth
        }
      }
    ) });
  })
);

//# sourceMappingURL=Popper.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/popper/dist/esm/index.mjs":
/*!*************************************************************!*\
  !*** ../../node_modules/@tamagui/popper/dist/esm/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Popper": () => (/* reexport safe */ _Popper__WEBPACK_IMPORTED_MODULE_0__.Popper),
/* harmony export */   "PopperAnchor": () => (/* reexport safe */ _Popper__WEBPACK_IMPORTED_MODULE_0__.PopperAnchor),
/* harmony export */   "PopperArrow": () => (/* reexport safe */ _Popper__WEBPACK_IMPORTED_MODULE_0__.PopperArrow),
/* harmony export */   "PopperContent": () => (/* reexport safe */ _Popper__WEBPACK_IMPORTED_MODULE_0__.PopperContent),
/* harmony export */   "PopperContentFrame": () => (/* reexport safe */ _Popper__WEBPACK_IMPORTED_MODULE_0__.PopperContentFrame),
/* harmony export */   "PopperProvider": () => (/* reexport safe */ _Popper__WEBPACK_IMPORTED_MODULE_0__.PopperProvider),
/* harmony export */   "createPopperScope": () => (/* reexport safe */ _Popper__WEBPACK_IMPORTED_MODULE_0__.createPopperScope),
/* harmony export */   "usePopperContext": () => (/* reexport safe */ _Popper__WEBPACK_IMPORTED_MODULE_0__.usePopperContext)
/* harmony export */ });
/* harmony import */ var _Popper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Popper */ "../../node_modules/@tamagui/popper/dist/esm/Popper.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/progress/dist/esm/Progress.mjs":
/*!******************************************************************!*\
  !*** ../../node_modules/@tamagui/progress/dist/esm/Progress.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Progress": () => (/* binding */ Progress),
/* harmony export */   "ProgressFrame": () => (/* binding */ ProgressFrame),
/* harmony export */   "ProgressIndicator": () => (/* binding */ ProgressIndicator),
/* harmony export */   "ProgressIndicatorFrame": () => (/* binding */ ProgressIndicatorFrame),
/* harmony export */   "createProgressScope": () => (/* binding */ createProgressScope)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_get_size__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/get-size */ "../../node_modules/@tamagui/get-size/dist/esm/index.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);






const PROGRESS_NAME = "Progress";
const [createProgressContext, createProgressScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_2__.createContextScope)(PROGRESS_NAME);
const [ProgressProvider, useProgressContext] = createProgressContext(PROGRESS_NAME);
const INDICATOR_NAME = "ProgressIndicator";
const ProgressIndicatorFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__.ThemeableStack, {
  name: INDICATOR_NAME,
  height: "100%",
  width: "100%",
  backgrounded: true
});
const ProgressIndicator = ProgressIndicatorFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
    (props, forwardedRef) => {
      const { __scopeProgress, ...indicatorProps } = props;
      const context = useProgressContext(INDICATOR_NAME, __scopeProgress);
      const pct = context.max - (context.value ?? 0);
      const x = -context.width * (pct / 100);
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        ProgressIndicatorFrame,
        {
          "data-state": getProgressState(context.value, context.max),
          "data-value": context.value ?? void 0,
          "data-max": context.max,
          x,
          width: context.width,
          ...indicatorProps,
          ref: forwardedRef
        }
      );
    }
  )
);
ProgressIndicator.displayName = INDICATOR_NAME;
function defaultGetValueLabel(value, max) {
  return `${Math.round(value / max * 100)}%`;
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function isNumber(value) {
  return typeof value === "number";
}
function isValidMaxNumber(max) {
  return isNumber(max) && !isNaN(max) && max > 0;
}
function isValidValueNumber(value, max) {
  return isNumber(value) && !isNaN(value) && value <= max && value >= 0;
}
function getInvalidMaxError(propValue, componentName) {
  return `Invalid prop \`max\` of value \`${propValue}\` supplied to \`${componentName}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${DEFAULT_MAX}\`.`;
}
function getInvalidValueError(propValue, componentName) {
  return `Invalid prop \`value\` of value \`${propValue}\` supplied to \`${componentName}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\` if the progress is indeterminate.

Defaulting to \`null\`.`;
}
const DEFAULT_MAX = 100;
const ProgressFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__.ThemeableStack, {
  name: PROGRESS_NAME,
  borderRadius: 1e5,
  overflow: "hidden",
  backgrounded: true,
  variants: {
    size: {
      "...size": (val) => {
        const size = Math.round((0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.getVariableValue)((0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_6__.getSize)(val)) * 0.25);
        return {
          height: size,
          minWidth: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.getVariableValue)(size) * 20,
          width: "100%"
        };
      }
    }
  }
});
const Progress = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.withStaticProperties)(
  ProgressFrame.extractable(
    react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
      (props, forwardedRef) => {
        const {
          __scopeProgress,
          value: valueProp,
          max: maxProp,
          getValueLabel = defaultGetValueLabel,
          size = "$true",
          ...progressProps
        } = props;
        const max = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX;
        const value = isValidValueNumber(valueProp, max) ? valueProp : null;
        const valueLabel = isNumber(value) ? getValueLabel(value, max) : void 0;
        const [width, setWidth] = react__WEBPACK_IMPORTED_MODULE_1__.useState(0);
        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ProgressProvider, { scope: __scopeProgress, value, max, width, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          ProgressFrame,
          {
            size,
            "aria-valuemax": max,
            "aria-valuemin": 0,
            "aria-valuenow": isNumber(value) ? value : void 0,
            "aria-valuetext": valueLabel,
            role: "progressbar",
            "data-state": getProgressState(value, max),
            "data-value": value ?? void 0,
            "data-max": max,
            ...progressProps,
            onLayout: (e) => {
              var _a;
              setWidth(e.nativeEvent.layout.width);
              (_a = progressProps.onLayout) == null ? void 0 : _a.call(progressProps, e);
            },
            ref: forwardedRef
          }
        ) });
      }
    )
  ),
  {
    Indicator: ProgressIndicator
  }
);
Progress.displayName = PROGRESS_NAME;
Progress.propTypes = {
  max(props, propName, componentName) {
    const propValue = props[propName];
    const strVal = String(propValue);
    if (propValue && !isValidMaxNumber(propValue)) {
      return new Error(getInvalidMaxError(strVal, componentName));
    }
    return null;
  },
  value(props, propName, componentName) {
    const valueProp = props[propName];
    const strVal = String(valueProp);
    const max = isValidMaxNumber(props.max) ? props.max : DEFAULT_MAX;
    if (valueProp != null && !isValidValueNumber(valueProp, max)) {
      return new Error(getInvalidValueError(strVal, componentName));
    }
    return null;
  }
};

//# sourceMappingURL=Progress.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/progress/dist/esm/index.mjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@tamagui/progress/dist/esm/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Progress": () => (/* reexport safe */ _Progress__WEBPACK_IMPORTED_MODULE_0__.Progress),
/* harmony export */   "ProgressFrame": () => (/* reexport safe */ _Progress__WEBPACK_IMPORTED_MODULE_0__.ProgressFrame),
/* harmony export */   "ProgressIndicator": () => (/* reexport safe */ _Progress__WEBPACK_IMPORTED_MODULE_0__.ProgressIndicator),
/* harmony export */   "ProgressIndicatorFrame": () => (/* reexport safe */ _Progress__WEBPACK_IMPORTED_MODULE_0__.ProgressIndicatorFrame),
/* harmony export */   "createProgressScope": () => (/* reexport safe */ _Progress__WEBPACK_IMPORTED_MODULE_0__.createProgressScope)
/* harmony export */ });
/* harmony import */ var _Progress__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Progress */ "../../node_modules/@tamagui/progress/dist/esm/Progress.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/radio-group/dist/esm/RadioGroup.mjs":
/*!***********************************************************************!*\
  !*** ../../node_modules/@tamagui/radio-group/dist/esm/RadioGroup.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RadioGroup": () => (/* binding */ RadioGroup),
/* harmony export */   "createRadioGroupScope": () => (/* binding */ createRadioGroupScope)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _radix_ui_react_use_previous__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @radix-ui/react-use-previous */ "../../node_modules/@radix-ui/react-use-previous/dist/index.module.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_get_size__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/get-size */ "../../node_modules/@tamagui/get-size/dist/esm/index.mjs");
/* harmony import */ var _tamagui_label__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/label */ "../../node_modules/@tamagui/label/dist/esm/Label.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);










const RADIO_GROUP_NAME = "RadioGroup";
const ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
const [createRadioGroupContext, createRadioGroupScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_2__.createContextScope)(RADIO_GROUP_NAME);
const [RadioGroupProvider, useRadioGroupContext] = createRadioGroupContext(RADIO_GROUP_NAME);
const getState = (checked) => {
  return checked ? "checked" : "unchecked";
};
const RADIO_GROUP_INDICATOR_NAME = "RadioGroupIndicator";
const RadioIndicatorFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__.ThemeableStack, {
  name: RADIO_GROUP_INDICATOR_NAME,
  variants: {
    unstyled: {
      false: {
        width: "33%",
        height: "33%",
        borderRadius: 1e3,
        backgroundColor: "$color",
        pressTheme: true
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const RadioIndicator = RadioIndicatorFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
    (props, forwardedRef) => {
      const { __scopeRadioGroupItem, forceMount, disabled, ...indicatorProps } = props;
      const { checked } = useRadioGroupItemContext(
        RADIO_GROUP_INDICATOR_NAME,
        __scopeRadioGroupItem
      );
      if (forceMount || checked) {
        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          RadioIndicatorFrame,
          {
            "data-state": getState(checked),
            "data-disabled": disabled ? "" : void 0,
            ...indicatorProps,
            ref: forwardedRef
          }
        );
      }
      return null;
    }
  )
);
RadioIndicator.displayName = RADIO_GROUP_INDICATOR_NAME;
const RADIO_GROUP_ITEM_NAME = "RadioGroupItem";
const [RadioGroupItemProvider, useRadioGroupItemContext] = createRadioGroupContext(RADIO_GROUP_NAME);
const RadioGroupItemFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__.ThemeableStack, {
  name: RADIO_GROUP_ITEM_NAME,
  tag: "button",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        borderRadius: 1e3,
        backgroundColor: "$background",
        alignItems: "center",
        justifyContent: "center",
        borderWidth: 1,
        borderColor: "$borderColor",
        padding: 0,
        hoverStyle: {
          borderColor: "$borderColorHover",
          background: "$backgroundHover"
        },
        focusStyle: {
          borderColor: "$borderColorHover",
          background: "$backgroundHover"
        },
        pressStyle: {
          borderColor: "$borderColorFocus",
          background: "$backgroundFocus"
        }
      }
    },
    size: {
      "...size": (value, { props }) => {
        const size = Math.floor(
          (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.getVariableValue)((0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_6__.getSize)(value)) * (props["scaleSize"] ?? 0.5)
        );
        return {
          width: size,
          height: size
        };
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const RadioGroupItem = RadioGroupItemFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeRadioGroup,
        value,
        labelledBy: ariaLabelledby,
        disabled: itemDisabled,
        ...itemProps
      } = props;
      const {
        value: groupValue,
        disabled,
        required,
        onChange,
        name,
        native,
        accentColor
      } = useRadioGroupContext(RADIO_GROUP_ITEM_NAME, __scopeRadioGroup);
      const [button, setButton] = react__WEBPACK_IMPORTED_MODULE_1__.useState(null);
      const hasConsumerStoppedPropagationRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(false);
      const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);
      const composedRefs = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.useComposedRefs)(forwardedRef, (node) => setButton(node), ref);
      const isArrowKeyPressedRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(false);
      const isFormControl = _tamagui_core__WEBPACK_IMPORTED_MODULE_8__.isWeb ? button ? Boolean(button.closest("form")) : true : false;
      const checked = groupValue === value;
      const labelId = (0,_tamagui_label__WEBPACK_IMPORTED_MODULE_9__.useLabelContext)(button);
      const labelledBy = ariaLabelledby || labelId;
      react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
        if (_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.isWeb) {
          const handleKeyDown = (event) => {
            if (ARROW_KEYS.includes(event.key)) {
              isArrowKeyPressedRef.current = true;
            }
          };
          const handleKeyUp = () => isArrowKeyPressedRef.current = false;
          document.addEventListener("keydown", handleKeyDown);
          document.addEventListener("keyup", handleKeyUp);
          return () => {
            document.removeEventListener("keydown", handleKeyDown);
            document.removeEventListener("keyup", handleKeyUp);
          };
        }
      }, []);
      if (false) {}
      const isDisabled = disabled || itemDisabled;
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RadioGroupItemProvider, { checked, scope: __scopeRadioGroup, children: _tamagui_core__WEBPACK_IMPORTED_MODULE_8__.isWeb && native ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        BubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled: isDisabled,
          id: props.id,
          accentColor
        }
      ) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [
        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          RadioGroupItemFrame,
          {
            "data-state": getState(checked),
            "data-disabled": isDisabled ? "" : void 0,
            role: "radio",
            "aria-labelledby": labelledBy,
            "aria-checked": checked,
            "aria-required": required,
            disabled: isDisabled,
            ref: composedRefs,
            ..._tamagui_core__WEBPACK_IMPORTED_MODULE_8__.isWeb && {
              type: "button",
              value
            },
            ...itemProps,
            onPress: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(props.onPress, (event) => {
              if (!checked) {
                onChange == null ? void 0 : onChange(value);
              }
              if (isFormControl) {
                hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
                if (!hasConsumerStoppedPropagationRef.current)
                  event.stopPropagation();
              }
            }),
            ..._tamagui_core__WEBPACK_IMPORTED_MODULE_8__.isWeb && {
              onKeyDown: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(
                props.onKeyDown,
                (event) => {
                  if (event.key === "Enter")
                    event.preventDefault();
                }
              ),
              onFocus: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(itemProps.onFocus, () => {
                var _a;
                if (isArrowKeyPressedRef.current)
                  (_a = ref.current) == null ? void 0 : _a.click();
              })
            }
          }
        ),
        isFormControl && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          BubbleInput,
          {
            isHidden: true,
            control: button,
            bubbles: !hasConsumerStoppedPropagationRef.current,
            name,
            value,
            checked,
            required,
            disabled: isDisabled
          }
        )
      ] }) });
    }
  )
);
const BubbleInput = (props) => {
  const { checked, bubbles = true, control, isHidden, accentColor, ...inputProps } = props;
  const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);
  const prevChecked = (0,_radix_ui_react_use_previous__WEBPACK_IMPORTED_MODULE_11__.usePrevious)(checked);
  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
    const input = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(
      inputProto,
      "checked"
    );
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input, checked);
      input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    "input",
    {
      type: "radio",
      defaultChecked: checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      "aria-hidden": isHidden,
      style: {
        ...isHidden ? {
          // ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        } : {
          appearance: "auto",
          accentColor
        },
        ...props.style
      }
    }
  );
};
const RadioGroupFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__.ThemeableStack, {
  name: RADIO_GROUP_NAME,
  variants: {
    orientation: {
      horizontal: {
        flexDirection: "row",
        spaceDirection: "horizontal"
      },
      vertical: {
        flexDirection: "column",
        spaceDirection: "vertical"
      }
    }
  }
});
const RadioGroup = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.withStaticProperties)(
  RadioGroupFrame.extractable(
    react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
      (props, forwardedRef) => {
        const {
          __scopeRadioGroup,
          value: valueProp,
          defaultValue,
          onValueChange,
          disabled = false,
          required = false,
          name,
          orientation,
          native,
          accentColor,
          ...radioGroupProps
        } = props;
        const [value, setValue] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_13__.useControllableState)({
          prop: valueProp,
          defaultProp: defaultValue,
          onChange: onValueChange
        });
        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          RadioGroupProvider,
          {
            scope: __scopeRadioGroup,
            value,
            required,
            onChange: setValue,
            disabled,
            name,
            native,
            accentColor,
            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
              RadioGroupFrame,
              {
                "aria-valuetext": value,
                role: "radiogroup",
                "aria-orientation": orientation,
                ref: forwardedRef,
                orientation,
                "data-disabled": disabled ? "" : void 0,
                ...radioGroupProps
              }
            )
          }
        );
      }
    )
  ),
  {
    Indicator: RadioIndicator,
    Item: RadioGroupItem
  }
);
RadioGroup.displayName = RADIO_GROUP_NAME;

//# sourceMappingURL=RadioGroup.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/radio-group/dist/esm/index.mjs":
/*!******************************************************************!*\
  !*** ../../node_modules/@tamagui/radio-group/dist/esm/index.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RadioGroup": () => (/* reexport safe */ _RadioGroup__WEBPACK_IMPORTED_MODULE_0__.RadioGroup),
/* harmony export */   "createRadioGroupScope": () => (/* reexport safe */ _RadioGroup__WEBPACK_IMPORTED_MODULE_0__.createRadioGroupScope)
/* harmony export */ });
/* harmony import */ var _RadioGroup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RadioGroup */ "../../node_modules/@tamagui/radio-group/dist/esm/RadioGroup.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/remove-scroll/dist/esm/RemoveScroll.mjs":
/*!***************************************************************************!*\
  !*** ../../node_modules/@tamagui/remove-scroll/dist/esm/RemoveScroll.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemoveScroll": () => (/* binding */ RemoveScroll)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var react_remove_scroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-remove-scroll */ "../../node_modules/react-remove-scroll/dist/es2015/Combination.js");


const RemoveScroll = (props) => {
  if (!props.children)
    return null;
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_remove_scroll__WEBPACK_IMPORTED_MODULE_1__["default"], { ...props });
};
RemoveScroll.classNames = react_remove_scroll__WEBPACK_IMPORTED_MODULE_1__["default"].classNames;

//# sourceMappingURL=RemoveScroll.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/remove-scroll/dist/esm/index.mjs":
/*!********************************************************************!*\
  !*** ../../node_modules/@tamagui/remove-scroll/dist/esm/index.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemoveScroll": () => (/* reexport safe */ _RemoveScroll__WEBPACK_IMPORTED_MODULE_0__.RemoveScroll)
/* harmony export */ });
/* harmony import */ var _RemoveScroll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RemoveScroll */ "../../node_modules/@tamagui/remove-scroll/dist/esm/RemoveScroll.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/roving-focus/dist/esm/RovingFocusGroup.mjs":
/*!******************************************************************************!*\
  !*** ../../node_modules/@tamagui/roving-focus/dist/esm/RovingFocusGroup.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RovingFocusGroup": () => (/* binding */ RovingFocusGroup),
/* harmony export */   "createRovingFocusGroupScope": () => (/* binding */ createRovingFocusGroupScope)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_collection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/collection */ "../../node_modules/@tamagui/collection/dist/esm/Collection.mjs");
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/use-event/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/core/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");
/* harmony import */ var _tamagui_use_direction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/use-direction */ "../../node_modules/@tamagui/use-direction/dist/esm/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);








const ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
const EVENT_OPTIONS = { bubbles: false, cancelable: true };
const RovingFocusGroupImpl = react__WEBPACK_IMPORTED_MODULE_2__.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    ...groupProps
  } = props;
  const ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);
  const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_3__.useComposedRefs)(forwardedRef, ref);
  const direction = (0,_tamagui_use_direction__WEBPACK_IMPORTED_MODULE_1__.useDirection)(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_4__.useControllableState)({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);
  const handleEntryFocus = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.useEvent)(onEntryFocus);
  const getItems = useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = react__WEBPACK_IMPORTED_MODULE_2__.useState(0);
  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: react__WEBPACK_IMPORTED_MODULE_2__.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: react__WEBPACK_IMPORTED_MODULE_2__.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: react__WEBPACK_IMPORTED_MODULE_2__.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: react__WEBPACK_IMPORTED_MODULE_2__.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        _tamagui_core__WEBPACK_IMPORTED_MODULE_6__.Stack,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: [{ outline: "none" }, props.style],
          onMouseDown: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.composeEventHandlers)(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.composeEventHandlers)(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst(candidateNodes);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.composeEventHandlers)(
            props.onBlur,
            () => setIsTabbingBackOut(false)
          )
        }
      )
    }
  );
});
const ITEM_NAME = "RovingFocusGroupItem";
const RovingFocusGroupItem = react__WEBPACK_IMPORTED_MODULE_2__.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    focusable = true,
    active = false,
    tabStopId,
    ...itemProps
  } = props;
  const autoId = react__WEBPACK_IMPORTED_MODULE_2__.useId();
  const id = tabStopId || autoId;
  const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);
  const isCurrentTabStop = context.currentTabStopId === id;
  const getItems = useCollection(__scopeRovingFocusGroup);
  const { onFocusableItemAdd, onFocusableItemRemove } = context;
  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {
    if (focusable) {
      onFocusableItemAdd();
      return () => onFocusableItemRemove();
    }
  }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    Collection.ItemSlot,
    {
      scope: __scopeRovingFocusGroup,
      id,
      focusable,
      active,
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        _tamagui_core__WEBPACK_IMPORTED_MODULE_6__.Stack,
        {
          tabIndex: isCurrentTabStop ? 0 : -1,
          "data-orientation": context.orientation,
          ...itemProps,
          ref: forwardedRef,
          onMouseDown: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.composeEventHandlers)(props.onMouseDown, (event) => {
            if (!focusable)
              event.preventDefault();
            else
              context.onItemFocus(id);
          }),
          onFocus: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.composeEventHandlers)(props.onFocus, () => context.onItemFocus(id)),
          ..._tamagui_core__WEBPACK_IMPORTED_MODULE_8__.isWeb && {
            onKeyDown: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.composeEventHandlers)(
              props.onKeyDown,
              (event) => {
                if (event.key === "Tab" && event.shiftKey) {
                  context.onItemShiftTab();
                  return;
                }
                if (event.target !== event.currentTarget)
                  return;
                const focusIntent = getFocusIntent(event, context.orientation, context.dir);
                if (focusIntent !== void 0) {
                  event.preventDefault();
                  const items = getItems().filter((item) => item.focusable);
                  let candidateNodes = items.map((item) => item.ref.current);
                  if (focusIntent === "last")
                    candidateNodes.reverse();
                  else if (focusIntent === "prev" || focusIntent === "next") {
                    if (focusIntent === "prev")
                      candidateNodes.reverse();
                    const currentIndex = candidateNodes.indexOf(event.currentTarget);
                    candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                  }
                  setTimeout(() => focusFirst(candidateNodes));
                }
              }
            )
          }
        }
      )
    }
  );
});
RovingFocusGroupItem.displayName = ITEM_NAME;
const GROUP_NAME = "RovingFocusGroup";
const [Collection, useCollection, createCollectionScope] = (0,_tamagui_collection__WEBPACK_IMPORTED_MODULE_9__.createCollection)(GROUP_NAME);
const [createRovingFocusGroupContext, createRovingFocusGroupScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_10__.createContextScope)(
  GROUP_NAME,
  [createCollectionScope]
);
const [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);
const RovingFocusGroup = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.withStaticProperties)(
  react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(
    (props, forwardedRef) => {
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Collection.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Collection.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
    }
  ),
  {
    Item: RovingFocusGroupItem
  }
);
RovingFocusGroup.displayName = GROUP_NAME;
const MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key))
    return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key))
    return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}

//# sourceMappingURL=RovingFocusGroup.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/scroll-view/dist/esm/ScrollView.mjs":
/*!***********************************************************************!*\
  !*** ../../node_modules/@tamagui/scroll-view/dist/esm/ScrollView.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollView": () => (/* binding */ ScrollView)
/* harmony export */ });
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/setupReactNative.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-native */ "../../node_modules/react-native-web/dist/index.js");



(0,_tamagui_web__WEBPACK_IMPORTED_MODULE_0__.setupReactNative)({
  ScrollView: react_native__WEBPACK_IMPORTED_MODULE_1__.ScrollView
});
const ScrollView = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_2__.styled)(react_native__WEBPACK_IMPORTED_MODULE_1__.ScrollView, {
  name: "ScrollView",
  scrollEnabled: true,
  variants: {
    fullscreen: {
      true: _tamagui_stacks__WEBPACK_IMPORTED_MODULE_3__.fullscreenStyle
    }
  }
});

//# sourceMappingURL=ScrollView.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/scroll-view/dist/esm/index.mjs":
/*!******************************************************************!*\
  !*** ../../node_modules/@tamagui/scroll-view/dist/esm/index.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollView": () => (/* reexport safe */ _ScrollView__WEBPACK_IMPORTED_MODULE_0__.ScrollView)
/* harmony export */ });
/* harmony import */ var _ScrollView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ScrollView */ "../../node_modules/@tamagui/scroll-view/dist/esm/ScrollView.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/select/dist/esm/Select.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/select/dist/esm/Select.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Select": () => (/* binding */ Select),
/* harmony export */   "SelectGroupFrame": () => (/* binding */ SelectGroupFrame),
/* harmony export */   "SelectIcon": () => (/* binding */ SelectIcon),
/* harmony export */   "SelectItem": () => (/* binding */ SelectItem),
/* harmony export */   "SelectItemTextFrame": () => (/* binding */ SelectItemTextFrame),
/* harmony export */   "SelectSeparator": () => (/* binding */ SelectSeparator),
/* harmony export */   "SelectTrigger": () => (/* binding */ SelectTrigger)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/adapt */ "../../node_modules/@tamagui/adapt/dist/esm/index.mjs");
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/use-event/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_list_item__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/list-item */ "../../node_modules/@tamagui/list-item/dist/esm/ListItem.mjs");
/* harmony import */ var _tamagui_portal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/portal */ "../../node_modules/@tamagui/portal/dist/esm/index.mjs");
/* harmony import */ var _tamagui_separator__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tamagui/separator */ "../../node_modules/@tamagui/separator/dist/esm/Separator.mjs");
/* harmony import */ var _tamagui_sheet__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tamagui/sheet */ "../../node_modules/@tamagui/sheet/dist/esm/Sheet.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var _tamagui_text__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/text */ "../../node_modules/@tamagui/text/dist/esm/Paragraph.mjs");
/* harmony import */ var _tamagui_text__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/text */ "../../node_modules/@tamagui/text/dist/esm/SizableText.mjs");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./constants */ "../../node_modules/@tamagui/select/dist/esm/constants.mjs");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./context */ "../../node_modules/@tamagui/select/dist/esm/context.mjs");
/* harmony import */ var _SelectContent__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./SelectContent */ "../../node_modules/@tamagui/select/dist/esm/SelectContent.mjs");
/* harmony import */ var _SelectImpl__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./SelectImpl */ "../../node_modules/@tamagui/select/dist/esm/SelectImpl.mjs");
/* harmony import */ var _SelectScrollButton__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./SelectScrollButton */ "../../node_modules/@tamagui/select/dist/esm/SelectScrollButton.mjs");
/* harmony import */ var _SelectViewport__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./SelectViewport */ "../../node_modules/@tamagui/select/dist/esm/SelectViewport.mjs");
/* harmony import */ var _useSelectBreakpointActive__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./useSelectBreakpointActive */ "../../node_modules/@tamagui/select/dist/esm/useSelectBreakpointActive.mjs");



















const TRIGGER_NAME = "SelectTrigger";
const SelectTrigger = react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      disabled = false,
      // @ts-ignore
      "aria-labelledby": ariaLabelledby,
      ...triggerProps
    } = props;
    const context = (0,_context__WEBPACK_IMPORTED_MODULE_4__.useSelectContext)(TRIGGER_NAME, __scopeSelect);
    const labelledBy = ariaLabelledby;
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _tamagui_list_item__WEBPACK_IMPORTED_MODULE_5__.ListItem,
      {
        componentName: TRIGGER_NAME,
        backgrounded: true,
        radiused: true,
        hoverTheme: true,
        pressTheme: true,
        focusTheme: true,
        focusable: true,
        borderWidth: 1,
        size: context.size,
        "aria-expanded": context.open,
        "aria-autocomplete": "none",
        "aria-labelledby": labelledBy,
        dir: context.dir,
        disabled,
        "data-disabled": disabled ? "" : void 0,
        ...triggerProps,
        ref: forwardedRef,
        ... true && context.interactions ? context.interactions.getReferenceProps() : {
          onPress() {
            context.setOpen(!context.open);
          }
        }
      }
    );
  }
);
SelectTrigger.displayName = TRIGGER_NAME;
const VALUE_NAME = "SelectValue";
const SelectValueFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_6__.styled)(_tamagui_text__WEBPACK_IMPORTED_MODULE_7__.Paragraph, {
  name: VALUE_NAME,
  userSelect: "none"
});
const SelectValue = SelectValueFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(
    ({
      __scopeSelect,
      children: childrenProp,
      placeholder
    }, forwardedRef) => {
      const context = (0,_context__WEBPACK_IMPORTED_MODULE_4__.useSelectContext)(VALUE_NAME, __scopeSelect);
      const { onValueNodeHasChildrenChange } = context;
      const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_8__.useComposedRefs)(forwardedRef, context.onValueNodeChange);
      const children = childrenProp ?? context.selectedItem;
      const hasChildren = !!children;
      const isEmptyValue = context.value == null || context.value === "";
      const selectValueChildren = isEmptyValue ? placeholder ?? children : children;
      (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_9__.useIsomorphicLayoutEffect)(() => {
        onValueNodeHasChildrenChange(hasChildren);
      }, [onValueNodeHasChildrenChange, hasChildren]);
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        SelectValueFrame,
        {
          size: context.size,
          ref: composedRefs,
          pointerEvents: "none",
          children: selectValueChildren
        }
      );
    }
  )
);
SelectValue.displayName = VALUE_NAME;
const SelectIcon = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_6__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_10__.XStack, {
  name: "SelectIcon",
  // @ts-ignore
  "aria-hidden": true,
  children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_text__WEBPACK_IMPORTED_MODULE_7__.Paragraph, { children: "\u25BC" })
});
const ITEM_NAME = "SelectItem";
const [SelectItemContextProvider, useSelectItemContext] = (0,_context__WEBPACK_IMPORTED_MODULE_4__.createSelectContext)(ITEM_NAME);
const SelectItem = react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      index,
      ...itemProps
    } = props;
    const context = (0,_context__WEBPACK_IMPORTED_MODULE_4__.useSelectContext)(ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value;
    const textId = react__WEBPACK_IMPORTED_MODULE_3__.useId();
    const {
      selectedIndex,
      setSelectedIndex,
      listRef,
      open,
      setOpen,
      onChange,
      setActiveIndex,
      allowMouseUpRef,
      allowSelectRef,
      setValueAtIndex,
      selectTimeoutRef,
      dataRef
    } = context;
    const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_8__.useComposedRefs)(forwardedRef, (node) => {
      if (!_tamagui_core__WEBPACK_IMPORTED_MODULE_9__.isWeb)
        return;
      if (node instanceof HTMLElement) {
        if (listRef) {
          listRef.current[index] = node;
        }
      }
    });
    react__WEBPACK_IMPORTED_MODULE_3__.useEffect(() => {
      setValueAtIndex(index, value);
    }, [index, setValueAtIndex, value]);
    function handleSelect() {
      setSelectedIndex(index);
      onChange(value);
      setOpen(false);
    }
    const selectItemProps = context.interactions ? context.interactions.getItemProps({
      onTouchStart() {
        allowSelectRef.current = true;
        allowMouseUpRef.current = false;
      },
      onKeyDown(event) {
        if (event.key === "Enter" || event.key === " " && !(dataRef == null ? void 0 : dataRef.current.typing)) {
          event.preventDefault();
          handleSelect();
        } else {
          allowSelectRef.current = true;
        }
      },
      onClick() {
        if (allowSelectRef.current) {
          setSelectedIndex(index);
          setOpen(false);
        }
      },
      onMouseUp() {
        if (!allowMouseUpRef.current) {
          return;
        }
        if (allowSelectRef.current) {
          handleSelect();
        }
        clearTimeout(selectTimeoutRef.current);
        selectTimeoutRef.current = setTimeout(() => {
          allowSelectRef.current = true;
        });
      }
    }) : {
      onPress: handleSelect
    };
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        textId: textId || "",
        isSelected,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          _tamagui_list_item__WEBPACK_IMPORTED_MODULE_5__.ListItem,
          {
            tag: "div",
            backgrounded: true,
            pressTheme: true,
            hoverTheme: true,
            cursor: "default",
            outlineWidth: 0,
            componentName: ITEM_NAME,
            ref: composedRefs,
            "aria-labelledby": textId,
            "aria-selected": isSelected,
            "data-state": isSelected ? "active" : "inactive",
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            tabIndex: disabled ? void 0 : -1,
            size: context.size,
            focusStyle: {
              backgroundColor: "$backgroundHover"
            },
            ...itemProps,
            ...selectItemProps
          }
        )
      }
    );
  }
);
SelectItem.displayName = ITEM_NAME;
const ITEM_TEXT_NAME = "SelectItemText";
const SelectItemTextFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_6__.styled)(_tamagui_text__WEBPACK_IMPORTED_MODULE_11__.SizableText, {
  name: ITEM_TEXT_NAME,
  userSelect: "none"
});
const SelectItemText = react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, ...itemTextProps } = props;
    const context = (0,_context__WEBPACK_IMPORTED_MODULE_4__.useSelectContext)(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const ref = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);
    const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_8__.useComposedRefs)(forwardedRef, ref);
    const isSelected = Boolean(itemContext.isSelected && context.valueNode);
    const contents = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(
      () => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        SelectItemTextFrame,
        {
          className,
          size: context.size,
          id: itemContext.textId,
          ...itemTextProps,
          ref: composedRefs
        }
      ),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [props, context.size, className, itemContext.textId]
    );
    (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_9__.useIsomorphicLayoutEffect)(() => {
      if (isSelected) {
        context.setSelectedItem(contents);
      }
    }, [isSelected, contents]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: contents });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
const ITEM_INDICATOR_NAME = "SelectItemIndicator";
const SelectItemIndicatorFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_6__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_10__.XStack, {
  name: ITEM_TEXT_NAME
});
const SelectItemIndicator = react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectItemIndicatorFrame, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
const GROUP_NAME = "SelectGroup";
const [SelectGroupContextProvider, useSelectGroupContext] = (0,_context__WEBPACK_IMPORTED_MODULE_4__.createSelectContext)(GROUP_NAME);
const SelectGroupFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_6__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_10__.YStack, {
  name: GROUP_NAME,
  width: "100%"
});
const SelectGroup = react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = react__WEBPACK_IMPORTED_MODULE_3__.useId();
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId || "", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      SelectGroupFrame,
      {
        role: "group",
        "aria-labelledby": groupId,
        ...groupProps,
        ref: forwardedRef
      }
    ) });
  }
);
SelectGroup.displayName = GROUP_NAME;
const LABEL_NAME = "SelectLabel";
const SelectLabel = react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const context = (0,_context__WEBPACK_IMPORTED_MODULE_4__.useSelectContext)(LABEL_NAME, __scopeSelect);
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _tamagui_list_item__WEBPACK_IMPORTED_MODULE_5__.ListItem,
      {
        tag: "div",
        componentName: LABEL_NAME,
        fontWeight: "800",
        id: groupContext.id,
        size: context.size,
        ...labelProps,
        ref: forwardedRef
      }
    );
  }
);
SelectLabel.displayName = LABEL_NAME;
const SelectSeparator = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_6__.styled)(_tamagui_separator__WEBPACK_IMPORTED_MODULE_12__.Separator, {
  name: "SelectSeparator"
});
const SelectSheetController = (props) => {
  const context = (0,_context__WEBPACK_IMPORTED_MODULE_4__.useSelectContext)("SelectSheetController", props.__scopeSelect);
  const showSheet = (0,_useSelectBreakpointActive__WEBPACK_IMPORTED_MODULE_13__.useShowSelectSheet)(context);
  const breakpointActive = (0,_useSelectBreakpointActive__WEBPACK_IMPORTED_MODULE_13__.useSelectBreakpointActive)(context.sheetBreakpoint);
  const getShowSheet = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_14__.useGet)(showSheet);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    _tamagui_sheet__WEBPACK_IMPORTED_MODULE_15__.SheetController,
    {
      onOpenChange: (val) => {
        if (getShowSheet()) {
          props.onOpenChange(val);
        }
      },
      open: context.open,
      hidden: breakpointActive === false,
      children: props.children
    }
  );
};
const SelectSheetImpl = (props) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: props.children });
};
const Select = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_16__.withStaticProperties)(
  (props) => {
    const {
      __scopeSelect,
      children,
      open: openProp,
      defaultOpen,
      onOpenChange,
      value: valueProp,
      defaultValue,
      onValueChange,
      size: sizeProp = "$true",
      dir
    } = props;
    const id = react__WEBPACK_IMPORTED_MODULE_3__.useId();
    const scopeKey = __scopeSelect ? Object.keys(__scopeSelect)[0] ?? id : id;
    const { when, AdaptProvider } = (0,_tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__.useAdaptParent)({
      Contents: react__WEBPACK_IMPORTED_MODULE_3__.useCallback(
        () => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_portal__WEBPACK_IMPORTED_MODULE_2__.PortalHost, { name: `${scopeKey}SheetContents` }),
        [scopeKey]
      )
    });
    const sheetBreakpoint = when;
    const isSheet = (0,_useSelectBreakpointActive__WEBPACK_IMPORTED_MODULE_13__.useSelectBreakpointActive)(sheetBreakpoint);
    const SelectImpl = isSheet || !_tamagui_core__WEBPACK_IMPORTED_MODULE_9__.isWeb ? SelectSheetImpl : _SelectImpl__WEBPACK_IMPORTED_MODULE_17__.SelectInlineImpl;
    const forceUpdate = react__WEBPACK_IMPORTED_MODULE_3__.useReducer(() => ({}), {})[1];
    const [selectedItem, setSelectedItem] = react__WEBPACK_IMPORTED_MODULE_3__.useState(null);
    const [open, setOpen] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_18__.useControllableState)({
      prop: openProp,
      defaultProp: defaultOpen || false,
      onChange: onOpenChange
    });
    const [value, setValue] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_18__.useControllableState)({
      prop: valueProp,
      defaultProp: defaultValue || "",
      onChange: onValueChange,
      transition: true
    });
    const [activeIndex, setActiveIndex] = react__WEBPACK_IMPORTED_MODULE_3__.useState(0);
    const selectedIndexRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);
    const activeIndexRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);
    const listContentRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef([]);
    const [selectedIndex, setSelectedIndex] = react__WEBPACK_IMPORTED_MODULE_3__.useState(0);
    const [valueNode, setValueNode] = react__WEBPACK_IMPORTED_MODULE_3__.useState(null);
    const [valueNodeHasChildren, setValueNodeHasChildren] = react__WEBPACK_IMPORTED_MODULE_3__.useState(false);
    (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_9__.useIsomorphicLayoutEffect)(() => {
      selectedIndexRef.current = selectedIndex;
      activeIndexRef.current = activeIndex;
    });
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AdaptProvider, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _context__WEBPACK_IMPORTED_MODULE_4__.SelectProvider,
      {
        dir,
        blockSelection: false,
        size: sizeProp,
        fallback: false,
        selectedItem,
        setSelectedItem,
        forceUpdate,
        valueNode,
        onValueNodeChange: setValueNode,
        onValueNodeHasChildrenChange: setValueNodeHasChildren,
        valueNodeHasChildren,
        scopeKey,
        sheetBreakpoint,
        scope: __scopeSelect,
        setValueAtIndex: (index, value2) => {
          listContentRef.current[index] = value2;
        },
        activeIndex,
        onChange: setValue,
        selectedIndex,
        setActiveIndex,
        setOpen,
        setSelectedIndex,
        value,
        open,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectSheetController, { onOpenChange: setOpen, __scopeSelect, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          SelectImpl,
          {
            activeIndexRef,
            listContentRef,
            selectedIndexRef,
            ...props,
            open,
            value,
            children
          }
        ) })
      }
    ) });
  },
  {
    Adapt: _tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__.Adapt,
    Content: _SelectContent__WEBPACK_IMPORTED_MODULE_19__.SelectContent,
    Group: SelectGroup,
    Icon: SelectIcon,
    Item: SelectItem,
    ItemIndicator: SelectItemIndicator,
    ItemText: SelectItemText,
    Label: SelectLabel,
    ScrollDownButton: _SelectScrollButton__WEBPACK_IMPORTED_MODULE_20__.SelectScrollDownButton,
    ScrollUpButton: _SelectScrollButton__WEBPACK_IMPORTED_MODULE_20__.SelectScrollUpButton,
    Trigger: SelectTrigger,
    Value: SelectValue,
    Viewport: _SelectViewport__WEBPACK_IMPORTED_MODULE_21__.SelectViewport,
    Sheet: _tamagui_sheet__WEBPACK_IMPORTED_MODULE_15__.ControlledSheet
  }
);
Select.displayName = _constants__WEBPACK_IMPORTED_MODULE_22__.SELECT_NAME;

//# sourceMappingURL=Select.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/select/dist/esm/SelectContent.mjs":
/*!*********************************************************************!*\
  !*** ../../node_modules/@tamagui/select/dist/esm/SelectContent.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectContent": () => (/* binding */ SelectContent)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @floating-ui/react */ "../../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useThemeName.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/views/Theme.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useIsTouchDevice.js");
/* harmony import */ var _tamagui_dismissable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/dismissable */ "../../node_modules/@tamagui/dismissable/dist/esm/index.mjs");
/* harmony import */ var _tamagui_focus_scope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/focus-scope */ "../../node_modules/@tamagui/focus-scope/dist/esm/index.mjs");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context */ "../../node_modules/@tamagui/select/dist/esm/context.mjs");
/* harmony import */ var _useSelectBreakpointActive__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./useSelectBreakpointActive */ "../../node_modules/@tamagui/select/dist/esm/useSelectBreakpointActive.mjs");







const CONTENT_NAME = "SelectContent";
const SelectContent = ({
  children,
  __scopeSelect,
  zIndex = 1e3,
  ...focusScopeProps
}) => {
  const context = (0,_context__WEBPACK_IMPORTED_MODULE_3__.useSelectContext)(CONTENT_NAME, __scopeSelect);
  const themeName = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.useThemeName)();
  const showSheet = (0,_useSelectBreakpointActive__WEBPACK_IMPORTED_MODULE_5__.useShowSelectSheet)(context);
  const contents = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_core__WEBPACK_IMPORTED_MODULE_6__.Theme, { forceClassName: true, name: themeName, children });
  const touch = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.useIsTouchDevice)();
  if (showSheet) {
    if (!context.open) {
      return null;
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: contents });
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.FloatingPortal, { children: context.open ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.FloatingOverlay, { style: { zIndex }, lockScroll: !touch, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_focus_scope__WEBPACK_IMPORTED_MODULE_2__.FocusScope, { loop: true, trapped: true, ...focusScopeProps, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_dismissable__WEBPACK_IMPORTED_MODULE_1__.Dismissable, { children: contents }) }) }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { style: { display: "none" }, children: contents }) });
};

//# sourceMappingURL=SelectContent.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/select/dist/esm/SelectImpl.mjs":
/*!******************************************************************!*\
  !*** ../../node_modules/@tamagui/select/dist/esm/SelectImpl.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectInlineImpl": () => (/* binding */ SelectInlineImpl)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/react */ "../../node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs");
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @floating-ui/react */ "../../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js");
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @floating-ui/react */ "../../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useIsTouchDevice.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "../../node_modules/react-dom/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constants */ "../../node_modules/@tamagui/select/dist/esm/constants.mjs");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context */ "../../node_modules/@tamagui/select/dist/esm/context.mjs");







const SelectInlineImpl = (props) => {
  const {
    __scopeSelect,
    children,
    open = false,
    selectedIndexRef,
    listContentRef
  } = props;
  const selectContext = (0,_context__WEBPACK_IMPORTED_MODULE_3__.useSelectContext)("SelectSheetImpl", __scopeSelect);
  const {
    setActiveIndex,
    setOpen,
    setSelectedIndex,
    selectedIndex,
    activeIndex,
    forceUpdate
  } = selectContext;
  const [scrollTop, setScrollTop] = react__WEBPACK_IMPORTED_MODULE_1__.useState(0);
  const touch = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.useIsTouchDevice)();
  const listItemsRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef([]);
  const overflowRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);
  const upArrowRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);
  const downArrowRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);
  const allowSelectRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(false);
  const allowMouseUpRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(true);
  const selectTimeoutRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef();
  const state = react__WEBPACK_IMPORTED_MODULE_1__.useRef({
    isMouseOutside: false
  });
  const [controlledScrolling, setControlledScrolling] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);
  const [fallback, setFallback] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);
  const [innerOffset, setInnerOffset] = react__WEBPACK_IMPORTED_MODULE_1__.useState(0);
  const [blockSelection, setBlockSelection] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);
  const floatingStyle = react__WEBPACK_IMPORTED_MODULE_1__.useRef({});
  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
    const frame = requestAnimationFrame(() => {
      if (!open) {
        setScrollTop(0);
        setFallback(false);
        setActiveIndex(null);
        setControlledScrolling(false);
      }
    });
    return () => {
      cancelAnimationFrame(frame);
    };
  }, [open, setActiveIndex]);
  if (_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.isWeb && _tamagui_core__WEBPACK_IMPORTED_MODULE_5__.isClient) {
    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
      if (!open)
        return;
      const mouseUp = (e) => {
        if (state.current.isMouseOutside) {
          setOpen(false);
        }
      };
      document.addEventListener("mouseup", mouseUp);
      return () => {
        document.removeEventListener("mouseup", mouseUp);
      };
    }, [open]);
  }
  const updateFloatingSize = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.size)({
    apply({
      availableHeight,
      rects: {
        reference: { width }
      }
    }) {
      floatingStyle.current = {
        width,
        maxHeight: availableHeight
      };
    },
    padding: _constants__WEBPACK_IMPORTED_MODULE_7__.WINDOW_PADDING
  });
  const { x, y, reference, floating, strategy, context, refs } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.useFloating)({
    open,
    onOpenChange: setOpen,
    whileElementsMounted: _floating_ui_react__WEBPACK_IMPORTED_MODULE_9__.autoUpdate,
    placement: "bottom-start",
    middleware: fallback ? [
      (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.offset)(5),
      ...[
        touch ? (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.shift)({ crossAxis: true, padding: _constants__WEBPACK_IMPORTED_MODULE_7__.WINDOW_PADDING }) : (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.flip)({ padding: _constants__WEBPACK_IMPORTED_MODULE_7__.WINDOW_PADDING })
      ],
      updateFloatingSize
    ] : [
      (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.inner)({
        listRef: listItemsRef,
        overflowRef,
        index: selectedIndex,
        offset: innerOffset,
        onFallbackChange: setFallback,
        padding: 10,
        minItemsVisible: touch ? 10 : 4,
        referenceOverflowThreshold: 20
      }),
      updateFloatingSize
    ]
  });
  const floatingRef = refs.floating;
  const showUpArrow = open && scrollTop > _constants__WEBPACK_IMPORTED_MODULE_7__.SCROLL_ARROW_THRESHOLD;
  const showDownArrow = open && floatingRef.current && scrollTop < floatingRef.current.scrollHeight - floatingRef.current.clientHeight - _constants__WEBPACK_IMPORTED_MODULE_7__.SCROLL_ARROW_THRESHOLD;
  const interactions = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.useInteractions)([
    (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.useClick)(context, { event: "mousedown" }),
    (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.useDismiss)(context, { outsidePress: true }),
    (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.useRole)(context, { role: "listbox" }),
    (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.useInnerOffset)(context, {
      enabled: !fallback,
      onChange: setInnerOffset,
      overflowRef
    }),
    (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.useListNavigation)(context, {
      listRef: listItemsRef,
      activeIndex,
      selectedIndex,
      onNavigate: setActiveIndex
    }),
    (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.useTypeahead)(context, {
      listRef: listContentRef,
      onMatch: open ? setActiveIndex : setSelectedIndex,
      selectedIndex,
      activeIndex
    })
  ]);
  const interactionsContext = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {
    return {
      ...interactions,
      getReferenceProps() {
        return interactions.getReferenceProps({
          ref: reference,
          className: "SelectTrigger",
          onKeyDown(event) {
            if (event.key === "Enter" || event.key === " " && !context.dataRef.current.typing) {
              event.preventDefault();
              setOpen(true);
            }
          }
        });
      },
      getFloatingProps(props2) {
        return interactions.getFloatingProps({
          ref: floating,
          className: "Select",
          ...props2,
          style: {
            position: strategy,
            top: y ?? "",
            left: x ?? "",
            outline: 0,
            scrollbarWidth: "none",
            ...floatingStyle.current,
            ...props2 == null ? void 0 : props2.style
          },
          onPointerEnter() {
            setControlledScrolling(false);
            state.current.isMouseOutside = false;
          },
          onPointerLeave() {
            state.current.isMouseOutside = true;
          },
          onPointerMove() {
            state.current.isMouseOutside = false;
            setControlledScrolling(false);
          },
          onKeyDown() {
            setControlledScrolling(true);
          },
          onContextMenu(e) {
            e.preventDefault();
          },
          onScroll(event) {
            (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync)(() => setScrollTop(event.currentTarget.scrollTop));
          }
        });
      }
    };
  }, [floating, y, x, interactions]);
  (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.useIsomorphicLayoutEffect)(() => {
    if (open) {
      selectTimeoutRef.current = setTimeout(() => {
        allowSelectRef.current = true;
      }, 300);
      return () => {
        clearTimeout(selectTimeoutRef.current);
      };
    } else {
      allowSelectRef.current = false;
      allowMouseUpRef.current = true;
      setInnerOffset(0);
      setFallback(false);
      setBlockSelection(false);
    }
  }, [open]);
  (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.useIsomorphicLayoutEffect)(() => {
    function onPointerDown(e) {
      var _a, _b, _c;
      const target = e.target;
      if (!(((_a = refs.floating.current) == null ? void 0 : _a.contains(target)) || ((_b = upArrowRef.current) == null ? void 0 : _b.contains(target)) || ((_c = downArrowRef.current) == null ? void 0 : _c.contains(target)))) {
        setOpen(false);
        setControlledScrolling(false);
      }
    }
    if (open) {
      document.addEventListener("pointerdown", onPointerDown);
      return () => {
        document.removeEventListener("pointerdown", onPointerDown);
      };
    }
  }, [open, refs, setOpen]);
  (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.useIsomorphicLayoutEffect)(() => {
    var _a, _b;
    if (open && controlledScrolling) {
      if (activeIndex != null) {
        (_a = listItemsRef.current[activeIndex]) == null ? void 0 : _a.scrollIntoView({ block: "nearest" });
      }
    }
    setScrollTop(((_b = refs.floating.current) == null ? void 0 : _b.scrollTop) ?? 0);
  }, [open, refs, controlledScrolling, activeIndex]);
  (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.useIsomorphicLayoutEffect)(() => {
    var _a;
    if (open && fallback) {
      if (selectedIndex != null) {
        (_a = listItemsRef.current[selectedIndex]) == null ? void 0 : _a.scrollIntoView({ block: "nearest" });
      }
    }
  }, [open, fallback, selectedIndex]);
  (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.useIsomorphicLayoutEffect)(() => {
    if (refs.floating.current && fallback) {
      refs.floating.current.style.maxHeight = "";
    }
  }, [refs, fallback]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    _context__WEBPACK_IMPORTED_MODULE_3__.SelectProvider,
    {
      scope: __scopeSelect,
      ...selectContext,
      setScrollTop,
      setInnerOffset,
      floatingRef,
      setValueAtIndex: (index, value) => {
        listContentRef.current[index] = value;
      },
      fallback,
      interactions: interactionsContext,
      floatingContext: context,
      activeIndex,
      canScrollDown: !!showDownArrow,
      canScrollUp: !!showUpArrow,
      controlledScrolling,
      dataRef: context.dataRef,
      listRef: listItemsRef,
      blockSelection,
      allowMouseUpRef,
      upArrowRef,
      downArrowRef,
      selectTimeoutRef,
      allowSelectRef,
      children
    }
  );
};
const userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";

//# sourceMappingURL=SelectImpl.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/select/dist/esm/SelectScrollButton.mjs":
/*!**************************************************************************!*\
  !*** ../../node_modules/@tamagui/select/dist/esm/SelectScrollButton.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectScrollDownButton": () => (/* binding */ SelectScrollDownButton),
/* harmony export */   "SelectScrollUpButton": () => (/* binding */ SelectScrollUpButton)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/react */ "../../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js");
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @floating-ui/react */ "../../node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs");
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/react */ "../../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs");
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "../../node_modules/react-dom/index.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context */ "../../node_modules/@tamagui/select/dist/esm/context.mjs");








const SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
const SelectScrollUpButton = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    SelectScrollButtonImpl,
    {
      componentName: SCROLL_UP_BUTTON_NAME,
      ...props,
      dir: "up",
      ref: forwardedRef
    }
  );
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
const SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
const SelectScrollDownButton = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    SelectScrollButtonImpl,
    {
      componentName: SCROLL_DOWN_BUTTON_NAME,
      ...props,
      dir: "down",
      ref: forwardedRef
    }
  );
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
const SelectScrollButtonImpl = react__WEBPACK_IMPORTED_MODULE_1__.memo(
  react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
    (props, forwardedRef) => {
      var _a;
      const { __scopeSelect, dir, componentName, ...scrollIndicatorProps } = props;
      const {
        floatingRef,
        forceUpdate,
        open,
        fallback,
        setScrollTop,
        setInnerOffset,
        ...context
      } = (0,_context__WEBPACK_IMPORTED_MODULE_3__.useSelectContext)(componentName, __scopeSelect);
      const [element, setElement] = react__WEBPACK_IMPORTED_MODULE_1__.useState(null);
      const statusRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef("idle");
      const isVisible = context[dir === "down" ? "canScrollDown" : "canScrollUp"];
      const frameRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef();
      const { x, y, reference, floating, strategy, update, refs } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.useFloating)({
        open: open && isVisible,
        strategy: "fixed",
        placement: dir === "up" ? "top" : "bottom",
        middleware: [(0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.offset)(({ rects }) => -rects.floating.height)],
        whileElementsMounted: (...args) => (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.autoUpdate)(...args, { animationFrame: true })
      });
      const composedRef = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_7__.useComposedRefs)(forwardedRef, floating);
      if (floatingRef) {
        if (open) {
          if (element !== floatingRef.current) {
            setElement(floatingRef.current);
            reference(floatingRef.current);
            requestAnimationFrame(update);
          }
        } else {
          cancelAnimationFrame(frameRef.current);
        }
      }
      (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.useIsomorphicLayoutEffect)(() => {
        return () => {
          cancelAnimationFrame(frameRef.current);
        };
      }, []);
      if (!(isVisible && floatingRef)) {
        return null;
      }
      const onScroll = (amount) => {
        console.log("on scroll?");
        if (fallback) {
          if (refs.floating.current) {
            refs.floating.current.scrollTop -= amount;
            (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync)(() => {
              var _a2;
              return setScrollTop(((_a2 = refs.floating.current) == null ? void 0 : _a2.scrollTop) ?? 0);
            });
          }
        } else {
          (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync)(() => setInnerOffset((value) => value - amount));
        }
      };
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        _tamagui_stacks__WEBPACK_IMPORTED_MODULE_9__.YStack,
        {
          ref: composedRef,
          componentName,
          "aria-hidden": true,
          ...scrollIndicatorProps,
          zIndex: 1e3,
          position: strategy,
          left: x || 0,
          top: y || 0,
          width: `calc(${(((_a = floatingRef == null ? void 0 : floatingRef.current) == null ? void 0 : _a.offsetWidth) ?? 0) - 2}px)`,
          onPointerEnter: () => {
            statusRef.current = "active";
            let prevNow = Date.now();
            function frame() {
              if (element) {
                const currentNow = Date.now();
                const msElapsed = currentNow - prevNow;
                prevNow = currentNow;
                const pixelsToScroll = msElapsed / 2;
                const remainingPixels = dir === "up" ? element.scrollTop : element.scrollHeight - element.clientHeight - element.scrollTop;
                const scrollRemaining = dir === "up" ? element.scrollTop - pixelsToScroll > 0 : element.scrollTop + pixelsToScroll < element.scrollHeight - element.clientHeight;
                onScroll(
                  dir === "up" ? Math.min(pixelsToScroll, remainingPixels) : Math.max(-pixelsToScroll, -remainingPixels)
                );
                if (scrollRemaining) {
                  frameRef.current = requestAnimationFrame(frame);
                }
              }
            }
            cancelAnimationFrame(frameRef.current);
            frameRef.current = requestAnimationFrame(frame);
          },
          onPointerLeave: () => {
            statusRef.current = "idle";
            cancelAnimationFrame(frameRef.current);
          }
        }
      );
    }
  )
);

//# sourceMappingURL=SelectScrollButton.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/select/dist/esm/SelectViewport.mjs":
/*!**********************************************************************!*\
  !*** ../../node_modules/@tamagui/select/dist/esm/SelectViewport.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectViewport": () => (/* binding */ SelectViewport),
/* harmony export */   "SelectViewportFrame": () => (/* binding */ SelectViewportFrame)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @floating-ui/react */ "../../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_portal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/portal */ "../../node_modules/@tamagui/portal/dist/esm/index.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "../../node_modules/@tamagui/select/dist/esm/constants.mjs");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./context */ "../../node_modules/@tamagui/select/dist/esm/context.mjs");
/* harmony import */ var _useSelectBreakpointActive__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./useSelectBreakpointActive */ "../../node_modules/@tamagui/select/dist/esm/useSelectBreakpointActive.mjs");










const SelectViewportFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_4__.ThemeableStack, {
  name: _constants__WEBPACK_IMPORTED_MODULE_5__.VIEWPORT_NAME,
  backgroundColor: "$background",
  elevate: true,
  bordered: true,
  userSelect: "none",
  outlineWidth: 0,
  variants: {
    size: {
      "...size": (val, { tokens }) => {
        return {
          borderRadius: tokens.radius[val] ?? val
        };
      }
    }
  },
  defaultVariants: {
    size: "$2"
  }
});
const SelectViewport = react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, disableScroll, ...viewportProps } = props;
    const context = (0,_context__WEBPACK_IMPORTED_MODULE_6__.useSelectContext)(_constants__WEBPACK_IMPORTED_MODULE_5__.VIEWPORT_NAME, __scopeSelect);
    const breakpointActive = (0,_useSelectBreakpointActive__WEBPACK_IMPORTED_MODULE_7__.useSelectBreakpointActive)(context.sheetBreakpoint);
    if (breakpointActive || !_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.isWeb) {
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_portal__WEBPACK_IMPORTED_MODULE_1__.PortalItem, { hostName: `${context.scopeKey}SheetContents`, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_context__WEBPACK_IMPORTED_MODULE_6__.ForwardSelectContext, { context, children }) });
    }
    if (!context.floatingContext) {
      return null;
    }
    if (!context.open) {
      return children;
    }
    const {
      style: { scrollbarWidth, listStyleType, overflow, ...restStyle },
      ...floatingProps
    } = context.interactions.getFloatingProps();
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [
      !disableScroll && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: selectViewportCSS
          }
        }
      ),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_9__.FloatingFocusManager, { context: context.floatingContext, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        SelectViewportFrame,
        {
          size: context.size,
          role: "presentation",
          ...viewportProps,
          ref: forwardedRef,
          ...floatingProps,
          ...restStyle,
          overflow: disableScroll ? void 0 : overflow ?? "scroll",
          children
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = _constants__WEBPACK_IMPORTED_MODULE_5__.VIEWPORT_NAME;
const selectViewportCSS = `
.is_SelectViewport {
  scrollbar-width: none;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}

.is_SelectViewport::-webkit-scrollbar{
  display:none
}
`;

//# sourceMappingURL=SelectViewport.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/select/dist/esm/constants.mjs":
/*!*****************************************************************!*\
  !*** ../../node_modules/@tamagui/select/dist/esm/constants.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FALLBACK_THRESHOLD": () => (/* binding */ FALLBACK_THRESHOLD),
/* harmony export */   "MIN_HEIGHT": () => (/* binding */ MIN_HEIGHT),
/* harmony export */   "SCROLL_ARROW_THRESHOLD": () => (/* binding */ SCROLL_ARROW_THRESHOLD),
/* harmony export */   "SCROLL_ARROW_VELOCITY": () => (/* binding */ SCROLL_ARROW_VELOCITY),
/* harmony export */   "SELECT_NAME": () => (/* binding */ SELECT_NAME),
/* harmony export */   "VIEWPORT_NAME": () => (/* binding */ VIEWPORT_NAME),
/* harmony export */   "WINDOW_PADDING": () => (/* binding */ WINDOW_PADDING)
/* harmony export */ });
const SELECT_NAME = "Select";
const WINDOW_PADDING = 8;
const SCROLL_ARROW_VELOCITY = 8;
const SCROLL_ARROW_THRESHOLD = 8;
const MIN_HEIGHT = 80;
const FALLBACK_THRESHOLD = 16;
const VIEWPORT_NAME = "SelectViewport";

//# sourceMappingURL=constants.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/select/dist/esm/context.mjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@tamagui/select/dist/esm/context.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ForwardSelectContext": () => (/* binding */ ForwardSelectContext),
/* harmony export */   "SelectProvider": () => (/* binding */ SelectProvider),
/* harmony export */   "createSelectContext": () => (/* binding */ createSelectContext),
/* harmony export */   "createSelectScope": () => (/* binding */ createSelectScope),
/* harmony export */   "useSelectContext": () => (/* binding */ useSelectContext)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "../../node_modules/@tamagui/select/dist/esm/constants.mjs");



const [createSelectContext, createSelectScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_1__.createContextScope)(_constants__WEBPACK_IMPORTED_MODULE_2__.SELECT_NAME);
const [SelectProvider, useSelectContext] = createSelectContext(_constants__WEBPACK_IMPORTED_MODULE_2__.SELECT_NAME);
const ForwardSelectContext = (props) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectProvider, { isInSheet: true, scope: props.__scopeSelect, ...props.context, children: props.children });
};

//# sourceMappingURL=context.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/select/dist/esm/index.mjs":
/*!*************************************************************!*\
  !*** ../../node_modules/@tamagui/select/dist/esm/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ForwardSelectContext": () => (/* reexport safe */ _context__WEBPACK_IMPORTED_MODULE_1__.ForwardSelectContext),
/* harmony export */   "Select": () => (/* reexport safe */ _Select__WEBPACK_IMPORTED_MODULE_0__.Select),
/* harmony export */   "SelectGroupFrame": () => (/* reexport safe */ _Select__WEBPACK_IMPORTED_MODULE_0__.SelectGroupFrame),
/* harmony export */   "SelectIcon": () => (/* reexport safe */ _Select__WEBPACK_IMPORTED_MODULE_0__.SelectIcon),
/* harmony export */   "SelectItem": () => (/* reexport safe */ _Select__WEBPACK_IMPORTED_MODULE_0__.SelectItem),
/* harmony export */   "SelectItemTextFrame": () => (/* reexport safe */ _Select__WEBPACK_IMPORTED_MODULE_0__.SelectItemTextFrame),
/* harmony export */   "SelectProvider": () => (/* reexport safe */ _context__WEBPACK_IMPORTED_MODULE_1__.SelectProvider),
/* harmony export */   "SelectSeparator": () => (/* reexport safe */ _Select__WEBPACK_IMPORTED_MODULE_0__.SelectSeparator),
/* harmony export */   "SelectTrigger": () => (/* reexport safe */ _Select__WEBPACK_IMPORTED_MODULE_0__.SelectTrigger),
/* harmony export */   "createSelectContext": () => (/* reexport safe */ _context__WEBPACK_IMPORTED_MODULE_1__.createSelectContext),
/* harmony export */   "createSelectScope": () => (/* reexport safe */ _context__WEBPACK_IMPORTED_MODULE_1__.createSelectScope),
/* harmony export */   "useSelectContext": () => (/* reexport safe */ _context__WEBPACK_IMPORTED_MODULE_1__.useSelectContext)
/* harmony export */ });
/* harmony import */ var _Select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Select */ "../../node_modules/@tamagui/select/dist/esm/Select.mjs");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context */ "../../node_modules/@tamagui/select/dist/esm/context.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/select/dist/esm/useSelectBreakpointActive.mjs":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@tamagui/select/dist/esm/useSelectBreakpointActive.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useSelectBreakpointActive": () => (/* binding */ useSelectBreakpointActive),
/* harmony export */   "useShowSelectSheet": () => (/* binding */ useShowSelectSheet)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useMedia.js");

const useSelectBreakpointActive = (sheetBreakpoint) => {
  const media = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.useMedia)();
  if (!sheetBreakpoint)
    return false;
  if (sheetBreakpoint === true)
    return true;
  return sheetBreakpoint ? media[sheetBreakpoint] : false;
};
const useShowSelectSheet = (context) => {
  const breakpointActive = useSelectBreakpointActive(context.sheetBreakpoint);
  return context.open === false ? false : breakpointActive;
};

//# sourceMappingURL=useSelectBreakpointActive.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/separator/dist/esm/Separator.mjs":
/*!********************************************************************!*\
  !*** ../../node_modules/@tamagui/separator/dist/esm/Separator.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Separator": () => (/* binding */ Separator)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/core/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");

const Separator = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.Stack, {
  name: "Separator",
  borderColor: "$borderColor",
  flexShrink: 0,
  borderWidth: 0,
  flex: 1,
  height: 0,
  maxHeight: 0,
  borderBottomWidth: 1,
  y: -0.5,
  variants: {
    vertical: {
      true: {
        y: 0,
        x: -0.5,
        height: _tamagui_core__WEBPACK_IMPORTED_MODULE_2__.isWeb ? "initial" : "auto",
        // maxHeight auto WILL BE passed to style attribute, but for some reason not used?
        // almost seems like a react or browser bug, but for now `initial` works
        // also, it doesn't happen for `height`, but for consistency using the same values
        maxHeight: _tamagui_core__WEBPACK_IMPORTED_MODULE_2__.isWeb ? "initial" : "auto",
        width: 0,
        maxWidth: 0,
        borderBottomWidth: 0,
        borderRightWidth: 1
      }
    }
  }
});

//# sourceMappingURL=Separator.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/separator/dist/esm/index.mjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@tamagui/separator/dist/esm/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Separator": () => (/* reexport safe */ _Separator__WEBPACK_IMPORTED_MODULE_0__.Separator)
/* harmony export */ });
/* harmony import */ var _Separator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Separator */ "../../node_modules/@tamagui/separator/dist/esm/Separator.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/shapes/dist/esm/Circle.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/shapes/dist/esm/Circle.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Circle": () => (/* binding */ Circle)
/* harmony export */ });
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _Square__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Square */ "../../node_modules/@tamagui/shapes/dist/esm/Square.mjs");


const Circle = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_0__.styled)(_Square__WEBPACK_IMPORTED_MODULE_1__.Square, {
  name: "Circle",
  circular: true
});

//# sourceMappingURL=Circle.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/shapes/dist/esm/Square.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/shapes/dist/esm/Square.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Square": () => (/* binding */ Square)
/* harmony export */ });
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _getShapeSize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getShapeSize */ "../../node_modules/@tamagui/shapes/dist/esm/getShapeSize.mjs");



const Square = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_0__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_1__.ThemeableStack, {
  name: "Square",
  alignItems: "center",
  justifyContent: "center",
  variants: {
    circular: {
      true: {
        borderRadius: 1e5
      }
    },
    size: {
      "...size": _getShapeSize__WEBPACK_IMPORTED_MODULE_2__.getShapeSize
    }
  }
});

//# sourceMappingURL=Square.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/shapes/dist/esm/getShapeSize.mjs":
/*!********************************************************************!*\
  !*** ../../node_modules/@tamagui/shapes/dist/esm/getShapeSize.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getShapeSize": () => (/* binding */ getShapeSize)
/* harmony export */ });
const getShapeSize = (size, { tokens }) => {
  const width = tokens.size[size] ?? size;
  const height = tokens.size[size] ?? size;
  return {
    width,
    height,
    minWidth: width,
    maxWidth: width,
    maxHeight: height,
    minHeight: height
  };
};

//# sourceMappingURL=getShapeSize.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/shapes/dist/esm/index.mjs":
/*!*************************************************************!*\
  !*** ../../node_modules/@tamagui/shapes/dist/esm/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Circle": () => (/* reexport safe */ _Circle__WEBPACK_IMPORTED_MODULE_1__.Circle),
/* harmony export */   "Square": () => (/* reexport safe */ _Square__WEBPACK_IMPORTED_MODULE_0__.Square),
/* harmony export */   "getShapeSize": () => (/* reexport safe */ _getShapeSize__WEBPACK_IMPORTED_MODULE_2__.getShapeSize)
/* harmony export */ });
/* harmony import */ var _Square__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Square */ "../../node_modules/@tamagui/shapes/dist/esm/Square.mjs");
/* harmony import */ var _Circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Circle */ "../../node_modules/@tamagui/shapes/dist/esm/Circle.mjs");
/* harmony import */ var _getShapeSize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getShapeSize */ "../../node_modules/@tamagui/shapes/dist/esm/getShapeSize.mjs");



//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/sheet/dist/esm/Sheet.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/@tamagui/sheet/dist/esm/Sheet.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ControlledSheet": () => (/* binding */ ControlledSheet),
/* harmony export */   "Sheet": () => (/* binding */ Sheet),
/* harmony export */   "SheetController": () => (/* binding */ SheetController),
/* harmony export */   "SheetFrame": () => (/* binding */ SheetFrame),
/* harmony export */   "SheetFrameFrame": () => (/* binding */ SheetFrameFrame),
/* harmony export */   "SheetHandle": () => (/* binding */ SheetHandle),
/* harmony export */   "SheetHandleFrame": () => (/* binding */ SheetHandleFrame),
/* harmony export */   "SheetOverlay": () => (/* binding */ SheetOverlay),
/* harmony export */   "SheetOverlayFrame": () => (/* binding */ SheetOverlayFrame),
/* harmony export */   "createSheetScope": () => (/* reexport safe */ _SheetContext__WEBPACK_IMPORTED_MODULE_10__.createSheetScope)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/adapt */ "../../node_modules/@tamagui/adapt/dist/esm/index.mjs");
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/views/Slot.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/use-did-finish-ssr/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/themeable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useAnimationDriver.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useThemeName.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/use-event/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/views/Theme.js");
/* harmony import */ var _tamagui_portal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/portal */ "../../node_modules/@tamagui/portal/dist/esm/index.mjs");
/* harmony import */ var _tamagui_remove_scroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/remove-scroll */ "../../node_modules/@tamagui/remove-scroll/dist/esm/index.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var _tamagui_use_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/use-constant */ "../../node_modules/@tamagui/use-constant/dist/esm/index.mjs");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");
/* harmony import */ var _tamagui_use_keyboard_visible__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/use-keyboard-visible */ "../../node_modules/@tamagui/use-keyboard-visible/dist/esm/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! react-native */ "../../node_modules/react-native-web/dist/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./constants */ "../../node_modules/@tamagui/sheet/dist/esm/constants.mjs");
/* harmony import */ var _SheetContext__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./SheetContext */ "../../node_modules/@tamagui/sheet/dist/esm/SheetContext.mjs");
/* harmony import */ var _SheetScrollView__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./SheetScrollView */ "../../node_modules/@tamagui/sheet/dist/esm/SheetScrollView.mjs");
















const SheetHandleFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_8__.XStack, {
  name: _constants__WEBPACK_IMPORTED_MODULE_9__.SHEET_HANDLE_NAME,
  height: 10,
  borderRadius: 100,
  backgroundColor: "$background",
  zIndex: 10,
  marginHorizontal: "35%",
  marginBottom: "$2",
  opacity: 0.5,
  hoverStyle: {
    opacity: 0.7
  },
  variants: {
    open: {
      true: {
        pointerEvents: "auto"
      },
      false: {
        opacity: 0,
        pointerEvents: "none"
      }
    }
  }
});
const SheetHandle = SheetHandleFrame.extractable(
  ({ __scopeSheet, ...props }) => {
    const context = (0,_SheetContext__WEBPACK_IMPORTED_MODULE_10__.useSheetContext)(_constants__WEBPACK_IMPORTED_MODULE_9__.SHEET_HANDLE_NAME, __scopeSheet);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      SheetHandleFrame,
      {
        onPress: () => {
          const max = context.snapPoints.length + (context.dismissOnSnapToBottom ? -1 : 0);
          const nextPos = (context.position + 1) % max;
          context.setPosition(nextPos);
        },
        open: context.open,
        ...props
      }
    );
  }
);
const SHEET_OVERLAY_NAME = "SheetOverlay";
const SheetOverlayFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_11__.ThemeableStack, {
  name: SHEET_OVERLAY_NAME,
  fullscreen: true,
  backgrounded: true,
  opacity: 0.5,
  zIndex: 0,
  variants: {
    closed: {
      true: {
        opacity: 0,
        pointerEvents: "none"
      },
      false: {
        pointerEvents: "auto"
      }
    }
  }
});
const SheetOverlay = SheetOverlayFrame.extractable(
  ({ __scopeSheet, ...props }) => {
    const context = (0,_SheetContext__WEBPACK_IMPORTED_MODULE_10__.useSheetContext)(SHEET_OVERLAY_NAME, __scopeSheet);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      SheetOverlayFrame,
      {
        closed: !context.open || context.hidden,
        ...props,
        onPress: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.mergeEvent)(
          props.onPress,
          context.dismissOnOverlayPress ? () => {
            context.setOpen(false);
          } : void 0
        )
      }
    );
  }
);
const selectionStyleSheet = _tamagui_core__WEBPACK_IMPORTED_MODULE_13__.isClient ? document.createElement("style") : null;
if (selectionStyleSheet) {
  document.head.appendChild(selectionStyleSheet);
}
const SheetFrameFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_8__.YStack, {
  name: _constants__WEBPACK_IMPORTED_MODULE_9__.SHEET_NAME,
  flex: 1,
  backgroundColor: "$background",
  borderTopLeftRadius: "$true",
  borderTopRightRadius: "$true",
  width: "100%",
  maxHeight: "100%",
  overflow: "hidden",
  pointerEvents: "auto"
});
const SheetFrame = SheetFrameFrame.extractable(
  (0,react__WEBPACK_IMPORTED_MODULE_6__.forwardRef)(
    ({ __scopeSheet, ...props }, forwardedRef) => {
      const context = (0,_SheetContext__WEBPACK_IMPORTED_MODULE_10__.useSheetContext)(_constants__WEBPACK_IMPORTED_MODULE_9__.SHEET_NAME, __scopeSheet);
      const composedContentRef = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_14__.useComposedRefs)(forwardedRef, context.contentRef);
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SheetFrameFrame, { ref: composedContentRef, ...props });
    }
  )
);
const HIDDEN_SIZE = 1e4;
const sheetComponents = {
  Handle: SheetHandle,
  Frame: SheetFrame,
  Overlay: SheetOverlay,
  ScrollView: _SheetScrollView__WEBPACK_IMPORTED_MODULE_15__.SheetScrollView
};
const ParentSheetContext = (0,react__WEBPACK_IMPORTED_MODULE_6__.createContext)({
  zIndex: 40
});
const useSheetContoller = () => {
  const controller = (0,react__WEBPACK_IMPORTED_MODULE_6__.useContext)(SheetControllerContext);
  const isHidden = controller == null ? void 0 : controller.hidden;
  const isShowingNonSheet = isHidden && (controller == null ? void 0 : controller.open);
  return {
    controller,
    isHidden,
    isShowingNonSheet
  };
};
const Sheet = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_16__.withStaticProperties)(
  (0,react__WEBPACK_IMPORTED_MODULE_6__.forwardRef)(function Sheet2(props, ref) {
    const hydrated = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_17__.useDidFinishSSR)();
    const { isShowingNonSheet } = useSheetContoller();
    if (isShowingNonSheet || !hydrated) {
      return null;
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SheetImplementation, { ref, ...props });
  }),
  sheetComponents
);
const SheetImplementation = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_18__.themeable)(
  (0,react__WEBPACK_IMPORTED_MODULE_6__.forwardRef)(function SheetImplementation2(props, forwardedRef) {
    const parentSheet = (0,react__WEBPACK_IMPORTED_MODULE_6__.useContext)(ParentSheetContext);
    const { isHidden, controller } = useSheetContoller();
    const {
      __scopeSheet,
      snapPoints: snapPointsProp = [80],
      open: openProp,
      defaultOpen,
      children: childrenProp,
      position: positionProp,
      onPositionChange,
      onOpenChange,
      defaultPosition,
      dismissOnOverlayPress = true,
      animationConfig,
      dismissOnSnapToBottom = false,
      forceRemoveScrollEnabled = null,
      disableDrag: disableDragProp,
      modal = false,
      zIndex = parentSheet.zIndex + 1,
      moveOnKeyboardChange = false,
      portalProps
    } = props;
    if (true) {
      if (snapPointsProp.some((p) => p < 0 || p > 100)) {
        console.warn(
          "\u26A0\uFE0F Invalid snapPoint given, snapPoints must be between 0 and 100, equal to percent height of frame"
        );
      }
    }
    const sheetRef = (0,react__WEBPACK_IMPORTED_MODULE_6__.useRef)(null);
    const ref = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_14__.useComposedRefs)(forwardedRef, sheetRef);
    const driver = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_19__.useAnimationDriver)();
    if (!driver) {
      throw new Error("Must set animations in tamagui.config.ts");
    }
    const disableDrag = disableDragProp ?? (controller == null ? void 0 : controller.disableDrag);
    const keyboardIsVisible = (0,_tamagui_use_keyboard_visible__WEBPACK_IMPORTED_MODULE_5__.useKeyboardVisible)();
    const themeName = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_20__.useThemeName)();
    const contentRef = react__WEBPACK_IMPORTED_MODULE_6___default().useRef(null);
    const scrollBridge = (0,_tamagui_use_constant__WEBPACK_IMPORTED_MODULE_4__.useConstant)(() => ({
      enabled: false,
      y: 0,
      paneY: 0,
      paneMinY: 0,
      scrollStartY: -1,
      drag: () => {
      },
      release: () => {
      },
      scrollLock: false
    }));
    const onOpenChangeInternal = (val) => {
      var _a;
      (_a = controller == null ? void 0 : controller.onOpenChange) == null ? void 0 : _a.call(controller, val);
      onOpenChange == null ? void 0 : onOpenChange(val);
    };
    const [open, setOpen] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_21__.useControllableState)({
      prop: (controller == null ? void 0 : controller.open) ?? openProp,
      defaultProp: true,
      onChange: onOpenChangeInternal,
      strategy: "most-recent-wins",
      transition: true
    });
    const [frameSize, setFrameSize] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(0);
    const snapPoints = (0,react__WEBPACK_IMPORTED_MODULE_6__.useMemo)(
      () => dismissOnSnapToBottom ? [...snapPointsProp, 0] : snapPointsProp,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [JSON.stringify(snapPointsProp), dismissOnSnapToBottom]
    );
    const [position_, setPosition_] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_21__.useControllableState)({
      prop: positionProp,
      defaultProp: defaultPosition || (open ? 0 : -1),
      onChange: onPositionChange,
      strategy: "most-recent-wins",
      transition: true
    });
    const position = open === false ? -1 : position_;
    if (open && dismissOnSnapToBottom && position === snapPoints.length - 1) {
      setPosition_(0);
    }
    const setPosition = (0,react__WEBPACK_IMPORTED_MODULE_6__.useCallback)(
      (next) => {
        if (dismissOnSnapToBottom && next === snapPoints.length - 1) {
          setOpen(false);
        } else {
          setPosition_(next);
        }
      },
      [dismissOnSnapToBottom, snapPoints.length, setPosition_, setOpen]
    );
    const { useAnimatedNumber, useAnimatedNumberReaction, useAnimatedNumberStyle } = driver;
    const animatedNumber = useAnimatedNumber(HIDDEN_SIZE);
    const at = (0,react__WEBPACK_IMPORTED_MODULE_6__.useRef)(0);
    useAnimatedNumberReaction(
      {
        value: animatedNumber,
        hostRef: sheetRef
      },
      (value) => {
        if (!driver.isReactNative)
          return;
        at.current = value;
        scrollBridge.paneY = value;
      }
    );
    function stopSpring() {
      animatedNumber.stop();
      if (scrollBridge.onFinishAnimate) {
        scrollBridge.onFinishAnimate();
        scrollBridge.onFinishAnimate = void 0;
      }
    }
    const shouldSetPositionOpen = open && position < 0;
    (0,react__WEBPACK_IMPORTED_MODULE_6__.useEffect)(() => {
      if (shouldSetPositionOpen) {
        setPosition(0);
      }
    }, [setPosition, shouldSetPositionOpen]);
    const maxSnapPoint = snapPoints.reduce((prev, cur) => Math.max(prev, cur));
    const screenSize = frameSize / (maxSnapPoint / 100);
    const positions = (0,react__WEBPACK_IMPORTED_MODULE_6__.useMemo)(
      () => snapPoints.map((point) => getPercentSize(point, screenSize)),
      [frameSize, snapPoints]
    );
    const [opacity, setOpacity] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(open ? 1 : 0);
    if (open && opacity === 0) {
      setOpacity(1);
    }
    (0,react__WEBPACK_IMPORTED_MODULE_6__.useEffect)(() => {
      if (!open) {
        const tm = setTimeout(() => {
          setOpacity(0);
        }, 400);
        return () => {
          clearTimeout(tm);
        };
      }
    }, [open]);
    const animateTo = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_22__.useEvent)((position2) => {
      const current = animatedNumber.getValue();
      if (isHidden && open)
        return;
      if (!current)
        return;
      if (frameSize === 0)
        return;
      const hiddenValue = frameSize === 0 ? HIDDEN_SIZE : screenSize;
      const toValue = isHidden || position2 === -1 ? hiddenValue : positions[position2];
      if (at.current === toValue)
        return;
      stopSpring();
      if (isHidden) {
        animatedNumber.setValue(toValue, {
          type: "timing",
          duration: 0
        });
        at.current = toValue;
        return;
      }
      const overshootClamping = at.current === HIDDEN_SIZE;
      animatedNumber.setValue(toValue, {
        ...animationConfig,
        type: "spring",
        overshootClamping
      });
    });
    (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_13__.useIsomorphicLayoutEffect)(() => {
      animateTo(position);
    }, [isHidden, frameSize, position, animateTo]);
    const [isShowingInnerSheet, setIsShowingInnerSheet] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(false);
    const shouldHideParentSheet = !_tamagui_core__WEBPACK_IMPORTED_MODULE_13__.isWeb && modal && isShowingInnerSheet;
    const parentSheetContext = (0,react__WEBPACK_IMPORTED_MODULE_6__.useContext)(SheetInsideSheetContext);
    const onInnerSheet = (0,react__WEBPACK_IMPORTED_MODULE_6__.useCallback)((hasChild) => {
      setIsShowingInnerSheet(hasChild);
    }, []);
    const panResponder = (0,react__WEBPACK_IMPORTED_MODULE_6__.useMemo)(
      () => {
        if (disableDrag)
          return;
        if (!frameSize)
          return;
        if (isShowingInnerSheet)
          return;
        const minY = positions[0];
        scrollBridge.paneMinY = minY;
        let startY = at.current;
        function makeUnselectable(val) {
          if (!selectionStyleSheet)
            return;
          if (!val) {
            selectionStyleSheet.innerText = "";
          } else {
            selectionStyleSheet.innerText = ":root * { user-select: none !important; -webkit-user-select: none !important; }";
          }
        }
        const release = ({ vy, dragAt }) => {
          isExternalDrag = false;
          previouslyScrolling = false;
          makeUnselectable(false);
          const at2 = dragAt + startY;
          const end = at2 + frameSize * vy * 0.2;
          let closestPoint = 0;
          let dist = Infinity;
          for (let i = 0; i < positions.length; i++) {
            const position2 = positions[i];
            const curDist = end > position2 ? end - position2 : position2 - end;
            if (curDist < dist) {
              dist = curDist;
              closestPoint = i;
            }
          }
          setPosition(closestPoint);
          animateTo(closestPoint);
        };
        const finish = (_e, state) => {
          release({
            vy: state.vy,
            dragAt: state.dy
          });
        };
        let previouslyScrolling = false;
        const onMoveShouldSet = (_e, { dy }) => {
          const isScrolled = scrollBridge.y !== 0;
          const isDraggingUp = dy < 0;
          const isNearTop = scrollBridge.paneY - 5 <= scrollBridge.paneMinY;
          if (isScrolled) {
            previouslyScrolling = true;
            return false;
          }
          if (isNearTop) {
            if (!isScrolled && isDraggingUp) {
              return false;
            }
          }
          return Math.abs(dy) > 5;
        };
        const grant = () => {
          makeUnselectable(true);
          stopSpring();
          startY = at.current;
        };
        let isExternalDrag = false;
        scrollBridge.drag = (dy) => {
          if (!isExternalDrag) {
            isExternalDrag = true;
            grant();
          }
          const to = dy + startY;
          animatedNumber.setValue(resisted(to, minY), { type: "direct" });
        };
        scrollBridge.release = release;
        return react_native__WEBPACK_IMPORTED_MODULE_23__.PanResponder.create({
          onMoveShouldSetPanResponder: onMoveShouldSet,
          onPanResponderGrant: grant,
          onPanResponderMove: (_e, { dy }) => {
            const toFull = dy + startY;
            const to = resisted(toFull, minY);
            animatedNumber.setValue(to, { type: "direct" });
          },
          onPanResponderEnd: finish,
          onPanResponderTerminate: finish,
          onPanResponderRelease: finish
        });
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [disableDrag, isShowingInnerSheet, animateTo, frameSize, positions, setPosition]
    );
    let handleComponent = null;
    let overlayComponent = null;
    let frameComponent = null;
    react__WEBPACK_IMPORTED_MODULE_6___default().Children.forEach(childrenProp, (child) => {
      var _a, _b;
      if ((0,react__WEBPACK_IMPORTED_MODULE_6__.isValidElement)(child)) {
        const name = (_b = (_a = child.type) == null ? void 0 : _a["staticConfig"]) == null ? void 0 : _b.componentName;
        switch (name) {
          case "SheetHandle":
            handleComponent = child;
            break;
          case "Sheet":
            frameComponent = child;
            break;
          case "SheetOverlay":
            overlayComponent = child;
            break;
          default:
            console.warn("Warning: passed invalid child to Sheet", child);
        }
      }
    });
    const animatedStyle = useAnimatedNumberStyle(animatedNumber, (val) => {
      const translateY = frameSize === 0 ? HIDDEN_SIZE : val;
      return {
        transform: [{ translateY }]
      };
    });
    const sizeBeforeKeyboard = (0,react__WEBPACK_IMPORTED_MODULE_6__.useRef)(null);
    (0,react__WEBPACK_IMPORTED_MODULE_6__.useEffect)(() => {
      if (_tamagui_core__WEBPACK_IMPORTED_MODULE_13__.isWeb || !moveOnKeyboardChange)
        return;
      const keyboardDidShowListener = react_native__WEBPACK_IMPORTED_MODULE_23__.Keyboard.addListener("keyboardDidShow", (e) => {
        if (sizeBeforeKeyboard.current !== null)
          return;
        sizeBeforeKeyboard.current = animatedNumber.getValue();
        animatedNumber.setValue(
          Math.max(animatedNumber.getValue() - e.endCoordinates.height, 0)
        );
      });
      const keyboardDidHideListener = react_native__WEBPACK_IMPORTED_MODULE_23__.Keyboard.addListener("keyboardDidHide", () => {
        if (sizeBeforeKeyboard.current === null)
          return;
        animatedNumber.setValue(sizeBeforeKeyboard.current);
        sizeBeforeKeyboard.current = null;
      });
      return () => {
        keyboardDidHideListener.remove();
        keyboardDidShowListener.remove();
      };
    }, []);
    const AnimatedView = driver["NumberView"] ?? driver.View;
    (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_13__.useIsomorphicLayoutEffect)(() => {
      if (!(parentSheetContext && open))
        return;
      parentSheetContext(true);
      return () => {
        parentSheetContext(false);
      };
    }, [parentSheetContext, open]);
    const nextParentContext = (0,react__WEBPACK_IMPORTED_MODULE_6__.useMemo)(
      () => ({
        zIndex
      }),
      [zIndex]
    );
    const handleLayout = (0,react__WEBPACK_IMPORTED_MODULE_6__.useCallback)(
      (e) => {
        var _a;
        let next = (_a = e.nativeEvent) == null ? void 0 : _a.layout.height;
        if (_tamagui_core__WEBPACK_IMPORTED_MODULE_13__.isWeb && _tamagui_core__WEBPACK_IMPORTED_MODULE_13__.isTouchable && !open) {
          next += 100;
        }
        if (!next)
          return;
        setFrameSize(() => next);
      },
      [keyboardIsVisible]
    );
    const removeScrollEnabled = forceRemoveScrollEnabled ?? (open && modal);
    const contents = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ParentSheetContext.Provider, { value: nextParentContext, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(
      _SheetContext__WEBPACK_IMPORTED_MODULE_10__.SheetProvider,
      {
        modal,
        contentRef,
        frameSize,
        dismissOnOverlayPress,
        dismissOnSnapToBottom,
        open,
        hidden: !!isHidden,
        scope: __scopeSheet,
        position,
        snapPoints,
        setPosition,
        setOpen,
        scrollBridge,
        children: [
          shouldHideParentSheet ? null : overlayComponent,
          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(
            AnimatedView,
            {
              ref,
              ...panResponder == null ? void 0 : panResponder.panHandlers,
              onLayout: handleLayout,
              pointerEvents: open && !shouldHideParentSheet ? "auto" : "none",
              animation: props.animation,
              style: [
                {
                  position: "absolute",
                  zIndex,
                  width: "100%",
                  height: `${maxSnapPoint}%`,
                  opacity
                },
                animatedStyle
              ],
              children: [
                handleComponent,
                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
                  _tamagui_remove_scroll__WEBPACK_IMPORTED_MODULE_3__.RemoveScroll,
                  {
                    forwardProps: true,
                    enabled: removeScrollEnabled,
                    allowPinchZoom: true,
                    shards: [contentRef],
                    removeScrollBar: false,
                    children: frameComponent
                  }
                )
              ]
            }
          )
        ]
      }
    ) });
    const adaptContext = (0,react__WEBPACK_IMPORTED_MODULE_6__.useContext)(_tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__.AdaptParentContext);
    if (modal) {
      const modalContents = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_portal__WEBPACK_IMPORTED_MODULE_2__.Portal, { zIndex, ...portalProps, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_core__WEBPACK_IMPORTED_MODULE_24__.Theme, { forceClassName: true, name: themeName, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__.AdaptParentContext.Provider, { value: adaptContext, children: contents }) }) });
      if (_tamagui_core__WEBPACK_IMPORTED_MODULE_13__.isWeb) {
        return modalContents;
      }
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SheetInsideSheetContext.Provider, { value: onInnerSheet, children: modalContents });
    }
    return contents;
  }),
  { componentName: "Sheet" }
);
const SheetInsideSheetContext = (0,react__WEBPACK_IMPORTED_MODULE_6__.createContext)(null);
const ControlledSheet = Sheet;
function getPercentSize(point, screenSize) {
  if (!screenSize)
    return 0;
  if (point === void 0) {
    console.warn("No snapPoint");
    return 0;
  }
  const pct = point / 100;
  const next = Math.round(screenSize - pct * screenSize);
  return next;
}
function resisted(y, minY, maxOverflow = 25) {
  if (y < minY) {
    const past = minY - y;
    const pctPast = Math.min(maxOverflow, past) / maxOverflow;
    const diminishBy = 1.1 - Math.pow(0.1, pctPast);
    const extra = -diminishBy * maxOverflow;
    return minY + extra;
  }
  return y;
}
const SheetControllerContext = (0,react__WEBPACK_IMPORTED_MODULE_6__.createContext)(null);
const SheetController = ({
  children,
  onOpenChange: onOpenChangeProp,
  ...value
}) => {
  const onOpenChange = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_22__.useEvent)(onOpenChangeProp);
  const memoValue = (0,react__WEBPACK_IMPORTED_MODULE_6__.useMemo)(
    () => ({
      open: value.open,
      hidden: value.hidden,
      disableDrag: value.disableDrag,
      onOpenChange
    }),
    [onOpenChange, value.open, value.hidden, value.disableDrag]
  );
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SheetControllerContext.Provider, { value: memoValue, children });
};

//# sourceMappingURL=Sheet.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/sheet/dist/esm/SheetContext.mjs":
/*!*******************************************************************!*\
  !*** ../../node_modules/@tamagui/sheet/dist/esm/SheetContext.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SheetProvider": () => (/* binding */ SheetProvider),
/* harmony export */   "createSheetContext": () => (/* binding */ createSheetContext),
/* harmony export */   "createSheetScope": () => (/* binding */ createSheetScope),
/* harmony export */   "useSheetContext": () => (/* binding */ useSheetContext)
/* harmony export */ });
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "../../node_modules/@tamagui/sheet/dist/esm/constants.mjs");


const [createSheetContext, createSheetScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_0__.createContextScope)(_constants__WEBPACK_IMPORTED_MODULE_1__.SHEET_NAME);
const [SheetProvider, useSheetContext] = createSheetContext(
  _constants__WEBPACK_IMPORTED_MODULE_1__.SHEET_NAME,
  {}
);

//# sourceMappingURL=SheetContext.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/sheet/dist/esm/SheetScrollView.mjs":
/*!**********************************************************************!*\
  !*** ../../node_modules/@tamagui/sheet/dist/esm/SheetScrollView.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SheetScrollView": () => (/* binding */ SheetScrollView)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/core/dist/esm/index.mjs");
/* harmony import */ var _tamagui_scroll_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/scroll-view */ "../../node_modules/@tamagui/scroll-view/dist/esm/ScrollView.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _SheetContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SheetContext */ "../../node_modules/@tamagui/sheet/dist/esm/SheetContext.mjs");





const SHEET_SCROLL_VIEW_NAME = "SheetScrollView";
const SheetScrollView = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(
  ({ __scopeSheet, children, ...props }, ref) => {
    const { scrollBridge, position, snapPoints, frameSize, open } = (0,_SheetContext__WEBPACK_IMPORTED_MODULE_2__.useSheetContext)(
      SHEET_SCROLL_VIEW_NAME,
      __scopeSheet
    );
    const scrollRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
    const percentOpened = snapPoints[position] ?? 0;
    const [percentToPadBottom, setPercentToPadBottom] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);
    const next = 100 - percentOpened;
    if (open && next !== percentToPadBottom) {
      setPercentToPadBottom(next);
    }
    const state = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({
      lastPageY: 0,
      dragAt: 0,
      dys: [],
      // store a few recent dys to get velocity on release
      isScrolling: false,
      isDragging: false
    });
    const release = () => {
      if (!state.current.isDragging) {
        return;
      }
      state.current.isDragging = false;
      scrollBridge.scrollStartY = -1;
      state.current.isScrolling = false;
      let vy = 0;
      if (state.current.dys.length) {
        const recentDys = state.current.dys.slice(-10);
        const dist = recentDys.length ? recentDys.reduce((a, b) => a + b, 0) : 0;
        const avgDy = dist / recentDys.length;
        vy = avgDy * 0.04;
      }
      state.current.dys = [];
      scrollBridge.release({
        dragAt: state.current.dragAt,
        vy
      });
    };
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(
      _tamagui_scroll_view__WEBPACK_IMPORTED_MODULE_3__.ScrollView,
      {
        ref: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.composeRefs)(scrollRef, ref),
        flex: 1,
        scrollEventThrottle: 8,
        onScroll: (e) => {
          const { y } = e.nativeEvent.contentOffset;
          scrollBridge.y = y;
          if (y > 0) {
            scrollBridge.scrollStartY = -1;
          }
        },
        onStartShouldSetResponder: () => {
          scrollBridge.scrollStartY = -1;
          state.current.isDragging = true;
          return true;
        },
        onMoveShouldSetResponder: () => false,
        onResponderRelease: release,
        className: "_ovs-contain",
        ...props,
        children: [
          (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => children, [children]),
          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.Stack, { height: percentToPadBottom / 100 * frameSize, width: 0 })
        ]
      }
    );
  }
);

//# sourceMappingURL=SheetScrollView.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/sheet/dist/esm/constants.mjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@tamagui/sheet/dist/esm/constants.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SHEET_HANDLE_NAME": () => (/* binding */ SHEET_HANDLE_NAME),
/* harmony export */   "SHEET_NAME": () => (/* binding */ SHEET_NAME),
/* harmony export */   "constants": () => (/* binding */ constants)
/* harmony export */ });
const constants = {};
const SHEET_NAME = "Sheet";
const SHEET_HANDLE_NAME = "SheetHandle";

//# sourceMappingURL=constants.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/sheet/dist/esm/index.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/@tamagui/sheet/dist/esm/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ControlledSheet": () => (/* reexport safe */ _Sheet__WEBPACK_IMPORTED_MODULE_0__.ControlledSheet),
/* harmony export */   "Sheet": () => (/* reexport safe */ _Sheet__WEBPACK_IMPORTED_MODULE_0__.Sheet),
/* harmony export */   "SheetController": () => (/* reexport safe */ _Sheet__WEBPACK_IMPORTED_MODULE_0__.SheetController),
/* harmony export */   "SheetFrame": () => (/* reexport safe */ _Sheet__WEBPACK_IMPORTED_MODULE_0__.SheetFrame),
/* harmony export */   "SheetFrameFrame": () => (/* reexport safe */ _Sheet__WEBPACK_IMPORTED_MODULE_0__.SheetFrameFrame),
/* harmony export */   "SheetHandle": () => (/* reexport safe */ _Sheet__WEBPACK_IMPORTED_MODULE_0__.SheetHandle),
/* harmony export */   "SheetHandleFrame": () => (/* reexport safe */ _Sheet__WEBPACK_IMPORTED_MODULE_0__.SheetHandleFrame),
/* harmony export */   "SheetOverlay": () => (/* reexport safe */ _Sheet__WEBPACK_IMPORTED_MODULE_0__.SheetOverlay),
/* harmony export */   "SheetOverlayFrame": () => (/* reexport safe */ _Sheet__WEBPACK_IMPORTED_MODULE_0__.SheetOverlayFrame),
/* harmony export */   "createSheetScope": () => (/* reexport safe */ _Sheet__WEBPACK_IMPORTED_MODULE_0__.createSheetScope)
/* harmony export */ });
/* harmony import */ var _Sheet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sheet */ "../../node_modules/@tamagui/sheet/dist/esm/Sheet.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/slider/dist/esm/Slider.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/slider/dist/esm/Slider.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Range": () => (/* binding */ Range),
/* harmony export */   "Slider": () => (/* binding */ Slider),
/* harmony export */   "SliderThumb": () => (/* binding */ SliderThumb),
/* harmony export */   "SliderThumbFrame": () => (/* binding */ SliderThumbFrame),
/* harmony export */   "SliderTrack": () => (/* binding */ SliderTrack),
/* harmony export */   "SliderTrackActive": () => (/* binding */ SliderTrackActive),
/* harmony export */   "SliderTrackActiveFrame": () => (/* binding */ SliderTrackActiveFrame),
/* harmony export */   "SliderTrackFrame": () => (/* binding */ SliderTrackFrame),
/* harmony export */   "Thumb": () => (/* binding */ Thumb),
/* harmony export */   "Track": () => (/* binding */ Track)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_get_size__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/get-size */ "../../node_modules/@tamagui/get-size/dist/esm/index.mjs");
/* harmony import */ var _tamagui_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/helpers */ "../../node_modules/@tamagui/helpers/dist/esm/index.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");
/* harmony import */ var _tamagui_use_direction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/use-direction */ "../../node_modules/@tamagui/use-direction/dist/esm/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "../../node_modules/@tamagui/slider/dist/esm/constants.mjs");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers */ "../../node_modules/@tamagui/slider/dist/esm/helpers.mjs");
/* harmony import */ var _SliderImpl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SliderImpl */ "../../node_modules/@tamagui/slider/dist/esm/SliderImpl.mjs");












const SliderHorizontal = react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(
  (props, forwardedRef) => {
    const { min, max, dir, onSlideStart, onSlideMove, onStepKeyDown, ...sliderProps } = props;
    const direction = (0,_tamagui_use_direction__WEBPACK_IMPORTED_MODULE_2__.useDirection)(dir);
    const isDirectionLTR = direction === "ltr";
    const sliderRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);
    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_3__.useState(() => ({ size: 0, offset: 0 }));
    function getValueFromPointer(pointerPosition) {
      const input = [0, state.size];
      const output = isDirectionLTR ? [min, max] : [max, min];
      const value = (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.linearScale)(input, output);
      return value(pointerPosition);
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _constants__WEBPACK_IMPORTED_MODULE_5__.SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isDirectionLTR ? "left" : "right",
        endEdge: isDirectionLTR ? "right" : "left",
        direction: isDirectionLTR ? 1 : -1,
        sizeProp: "width",
        size: state.size,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          _SliderImpl__WEBPACK_IMPORTED_MODULE_6__.SliderImpl,
          {
            ref: (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_7__.composeRefs)(forwardedRef, sliderRef),
            dir: direction,
            ...sliderProps,
            orientation: "horizontal",
            onLayout: () => {
              var _a;
              (_a = sliderRef.current) == null ? void 0 : _a.measure((_x, _y, width, _height, pageX, _pageY) => {
                setState({
                  size: width,
                  offset: pageX
                });
              });
            },
            onSlideStart: (event, target) => {
              const value = getValueFromPointer(event.nativeEvent.locationX);
              if (value) {
                onSlideStart == null ? void 0 : onSlideStart(value, target);
              }
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.nativeEvent.pageX - state.offset);
              if (value) {
                onSlideMove == null ? void 0 : onSlideMove(value);
              }
            },
            onSlideEnd: () => {
            },
            onStepKeyDown: (event) => {
              const isBackKey = _constants__WEBPACK_IMPORTED_MODULE_5__.BACK_KEYS[direction].includes(event.key);
              onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
const SliderVertical = react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(
  (props, forwardedRef) => {
    const { min, max, onSlideStart, onSlideMove, onStepKeyDown, ...sliderProps } = props;
    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_3__.useState(() => ({ size: 0, offset: 0 }));
    const sliderRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);
    function getValueFromPointer(pointerPosition) {
      const input = [0, state.size];
      const output = [max, min];
      const value = (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.linearScale)(input, output);
      return value(pointerPosition);
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _constants__WEBPACK_IMPORTED_MODULE_5__.SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: "bottom",
        endEdge: "top",
        sizeProp: "height",
        size: state.size,
        direction: 1,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          _SliderImpl__WEBPACK_IMPORTED_MODULE_6__.SliderImpl,
          {
            ref: (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_7__.composeRefs)(forwardedRef, sliderRef),
            ...sliderProps,
            orientation: "vertical",
            onLayout: ({ nativeEvent: { layout } }) => {
              var _a;
              (_a = sliderRef.current) == null ? void 0 : _a.measure((_x, _y, _width, height, _pageX, pageY) => {
                setState({
                  size: height,
                  offset: pageY
                });
              });
            },
            onSlideStart: (event, target) => {
              const value = getValueFromPointer(event.nativeEvent.locationY);
              if (value) {
                onSlideStart == null ? void 0 : onSlideStart(value, target);
              }
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.nativeEvent.pageY - state.offset);
              if (value) {
                onSlideMove == null ? void 0 : onSlideMove(value);
              }
            },
            onSlideEnd: () => {
            },
            onStepKeyDown: (event) => {
              const isBackKey = _constants__WEBPACK_IMPORTED_MODULE_5__.BACK_KEYS.ltr.includes(event.key);
              onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
const TRACK_NAME = "SliderTrack";
const SliderTrackFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_SliderImpl__WEBPACK_IMPORTED_MODULE_6__.SliderFrame, {
  name: "SliderTrack",
  height: "100%",
  width: "100%",
  backgroundColor: "$background",
  position: "relative",
  borderRadius: 1e5,
  overflow: "hidden"
});
const SliderTrack = react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...trackProps } = props;
    const context = (0,_constants__WEBPACK_IMPORTED_MODULE_5__.useSliderContext)(TRACK_NAME, __scopeSlider);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      SliderTrackFrame,
      {
        "data-disabled": context.disabled ? "" : void 0,
        "data-orientation": context.orientation,
        orientation: context.orientation,
        size: context.size,
        ...trackProps,
        ref: forwardedRef
      }
    );
  }
);
SliderTrack.displayName = TRACK_NAME;
const RANGE_NAME = "SliderTrackActive";
const SliderTrackActiveFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_SliderImpl__WEBPACK_IMPORTED_MODULE_6__.SliderFrame, {
  name: "SliderTrackActive",
  backgroundColor: "$background",
  position: "absolute"
});
const SliderTrackActive = react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...rangeProps } = props;
    const context = (0,_constants__WEBPACK_IMPORTED_MODULE_5__.useSliderContext)(RANGE_NAME, __scopeSlider);
    const orientation = (0,_constants__WEBPACK_IMPORTED_MODULE_5__.useSliderOrientationContext)(RANGE_NAME, __scopeSlider);
    const ref = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);
    const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_7__.useComposedRefs)(forwardedRef, ref);
    const valuesCount = context.values.length;
    const percentages = context.values.map(
      (value) => (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.convertValueToPercentage)(value, context.min, context.max)
    );
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      SliderTrackActiveFrame,
      {
        orientation: context.orientation,
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0,
        size: context.size,
        ...rangeProps,
        ref: composedRefs,
        ...{
          [orientation.startEdge]: `${offsetStart}%`,
          [orientation.endEdge]: `${offsetEnd}%`
        },
        ...orientation.sizeProp === "width" ? {
          height: "100%"
        } : {
          left: 0,
          right: 0
        }
      }
    );
  }
);
SliderTrackActive.displayName = RANGE_NAME;
const THUMB_NAME = "SliderThumb";
const getThumbSize = (val) => {
  const size = typeof val === "number" ? val : (0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_9__.getSize)(val, -1);
  return {
    width: size,
    height: size,
    minWidth: size,
    minHeight: size
  };
};
const SliderThumbFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_10__.ThemeableStack, {
  name: "SliderThumb",
  position: "absolute",
  bordered: 2,
  borderWidth: 2,
  backgrounded: true,
  pressTheme: _tamagui_core__WEBPACK_IMPORTED_MODULE_11__.isWeb,
  focusTheme: _tamagui_core__WEBPACK_IMPORTED_MODULE_11__.isWeb,
  hoverTheme: _tamagui_core__WEBPACK_IMPORTED_MODULE_11__.isWeb,
  variants: {
    size: {
      "...size": getThumbSize
    }
  }
});
const SliderThumb = react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, index, size: sizeProp, ...thumbProps } = props;
    const context = (0,_constants__WEBPACK_IMPORTED_MODULE_5__.useSliderContext)(THUMB_NAME, __scopeSlider);
    const orientation = (0,_constants__WEBPACK_IMPORTED_MODULE_5__.useSliderOrientationContext)(THUMB_NAME, __scopeSlider);
    const [thumb, setThumb] = react__WEBPACK_IMPORTED_MODULE_3__.useState(null);
    const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_7__.useComposedRefs)(forwardedRef, (node) => setThumb(node));
    const value = context.values[index];
    const percent = value === void 0 ? 0 : (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.convertValueToPercentage)(value, context.min, context.max);
    const label = (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.getLabel)(index, context.values.length);
    const sizeIn = sizeProp ?? context.size ?? "$true";
    const [size, setSize] = react__WEBPACK_IMPORTED_MODULE_3__.useState(() => {
      const estimatedSize = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_12__.getVariableValue)(getThumbSize(sizeIn).width);
      return estimatedSize;
    });
    const thumbInBoundsOffset = size ? (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.getThumbInBoundsOffset)(size, percent, orientation.direction) : 0;
    react__WEBPACK_IMPORTED_MODULE_3__.useEffect(() => {
      if (thumb) {
        context.thumbs.add(thumb);
        return () => {
          context.thumbs.delete(thumb);
        };
      }
    }, [thumb, context.thumbs]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      SliderThumbFrame,
      {
        ref: composedRefs,
        role: "slider",
        "aria-label": props["aria-label"] || label,
        "aria-valuemin": context.min,
        "aria-valuenow": value,
        "aria-valuemax": context.max,
        "aria-orientation": context.orientation,
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0,
        tabIndex: context.disabled ? void 0 : 0,
        animateOnly: ["transform", "left", "right", "top", "bottom"],
        ...thumbProps,
        ...context.orientation === "horizontal" ? {
          x: thumbInBoundsOffset - size / 2,
          y: -size / 2,
          top: "50%",
          ...size === 0 && {
            top: "auto",
            bottom: "auto"
          }
        } : {
          x: -size / 2,
          y: size / 2,
          left: "50%",
          ...size === 0 && {
            left: "auto",
            right: "auto"
          }
        },
        ...{
          [orientation.startEdge]: `${percent}%`
        },
        size: sizeIn,
        onLayout: (e) => {
          setSize(e.nativeEvent.layout[orientation.sizeProp]);
        },
        onFocus: (0,_tamagui_helpers__WEBPACK_IMPORTED_MODULE_1__.composeEventHandlers)(props.onFocus, () => {
          context.valueIndexToChangeRef.current = index;
        })
      }
    );
  }
);
SliderThumb.displayName = THUMB_NAME;
const Slider = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_13__.withStaticProperties)(
  react__WEBPACK_IMPORTED_MODULE_3__.forwardRef((props, forwardedRef) => {
    const {
      name,
      min = 0,
      max = 100,
      step = 1,
      orientation = "horizontal",
      disabled = false,
      minStepsBetweenThumbs = 0,
      defaultValue = [min],
      value,
      onValueChange = () => {
      },
      size: sizeProp,
      ...sliderProps
    } = props;
    const sliderRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);
    const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_7__.useComposedRefs)(sliderRef, forwardedRef);
    const thumbRefs = react__WEBPACK_IMPORTED_MODULE_3__.useRef(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(0);
    const isHorizontal = orientation === "horizontal";
    const [values = [], setValues] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_14__.useControllableState)({
      prop: value,
      defaultProp: defaultValue,
      transition: true,
      onChange: (value2) => {
        var _a;
        if (_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.isWeb) {
          const thumbs = [...thumbRefs.current];
          (_a = thumbs[valueIndexToChangeRef.current]) == null ? void 0 : _a.focus();
        }
        onValueChange(value2);
      }
    });
    if (_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.isWeb) {
      react__WEBPACK_IMPORTED_MODULE_3__.useEffect(() => {
        const node = sliderRef.current;
        if (!node)
          return;
        const preventDefault = (e) => {
          e.preventDefault();
        };
        node.addEventListener("touchstart", preventDefault);
        return () => {
          node.removeEventListener("touchstart", preventDefault);
        };
      }, []);
    }
    function handleSlideMove(value2) {
      updateValues(value2, valueIndexToChangeRef.current);
    }
    function updateValues(value2, atIndex) {
      const decimalCount = (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.getDecimalCount)(step);
      const snapToStep = (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.roundValue)(
        Math.round((value2 - min) / step) * step + min,
        decimalCount
      );
      const nextValue = (0,_tamagui_helpers__WEBPACK_IMPORTED_MODULE_1__.clamp)(snapToStep, [min, max]);
      setValues((prevValues = []) => {
        const nextValues = (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.getNextSortedValues)(prevValues, nextValue, atIndex);
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_4__.hasMinStepsBetweenValues)(nextValues, minStepsBetweenThumbs * step)) {
          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
          return String(nextValues) === String(prevValues) ? prevValues : nextValues;
        } else {
          return prevValues;
        }
      });
    }
    const SliderOriented = isHorizontal ? SliderHorizontal : SliderVertical;
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _constants__WEBPACK_IMPORTED_MODULE_5__.SliderProvider,
      {
        scope: props.__scopeSlider,
        disabled,
        min,
        max,
        valueIndexToChangeRef,
        thumbs: thumbRefs.current,
        values,
        orientation,
        size: sizeProp,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          SliderOriented,
          {
            "aria-disabled": disabled,
            "data-disabled": disabled ? "" : void 0,
            ...sliderProps,
            ref: composedRefs,
            min,
            max,
            onSlideStart: disabled ? void 0 : (value2, target) => {
              if (target !== "thumb") {
                const closestIndex = (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.getClosestValueIndex)(values, value2);
                updateValues(value2, closestIndex);
              }
            },
            onSlideMove: disabled ? void 0 : handleSlideMove,
            onHomeKeyDown: () => !disabled && updateValues(min, 0),
            onEndKeyDown: () => !disabled && updateValues(max, values.length - 1),
            onStepKeyDown: ({ event, direction: stepDirection }) => {
              if (!disabled) {
                const isPageKey = _constants__WEBPACK_IMPORTED_MODULE_5__.PAGE_KEYS.includes(event.key);
                const isSkipKey = isPageKey || event.shiftKey && _constants__WEBPACK_IMPORTED_MODULE_5__.ARROW_KEYS.includes(event.key);
                const multiplier = isSkipKey ? 10 : 1;
                const atIndex = valueIndexToChangeRef.current;
                const value2 = values[atIndex];
                const stepInDirection = step * multiplier * stepDirection;
                updateValues(value2 + stepInDirection, atIndex);
              }
            }
          }
        )
      }
    );
  }),
  {
    Track: SliderTrack,
    TrackActive: SliderTrackActive,
    Thumb: SliderThumb
  }
);
Slider.displayName = _constants__WEBPACK_IMPORTED_MODULE_5__.SLIDER_NAME;
const Track = SliderTrack;
const Range = SliderTrackActive;
const Thumb = SliderThumb;

//# sourceMappingURL=Slider.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/slider/dist/esm/SliderImpl.mjs":
/*!******************************************************************!*\
  !*** ../../node_modules/@tamagui/slider/dist/esm/SliderImpl.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DirectionalYStack": () => (/* binding */ DirectionalYStack),
/* harmony export */   "SliderFrame": () => (/* binding */ SliderFrame),
/* harmony export */   "SliderImpl": () => (/* binding */ SliderImpl)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/index.mjs");
/* harmony import */ var _tamagui_get_size__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/get-size */ "../../node_modules/@tamagui/get-size/dist/esm/index.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "../../node_modules/@tamagui/slider/dist/esm/constants.mjs");






const DirectionalYStack = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_3__.YStack, {
  variants: {
    orientation: {
      horizontal: {},
      vertical: {}
    }
  }
});
const SliderFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.styled)(DirectionalYStack, {
  position: "relative",
  variants: {
    size: (val, extras) => {
      const orientation = extras.props.orientation;
      const size = Math.round((0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.getVariableValue)((0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_5__.getSize)(val)) / 6);
      if (orientation === "horizontal") {
        return {
          height: size,
          borderRadius: size,
          justifyContent: "center"
        };
      }
      return {
        width: size,
        borderRadius: size,
        alignItems: "center"
      };
    }
  }
});
const SliderImpl = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSlider,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onHomeKeyDown,
      onEndKeyDown,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const context = (0,_constants__WEBPACK_IMPORTED_MODULE_6__.useSliderContext)(_constants__WEBPACK_IMPORTED_MODULE_6__.SLIDER_NAME, __scopeSlider);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      SliderFrame,
      {
        size: "$4",
        ...sliderProps,
        "data-orientation": sliderProps.orientation,
        ref: forwardedRef,
        ..._tamagui_core__WEBPACK_IMPORTED_MODULE_7__.isWeb && {
          onKeyDown: (event) => {
            if (event.key === "Home") {
              onHomeKeyDown(event);
              event.preventDefault();
            } else if (event.key === "End") {
              onEndKeyDown(event);
              event.preventDefault();
            } else if (_constants__WEBPACK_IMPORTED_MODULE_6__.PAGE_KEYS.concat(_constants__WEBPACK_IMPORTED_MODULE_6__.ARROW_KEYS).includes(event.key)) {
              onStepKeyDown(event);
              event.preventDefault();
            }
          }
        },
        onMoveShouldSetResponderCapture: () => true,
        onScrollShouldSetResponder: () => true,
        onScrollShouldSetResponderCapture: () => true,
        onMoveShouldSetResponder: () => true,
        onStartShouldSetResponder: () => true,
        onResponderTerminationRequest: () => {
          return false;
        },
        onResponderGrant: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.composeEventHandlers)(props.onResponderGrant, (event) => {
          const target = event.target;
          const isStartingOnThumb = context.thumbs.has(target);
          if (_tamagui_core__WEBPACK_IMPORTED_MODULE_7__.isWeb && target instanceof HTMLElement) {
            if (context.thumbs.has(target)) {
              target.focus();
            }
          }
          onSlideStart(event, isStartingOnThumb ? "thumb" : "track");
        }),
        onResponderMove: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.composeEventHandlers)(props.onResponderMove, (event) => {
          event.stopPropagation();
          onSlideMove(event);
        }),
        onResponderRelease: (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.composeEventHandlers)(props.onResponderRelease, (event) => {
          onSlideEnd(event);
        })
      }
    );
  }
);

//# sourceMappingURL=SliderImpl.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/slider/dist/esm/constants.mjs":
/*!*****************************************************************!*\
  !*** ../../node_modules/@tamagui/slider/dist/esm/constants.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ARROW_KEYS": () => (/* binding */ ARROW_KEYS),
/* harmony export */   "BACK_KEYS": () => (/* binding */ BACK_KEYS),
/* harmony export */   "PAGE_KEYS": () => (/* binding */ PAGE_KEYS),
/* harmony export */   "SLIDER_NAME": () => (/* binding */ SLIDER_NAME),
/* harmony export */   "SliderOrientationProvider": () => (/* binding */ SliderOrientationProvider),
/* harmony export */   "SliderProvider": () => (/* binding */ SliderProvider),
/* harmony export */   "createSliderContext": () => (/* binding */ createSliderContext),
/* harmony export */   "createSliderScope": () => (/* binding */ createSliderScope),
/* harmony export */   "useSliderContext": () => (/* binding */ useSliderContext),
/* harmony export */   "useSliderOrientationContext": () => (/* binding */ useSliderOrientationContext)
/* harmony export */ });
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");

const SLIDER_NAME = "Slider";
const [createSliderContext, createSliderScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_0__.createContextScope)(SLIDER_NAME);
const [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
const [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
  startEdge: "left",
  endEdge: "right",
  sizeProp: "width",
  size: 0,
  direction: 1
});
const PAGE_KEYS = ["PageUp", "PageDown"];
const ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
const BACK_KEYS = {
  ltr: ["ArrowDown", "Home", "ArrowLeft", "PageDown"],
  rtl: ["ArrowDown", "Home", "ArrowRight", "PageDown"]
};

//# sourceMappingURL=constants.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/slider/dist/esm/helpers.mjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@tamagui/slider/dist/esm/helpers.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertValueToPercentage": () => (/* binding */ convertValueToPercentage),
/* harmony export */   "getClosestValueIndex": () => (/* binding */ getClosestValueIndex),
/* harmony export */   "getDecimalCount": () => (/* binding */ getDecimalCount),
/* harmony export */   "getLabel": () => (/* binding */ getLabel),
/* harmony export */   "getNextSortedValues": () => (/* binding */ getNextSortedValues),
/* harmony export */   "getThumbInBoundsOffset": () => (/* binding */ getThumbInBoundsOffset),
/* harmony export */   "hasMinStepsBetweenValues": () => (/* binding */ hasMinStepsBetweenValues),
/* harmony export */   "linearScale": () => (/* binding */ linearScale),
/* harmony export */   "roundValue": () => (/* binding */ roundValue)
/* harmony export */ });
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a, b) => a - b);
}
function convertValueToPercentage(value, min, max) {
  const maxSteps = max - min;
  const percentPerStep = 100 / maxSteps;
  return percentPerStep * (value - min);
}
function getLabel(index, totalValues) {
  if (totalValues > 2) {
    return `Value ${index + 1} of ${totalValues}`;
  } else if (totalValues === 2) {
    return ["Minimum", "Maximum"][index];
  } else {
    return void 0;
  }
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1)
    return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset = linearScale([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index) => values[index + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}

//# sourceMappingURL=helpers.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/slider/dist/esm/index.mjs":
/*!*************************************************************!*\
  !*** ../../node_modules/@tamagui/slider/dist/esm/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DirectionalYStack": () => (/* reexport safe */ _SliderImpl__WEBPACK_IMPORTED_MODULE_1__.DirectionalYStack),
/* harmony export */   "Range": () => (/* reexport safe */ _Slider__WEBPACK_IMPORTED_MODULE_0__.Range),
/* harmony export */   "Slider": () => (/* reexport safe */ _Slider__WEBPACK_IMPORTED_MODULE_0__.Slider),
/* harmony export */   "SliderFrame": () => (/* reexport safe */ _SliderImpl__WEBPACK_IMPORTED_MODULE_1__.SliderFrame),
/* harmony export */   "SliderThumb": () => (/* reexport safe */ _Slider__WEBPACK_IMPORTED_MODULE_0__.SliderThumb),
/* harmony export */   "SliderThumbFrame": () => (/* reexport safe */ _Slider__WEBPACK_IMPORTED_MODULE_0__.SliderThumbFrame),
/* harmony export */   "SliderTrack": () => (/* reexport safe */ _Slider__WEBPACK_IMPORTED_MODULE_0__.SliderTrack),
/* harmony export */   "SliderTrackActive": () => (/* reexport safe */ _Slider__WEBPACK_IMPORTED_MODULE_0__.SliderTrackActive),
/* harmony export */   "SliderTrackActiveFrame": () => (/* reexport safe */ _Slider__WEBPACK_IMPORTED_MODULE_0__.SliderTrackActiveFrame),
/* harmony export */   "SliderTrackFrame": () => (/* reexport safe */ _Slider__WEBPACK_IMPORTED_MODULE_0__.SliderTrackFrame),
/* harmony export */   "Thumb": () => (/* reexport safe */ _Slider__WEBPACK_IMPORTED_MODULE_0__.Thumb),
/* harmony export */   "Track": () => (/* reexport safe */ _Slider__WEBPACK_IMPORTED_MODULE_0__.Track)
/* harmony export */ });
/* harmony import */ var _Slider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Slider */ "../../node_modules/@tamagui/slider/dist/esm/Slider.mjs");
/* harmony import */ var _SliderImpl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SliderImpl */ "../../node_modules/@tamagui/slider/dist/esm/SliderImpl.mjs");



//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/stacks/dist/esm/SizableStack.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@tamagui/stacks/dist/esm/SizableStack.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SizableStack": () => (/* binding */ SizableStack)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_get_button_sized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/get-button-sized */ "../../node_modules/@tamagui/get-button-sized/dist/esm/index.mjs");
/* harmony import */ var _Stacks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.mjs");
/* harmony import */ var _variants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./variants */ "../../node_modules/@tamagui/stacks/dist/esm/variants.mjs");




const SizableStack = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.styled)(_Stacks__WEBPACK_IMPORTED_MODULE_1__.XStack, {
  name: "SizableStack",
  variants: {
    unstyled: {
      true: {
        hoverTheme: false,
        pressTheme: false,
        focusTheme: false,
        elevate: false,
        bordered: false
      },
      false: {
        backgroundColor: "$background",
        flexShrink: 1
      }
    },
    hoverTheme: _variants__WEBPACK_IMPORTED_MODULE_2__.hoverTheme,
    pressTheme: _variants__WEBPACK_IMPORTED_MODULE_2__.pressTheme,
    focusTheme: _variants__WEBPACK_IMPORTED_MODULE_2__.focusTheme,
    circular: _variants__WEBPACK_IMPORTED_MODULE_2__.circular,
    elevate: _variants__WEBPACK_IMPORTED_MODULE_2__.elevate,
    bordered: _variants__WEBPACK_IMPORTED_MODULE_2__.bordered,
    size: {
      "...size": _tamagui_get_button_sized__WEBPACK_IMPORTED_MODULE_3__.getButtonSized
    }
  }
});

//# sourceMappingURL=SizableStack.js.map


/***/ }),

/***/ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/stacks/dist/esm/Stacks.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "XStack": () => (/* binding */ XStack),
/* harmony export */   "YStack": () => (/* binding */ YStack),
/* harmony export */   "ZStack": () => (/* binding */ ZStack),
/* harmony export */   "fullscreenStyle": () => (/* binding */ fullscreenStyle)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/core/dist/esm/index.mjs");
/* harmony import */ var _getElevation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getElevation.js */ "../../node_modules/@tamagui/stacks/dist/esm/getElevation.js");


const fullscreenStyle = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
};
const variants = {
  fullscreen: {
    true: fullscreenStyle
  },
  elevation: {
    "...size": _getElevation_js__WEBPACK_IMPORTED_MODULE_0__.getElevation
  }
};
const YStack = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.Stack, {
  flexDirection: "column",
  name: "YStack",
  variants
});
const XStack = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.Stack, {
  flexDirection: "row",
  name: "XStack",
  variants
});
const ZStack = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.styled)(
  YStack,
  {
    name: "ZStack",
    position: "relative"
  },
  {
    neverFlatten: true,
    isZStack: true
  }
);

//# sourceMappingURL=Stacks.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/stacks/dist/esm/index.mjs":
/*!*************************************************************!*\
  !*** ../../node_modules/@tamagui/stacks/dist/esm/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SizableStack": () => (/* reexport safe */ _SizableStack_js__WEBPACK_IMPORTED_MODULE_1__.SizableStack),
/* harmony export */   "ThemeableStack": () => (/* reexport safe */ _ThemeableStack_js__WEBPACK_IMPORTED_MODULE_2__.ThemeableStack),
/* harmony export */   "XStack": () => (/* reexport safe */ _Stacks_js__WEBPACK_IMPORTED_MODULE_0__.XStack),
/* harmony export */   "YStack": () => (/* reexport safe */ _Stacks_js__WEBPACK_IMPORTED_MODULE_0__.YStack),
/* harmony export */   "ZStack": () => (/* reexport safe */ _Stacks_js__WEBPACK_IMPORTED_MODULE_0__.ZStack),
/* harmony export */   "fullscreenStyle": () => (/* reexport safe */ _Stacks_js__WEBPACK_IMPORTED_MODULE_0__.fullscreenStyle)
/* harmony export */ });
/* harmony import */ var _Stacks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Stacks.js */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var _SizableStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SizableStack.js */ "../../node_modules/@tamagui/stacks/dist/esm/SizableStack.js");
/* harmony import */ var _ThemeableStack_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ThemeableStack.js */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");



//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/stacks/dist/esm/variants.mjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@tamagui/stacks/dist/esm/variants.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bordered": () => (/* binding */ bordered),
/* harmony export */   "circular": () => (/* binding */ circular),
/* harmony export */   "elevate": () => (/* binding */ elevate),
/* harmony export */   "focusTheme": () => (/* binding */ focusTheme),
/* harmony export */   "hoverTheme": () => (/* binding */ hoverTheme),
/* harmony export */   "padded": () => (/* binding */ padded),
/* harmony export */   "pressTheme": () => (/* binding */ pressTheme),
/* harmony export */   "radiused": () => (/* binding */ radiused)
/* harmony export */ });
/* harmony import */ var _getElevation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getElevation */ "../../node_modules/@tamagui/stacks/dist/esm/getElevation.mjs");

const elevate = {
  true: (_, extras) => {
    return (0,_getElevation__WEBPACK_IMPORTED_MODULE_0__.getElevation)(extras.props["size"], extras);
  }
};
const bordered = (val, { props }) => {
  return {
    // TODO size it with size in '...size'
    borderWidth: typeof val === "number" ? val : 1,
    borderColor: "$borderColor",
    ...props.hoverTheme && {
      hoverStyle: {
        borderColor: "$borderColorHover"
      }
    },
    ...props.pressTheme && {
      pressStyle: {
        borderColor: "$borderColorPress"
      }
    },
    ...props.focusTheme && {
      focusStyle: {
        borderColor: "$borderColorFocus"
      }
    }
  };
};
const padded = {
  true: (_, extras) => {
    const { tokens, props } = extras;
    return {
      padding: tokens.space[props.size] || tokens.space["$true"]
    };
  }
};
const radiused = {
  true: (_, extras) => {
    const { tokens, props } = extras;
    return {
      borderRadius: tokens.radius[props.size] || tokens.radius["$true"]
    };
  }
};
const circular = {
  true: (_, { props, tokens }) => {
    const size = tokens.size[props.size];
    return {
      width: size,
      height: size,
      maxWidth: size,
      maxHeight: size,
      minWidth: size,
      minHeight: size,
      borderRadius: 1e5,
      padding: 0
    };
  }
};
const hoverTheme = {
  true: {
    hoverStyle: {
      backgroundColor: "$backgroundHover",
      borderColor: "$borderColorHover"
    }
  },
  false: {}
};
const pressTheme = {
  true: {
    cursor: "pointer",
    pressStyle: {
      backgroundColor: "$backgroundPress",
      borderColor: "$borderColorPress"
    }
  },
  false: {}
};
const focusTheme = {
  true: {
    focusStyle: {
      backgroundColor: "$backgroundFocus",
      borderColor: "$borderColorFocus"
    }
  },
  false: {}
};

//# sourceMappingURL=variants.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/switch/dist/esm/Switch.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/switch/dist/esm/Switch.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Switch": () => (/* binding */ Switch),
/* harmony export */   "SwitchFrame": () => (/* binding */ SwitchFrame),
/* harmony export */   "SwitchThumb": () => (/* binding */ SwitchThumb),
/* harmony export */   "SwitchThumbFrame": () => (/* binding */ SwitchThumbFrame),
/* harmony export */   "createSwitchScope": () => (/* binding */ createSwitchScope)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _radix_ui_react_use_previous__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @radix-ui/react-use-previous */ "../../node_modules/@radix-ui/react-use-previous/dist/index.module.js");
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_focusable__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tamagui/focusable */ "../../node_modules/@tamagui/focusable/dist/esm/registerFocusable.mjs");
/* harmony import */ var _tamagui_get_size__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/get-size */ "../../node_modules/@tamagui/get-size/dist/esm/index.mjs");
/* harmony import */ var _tamagui_label__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/label */ "../../node_modules/@tamagui/label/dist/esm/Label.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);











const SWITCH_NAME = "Switch";
const getSwitchHeight = (val) => Math.round((0,_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.getVariableValue)((0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_3__.getSize)(val)) * 0.65);
const getSwitchWidth = (val) => getSwitchHeight(val) * 2;
const scopeContexts = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_4__.createContextScope)(SWITCH_NAME);
const [createSwitchContext] = scopeContexts;
const createSwitchScope = scopeContexts[1];
const [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
const THUMB_NAME = "SwitchThumb";
const SwitchThumbFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_6__.ThemeableStack, {
  name: "SwitchThumb",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        backgroundColor: "$background",
        borderRadius: 1e3
      }
    },
    size: {
      "...size": (val) => {
        const size = getSwitchHeight(val);
        return {
          height: size,
          width: size
        };
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const SwitchThumb = SwitchThumbFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSwitch, size: sizeProp, ...thumbProps } = props;
      const {
        size: sizeContext,
        disabled,
        checked,
        unstyled
      } = useSwitchContext(THUMB_NAME, __scopeSwitch);
      const size = sizeProp ?? sizeContext;
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        SwitchThumbFrame,
        {
          unstyled,
          theme: checked ? "active" : null,
          size,
          "data-state": getState(checked),
          "data-disabled": disabled ? "" : void 0,
          ...thumbProps,
          x: checked ? (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.getVariableValue)(getSwitchWidth(size)) - (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.getVariableValue)(getSwitchHeight(size)) : 0,
          ref: forwardedRef
        }
      );
    }
  )
);
SwitchThumb.displayName = THUMB_NAME;
const SwitchFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_7__.XStack, {
  name: SWITCH_NAME,
  tag: "button",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        borderRadius: 1e3,
        borderWidth: 2,
        borderColor: "transparent",
        backgroundColor: "$background",
        focusStyle: {
          borderColor: "$borderColorFocus"
        }
      }
    },
    size: {
      "...size": (val) => {
        const height = getSwitchHeight(val) + 4;
        const width = getSwitchWidth(val) + 4;
        return {
          height,
          minHeight: height,
          width
        };
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const Switch = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.withStaticProperties)(
  SwitchFrame.extractable(
    react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(
      (props, forwardedRef) => {
        const {
          __scopeSwitch,
          labeledBy: ariaLabelledby,
          name,
          checked: checkedProp,
          defaultChecked,
          required,
          disabled,
          value = "on",
          onCheckedChange,
          size = "$true",
          unstyled = false,
          ...switchProps
        } = props;
        const [button, setButton] = react__WEBPACK_IMPORTED_MODULE_1__.useState(null);
        const composedRefs = (0,_tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_9__.useComposedRefs)(
          forwardedRef,
          (node) => setButton(node)
        );
        const labelId = (0,_tamagui_label__WEBPACK_IMPORTED_MODULE_10__.useLabelContext)(button);
        const labelledBy = ariaLabelledby || labelId;
        const hasConsumerStoppedPropagationRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(false);
        const isFormControl = _tamagui_core__WEBPACK_IMPORTED_MODULE_11__.isWeb ? button ? Boolean(button.closest("form")) : true : false;
        const [checked = false, setChecked] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_12__.useControllableState)({
          prop: checkedProp,
          defaultProp: defaultChecked || false,
          onChange: onCheckedChange,
          transition: true
        });
        if (!_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.isWeb) {
          react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
            if (!props.id)
              return;
            return (0,_tamagui_focusable__WEBPACK_IMPORTED_MODULE_13__.registerFocusable)(props.id, {
              focus: () => {
                setChecked((x) => !x);
              }
            });
          }, [props.id, setChecked]);
        }
        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(
          SwitchProvider,
          {
            scope: __scopeSwitch,
            checked,
            disabled,
            size,
            unstyled,
            children: [
              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
                SwitchFrame,
                {
                  unstyled,
                  size,
                  theme: checked ? "active" : null,
                  role: "switch",
                  "aria-checked": checked,
                  "aria-labelledby": labelledBy,
                  "aria-required": required,
                  "data-state": getState(checked),
                  "data-disabled": disabled ? "" : void 0,
                  disabled,
                  tabIndex: disabled ? void 0 : 0,
                  value,
                  ...switchProps,
                  ref: composedRefs,
                  onPress: (event) => {
                    var _a;
                    (_a = props.onPress) == null ? void 0 : _a.call(props, event);
                    setChecked((prevChecked) => !prevChecked);
                    if (_tamagui_core__WEBPACK_IMPORTED_MODULE_11__.isWeb && isFormControl) {
                      hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
                      if (!hasConsumerStoppedPropagationRef.current)
                        event.stopPropagation();
                    }
                  }
                }
              ),
              _tamagui_core__WEBPACK_IMPORTED_MODULE_11__.isWeb && isFormControl && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
                BubbleInput,
                {
                  control: button,
                  bubbles: !hasConsumerStoppedPropagationRef.current,
                  name,
                  value,
                  checked,
                  required,
                  disabled,
                  style: { transform: "translateX(-100%)" }
                }
              )
            ]
          }
        );
      }
    )
  ),
  {
    Thumb: SwitchThumb
  }
);
const BubbleInput = (props) => {
  const { control, checked, bubbles = true, ...inputProps } = props;
  const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);
  const prevChecked = (0,_radix_ui_react_use_previous__WEBPACK_IMPORTED_MODULE_14__.usePrevious)(checked);
  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
    const input = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(
      inputProto,
      "checked"
    );
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input, checked);
      input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    "input",
    {
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        // ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function getState(checked) {
  return checked ? "checked" : "unchecked";
}

//# sourceMappingURL=Switch.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/switch/dist/esm/index.mjs":
/*!*************************************************************!*\
  !*** ../../node_modules/@tamagui/switch/dist/esm/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Switch": () => (/* reexport safe */ _Switch__WEBPACK_IMPORTED_MODULE_0__.Switch),
/* harmony export */   "SwitchFrame": () => (/* reexport safe */ _Switch__WEBPACK_IMPORTED_MODULE_0__.SwitchFrame),
/* harmony export */   "SwitchThumb": () => (/* reexport safe */ _Switch__WEBPACK_IMPORTED_MODULE_0__.SwitchThumb),
/* harmony export */   "SwitchThumbFrame": () => (/* reexport safe */ _Switch__WEBPACK_IMPORTED_MODULE_0__.SwitchThumbFrame),
/* harmony export */   "createSwitchScope": () => (/* reexport safe */ _Switch__WEBPACK_IMPORTED_MODULE_0__.createSwitchScope)
/* harmony export */ });
/* harmony import */ var _Switch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Switch */ "../../node_modules/@tamagui/switch/dist/esm/Switch.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/tabs/dist/esm/Tabs.mjs":
/*!**********************************************************!*\
  !*** ../../node_modules/@tamagui/tabs/dist/esm/Tabs.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tabs": () => (/* binding */ Tabs)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_get_button_sized__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/get-button-sized */ "../../node_modules/@tamagui/get-button-sized/dist/esm/index.mjs");
/* harmony import */ var _tamagui_group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/group */ "../../node_modules/@tamagui/group/dist/esm/Group.mjs");
/* harmony import */ var _tamagui_roving_focus__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/roving-focus */ "../../node_modules/@tamagui/roving-focus/dist/esm/RovingFocusGroup.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/SizableStack.js");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");
/* harmony import */ var _tamagui_use_direction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/use-direction */ "../../node_modules/@tamagui/use-direction/dist/esm/index.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/views/Theme.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/index.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/use-event/dist/esm/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);










const TAB_LIST_NAME = "TabsList";
const TabsListFrame = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_group__WEBPACK_IMPORTED_MODULE_4__.Group, {
  name: TAB_LIST_NAME,
  focusable: true
});
const TabsList = TabsListFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(
    (props, forwardedRef) => {
      const { __scopeTabs, loop = true, children, ...listProps } = props;
      const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
      const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        _tamagui_roving_focus__WEBPACK_IMPORTED_MODULE_5__.RovingFocusGroup,
        {
          asChild: true,
          orientation: context.orientation,
          dir: context.dir,
          loop,
          ...rovingFocusGroupScope,
          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
            TabsListFrame,
            {
              role: "tablist",
              "aria-orientation": context.orientation,
              ref: forwardedRef,
              axis: context.orientation,
              ...listProps,
              children
            }
          )
        }
      );
    }
  )
);
TabsList.displayName = TAB_LIST_NAME;
const TRIGGER_NAME = "TabsTrigger";
const TabsTriggerFrame = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_6__.ThemeableStack, {
  name: TRIGGER_NAME,
  justifyContent: "center",
  alignItems: "center",
  flexWrap: "nowrap",
  flexDirection: "row",
  cursor: "pointer",
  backgroundColor: "$background",
  focusable: true,
  variants: {
    size: {
      "...size": _tamagui_get_button_sized__WEBPACK_IMPORTED_MODULE_7__.getButtonSized
    },
    disabled: {
      true: {
        pointerEvents: "none"
      }
    },
    unstyled: {
      false: {
        backgroundColor: "$background",
        pressStyle: {
          backgroundColor: "$backgroundPress"
        },
        hoverStyle: {
          backgroundColor: "$backgroundHover"
        },
        focusStyle: {
          backgroundColor: "$backgroundFocus"
        }
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const TabsTrigger = TabsTriggerFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeTabs,
        value,
        disabled = false,
        onInteraction,
        ...triggerProps
      } = props;
      const context = useTabsContext(TRIGGER_NAME, __scopeTabs);
      const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
      const triggerId = makeTriggerId(context.baseId, value);
      const contentId = makeContentId(context.baseId, value);
      const isSelected = value === context.value;
      const [layout, setLayout] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);
      const triggerRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);
      const groupItemProps = (0,_tamagui_group__WEBPACK_IMPORTED_MODULE_4__.useGroupItem)({ disabled });
      react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {
        context.registerTrigger();
        return () => context.unregisterTrigger();
      }, []);
      react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {
        if (!triggerRef.current || !_tamagui_web__WEBPACK_IMPORTED_MODULE_8__.isWeb)
          return;
        function getTriggerSize() {
          if (!triggerRef.current)
            return;
          setLayout({
            width: triggerRef.current.offsetWidth,
            height: triggerRef.current.offsetHeight,
            x: triggerRef.current.offsetLeft,
            y: triggerRef.current.offsetTop
          });
        }
        getTriggerSize();
        const observer = new ResizeObserver(getTriggerSize);
        observer.observe(triggerRef.current);
        return () => {
          if (!triggerRef.current)
            return;
          observer.unobserve(triggerRef.current);
        };
      }, [context.triggersCount]);
      react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {
        if (isSelected && layout) {
          onInteraction == null ? void 0 : onInteraction("select", layout);
        }
      }, [isSelected, value, layout]);
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_web__WEBPACK_IMPORTED_MODULE_9__.Theme, { name: isSelected ? "active" : null, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        _tamagui_roving_focus__WEBPACK_IMPORTED_MODULE_5__.RovingFocusGroup.Item,
        {
          asChild: true,
          ...rovingFocusGroupScope,
          focusable: !disabled,
          active: isSelected,
          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
            TabsTriggerFrame,
            {
              onLayout: (event) => {
                if (!_tamagui_web__WEBPACK_IMPORTED_MODULE_8__.isWeb) {
                  setLayout(event.nativeEvent.layout);
                }
              },
              onHoverIn: (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(props.onHoverIn, () => {
                if (layout) {
                  onInteraction == null ? void 0 : onInteraction("hover", layout);
                }
              }),
              onHoverOut: (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(props.onHoverOut, () => {
                onInteraction == null ? void 0 : onInteraction("hover", null);
              }),
              role: "tab",
              "aria-selected": isSelected,
              "aria-controls": contentId,
              "data-state": isSelected ? "active" : "inactive",
              "data-disabled": disabled ? "" : void 0,
              disabled,
              id: triggerId,
              size: context.size,
              ...triggerProps,
              ref: (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_11__.composeRefs)(forwardedRef, triggerRef),
              onPress: (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(props.onPress ?? void 0, (event) => {
                const webChecks = !_tamagui_web__WEBPACK_IMPORTED_MODULE_8__.isWeb || event.button === 0 && event.ctrlKey === false;
                if (!disabled && !isSelected && webChecks) {
                  context.onChange(value);
                } else {
                  event.preventDefault();
                }
              }),
              ..._tamagui_web__WEBPACK_IMPORTED_MODULE_8__.isWeb && {
                type: "button",
                onKeyDown: (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(
                  props.onKeyDown,
                  (event) => {
                    if ([" ", "Enter"].includes(event.key)) {
                      context.onChange(value);
                      event.preventDefault();
                    }
                  }
                ),
                onFocus: (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(props.onFocus, (event) => {
                  if (layout) {
                    onInteraction == null ? void 0 : onInteraction("focus", layout);
                  }
                  const isAutomaticActivation = context.activationMode !== "manual";
                  if (!isSelected && !disabled && isAutomaticActivation) {
                    context.onChange(value);
                  }
                }),
                onBlur: (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_10__.composeEventHandlers)(props.onFocus, () => {
                  onInteraction == null ? void 0 : onInteraction("focus", null);
                })
              },
              ...groupItemProps
            }
          )
        }
      ) });
    }
  )
);
TabsTrigger.displayName = TRIGGER_NAME;
const CONTENT_NAME = "TabsContent";
const TabsContentFrame = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_6__.ThemeableStack, {
  name: CONTENT_NAME
});
const TabsContent = TabsContentFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(
    (props, forwardedRef) => {
      const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
      const context = useTabsContext(CONTENT_NAME, __scopeTabs);
      const isSelected = value === context.value;
      const show = forceMount || isSelected;
      const triggerId = makeTriggerId(context.baseId, value);
      const contentId = makeContentId(context.baseId, value);
      if (!show)
        return null;
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        TabsContentFrame,
        {
          "data-state": isSelected ? "active" : "inactive",
          "data-orientation": context.orientation,
          role: "tabpanel",
          "aria-labelledby": triggerId,
          hidden: !show,
          id: contentId,
          tabIndex: 0,
          ...contentProps,
          ref: forwardedRef,
          children
        },
        value
      );
    }
  )
);
TabsContent.displayName = CONTENT_NAME;
const TABS_NAME = "Tabs";
const [createTabsContext, createTabsScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_12__.createContextScope)(TABS_NAME, [
  _tamagui_roving_focus__WEBPACK_IMPORTED_MODULE_5__.createRovingFocusGroupScope
]);
const useRovingFocusGroupScope = (0,_tamagui_roving_focus__WEBPACK_IMPORTED_MODULE_5__.createRovingFocusGroupScope)();
const [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
const TabsFrame = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_3__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_13__.SizableStack, {
  name: TABS_NAME
});
const Tabs = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_14__.withStaticProperties)(
  TabsFrame.extractable(
    react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(
      (props, forwardedRef) => {
        const {
          __scopeTabs,
          value: valueProp,
          onValueChange,
          defaultValue,
          orientation = "horizontal",
          dir,
          activationMode = "automatic",
          size = "$true",
          ...tabsProps
        } = props;
        const direction = (0,_tamagui_use_direction__WEBPACK_IMPORTED_MODULE_1__.useDirection)(dir);
        const [value, setValue] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_15__.useControllableState)({
          prop: valueProp,
          onChange: onValueChange,
          defaultProp: defaultValue ?? ""
        });
        const [triggersCount, setTriggersCount] = react__WEBPACK_IMPORTED_MODULE_2__.useState(0);
        const registerTrigger = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_16__.useEvent)(() => setTriggersCount((v) => v + 1));
        const unregisterTrigger = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_16__.useEvent)(() => setTriggersCount((v) => v - 1));
        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
          TabsProvider,
          {
            scope: __scopeTabs,
            baseId: react__WEBPACK_IMPORTED_MODULE_2__.useId(),
            value,
            onChange: setValue,
            orientation,
            dir: direction,
            activationMode,
            size,
            registerTrigger,
            triggersCount,
            unregisterTrigger,
            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
              TabsFrame,
              {
                direction,
                "data-orientation": orientation,
                ...tabsProps,
                ref: forwardedRef
              }
            )
          }
        );
      }
    )
  ),
  {
    List: TabsList,
    /**
     * @deprecated Use Tabs.Tab instead
     */
    Trigger: TabsTrigger,
    Tab: TabsTrigger,
    Content: TabsContent
  }
);
Tabs.displayName = TABS_NAME;
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}

//# sourceMappingURL=Tabs.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/tabs/dist/esm/index.mjs":
/*!***********************************************************!*\
  !*** ../../node_modules/@tamagui/tabs/dist/esm/index.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tabs": () => (/* reexport safe */ _Tabs__WEBPACK_IMPORTED_MODULE_0__.Tabs)
/* harmony export */ });
/* harmony import */ var _Tabs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tabs */ "../../node_modules/@tamagui/tabs/dist/esm/Tabs.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/text/dist/esm/Headings.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/text/dist/esm/Headings.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "H1": () => (/* binding */ H1),
/* harmony export */   "H2": () => (/* binding */ H2),
/* harmony export */   "H3": () => (/* binding */ H3),
/* harmony export */   "H4": () => (/* binding */ H4),
/* harmony export */   "H5": () => (/* binding */ H5),
/* harmony export */   "H6": () => (/* binding */ H6),
/* harmony export */   "Heading": () => (/* binding */ Heading)
/* harmony export */ });
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _Paragraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Paragraph */ "../../node_modules/@tamagui/text/dist/esm/Paragraph.mjs");


const Heading = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_0__.styled)(_Paragraph__WEBPACK_IMPORTED_MODULE_1__.Paragraph, {
  tag: "span",
  name: "Heading",
  accessibilityRole: "header",
  fontFamily: "$heading",
  size: "$8",
  margin: 0
});
const H1 = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_0__.styled)(Heading, {
  name: "H1",
  tag: "h1",
  size: "$10"
});
const H2 = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_0__.styled)(Heading, {
  name: "H2",
  tag: "h2",
  size: "$9"
});
const H3 = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_0__.styled)(Heading, {
  name: "H3",
  tag: "h3",
  size: "$8"
});
const H4 = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_0__.styled)(Heading, {
  name: "H4",
  tag: "h4",
  size: "$7"
});
const H5 = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_0__.styled)(Heading, {
  name: "H5",
  tag: "h5",
  size: "$6"
});
const H6 = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_0__.styled)(Heading, {
  name: "H6",
  tag: "h6",
  size: "$5"
});

//# sourceMappingURL=Headings.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/text/dist/esm/Paragraph.mjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@tamagui/text/dist/esm/Paragraph.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Paragraph": () => (/* binding */ Paragraph)
/* harmony export */ });
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _SizableText__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SizableText */ "../../node_modules/@tamagui/text/dist/esm/SizableText.mjs");


const Paragraph = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_0__.styled)(_SizableText__WEBPACK_IMPORTED_MODULE_1__.SizableText, {
  name: "Paragraph",
  tag: "p",
  userSelect: "auto",
  color: "$color",
  size: "$true"
});

//# sourceMappingURL=Paragraph.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/text/dist/esm/index.mjs":
/*!***********************************************************!*\
  !*** ../../node_modules/@tamagui/text/dist/esm/index.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "H1": () => (/* reexport safe */ _Headings__WEBPACK_IMPORTED_MODULE_2__.H1),
/* harmony export */   "H2": () => (/* reexport safe */ _Headings__WEBPACK_IMPORTED_MODULE_2__.H2),
/* harmony export */   "H3": () => (/* reexport safe */ _Headings__WEBPACK_IMPORTED_MODULE_2__.H3),
/* harmony export */   "H4": () => (/* reexport safe */ _Headings__WEBPACK_IMPORTED_MODULE_2__.H4),
/* harmony export */   "H5": () => (/* reexport safe */ _Headings__WEBPACK_IMPORTED_MODULE_2__.H5),
/* harmony export */   "H6": () => (/* reexport safe */ _Headings__WEBPACK_IMPORTED_MODULE_2__.H6),
/* harmony export */   "Heading": () => (/* reexport safe */ _Headings__WEBPACK_IMPORTED_MODULE_2__.Heading),
/* harmony export */   "Paragraph": () => (/* reexport safe */ _Paragraph__WEBPACK_IMPORTED_MODULE_1__.Paragraph),
/* harmony export */   "SizableText": () => (/* reexport safe */ _SizableText__WEBPACK_IMPORTED_MODULE_0__.SizableText),
/* harmony export */   "wrapChildrenInText": () => (/* reexport safe */ _wrapChildrenInText__WEBPACK_IMPORTED_MODULE_3__.wrapChildrenInText)
/* harmony export */ });
/* harmony import */ var _SizableText__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SizableText */ "../../node_modules/@tamagui/text/dist/esm/SizableText.mjs");
/* harmony import */ var _Paragraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Paragraph */ "../../node_modules/@tamagui/text/dist/esm/Paragraph.mjs");
/* harmony import */ var _Headings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Headings */ "../../node_modules/@tamagui/text/dist/esm/Headings.mjs");
/* harmony import */ var _wrapChildrenInText__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wrapChildrenInText */ "../../node_modules/@tamagui/text/dist/esm/wrapChildrenInText.mjs");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ "../../node_modules/@tamagui/text/dist/esm/types.mjs");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_4__) if(["default","SizableText","Paragraph","H1","H2","H3","H4","H5","H6","Heading","wrapChildrenInText"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _types__WEBPACK_IMPORTED_MODULE_4__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);





//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/text/dist/esm/types.mjs":
/*!***********************************************************!*\
  !*** ../../node_modules/@tamagui/text/dist/esm/types.mjs ***!
  \***********************************************************/
/***/ (() => {

//# sourceMappingURL=types.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/text/dist/esm/wrapChildrenInText.mjs":
/*!************************************************************************!*\
  !*** ../../node_modules/@tamagui/text/dist/esm/wrapChildrenInText.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wrapChildrenInText": () => (/* binding */ wrapChildrenInText)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);


function wrapChildrenInText(TextComponent, propsIn, extraProps) {
  const {
    children,
    textProps,
    size,
    noTextWrap,
    color,
    fontFamily,
    fontSize,
    fontWeight,
    letterSpacing,
    textAlign,
    fontStyle
  } = propsIn;
  if (noTextWrap || !children) {
    return [children];
  }
  const allChildren = react__WEBPACK_IMPORTED_MODULE_1___default().Children.toArray(children);
  const nextChildren = [];
  let lastIsString = false;
  const props = {
    ...extraProps
  };
  if (color)
    props.color = color;
  if (fontFamily)
    props.fontFamily = fontFamily;
  if (fontSize)
    props.fontSize = fontSize;
  if (fontWeight)
    props.fontWeight = fontWeight;
  if (letterSpacing)
    props.letterSpacing = letterSpacing;
  if (textAlign)
    props.textAlign = textAlign;
  if (size)
    props.size = size;
  if (fontStyle)
    props.fontStyle = fontStyle;
  function concatStringChildren() {
    if (!lastIsString)
      return;
    const index = nextChildren.length - 1;
    const childrenStrings = nextChildren[index];
    nextChildren[index] = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TextComponent, { ...props, ...textProps, children: childrenStrings }, index);
  }
  for (const child of allChildren) {
    const last = nextChildren[nextChildren.length - 1];
    const isString = typeof child === "string";
    if (isString) {
      if (lastIsString) {
        last.push(child);
      } else {
        nextChildren.push([child]);
      }
    } else {
      concatStringChildren();
      nextChildren.push(child);
    }
    lastIsString = isString;
  }
  concatStringChildren();
  return nextChildren;
}

//# sourceMappingURL=wrapChildrenInText.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/theme/dist/esm/addTheme.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/theme/dist/esm/addTheme.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addTheme": () => (/* binding */ addTheme)
/* harmony export */ });
/* harmony import */ var _tamagui_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/constants */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/config.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/helpers/themes.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/helpers/getThemeCSSRules.js");


function addTheme(props) {
  var _a;
  const config = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_1__.getConfig)();
  if (true) {
    if (!config) {
      throw new Error("No config");
    }
    const theme2 = config.themes[props.name];
    if (!props.update && theme2) {
      return { theme: theme2 };
    }
  }
  const { name: themeName, theme: themeIn, insertCSS } = props;
  const theme = { ...themeIn };
  for (const key in theme) {
    (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_2__.ensureThemeVariable)(theme, key);
  }
  const themeProxied = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_2__.proxyThemeToParents)(themeName, theme, config.themes);
  config.themes[themeName] = themeProxied;
  let cssRules = [];
  if (_tamagui_constants__WEBPACK_IMPORTED_MODULE_0__.isWeb) {
    if (insertCSS) {
      cssRules = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_3__.getThemeCSSRules)({
        // @ts-ignore this works but should be fixed types
        config,
        themeName,
        names: [themeName],
        theme
      });
      const id = `t_theme_style_${themeName}`;
      const existing = document.querySelector(`#${id}`);
      const style = document.createElement("style");
      style.id = id;
      style.appendChild(document.createTextNode(cssRules.join("\n")));
      document.head.appendChild(style);
      if (existing) {
        (_a = existing.parentElement) == null ? void 0 : _a.removeChild(existing);
      }
    }
  }
  (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_1__.updateConfig)("themes", { ...config.themes, [themeName]: themeProxied });
  return {
    theme: themeProxied,
    cssRules
  };
}

//# sourceMappingURL=addTheme.js.map


/***/ }),

/***/ "../../node_modules/@tamagui/theme/dist/esm/addTheme.mjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@tamagui/theme/dist/esm/addTheme.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addTheme": () => (/* binding */ addTheme)
/* harmony export */ });
/* harmony import */ var _tamagui_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/constants */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/config.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/helpers/themes.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/helpers/getThemeCSSRules.js");


function addTheme(props) {
  var _a;
  const config = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_1__.getConfig)();
  if (true) {
    if (!config) {
      throw new Error("No config");
    }
    const theme2 = config.themes[props.name];
    if (!props.update && theme2) {
      return { theme: theme2 };
    }
  }
  const { name: themeName, theme: themeIn, insertCSS } = props;
  const theme = { ...themeIn };
  for (const key in theme) {
    (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_2__.ensureThemeVariable)(theme, key);
  }
  const themeProxied = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_2__.proxyThemeToParents)(themeName, theme, config.themes);
  config.themes[themeName] = themeProxied;
  let cssRules = [];
  if (_tamagui_constants__WEBPACK_IMPORTED_MODULE_0__.isWeb) {
    if (insertCSS) {
      cssRules = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_3__.getThemeCSSRules)({
        // @ts-ignore this works but should be fixed types
        config,
        themeName,
        names: [themeName],
        theme
      });
      const id = `t_theme_style_${themeName}`;
      const existing = document.querySelector(`#${id}`);
      const style = document.createElement("style");
      style.id = id;
      style.appendChild(document.createTextNode(cssRules.join("\n")));
      document.head.appendChild(style);
      if (existing) {
        (_a = existing.parentElement) == null ? void 0 : _a.removeChild(existing);
      }
    }
  }
  (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_1__.updateConfig)("themes", { ...config.themes, [themeName]: themeProxied });
  return {
    theme: themeProxied,
    cssRules
  };
}

//# sourceMappingURL=addTheme.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/theme/dist/esm/index.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/@tamagui/theme/dist/esm/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addTheme": () => (/* reexport safe */ _addTheme__WEBPACK_IMPORTED_MODULE_0__.addTheme),
/* harmony export */   "updateTheme": () => (/* reexport safe */ _updateTheme__WEBPACK_IMPORTED_MODULE_1__.updateTheme)
/* harmony export */ });
/* harmony import */ var _addTheme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addTheme */ "../../node_modules/@tamagui/theme/dist/esm/addTheme.mjs");
/* harmony import */ var _updateTheme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./updateTheme */ "../../node_modules/@tamagui/theme/dist/esm/updateTheme.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/theme/dist/esm/updateTheme.mjs":
/*!******************************************************************!*\
  !*** ../../node_modules/@tamagui/theme/dist/esm/updateTheme.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateTheme": () => (/* binding */ updateTheme)
/* harmony export */ });
/* harmony import */ var _addTheme_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addTheme.js */ "../../node_modules/@tamagui/theme/dist/esm/addTheme.js");


function updateTheme({
  name,
  theme
}) {
  const next = (0,_addTheme_js__WEBPACK_IMPORTED_MODULE_0__.addTheme)({ name, theme, insertCSS: true, update: true });
  if (false) {}
  return next;
}

//# sourceMappingURL=updateTheme.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/toggle-group/dist/esm/Toggle.mjs":
/*!********************************************************************!*\
  !*** ../../node_modules/@tamagui/toggle-group/dist/esm/Toggle.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Toggle": () => (/* binding */ Toggle),
/* harmony export */   "ToggleFrame": () => (/* binding */ ToggleFrame)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/ThemeableStack.js");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/views/Theme.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);





const NAME = "Toggle";
const ToggleFrame = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_2__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_3__.ThemeableStack, {
  name: NAME,
  tag: "button",
  variants: {
    unstyled: {
      false: {
        pressTheme: true,
        backgroundColor: "$background",
        alignItems: "center",
        justifyContent: "center",
        display: "flex",
        borderColor: "$borderColor",
        borderWidth: "1px",
        margin: "-1px",
        hoverStyle: {
          backgroundColor: "$backgroundHover"
        },
        pressStyle: {
          backgroundColor: "$backgroundPress"
        },
        focusStyle: {
          borderColor: "$borderColorPress",
          backgroundColor: "$backgroundPress"
        }
      }
    },
    active: {
      true: {
        zIndex: 1,
        hoverStyle: {
          backgroundColor: "$background"
        },
        focusStyle: {
          borderColor: "$borderColorPress",
          backgroundColor: "$backgroundPress"
        }
      }
    },
    orientation: {
      horizontal: {
        flexDirection: "row",
        spaceDirection: "horizontal"
      },
      vertical: {
        flexDirection: "column",
        spaceDirection: "vertical"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const Toggle = ToggleFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, forwardedRef) => {
    const {
      pressed: pressedProp,
      defaultPressed = false,
      onPressedChange,
      ...buttonProps
    } = props;
    const [pressed = false, setPressed] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_4__.useControllableState)({
      prop: pressedProp,
      onChange: onPressedChange,
      defaultProp: defaultPressed
    });
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_web__WEBPACK_IMPORTED_MODULE_5__.Theme, { name: pressed ? "active" : null, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      ToggleFrame,
      {
        active: !props.unstyled ? pressed : void 0,
        "aria-pressed": pressed,
        "data-state": pressed ? "on" : "off",
        "data-disabled": props.disabled ? "" : void 0,
        ...buttonProps,
        ref: forwardedRef,
        onPress: (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_6__.composeEventHandlers)(props.onPress ?? void 0, (event) => {
          if (!props.disabled) {
            setPressed(!pressed);
          }
        })
      }
    ) });
  })
);
Toggle.displayName = NAME;

//# sourceMappingURL=Toggle.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/toggle-group/dist/esm/ToggleGroup.mjs":
/*!*************************************************************************!*\
  !*** ../../node_modules/@tamagui/toggle-group/dist/esm/ToggleGroup.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToggleGroup": () => (/* binding */ ToggleGroup),
/* harmony export */   "createToggleGroupScope": () => (/* binding */ createToggleGroupScope)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/create-context.mjs");
/* harmony import */ var _tamagui_focusable__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tamagui/focusable */ "../../node_modules/@tamagui/focusable/dist/esm/registerFocusable.mjs");
/* harmony import */ var _tamagui_font_size__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/font-size */ "../../node_modules/@tamagui/font-size/dist/esm/getFontSize.mjs");
/* harmony import */ var _tamagui_get_size__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tamagui/get-size */ "../../node_modules/@tamagui/get-size/dist/esm/index.mjs");
/* harmony import */ var _tamagui_group__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/group */ "../../node_modules/@tamagui/group/dist/esm/Group.mjs");
/* harmony import */ var _tamagui_helpers_tamagui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/helpers-tamagui */ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/index.mjs");
/* harmony import */ var _tamagui_roving_focus__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/roving-focus */ "../../node_modules/@tamagui/roving-focus/dist/esm/RovingFocusGroup.mjs");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");
/* harmony import */ var _tamagui_use_direction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/use-direction */ "../../node_modules/@tamagui/use-direction/dist/esm/index.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/hooks/useTheme.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_web__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tamagui/web */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Toggle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Toggle */ "../../node_modules/@tamagui/toggle-group/dist/esm/Toggle.mjs");













const TOGGLE_GROUP_NAME = "ToggleGroup";
const [createToggleGroupContext, createToggleGroupScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_4__.createContextScope)(
  TOGGLE_GROUP_NAME,
  [_tamagui_roving_focus__WEBPACK_IMPORTED_MODULE_5__.createRovingFocusGroupScope]
);
const TOGGLE_GROUP_ITEM_NAME = "ToggleGroupItem";
const [createToggleGroupItemContext, createToggleGroupItemScope] = (0,_tamagui_create_context__WEBPACK_IMPORTED_MODULE_4__.createContextScope)(TOGGLE_GROUP_ITEM_NAME);
const [ToggleGroupItemProvider, useToggleGroupItemContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
const useToggleGroupItemScope = createToggleGroupItemScope();
const ToggleGroupItem = _Toggle__WEBPACK_IMPORTED_MODULE_6__.ToggleFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_3___default().forwardRef(
    (props, forwardedRef) => {
      const valueContext = useToggleGroupValueContext(
        TOGGLE_GROUP_ITEM_NAME,
        props.__scopeToggleGroup
      );
      const context = useToggleGroupContext(
        TOGGLE_GROUP_ITEM_NAME,
        props.__scopeToggleGroup
      );
      const __scopeToggleGroup = props.__scopeToggleGroup;
      const rovingFocusGroupScope = useRovingFocusGroupScope(props.__scopeToggleGroup);
      const pressed = valueContext.value.includes(props.value);
      const disabled = context.disabled || props.disabled || false;
      const ref = react__WEBPACK_IMPORTED_MODULE_3___default().useRef(null);
      const groupItemProps = (0,_tamagui_group__WEBPACK_IMPORTED_MODULE_7__.useGroupItem)({ disabled });
      const size = props.size ?? context.size;
      const sizeProps = {
        width: void 0,
        height: void 0,
        padding: (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_8__.getVariableValue)(size) * 0.6
      };
      if (props.orientation === "horizontal")
        sizeProps.height = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_8__.getVariableValue)(size) * 2.4;
      else
        sizeProps.width = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_8__.getVariableValue)(size) * 2.4;
      const iconSize = (typeof size === "number" ? size * 0.7 : (0,_tamagui_font_size__WEBPACK_IMPORTED_MODULE_9__.getFontSize)(size)) * 1.2;
      const theme = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_10__.useTheme)();
      const getThemedIcon = (0,_tamagui_helpers_tamagui__WEBPACK_IMPORTED_MODULE_1__.useGetThemedIcon)({ size: iconSize, color: theme.color });
      const childrens = react__WEBPACK_IMPORTED_MODULE_3___default().Children.toArray(props.children);
      const children = childrens.map((child) => {
        if (props.disablePassStyles || !react__WEBPACK_IMPORTED_MODULE_3___default().isValidElement(child)) {
          return child;
        }
        return getThemedIcon(child);
      });
      const commonProps = { ...props, pressed, disabled, ...sizeProps, children };
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToggleGroupItemProvider, { scope: __scopeToggleGroup, children: context.rovingFocus ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        _tamagui_roving_focus__WEBPACK_IMPORTED_MODULE_5__.RovingFocusGroup.Item,
        {
          asChild: true,
          ...rovingFocusGroupScope,
          focusable: !disabled,
          active: pressed,
          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
            _Toggle__WEBPACK_IMPORTED_MODULE_6__.ToggleFrame,
            {
              asChild: true,
              focusable: !disabled,
              disabled,
              ref,
              ...groupItemProps,
              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef })
            }
          )
        }
      ) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Toggle__WEBPACK_IMPORTED_MODULE_6__.ToggleFrame, { asChild: true, focusable: !disabled, disabled, ref, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef }) }) });
    }
  )
);
ToggleGroupItem.displayName = TOGGLE_GROUP_ITEM_NAME;
const ToggleGroupItemImpl = _Toggle__WEBPACK_IMPORTED_MODULE_6__.ToggleFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_3___default().forwardRef(
    (props, forwardedRef) => {
      const { __scopeToggleGroup, value, ...itemProps } = props;
      const valueContext = useToggleGroupValueContext(
        TOGGLE_GROUP_ITEM_NAME,
        __scopeToggleGroup
      );
      const singleProps = {
        "aria-pressed": void 0
      };
      const typeProps = valueContext.type === "single" ? singleProps : void 0;
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        _Toggle__WEBPACK_IMPORTED_MODULE_6__.Toggle,
        {
          ...typeProps,
          ...itemProps,
          ref: forwardedRef,
          onPressedChange: (pressed) => {
            if (pressed) {
              valueContext.onItemActivate(value);
            } else {
              valueContext.onItemDeactivate(value);
            }
          }
        }
      );
    }
  )
);
const useRovingFocusGroupScope = (0,_tamagui_roving_focus__WEBPACK_IMPORTED_MODULE_5__.createRovingFocusGroupScope)();
const ToggleGroup = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_11__.withStaticProperties)(
  react__WEBPACK_IMPORTED_MODULE_3___default().forwardRef((props, forwardedRef) => {
    const { type, ...toggleGroupProps } = props;
    if (!_tamagui_web__WEBPACK_IMPORTED_MODULE_12__.isWeb) {
      react__WEBPACK_IMPORTED_MODULE_3___default().useEffect(() => {
        if (!props.id)
          return;
        return (0,_tamagui_focusable__WEBPACK_IMPORTED_MODULE_13__.registerFocusable)(props.id, {
          // TODO: would be nice to focus on the first child later - could be done with reforest
          // for now leaving it empty
          focus: () => {
          }
        });
      }, [props.id]);
    }
    if (type === "single") {
      const singleProps = toggleGroupProps;
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToggleGroupImplSingle, { ...singleProps, ref: forwardedRef });
    }
    if (type === "multiple") {
      const multipleProps = toggleGroupProps;
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToggleGroupImplMultiple, { ...multipleProps, ref: forwardedRef });
    }
    throw new Error(`Missing prop \`type\` expected on \`${TOGGLE_GROUP_NAME}\``);
  }),
  {
    Item: ToggleGroupItem
  }
);
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
const [ToggleGroupValueProvider, useToggleGroupValueContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
const ToggleGroupImplSingle = react__WEBPACK_IMPORTED_MODULE_3___default().forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    disableDeactivation = false,
    ...toggleGroupSingleProps
  } = props;
  const [value, setValue] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_14__.useControllableState)({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    ToggleGroupValueProvider,
    {
      scope: props.__scopeToggleGroup,
      type: "single",
      value: value ? [value] : [],
      defaultValue: value,
      onItemActivate: setValue,
      onItemDeactivate: react__WEBPACK_IMPORTED_MODULE_3___default().useCallback(() => disableDeactivation ? null : setValue(""), [setValue, disableDeactivation]),
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToggleGroupImpl, { ...toggleGroupSingleProps, ref: forwardedRef })
    }
  );
});
const ToggleGroupImplMultiple = react__WEBPACK_IMPORTED_MODULE_3___default().forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...toggleGroupMultipleProps
  } = props;
  const [value = [], setValue] = (0,_tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_14__.useControllableState)({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const handleButtonActivate = react__WEBPACK_IMPORTED_MODULE_3___default().useCallback(
    (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),
    [setValue]
  );
  const handleButtonDeactivate = react__WEBPACK_IMPORTED_MODULE_3___default().useCallback(
    (itemValue) => setValue((prevValue = []) => prevValue.filter((value2) => value2 !== itemValue)),
    [setValue]
  );
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    ToggleGroupValueProvider,
    {
      scope: props.__scopeToggleGroup,
      type: "multiple",
      value,
      defaultValue: value,
      onItemActivate: handleButtonActivate,
      onItemDeactivate: handleButtonDeactivate,
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToggleGroupImpl, { ...toggleGroupMultipleProps, ref: forwardedRef })
    }
  );
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
const [ToggleGroupContext, useToggleGroupContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
const ToggleGroupImplElementFrame = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_15__.styled)(_tamagui_group__WEBPACK_IMPORTED_MODULE_7__.Group, {
  name: TOGGLE_GROUP_NAME,
  variants: {
    unstyled: {
      false: {
        backgroundColor: "$background"
      }
    },
    orientation: {
      vertical: {
        flexDirection: "column",
        spaceDirection: "vertical"
      },
      horizontal: {
        flexDirection: "row",
        spaceDirection: "horizontal"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const ToggleGroupImpl = ToggleGroupImplElementFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_3___default().forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeToggleGroup,
        disabled = false,
        orientation = "horizontal",
        dir,
        rovingFocus = true,
        loop = true,
        unstyled = false,
        size: sizeProp = "$true",
        sizeAdjust = 0,
        ...toggleGroupProps
      } = props;
      const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToggleGroup);
      const direction = (0,_tamagui_use_direction__WEBPACK_IMPORTED_MODULE_2__.useDirection)(dir);
      const commonProps = {
        role: "togglegroup",
        dir: direction,
        ...toggleGroupProps
      };
      const adjustedSize = (0,_tamagui_web__WEBPACK_IMPORTED_MODULE_8__.getVariableValue)(
        (0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_16__.stepTokenUpOrDown)("size", props.size, sizeAdjust)
      );
      const size = Math.round(adjustedSize * 0.45);
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        ToggleGroupContext,
        {
          scope: __scopeToggleGroup,
          rovingFocus,
          disabled,
          size,
          children: rovingFocus ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
            _tamagui_roving_focus__WEBPACK_IMPORTED_MODULE_5__.RovingFocusGroup,
            {
              asChild: true,
              ...rovingFocusGroupScope,
              orientation,
              dir: direction,
              loop,
              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
                ToggleGroupImplElementFrame,
                {
                  "aria-orientation": orientation,
                  orientation,
                  axis: orientation,
                  ref: forwardedRef,
                  "data-disabled": disabled ? "" : void 0,
                  unstyled,
                  ...commonProps
                }
              )
            }
          ) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
            ToggleGroupImplElementFrame,
            {
              "aria-orientation": orientation,
              ref: forwardedRef,
              orientation,
              "data-disabled": disabled ? "" : void 0,
              unstyled,
              ...commonProps
            }
          )
        }
      );
    }
  )
);

//# sourceMappingURL=ToggleGroup.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/toggle-group/dist/esm/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@tamagui/toggle-group/dist/esm/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToggleGroup": () => (/* reexport safe */ _ToggleGroup__WEBPACK_IMPORTED_MODULE_0__.ToggleGroup),
/* harmony export */   "createToggleGroupScope": () => (/* reexport safe */ _ToggleGroup__WEBPACK_IMPORTED_MODULE_0__.createToggleGroupScope)
/* harmony export */ });
/* harmony import */ var _ToggleGroup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ToggleGroup */ "../../node_modules/@tamagui/toggle-group/dist/esm/ToggleGroup.mjs");

//# sourceMappingURL=index.js.map


/***/ }),

/***/ "../../node_modules/@tamagui/tooltip/dist/esm/Tooltip.mjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@tamagui/tooltip/dist/esm/Tooltip.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tooltip": () => (/* binding */ Tooltip2),
/* harmony export */   "TooltipGroup": () => (/* binding */ TooltipGroup)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_polyfill_dev__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/polyfill-dev */ "../../node_modules/@tamagui/polyfill-dev/index.js");
/* harmony import */ var _tamagui_polyfill_dev__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tamagui_polyfill_dev__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @floating-ui/react */ "../../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/use-event/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");
/* harmony import */ var _tamagui_floating__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/floating */ "../../node_modules/@tamagui/floating/dist/esm/index.mjs");
/* harmony import */ var _tamagui_get_size__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/get-size */ "../../node_modules/@tamagui/get-size/dist/esm/index.mjs");
/* harmony import */ var _tamagui_popover__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/popover */ "../../node_modules/@tamagui/popover/dist/esm/Popover.mjs");
/* harmony import */ var _tamagui_popper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/popper */ "../../node_modules/@tamagui/popper/dist/esm/Popper.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);









const TooltipContent = _tamagui_popper__WEBPACK_IMPORTED_MODULE_4__.PopperContentFrame.extractable(
  react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(
    ({ __scopePopover, ...props }, ref) => {
      const popperScope = (0,_tamagui_popover__WEBPACK_IMPORTED_MODULE_5__.usePopoverScope)(__scopePopover);
      const popper = (0,_tamagui_popper__WEBPACK_IMPORTED_MODULE_4__.usePopperContext)("PopperContent", popperScope["__scopePopper"]);
      const padding = props.size || popper.size || (0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_6__.stepTokenUpOrDown)("size", "$true", -2);
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
        _tamagui_popover__WEBPACK_IMPORTED_MODULE_5__.PopoverContent,
        {
          componentName: "Tooltip",
          disableRemoveScroll: true,
          trapFocus: false,
          padding,
          pointerEvents: "none",
          ref,
          ...props
        }
      );
    }
  )
);
const TooltipArrow = react__WEBPACK_IMPORTED_MODULE_3__.forwardRef((props, ref) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_popover__WEBPACK_IMPORTED_MODULE_5__.PopoverArrow, { componentName: "Tooltip", ref, ...props });
});
const TooltipGroup = ({ children, delay }) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.FloatingDelayGroup, { delay: react__WEBPACK_IMPORTED_MODULE_3__.useMemo(() => delay, [JSON.stringify(delay)]), children });
};
const TooltipComponent = react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(function Tooltip(props, ref) {
  const {
    __scopePopover,
    children,
    delay: delayProp,
    restMs = typeof delayProp === "undefined" ? 500 : typeof delayProp === "number" ? delayProp : 0,
    onOpenChange: onOpenChangeProp,
    focus,
    ...restProps
  } = props;
  const popperScope = (0,_tamagui_popover__WEBPACK_IMPORTED_MODULE_5__.usePopoverScope)(__scopePopover);
  const triggerRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = react__WEBPACK_IMPORTED_MODULE_3__.useState(false);
  const { delay: delayGroup, setCurrentId } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.useDelayGroupContext)();
  const delay = delayProp ?? delayGroup;
  const [open, setOpen] = react__WEBPACK_IMPORTED_MODULE_3__.useState(false);
  const id = props.groupId;
  const onOpenChange = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_8__.useEvent)((open2) => {
    setOpen(open2);
    if (open2) {
      setCurrentId(id);
    }
    onOpenChangeProp == null ? void 0 : onOpenChangeProp(open2);
  });
  const useFloatingFn = (props2) => {
    const floating = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.useFloating)({
      ...props2,
      open,
      onOpenChange
    });
    const { getReferenceProps, getFloatingProps } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.useInteractions)([
      (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.useHover)(floating.context, { delay, restMs }),
      (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.useFocus)(floating.context, focus),
      (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.useRole)(floating.context, { role: "tooltip" }),
      (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.useDismiss)(floating.context),
      (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.useDelayGroup)(floating.context, { id })
    ]);
    return {
      ...floating,
      getReferenceProps,
      getFloatingProps
    };
  };
  const useFloatingContext = react__WEBPACK_IMPORTED_MODULE_3__.useCallback(useFloatingFn, [id, delay, open]);
  const onCustomAnchorAdd = react__WEBPACK_IMPORTED_MODULE_3__.useCallback(() => setHasCustomAnchor(true), []);
  const onCustomAnchorRemove = react__WEBPACK_IMPORTED_MODULE_3__.useCallback(() => setHasCustomAnchor(false), []);
  const contentId = react__WEBPACK_IMPORTED_MODULE_3__.useId();
  const twoSmallerKey = (0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_6__.stepTokenUpOrDown)("size", "$true", -2).key;
  const size = `$${twoSmallerKey}`;
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_floating__WEBPACK_IMPORTED_MODULE_2__.FloatingOverrideContext.Provider, { value: useFloatingContext, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_popper__WEBPACK_IMPORTED_MODULE_4__.Popper, { size, ...popperScope, ...restProps, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
    _tamagui_popover__WEBPACK_IMPORTED_MODULE_5__.__PopoverProviderInternal,
    {
      scope: __scopePopover,
      popperScope: popperScope.__scopePopper,
      contentId,
      triggerRef,
      sheetBreakpoint: false,
      scopeKey: "",
      open,
      onOpenChange: setOpen,
      onOpenToggle: voidFn,
      hasCustomAnchor,
      onCustomAnchorAdd,
      onCustomAnchorRemove,
      children
    }
  ) }) });
});
const Tooltip2 = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_9__.withStaticProperties)(TooltipComponent, {
  Anchor: _tamagui_popover__WEBPACK_IMPORTED_MODULE_5__.PopoverAnchor,
  Arrow: TooltipArrow,
  Content: TooltipContent,
  Trigger: _tamagui_popover__WEBPACK_IMPORTED_MODULE_5__.PopoverTrigger
});
const voidFn = () => {
};

//# sourceMappingURL=Tooltip.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/tooltip/dist/esm/TooltipSimple.mjs":
/*!**********************************************************************!*\
  !*** ../../node_modules/@tamagui/tooltip/dist/esm/TooltipSimple.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TooltipSimple": () => (/* binding */ TooltipSimple)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/react */ "../../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js");
/* harmony import */ var _tamagui_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/text */ "../../node_modules/@tamagui/text/dist/esm/Paragraph.mjs");
/* harmony import */ var _Tooltip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Tooltip */ "../../node_modules/@tamagui/tooltip/dist/esm/Tooltip.mjs");




const TooltipSimple = ({
  label,
  children,
  contentProps,
  ...tooltipProps
}) => {
  let context;
  try {
    context = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_1__.useDelayGroupContext)();
  } catch {
  }
  const contents = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_Tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip, { ...tooltipProps, children: [
    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.Trigger, { asChild: true, children }),
    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(
      _Tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.Content,
      {
        zIndex: 1e6,
        enterStyle: { x: 0, y: -8, opacity: 0, scale: 0.93 },
        exitStyle: { x: 0, y: -8, opacity: 0, scale: 0.93 },
        x: 0,
        scale: 1,
        y: 0,
        elevation: "$1",
        opacity: 1,
        animation: [
          "quick",
          {
            opacity: {
              overshootClamping: true
            }
          }
        ],
        ...contentProps,
        children: [
          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Tooltip__WEBPACK_IMPORTED_MODULE_2__.Tooltip.Arrow, {}),
          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_text__WEBPACK_IMPORTED_MODULE_3__.Paragraph, { size: "$2", lineHeight: "$0", children: label })
        ]
      }
    )
  ] });
  if (!context) {
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Tooltip__WEBPACK_IMPORTED_MODULE_2__.TooltipGroup, { delay: defaultTooltipDelay, children: contents });
  }
  return contents;
};
const defaultTooltipDelay = { open: 3e3, close: 100 };

//# sourceMappingURL=TooltipSimple.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/tooltip/dist/esm/index.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@tamagui/tooltip/dist/esm/index.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tooltip": () => (/* reexport safe */ _Tooltip__WEBPACK_IMPORTED_MODULE_0__.Tooltip),
/* harmony export */   "TooltipGroup": () => (/* reexport safe */ _Tooltip__WEBPACK_IMPORTED_MODULE_0__.TooltipGroup),
/* harmony export */   "TooltipSimple": () => (/* reexport safe */ _TooltipSimple__WEBPACK_IMPORTED_MODULE_1__.TooltipSimple)
/* harmony export */ });
/* harmony import */ var _Tooltip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tooltip */ "../../node_modules/@tamagui/tooltip/dist/esm/Tooltip.mjs");
/* harmony import */ var _TooltipSimple__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TooltipSimple */ "../../node_modules/@tamagui/tooltip/dist/esm/TooltipSimple.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/use-constant/dist/esm/index.mjs":
/*!*******************************************************************!*\
  !*** ../../node_modules/@tamagui/use-constant/dist/esm/index.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useConstant": () => (/* binding */ useConstant)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

function useConstant(fn) {
  if (typeof document === "undefined") {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => fn(), []);
  }
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  if (!ref.current) {
    ref.current = { v: fn() };
  }
  return ref.current.v;
}

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/use-controllable-state/dist/esm/index.mjs":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@tamagui/use-controllable-state/dist/esm/index.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useControllableState": () => (/* reexport safe */ _useControllableState__WEBPACK_IMPORTED_MODULE_0__.useControllableState)
/* harmony export */ });
/* harmony import */ var _useControllableState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useControllableState */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/useControllableState.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/use-debounce/dist/esm/index.mjs":
/*!*******************************************************************!*\
  !*** ../../node_modules/@tamagui/use-debounce/dist/esm/index.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debounce": () => (/* binding */ debounce),
/* harmony export */   "useDebounce": () => (/* binding */ useDebounce),
/* harmony export */   "useDebounceValue": () => (/* binding */ useDebounceValue)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

function debounce(func, wait, leading) {
  let timeout;
  let isCancelled = false;
  function debounced() {
    isCancelled = false;
    const context = this;
    const args = arguments;
    if (leading && !timeout) {
      func.apply(context, args);
    }
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      timeout = null;
      if (!(leading || isCancelled)) {
        func.apply(context, args);
      }
      isCancelled = false;
    }, wait);
  }
  debounced.cancel = () => {
    isCancelled = true;
  };
  return debounced;
}
const defaultOpts = { leading: false };
function useDebounce(fn, wait, options = defaultOpts, mountArgs = []) {
  const dbEffect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    return () => {
      var _a;
      (_a = dbEffect.current) == null ? void 0 : _a.cancel();
    };
  }, []);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    dbEffect.current = debounce(fn, wait, options.leading);
    return dbEffect.current;
  }, [options.leading, ...mountArgs]);
}
function useDebounceValue(val, amt = 0) {
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(val);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const tm = setTimeout(() => {
      setState((prev) => {
        if (prev === val)
          return prev;
        return val;
      });
    }, amt);
    return () => {
      clearTimeout(tm);
    };
  }, [val]);
  return state;
}

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/use-direction/dist/esm/index.mjs":
/*!********************************************************************!*\
  !*** ../../node_modules/@tamagui/use-direction/dist/esm/index.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DirectionProvider": () => (/* reexport safe */ _useDirection__WEBPACK_IMPORTED_MODULE_0__.DirectionProvider),
/* harmony export */   "Provider": () => (/* reexport safe */ _useDirection__WEBPACK_IMPORTED_MODULE_0__.Provider),
/* harmony export */   "useDirection": () => (/* reexport safe */ _useDirection__WEBPACK_IMPORTED_MODULE_0__.useDirection)
/* harmony export */ });
/* harmony import */ var _useDirection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useDirection */ "../../node_modules/@tamagui/use-direction/dist/esm/useDirection.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/use-direction/dist/esm/useDirection.mjs":
/*!***************************************************************************!*\
  !*** ../../node_modules/@tamagui/use-direction/dist/esm/useDirection.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DirectionProvider": () => (/* binding */ DirectionProvider),
/* harmony export */   "Provider": () => (/* binding */ Provider),
/* harmony export */   "useDirection": () => (/* binding */ useDirection)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);


const DirectionContext = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);
const DirectionProvider = (props) => {
  const { dir, children } = props;
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DirectionContext.Provider, { value: dir, children });
};
function useDirection(localDir) {
  const globalDir = react__WEBPACK_IMPORTED_MODULE_1__.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
const Provider = DirectionProvider;

//# sourceMappingURL=useDirection.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/use-keyboard-visible/dist/esm/index.mjs":
/*!***************************************************************************!*\
  !*** ../../node_modules/@tamagui/use-keyboard-visible/dist/esm/index.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useKeyboardVisible": () => (/* reexport safe */ _useKeyboardVisible__WEBPACK_IMPORTED_MODULE_0__.useKeyboardVisible)
/* harmony export */ });
/* harmony import */ var _useKeyboardVisible__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useKeyboardVisible */ "../../node_modules/@tamagui/use-keyboard-visible/dist/esm/useKeyboardVisible.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/use-keyboard-visible/dist/esm/useKeyboardVisible.mjs":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@tamagui/use-keyboard-visible/dist/esm/useKeyboardVisible.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useKeyboardVisible": () => (/* binding */ useKeyboardVisible)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-native */ "../../node_modules/react-native-web/dist/index.js");


const useKeyboardVisible = () => {
  const [isKeyboardVisible, setKeyboardVisible] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const keyboardDidShowListener = react_native__WEBPACK_IMPORTED_MODULE_1__.Keyboard.addListener("keyboardDidShow", () => {
      setKeyboardVisible(true);
    });
    const keyboardDidHideListener = react_native__WEBPACK_IMPORTED_MODULE_1__.Keyboard.addListener("keyboardDidHide", () => {
      setKeyboardVisible(false);
    });
    return () => {
      keyboardDidHideListener.remove();
      keyboardDidShowListener.remove();
    };
  }, []);
  return isKeyboardVisible;
};

//# sourceMappingURL=useKeyboardVisible.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/use-window-dimensions/dist/esm/index.mjs":
/*!****************************************************************************!*\
  !*** ../../node_modules/@tamagui/use-window-dimensions/dist/esm/index.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useWindowDimensions": () => (/* binding */ useWindowDimensions)
/* harmony export */ });
/* harmony import */ var _tamagui_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/constants */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-native */ "../../node_modules/react-native-web/dist/index.js");



const initialValue = {
  fontScale: 1,
  height: 800,
  width: 600,
  scale: 1
};
function useWindowDimensions() {
  const current = (0,react_native__WEBPACK_IMPORTED_MODULE_2__.useWindowDimensions)();
  if (false)
    {}
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialValue);
  (0,_tamagui_constants__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect)(() => {
    setState(current);
  }, [current.height, current.width, current.fontScale, current.scale]);
  return state;
}

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/@tamagui/visually-hidden/dist/esm/index.mjs":
/*!**********************************************************************!*\
  !*** ../../node_modules/@tamagui/visually-hidden/dist/esm/index.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VisuallyHidden": () => (/* reexport safe */ _VisuallyHidden__WEBPACK_IMPORTED_MODULE_0__.VisuallyHidden)
/* harmony export */ });
/* harmony import */ var _VisuallyHidden__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VisuallyHidden */ "../../node_modules/@tamagui/visually-hidden/dist/esm/VisuallyHidden.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/aria-hidden/dist/es2015/index.js":
/*!***********************************************************!*\
  !*** ../../node_modules/aria-hidden/dist/es2015/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hideOthers": () => (/* binding */ hideOthers),
/* harmony export */   "inertOthers": () => (/* binding */ inertOthers),
/* harmony export */   "supportsInert": () => (/* binding */ supportsInert),
/* harmony export */   "suppressOthers": () => (/* binding */ suppressOthers)
/* harmony export */ });
var getDefaultParent = function (originalTarget) {
    if (typeof document === 'undefined') {
        return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
};
var counterMap = new WeakMap();
var uncontrolledNodes = new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function (node) {
    return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function (parent, targets) {
    return targets.map(function (target) {
        if (parent.contains(target)) {
            return target;
        }
        var correctedTarget = unwrapHost(target);
        if (correctedTarget && parent.contains(correctedTarget)) {
            return correctedTarget;
        }
        console.error('aria-hidden', target, 'in not contained inside', parent, '. Doing nothing');
        return null;
    }).filter(function (x) { return Boolean(x); });
};
/**
 * Marks everything except given node(or nodes) as aria-hidden
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @param {String} [controlAttribute] - html Attribute to control
 * @return {Undo} undo command
 */
var applyAttributeToOthers = function (originalTarget, parentNode, markerName, controlAttribute) {
    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    if (!markerMap[markerName]) {
        markerMap[markerName] = new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = new Set();
    var elementsToStop = new Set(targets);
    var keep = function (el) {
        if (!el || elementsToKeep.has(el)) {
            return;
        }
        elementsToKeep.add(el);
        keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function (parent) {
        if (!parent || elementsToStop.has(parent)) {
            return;
        }
        Array.prototype.forEach.call(parent.children, function (node) {
            if (elementsToKeep.has(node)) {
                deep(node);
            }
            else {
                var attr = node.getAttribute(controlAttribute);
                var alreadyHidden = attr !== null && attr !== 'false';
                var counterValue = (counterMap.get(node) || 0) + 1;
                var markerValue = (markerCounter.get(node) || 0) + 1;
                counterMap.set(node, counterValue);
                markerCounter.set(node, markerValue);
                hiddenNodes.push(node);
                if (counterValue === 1 && alreadyHidden) {
                    uncontrolledNodes.set(node, true);
                }
                if (markerValue === 1) {
                    node.setAttribute(markerName, 'true');
                }
                if (!alreadyHidden) {
                    node.setAttribute(controlAttribute, 'true');
                }
            }
        });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function () {
        hiddenNodes.forEach(function (node) {
            var counterValue = counterMap.get(node) - 1;
            var markerValue = markerCounter.get(node) - 1;
            counterMap.set(node, counterValue);
            markerCounter.set(node, markerValue);
            if (!counterValue) {
                if (!uncontrolledNodes.has(node)) {
                    node.removeAttribute(controlAttribute);
                }
                uncontrolledNodes.delete(node);
            }
            if (!markerValue) {
                node.removeAttribute(markerName);
            }
        });
        lockCount--;
        if (!lockCount) {
            // clear
            counterMap = new WeakMap();
            counterMap = new WeakMap();
            uncontrolledNodes = new WeakMap();
            markerMap = {};
        }
    };
};
/**
 * Marks everything except given node(or nodes) as aria-hidden
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @return {Undo} undo command
 */
var hideOthers = function (originalTarget, parentNode, markerName) {
    if (markerName === void 0) { markerName = 'data-aria-hidden'; }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
        return function () { return null; };
    }
    // we should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live]')));
    return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');
};
/**
 * Marks everything except given node(or nodes) as inert
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @return {Undo} undo command
 */
var inertOthers = function (originalTarget, parentNode, markerName) {
    if (markerName === void 0) { markerName = 'data-inert-ed'; }
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
        return function () { return null; };
    }
    return applyAttributeToOthers(originalTarget, activeParentNode, markerName, 'inert');
};
/**
 * @returns if current browser supports inert
 */
var supportsInert = function () {
    return typeof HTMLElement !== 'undefined' && HTMLElement.prototype.hasOwnProperty('inert');
};
/**
 * Automatic function to "suppress" DOM elements - _hide_ or _inert_ in the best possible way
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @return {Undo} undo command
 */
var suppressOthers = function (originalTarget, parentNode, markerName) {
    if (markerName === void 0) { markerName = 'data-suppressed'; }
    return (supportsInert() ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);
};


/***/ }),

/***/ "../../node_modules/react-native-svg/lib/module/ReactNativeSVG.web.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/react-native-svg/lib/module/ReactNativeSVG.web.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var _interopRequireDefault=__webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(exports, "__esModule", ({value:true}));exports["default"]=exports.WebShape=exports.Use=exports.TextPath=exports.Text=exports.TSpan=exports.Symbol=exports.Svg=exports.Stop=exports.Rect=exports.RadialGradient=exports.Polyline=exports.Polygon=exports.Pattern=exports.Path=exports.Mask=exports.Marker=exports.LinearGradient=exports.Line=exports.Image=exports.G=exports.ForeignObject=exports.Ellipse=exports.Defs=exports.ClipPath=exports.Circle=void 0;var _createClass2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "../../node_modules/@babel/runtime/helpers/createClass.js"));var _classCallCheck2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "../../node_modules/@babel/runtime/helpers/classCallCheck.js"));var _assertThisInitialized2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "../../node_modules/@babel/runtime/helpers/assertThisInitialized.js"));var _inherits2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "../../node_modules/@babel/runtime/helpers/inherits.js"));var _possibleConstructorReturn2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));var _getPrototypeOf2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/getPrototypeOf.js"));var _defineProperty2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));var _extends2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js"));var _objectWithoutProperties2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js"));var React=_interopRequireWildcard(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));var _reactNative=__webpack_require__(/*! react-native-web/dist/index */ "../../node_modules/react-native-web/dist/index.js");var _SvgTouchableMixin=_interopRequireDefault(__webpack_require__(/*! ./lib/SvgTouchableMixin */ "../../node_modules/react-native-svg/lib/module/lib/SvgTouchableMixin.js"));var _resolve=__webpack_require__(/*! ./lib/resolve */ "../../node_modules/react-native-svg/lib/module/lib/resolve.js");var _excluded=["translate","translateX","translateY","scale","rotation","skewX","skewY","originX","originY","fontFamily","fontSize","fontWeight","fontStyle","style","forwardedRef"],_excluded2=["x","y"];function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!=="function")return null;var cacheBabelInterop=new WeakMap();var cacheNodeInterop=new WeakMap();return(_getRequireWildcardCache=function _getRequireWildcardCache(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj;}if(obj===null||typeof obj!=="object"&&typeof obj!=="function"){return{default:obj};}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj);}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!=="default"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}newObj.default=obj;if(cache){cache.set(obj,newObj);}return newObj;}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=(0,_getPrototypeOf2.default)(Derived),result;if(hasNativeReflectConstruct){var NewTarget=(0,_getPrototypeOf2.default)(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return(0,_possibleConstructorReturn2.default)(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}var createElement=_reactNative.createElement||_reactNative.unstable_createElement;var hasTouchableProperty=function hasTouchableProperty(props){return props.onPress||props.onPressIn||props.onPressOut||props.onLongPress;};var prepare=function prepare(self){var props=arguments.length>1&&arguments[1]!==undefined?arguments[1]:self.props;var translate=props.translate,translateX=props.translateX,translateY=props.translateY,scale=props.scale,rotation=props.rotation,skewX=props.skewX,skewY=props.skewY,originX=props.originX,originY=props.originY,fontFamily=props.fontFamily,fontSize=props.fontSize,fontWeight=props.fontWeight,fontStyle=props.fontStyle,style=props.style,forwardedRef=props.forwardedRef,rest=(0,_objectWithoutProperties2.default)(props,_excluded);var clean=(0,_extends2.default)({},hasTouchableProperty(props)?{onStartShouldSetResponder:self.touchableHandleStartShouldSetResponder,onResponderTerminationRequest:self.touchableHandleResponderTerminationRequest,onResponderGrant:self.touchableHandleResponderGrant,onResponderMove:self.touchableHandleResponderMove,onResponderRelease:self.touchableHandleResponderRelease,onResponderTerminate:self.touchableHandleResponderTerminate}:null,rest);var transform=[];if(originX!=null||originY!=null){transform.push("translate("+(originX||0)+", "+(originY||0)+")");}if(translate!=null){transform.push("translate("+translate+")");}if(translateX!=null||translateY!=null){transform.push("translate("+(translateX||0)+", "+(translateY||0)+")");}if(scale!=null){transform.push("scale("+scale+")");}if(rotation!=null){transform.push("rotate("+rotation+")");}if(skewX!=null){transform.push("skewX("+skewX+")");}if(skewY!=null){transform.push("skewY("+skewY+")");}if(originX!=null||originY!=null){transform.push("translate("+(-originX||0)+", "+(-originY||0)+")");}if(transform.length){clean.transform=transform.join(' ');}if(forwardedRef){clean.ref=forwardedRef;}var styles={};if(fontFamily!=null){styles.fontFamily=fontFamily;}if(fontSize!=null){styles.fontSize=fontSize;}if(fontWeight!=null){styles.fontWeight=fontWeight;}if(fontStyle!=null){styles.fontStyle=fontStyle;}clean.style=(0,_resolve.resolve)(style,styles);return clean;};var getBoundingClientRect=function getBoundingClientRect(node){if(node){var isElement=node.nodeType===1;if(isElement&&typeof node.getBoundingClientRect==='function'){return node.getBoundingClientRect();}}};var measureLayout=function measureLayout(node,callback){var relativeNode=node&&node.parentNode;if(relativeNode){setTimeout(function(){var relativeRect=getBoundingClientRect(relativeNode);var _getBoundingClientRec=getBoundingClientRect(node),height=_getBoundingClientRec.height,left=_getBoundingClientRec.left,top=_getBoundingClientRec.top,width=_getBoundingClientRec.width;var x=left-relativeRect.left;var y=top-relativeRect.top;callback(x,y,width,height,left,top);},0);}};function remeasure(){var tag=this.state.touchable.responderID;if(tag==null){return;}measureLayout(tag,this._handleQueryLayout);}var WebShape=function(_React$Component){(0,_inherits2.default)(WebShape,_React$Component);var _super=_createSuper(WebShape);function WebShape(props,context){var _this;(0,_classCallCheck2.default)(this,WebShape);_this=_super.call(this,props,context);(0,_defineProperty2.default)((0,_assertThisInitialized2.default)(_this),"_remeasureMetricsOnActivation",void 0);(0,_defineProperty2.default)((0,_assertThisInitialized2.default)(_this),"touchableHandleStartShouldSetResponder",void 0);(0,_defineProperty2.default)((0,_assertThisInitialized2.default)(_this),"touchableHandleResponderMove",void 0);(0,_defineProperty2.default)((0,_assertThisInitialized2.default)(_this),"touchableHandleResponderGrant",void 0);(0,_defineProperty2.default)((0,_assertThisInitialized2.default)(_this),"touchableHandleResponderRelease",void 0);(0,_defineProperty2.default)((0,_assertThisInitialized2.default)(_this),"touchableHandleResponderTerminate",void 0);(0,_defineProperty2.default)((0,_assertThisInitialized2.default)(_this),"touchableHandleResponderTerminationRequest",void 0);if(hasTouchableProperty(props)){(0,_SvgTouchableMixin.default)((0,_assertThisInitialized2.default)(_this));}_this._remeasureMetricsOnActivation=remeasure.bind((0,_assertThisInitialized2.default)(_this));return _this;}return(0,_createClass2.default)(WebShape);}(React.Component);exports.WebShape=WebShape;var Circle=function(_WebShape){(0,_inherits2.default)(Circle,_WebShape);var _super2=_createSuper(Circle);function Circle(){(0,_classCallCheck2.default)(this,Circle);return _super2.apply(this,arguments);}(0,_createClass2.default)(Circle,[{key:"render",value:function render(){return createElement('circle',prepare(this));}}]);return Circle;}(WebShape);exports.Circle=Circle;var ClipPath=function(_WebShape2){(0,_inherits2.default)(ClipPath,_WebShape2);var _super3=_createSuper(ClipPath);function ClipPath(){(0,_classCallCheck2.default)(this,ClipPath);return _super3.apply(this,arguments);}(0,_createClass2.default)(ClipPath,[{key:"render",value:function render(){return createElement('clipPath',prepare(this));}}]);return ClipPath;}(WebShape);exports.ClipPath=ClipPath;var Defs=function(_WebShape3){(0,_inherits2.default)(Defs,_WebShape3);var _super4=_createSuper(Defs);function Defs(){(0,_classCallCheck2.default)(this,Defs);return _super4.apply(this,arguments);}(0,_createClass2.default)(Defs,[{key:"render",value:function render(){return createElement('defs',prepare(this));}}]);return Defs;}(WebShape);exports.Defs=Defs;var Ellipse=function(_WebShape4){(0,_inherits2.default)(Ellipse,_WebShape4);var _super5=_createSuper(Ellipse);function Ellipse(){(0,_classCallCheck2.default)(this,Ellipse);return _super5.apply(this,arguments);}(0,_createClass2.default)(Ellipse,[{key:"render",value:function render(){return createElement('ellipse',prepare(this));}}]);return Ellipse;}(WebShape);exports.Ellipse=Ellipse;var G=function(_WebShape5){(0,_inherits2.default)(G,_WebShape5);var _super6=_createSuper(G);function G(){(0,_classCallCheck2.default)(this,G);return _super6.apply(this,arguments);}(0,_createClass2.default)(G,[{key:"render",value:function render(){var _this$props=this.props,x=_this$props.x,y=_this$props.y,rest=(0,_objectWithoutProperties2.default)(_this$props,_excluded2);if((x||y)&&!rest.translate){rest.translate=(x||0)+", "+(y||0);}return createElement('g',prepare(this,rest));}}]);return G;}(WebShape);exports.G=G;var Image=function(_WebShape6){(0,_inherits2.default)(Image,_WebShape6);var _super7=_createSuper(Image);function Image(){(0,_classCallCheck2.default)(this,Image);return _super7.apply(this,arguments);}(0,_createClass2.default)(Image,[{key:"render",value:function render(){return createElement('image',prepare(this));}}]);return Image;}(WebShape);exports.Image=Image;var Line=function(_WebShape7){(0,_inherits2.default)(Line,_WebShape7);var _super8=_createSuper(Line);function Line(){(0,_classCallCheck2.default)(this,Line);return _super8.apply(this,arguments);}(0,_createClass2.default)(Line,[{key:"render",value:function render(){return createElement('line',prepare(this));}}]);return Line;}(WebShape);exports.Line=Line;var LinearGradient=function(_WebShape8){(0,_inherits2.default)(LinearGradient,_WebShape8);var _super9=_createSuper(LinearGradient);function LinearGradient(){(0,_classCallCheck2.default)(this,LinearGradient);return _super9.apply(this,arguments);}(0,_createClass2.default)(LinearGradient,[{key:"render",value:function render(){return createElement('linearGradient',prepare(this));}}]);return LinearGradient;}(WebShape);exports.LinearGradient=LinearGradient;var Path=function(_WebShape9){(0,_inherits2.default)(Path,_WebShape9);var _super10=_createSuper(Path);function Path(){(0,_classCallCheck2.default)(this,Path);return _super10.apply(this,arguments);}(0,_createClass2.default)(Path,[{key:"render",value:function render(){return createElement('path',prepare(this));}}]);return Path;}(WebShape);exports.Path=Path;var Polygon=function(_WebShape10){(0,_inherits2.default)(Polygon,_WebShape10);var _super11=_createSuper(Polygon);function Polygon(){(0,_classCallCheck2.default)(this,Polygon);return _super11.apply(this,arguments);}(0,_createClass2.default)(Polygon,[{key:"render",value:function render(){return createElement('polygon',prepare(this));}}]);return Polygon;}(WebShape);exports.Polygon=Polygon;var Polyline=function(_WebShape11){(0,_inherits2.default)(Polyline,_WebShape11);var _super12=_createSuper(Polyline);function Polyline(){(0,_classCallCheck2.default)(this,Polyline);return _super12.apply(this,arguments);}(0,_createClass2.default)(Polyline,[{key:"render",value:function render(){return createElement('polyline',prepare(this));}}]);return Polyline;}(WebShape);exports.Polyline=Polyline;var RadialGradient=function(_WebShape12){(0,_inherits2.default)(RadialGradient,_WebShape12);var _super13=_createSuper(RadialGradient);function RadialGradient(){(0,_classCallCheck2.default)(this,RadialGradient);return _super13.apply(this,arguments);}(0,_createClass2.default)(RadialGradient,[{key:"render",value:function render(){return createElement('radialGradient',prepare(this));}}]);return RadialGradient;}(WebShape);exports.RadialGradient=RadialGradient;var Rect=function(_WebShape13){(0,_inherits2.default)(Rect,_WebShape13);var _super14=_createSuper(Rect);function Rect(){(0,_classCallCheck2.default)(this,Rect);return _super14.apply(this,arguments);}(0,_createClass2.default)(Rect,[{key:"render",value:function render(){return createElement('rect',prepare(this));}}]);return Rect;}(WebShape);exports.Rect=Rect;var Stop=function(_WebShape14){(0,_inherits2.default)(Stop,_WebShape14);var _super15=_createSuper(Stop);function Stop(){(0,_classCallCheck2.default)(this,Stop);return _super15.apply(this,arguments);}(0,_createClass2.default)(Stop,[{key:"render",value:function render(){return createElement('stop',prepare(this));}}]);return Stop;}(WebShape);exports.Stop=Stop;var Svg=function(_WebShape15){(0,_inherits2.default)(Svg,_WebShape15);var _super16=_createSuper(Svg);function Svg(){(0,_classCallCheck2.default)(this,Svg);return _super16.apply(this,arguments);}(0,_createClass2.default)(Svg,[{key:"render",value:function render(){return createElement('svg',prepare(this));}}]);return Svg;}(WebShape);exports.Svg=Svg;var Symbol=function(_WebShape16){(0,_inherits2.default)(Symbol,_WebShape16);var _super17=_createSuper(Symbol);function Symbol(){(0,_classCallCheck2.default)(this,Symbol);return _super17.apply(this,arguments);}(0,_createClass2.default)(Symbol,[{key:"render",value:function render(){return createElement('symbol',prepare(this));}}]);return Symbol;}(WebShape);exports.Symbol=Symbol;var Text=function(_WebShape17){(0,_inherits2.default)(Text,_WebShape17);var _super18=_createSuper(Text);function Text(){(0,_classCallCheck2.default)(this,Text);return _super18.apply(this,arguments);}(0,_createClass2.default)(Text,[{key:"render",value:function render(){return createElement('text',prepare(this));}}]);return Text;}(WebShape);exports.Text=Text;var TSpan=function(_WebShape18){(0,_inherits2.default)(TSpan,_WebShape18);var _super19=_createSuper(TSpan);function TSpan(){(0,_classCallCheck2.default)(this,TSpan);return _super19.apply(this,arguments);}(0,_createClass2.default)(TSpan,[{key:"render",value:function render(){return createElement('tspan',prepare(this));}}]);return TSpan;}(WebShape);exports.TSpan=TSpan;var TextPath=function(_WebShape19){(0,_inherits2.default)(TextPath,_WebShape19);var _super20=_createSuper(TextPath);function TextPath(){(0,_classCallCheck2.default)(this,TextPath);return _super20.apply(this,arguments);}(0,_createClass2.default)(TextPath,[{key:"render",value:function render(){return createElement('textPath',prepare(this));}}]);return TextPath;}(WebShape);exports.TextPath=TextPath;var Use=function(_WebShape20){(0,_inherits2.default)(Use,_WebShape20);var _super21=_createSuper(Use);function Use(){(0,_classCallCheck2.default)(this,Use);return _super21.apply(this,arguments);}(0,_createClass2.default)(Use,[{key:"render",value:function render(){return createElement('use',prepare(this));}}]);return Use;}(WebShape);exports.Use=Use;var Mask=function(_WebShape21){(0,_inherits2.default)(Mask,_WebShape21);var _super22=_createSuper(Mask);function Mask(){(0,_classCallCheck2.default)(this,Mask);return _super22.apply(this,arguments);}(0,_createClass2.default)(Mask,[{key:"render",value:function render(){return createElement('mask',prepare(this));}}]);return Mask;}(WebShape);exports.Mask=Mask;var ForeignObject=function(_WebShape22){(0,_inherits2.default)(ForeignObject,_WebShape22);var _super23=_createSuper(ForeignObject);function ForeignObject(){(0,_classCallCheck2.default)(this,ForeignObject);return _super23.apply(this,arguments);}(0,_createClass2.default)(ForeignObject,[{key:"render",value:function render(){return createElement('foreignObject',prepare(this));}}]);return ForeignObject;}(WebShape);exports.ForeignObject=ForeignObject;var Marker=function(_WebShape23){(0,_inherits2.default)(Marker,_WebShape23);var _super24=_createSuper(Marker);function Marker(){(0,_classCallCheck2.default)(this,Marker);return _super24.apply(this,arguments);}(0,_createClass2.default)(Marker,[{key:"render",value:function render(){return createElement('marker',prepare(this));}}]);return Marker;}(WebShape);exports.Marker=Marker;var Pattern=function(_WebShape24){(0,_inherits2.default)(Pattern,_WebShape24);var _super25=_createSuper(Pattern);function Pattern(){(0,_classCallCheck2.default)(this,Pattern);return _super25.apply(this,arguments);}(0,_createClass2.default)(Pattern,[{key:"render",value:function render(){return createElement('pattern',prepare(this));}}]);return Pattern;}(WebShape);exports.Pattern=Pattern;var _default=Svg;exports["default"]=_default;

/***/ }),

/***/ "../../node_modules/react-native-svg/lib/module/index.js":
/*!***************************************************************!*\
  !*** ../../node_modules/react-native-svg/lib/module/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

Object.defineProperty(exports, "__esModule", ({value:true}));var _exportNames={};Object.defineProperty(exports, "default", ({enumerable:true,get:function get(){return _ReactNativeSVG.default;}}));var _ReactNativeSVG=_interopRequireWildcard(__webpack_require__(/*! ./ReactNativeSVG */ "../../node_modules/react-native-svg/lib/module/ReactNativeSVG.web.js"));Object.keys(_ReactNativeSVG).forEach(function(key){if(key==="default"||key==="__esModule")return;if(Object.prototype.hasOwnProperty.call(_exportNames,key))return;if(key in exports&&exports[key]===_ReactNativeSVG[key])return;Object.defineProperty(exports,key,{enumerable:true,get:function get(){return _ReactNativeSVG[key];}});});function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!=="function")return null;var cacheBabelInterop=new WeakMap();var cacheNodeInterop=new WeakMap();return(_getRequireWildcardCache=function _getRequireWildcardCache(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj;}if(obj===null||typeof obj!=="object"&&typeof obj!=="function"){return{default:obj};}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj);}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!=="default"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}newObj.default=obj;if(cache){cache.set(obj,newObj);}return newObj;}

/***/ }),

/***/ "../../node_modules/react-native-svg/lib/module/lib/SvgTouchableMixin.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/react-native-svg/lib/module/lib/SvgTouchableMixin.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var _interopRequireDefault=__webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(exports, "__esModule", ({value:true}));exports["default"]=void 0;var _extends2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js"));var _reactNative=__webpack_require__(/*! react-native-web/dist/index */ "../../node_modules/react-native-web/dist/index.js");var PRESS_RETENTION_OFFSET={top:20,left:20,right:20,bottom:30};var Mixin=_reactNative.Touchable.Mixin;var _touchableHandleStartShouldSetResponder=Mixin.touchableHandleStartShouldSetResponder,_touchableHandleResponderTerminationRequest=Mixin.touchableHandleResponderTerminationRequest,_touchableHandleResponderGrant=Mixin.touchableHandleResponderGrant,_touchableHandleResponderMove=Mixin.touchableHandleResponderMove,_touchableHandleResponderRelease=Mixin.touchableHandleResponderRelease,_touchableHandleResponderTerminate=Mixin.touchableHandleResponderTerminate,touchableGetInitialState=Mixin.touchableGetInitialState;var SvgTouchableMixin=(0,_extends2.default)({},Mixin,{touchableHandleStartShouldSetResponder:function touchableHandleStartShouldSetResponder(e){var onStartShouldSetResponder=this.props.onStartShouldSetResponder;if(onStartShouldSetResponder){return onStartShouldSetResponder(e);}else{return _touchableHandleStartShouldSetResponder.call(this,e);}},touchableHandleResponderTerminationRequest:function touchableHandleResponderTerminationRequest(e){var onResponderTerminationRequest=this.props.onResponderTerminationRequest;if(onResponderTerminationRequest){return onResponderTerminationRequest(e);}else{return _touchableHandleResponderTerminationRequest.call(this,e);}},touchableHandleResponderGrant:function touchableHandleResponderGrant(e){var onResponderGrant=this.props.onResponderGrant;if(onResponderGrant){return onResponderGrant(e);}else{return _touchableHandleResponderGrant.call(this,e);}},touchableHandleResponderMove:function touchableHandleResponderMove(e){var onResponderMove=this.props.onResponderMove;if(onResponderMove){return onResponderMove(e);}else{return _touchableHandleResponderMove.call(this,e);}},touchableHandleResponderRelease:function touchableHandleResponderRelease(e){var onResponderRelease=this.props.onResponderRelease;if(onResponderRelease){return onResponderRelease(e);}else{return _touchableHandleResponderRelease.call(this,e);}},touchableHandleResponderTerminate:function touchableHandleResponderTerminate(e){var onResponderTerminate=this.props.onResponderTerminate;if(onResponderTerminate){return onResponderTerminate(e);}else{return _touchableHandleResponderTerminate.call(this,e);}},touchableHandlePress:function touchableHandlePress(e){var onPress=this.props.onPress;onPress&&onPress(e);},touchableHandleActivePressIn:function touchableHandleActivePressIn(e){var onPressIn=this.props.onPressIn;onPressIn&&onPressIn(e);},touchableHandleActivePressOut:function touchableHandleActivePressOut(e){var onPressOut=this.props.onPressOut;onPressOut&&onPressOut(e);},touchableHandleLongPress:function touchableHandleLongPress(e){var onLongPress=this.props.onLongPress;onLongPress&&onLongPress(e);},touchableGetPressRectOffset:function touchableGetPressRectOffset(){var pressRetentionOffset=this.props.pressRetentionOffset;return pressRetentionOffset||PRESS_RETENTION_OFFSET;},touchableGetHitSlop:function touchableGetHitSlop(){var hitSlop=this.props.hitSlop;return hitSlop;},touchableGetHighlightDelayMS:function touchableGetHighlightDelayMS(){var delayPressIn=this.props.delayPressIn;return delayPressIn||0;},touchableGetLongPressDelayMS:function touchableGetLongPressDelayMS(){var delayLongPress=this.props.delayLongPress;return delayLongPress===0?0:delayLongPress||500;},touchableGetPressOutDelayMS:function touchableGetPressOutDelayMS(){var delayPressOut=this.props.delayPressOut;return delayPressOut||0;}});var touchKeys=Object.keys(SvgTouchableMixin);var touchVals=touchKeys.map(function(key){return SvgTouchableMixin[key];});var numTouchKeys=touchKeys.length;var _default=function _default(target){for(var i=0;i<numTouchKeys;i++){var key=touchKeys[i];var val=touchVals[i];if(typeof val==='function'){target[key]=val.bind(target);}else{target[key]=val;}}target.state=touchableGetInitialState();};exports["default"]=_default;

/***/ }),

/***/ "../../node_modules/react-native-svg/lib/module/lib/resolve.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/react-native-svg/lib/module/lib/resolve.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var _interopRequireDefault=__webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(exports, "__esModule", ({value:true}));exports.resolve=resolve;var _extends2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js"));var _toConsumableArray2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "../../node_modules/@babel/runtime/helpers/toConsumableArray.js"));var _reactNative=__webpack_require__(/*! react-native-web/dist/index */ "../../node_modules/react-native-web/dist/index.js");function resolve(styleProp,cleanedProps){if(styleProp){return _reactNative.StyleSheet?[styleProp,cleanedProps]:styleProp[Symbol.iterator]?Object.assign.apply(Object,[{}].concat((0,_toConsumableArray2.default)(styleProp),[cleanedProps])):(0,_extends2.default)({},styleProp,cleanedProps);}else{return cleanedProps;}}

/***/ }),

/***/ "../../node_modules/solito/build/link/core.js":
/*!****************************************************!*\
  !*** ../../node_modules/solito/build/link/core.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var _interopRequireDefault=__webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(exports, "__esModule", ({value:true}));exports.LinkCore=LinkCore;var _objectWithoutProperties2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js"));var _jsxRuntime=__webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");var _Platform=_interopRequireDefault(__webpack_require__(/*! react-native-web/dist/exports/Platform */ "../../node_modules/react-native-web/dist/exports/Platform/index.js"));var _linking=__webpack_require__(/*! ./linking */ "../../node_modules/solito/build/link/linking.web.js");var _nextLink=__webpack_require__(/*! ./next-link */ "../../node_modules/solito/build/link/next-link.web.js");var _useCustomLink=__webpack_require__(/*! ./use-custom-link */ "../../node_modules/solito/build/link/use-custom-link.js");var _excluded=["children","href","as","componentProps","Component","replace","experimental"];function LinkCore(_ref){var children=_ref.children,href=_ref.href,as=_ref.as,componentProps=_ref.componentProps,Component=_ref.Component,replace=_ref.replace,experimental=_ref.experimental,props=(0,_objectWithoutProperties2.default)(_ref,_excluded);if(_Platform.default.OS==='web'){return(0,_jsxRuntime.jsx)(_nextLink.NextLink,Object.assign({},props,{replace:replace,href:href,as:as,passHref:true,legacyBehavior:true,children:(0,_jsxRuntime.jsx)(Component,Object.assign({},componentProps,{children:children}),void 0)}),void 0);}var linkTo=(0,_useCustomLink.useLink)({href:href,as:as,replace:replace,experimental:experimental});return(0,_jsxRuntime.jsx)(Component,Object.assign({accessibilityRole:"link"},componentProps,{onPress:function onPress(e){componentProps==null?void 0:componentProps.onPress==null?void 0:componentProps.onPress(e);var link=as||href;if(!(e!=null&&e.defaultPrevented)&&typeof link==='string'&&isAbsoluteUrl(link)){(0,_linking.openURL)(link);}else{linkTo.onPress(e);}},children:children}),void 0);}var ABSOLUTE_URL_REGEX=/^[a-zA-Z][a-zA-Z\d+\-.]*?:/;var isAbsoluteUrl=function isAbsoluteUrl(url){return ABSOLUTE_URL_REGEX.test(url);};

/***/ }),

/***/ "../../node_modules/solito/build/link/index.js":
/*!*****************************************************!*\
  !*** ../../node_modules/solito/build/link/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

Object.defineProperty(exports, "__esModule", ({value:true}));var _core=__webpack_require__(/*! ./core */ "../../node_modules/solito/build/link/core.js");Object.keys(_core).forEach(function(key){if(key==="default"||key==="__esModule")return;if(key in exports&&exports[key]===_core[key])return;Object.defineProperty(exports,key,{enumerable:true,get:function get(){return _core[key];}});});var _textLink=__webpack_require__(/*! ./text-link */ "../../node_modules/solito/build/link/text-link.js");Object.keys(_textLink).forEach(function(key){if(key==="default"||key==="__esModule")return;if(key in exports&&exports[key]===_textLink[key])return;Object.defineProperty(exports,key,{enumerable:true,get:function get(){return _textLink[key];}});});var _link=__webpack_require__(/*! ./link */ "../../node_modules/solito/build/link/link.js");Object.keys(_link).forEach(function(key){if(key==="default"||key==="__esModule")return;if(key in exports&&exports[key]===_link[key])return;Object.defineProperty(exports,key,{enumerable:true,get:function get(){return _link[key];}});});var _useCustomLink=__webpack_require__(/*! ./use-custom-link */ "../../node_modules/solito/build/link/use-custom-link.js");Object.keys(_useCustomLink).forEach(function(key){if(key==="default"||key==="__esModule")return;if(key in exports&&exports[key]===_useCustomLink[key])return;Object.defineProperty(exports,key,{enumerable:true,get:function get(){return _useCustomLink[key];}});});

/***/ }),

/***/ "../../node_modules/solito/build/link/link.js":
/*!****************************************************!*\
  !*** ../../node_modules/solito/build/link/link.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

'use client';var _interopRequireDefault=__webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(exports, "__esModule", ({value:true}));exports.Link=Link;var _objectWithoutProperties2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js"));var _jsxRuntime=__webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");var _Platform=_interopRequireDefault(__webpack_require__(/*! react-native-web/dist/exports/Platform */ "../../node_modules/react-native-web/dist/exports/Platform/index.js"));var _Pressable=_interopRequireDefault(__webpack_require__(/*! react-native-web/dist/exports/Pressable */ "../../node_modules/react-native-web/dist/exports/Pressable/index.js"));var _View=_interopRequireDefault(__webpack_require__(/*! react-native-web/dist/exports/View */ "../../node_modules/react-native-web/dist/exports/View/index.js"));var _core=__webpack_require__(/*! ./core */ "../../node_modules/solito/build/link/core.js");var _excluded=["viewProps"];function Link(_ref){var viewProps=_ref.viewProps,props=(0,_objectWithoutProperties2.default)(_ref,_excluded);return(0,_jsxRuntime.jsx)(_core.LinkCore,Object.assign({},props,{Component:_Platform.default.select({web:_View.default,default:_Pressable.default}),componentProps:viewProps}),void 0);}

/***/ }),

/***/ "../../node_modules/solito/build/link/linking.web.js":
/*!***********************************************************!*\
  !*** ../../node_modules/solito/build/link/linking.web.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({value:true}));exports.openURL=void 0;var openURL=function openURL(url){};exports.openURL=openURL;

/***/ }),

/***/ "../../node_modules/solito/build/link/next-link.web.js":
/*!*************************************************************!*\
  !*** ../../node_modules/solito/build/link/next-link.web.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var _interopRequireDefault=__webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(exports, "__esModule", ({value:true}));Object.defineProperty(exports, "NextLink", ({enumerable:true,get:function get(){return _link.default;}}));var _link=_interopRequireDefault(__webpack_require__(/*! next/link */ "../../node_modules/next/link.js"));

/***/ }),

/***/ "../../node_modules/solito/build/link/text-link.js":
/*!*********************************************************!*\
  !*** ../../node_modules/solito/build/link/text-link.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

'use client';var _interopRequireDefault=__webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(exports, "__esModule", ({value:true}));exports.TextLink=TextLink;var _objectWithoutProperties2=_interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js"));var _jsxRuntime=__webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");var _Text=_interopRequireDefault(__webpack_require__(/*! react-native-web/dist/exports/Text */ "../../node_modules/react-native-web/dist/exports/Text/index.js"));var _core=__webpack_require__(/*! ./core */ "../../node_modules/solito/build/link/core.js");var _excluded=["textProps"];function TextLink(_ref){var textProps=_ref.textProps,props=(0,_objectWithoutProperties2.default)(_ref,_excluded);return(0,_jsxRuntime.jsx)(_core.LinkCore,Object.assign({},props,{Component:_Text.default,componentProps:Object.assign({selectable:false},textProps)}),void 0);}

/***/ }),

/***/ "../../node_modules/solito/build/link/use-custom-link.js":
/*!***************************************************************!*\
  !*** ../../node_modules/solito/build/link/use-custom-link.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var _interopRequireDefault=__webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(exports, "__esModule", ({value:true}));exports.useLink=useLink;var _Platform=_interopRequireDefault(__webpack_require__(/*! react-native-web/dist/exports/Platform */ "../../node_modules/react-native-web/dist/exports/Platform/index.js"));var _router=__webpack_require__(/*! ../router */ "../../node_modules/solito/build/router/index.js");function useLink(_ref){var href=_ref.href,as=_ref.as,shallow=_ref.shallow,scroll=_ref.scroll,replace=_ref.replace,experimental=_ref.experimental;var router=(0,_router.useRouter)();var onPress=function onPress(e){var _e$currentTarget;var shouldHandle=false;if(_Platform.default.OS!=='web'||!e){shouldHandle=e?!e.defaultPrevented:true;}else if(!e.defaultPrevented&&!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)&&(e.button==null||e.button===0)&&[undefined,null,'','self'].includes((_e$currentTarget=e.currentTarget)==null?void 0:_e$currentTarget.target)){e.preventDefault();shouldHandle=true;}if(shouldHandle){if(href==='#'){return;}if(replace){router.replace(href,as,{shallow:shallow,scroll:scroll,experimental:experimental});}else{router.push(href,as,{shallow:shallow,scroll:scroll});}}};return{accessibilityRole:'link',onPress:onPress,href:router.parseNextPath(as||href)};}

/***/ }),

/***/ "../../node_modules/solito/build/router/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/solito/build/router/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

Object.defineProperty(exports, "__esModule", ({value:true}));var _parseNextPath=__webpack_require__(/*! ./parse-next-path */ "../../node_modules/solito/build/router/parse-next-path.js");Object.keys(_parseNextPath).forEach(function(key){if(key==="default"||key==="__esModule")return;if(key in exports&&exports[key]===_parseNextPath[key])return;Object.defineProperty(exports,key,{enumerable:true,get:function get(){return _parseNextPath[key];}});});var _useRouter=__webpack_require__(/*! ./use-router */ "../../node_modules/solito/build/router/use-router.js");Object.keys(_useRouter).forEach(function(key){if(key==="default"||key==="__esModule")return;if(key in exports&&exports[key]===_useRouter[key])return;Object.defineProperty(exports,key,{enumerable:true,get:function get(){return _useRouter[key];}});});

/***/ }),

/***/ "../../node_modules/solito/build/router/parse-next-path.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/solito/build/router/parse-next-path.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({value:true}));exports.parseNextPath=void 0;var parseNextPath=function parseNextPath(from){var path=(typeof from=='string'?from:from.pathname)||'';if(typeof from=='object'&&from.query&&typeof from.query=='object'){var query=Object.assign({},from.query);for(var key in query){if(path.includes("["+key+"]")){var _query$key;path=path.replace("["+key+"]",""+((_query$key=query[key])!=null?_query$key:''));delete query[key];}else if(path.includes("[..."+key+"]")){var values=query[key];if(Array.isArray(values)){path=path.replace("[..."+key+"]",values.join('/'));delete query[key];}}}if(Object.keys(query).length){path+='?';for(var _key in query){if(query[_key]!=null){path+=_key+"="+query[_key]+"&";}}if(path.endsWith('&')||path.endsWith('?')){path=path.slice(0,-1);}}}return path;};exports.parseNextPath=parseNextPath;

/***/ }),

/***/ "../../node_modules/solito/build/router/replace-helpers.web.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/solito/build/router/replace-helpers.web.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

Object.defineProperty(exports, "__esModule", ({value:true}));exports.getStateFromPath=exports.getActionFromState=exports.StackActions=exports.LinkingContext=void 0;var _react=__webpack_require__(/*! react */ "../../node_modules/react/index.js");var LinkingContext=(0,_react.createContext)({options:undefined});exports.LinkingContext=LinkingContext;var StackActions,getStateFromPath,getActionFromState;exports.getActionFromState=getActionFromState;exports.getStateFromPath=getStateFromPath;exports.StackActions=StackActions;

/***/ }),

/***/ "../../node_modules/solito/build/router/use-link-to.web.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/solito/build/router/use-link-to.web.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({value:true}));exports.useLinkTo=void 0;var noOp=function noOp(){throw new Error('[use-link-to] is not supported on the web. Something went wrong if you called this.');};var useLinkTo=function useLinkTo(){return noOp;};exports.useLinkTo=useLinkTo;

/***/ }),

/***/ "../../node_modules/solito/build/router/use-navigation.web.js":
/*!********************************************************************!*\
  !*** ../../node_modules/solito/build/router/use-navigation.web.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({value:true}));exports.useNavigation=void 0;var useNavigation=function useNavigation(){return undefined;};exports.useNavigation=useNavigation;

/***/ }),

/***/ "../../node_modules/solito/build/router/use-next-router.web.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/solito/build/router/use-next-router.web.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

Object.defineProperty(exports, "__esModule", ({value:true}));Object.defineProperty(exports, "useNextRouter", ({enumerable:true,get:function get(){return _router.useRouter;}}));var _router=__webpack_require__(/*! next/router */ "../../node_modules/next/router.js");

/***/ }),

/***/ "../../node_modules/solito/build/router/use-router.js":
/*!************************************************************!*\
  !*** ../../node_modules/solito/build/router/use-router.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var _interopRequireDefault=__webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(exports, "__esModule", ({value:true}));exports.useRouter=useRouter;var _react=__webpack_require__(/*! react */ "../../node_modules/react/index.js");var _Platform=_interopRequireDefault(__webpack_require__(/*! react-native-web/dist/exports/Platform */ "../../node_modules/react-native-web/dist/exports/Platform/index.js"));var _parseNextPath=__webpack_require__(/*! ./parse-next-path */ "../../node_modules/solito/build/router/parse-next-path.js");var _replaceHelpers=__webpack_require__(/*! ./replace-helpers */ "../../node_modules/solito/build/router/replace-helpers.web.js");var _useLinkTo=__webpack_require__(/*! ./use-link-to */ "../../node_modules/solito/build/router/use-link-to.web.js");var _useNavigation=__webpack_require__(/*! ./use-navigation */ "../../node_modules/solito/build/router/use-navigation.web.js");var _useNextRouter=__webpack_require__(/*! ./use-next-router */ "../../node_modules/solito/build/router/use-next-router.web.js");function useRouter(){var linkTo=(0,_useLinkTo.useLinkTo)();var navigation=(0,_useNavigation.useNavigation)();var nextRouter=(0,_useNextRouter.useNextRouter)();var linking=(0,_react.useContext)(_replaceHelpers.LinkingContext);return(0,_react.useMemo)(function(){return{push:function push(url,as,transitionOptions){if(_Platform.default.OS==='web'){nextRouter==null?void 0:nextRouter.push(url,as,transitionOptions);}else{var to=(0,_parseNextPath.parseNextPath)(as||url);if(to){linkTo(to);}}},replace:function replace(url,as,transitionOptions){if(_Platform.default.OS==='web'){nextRouter==null?void 0:nextRouter.replace(url,as,transitionOptions);}else{var to=(0,_parseNextPath.parseNextPath)(as||url);if(to){var _transitionOptions$ex;if((transitionOptions==null?void 0:(_transitionOptions$ex=transitionOptions.experimental)==null?void 0:_transitionOptions$ex.nativeBehavior)==='stack-replace'){if(linking!=null&&linking.options){var options=linking.options;var state=options!=null&&options.getStateFromPath?options.getStateFromPath(to,options.config):(0,_replaceHelpers.getStateFromPath)(to,options==null?void 0:options.config);if(state){var action=(0,_replaceHelpers.getActionFromState)(state,options==null?void 0:options.config);if(action!==undefined){if('payload'in action&&action.payload&&'name'in action.payload&&action.payload.name){var _transitionOptions$ex2;var _action$payload=action.payload,name=_action$payload.name,params=_action$payload.params;if(transitionOptions!=null&&(_transitionOptions$ex2=transitionOptions.experimental)!=null&&_transitionOptions$ex2.isNestedNavigator&&params&&'screen'in params&&params.screen){navigation==null?void 0:navigation.dispatch(_replaceHelpers.StackActions.replace(params.screen,params.params));}else{navigation==null?void 0:navigation.dispatch(_replaceHelpers.StackActions.replace(name,params));}}else{navigation==null?void 0:navigation.dispatch(action);}}else{navigation==null?void 0:navigation.reset(state);}}}else{console.warn("[solito] replace(\""+to+"\") faced an issue. You should still see your new screen, but it probably didn't replace the previous one. This may be due to a breaking change in React Navigation. \n  Please open an issue at https://github.com/nandorojo/solito and report how this happened. Thanks!");linkTo(to);}}else{linkTo(to);}}}},back:function back(){if(_Platform.default.OS==='web'){nextRouter==null?void 0:nextRouter.back();}else{navigation==null?void 0:navigation.goBack();}},parseNextPath:_parseNextPath.parseNextPath};},[linkTo,navigation,nextRouter==null?void 0:nextRouter.push,nextRouter==null?void 0:nextRouter.back,nextRouter==null?void 0:nextRouter.replace]);}

/***/ }),

/***/ "../../node_modules/solito/link/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/solito/link/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

Object.defineProperty(exports, "__esModule", ({value:true}));var _link=__webpack_require__(/*! ../build/link */ "../../node_modules/solito/build/link/index.js");Object.keys(_link).forEach(function(key){if(key==="default"||key==="__esModule")return;if(key in exports&&exports[key]===_link[key])return;Object.defineProperty(exports,key,{enumerable:true,get:function get(){return _link[key];}});});

/***/ }),

/***/ "../../node_modules/get-nonce/dist/es2015/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/get-nonce/dist/es2015/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getNonce": () => (/* binding */ getNonce),
/* harmony export */   "setNonce": () => (/* binding */ setNonce)
/* harmony export */ });
var currentNonce;
var setNonce = function (nonce) {
    currentNonce = nonce;
};
var getNonce = function () {
    if (currentNonce) {
        return currentNonce;
    }
    if (true) {
        return __webpack_require__.nc;
    }
    return undefined;
};


/***/ }),

/***/ "../../node_modules/next/dist/client/add-base-path.js":
/*!************************************************************!*\
  !*** ../../node_modules/next/dist/client/add-base-path.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.addBasePath = addBasePath;
var _addPathPrefix = __webpack_require__(/*! ../shared/lib/router/utils/add-path-prefix */ "../../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js");
var _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ "../../node_modules/next/dist/client/normalize-trailing-slash.js");
const basePath = ({}).__NEXT_ROUTER_BASEPATH || '';
function addBasePath(path, required) {
    if (({}).__NEXT_MANUAL_CLIENT_BASE_PATH) {
        if (!required) {
            return path;
        }
    }
    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash((0, _addPathPrefix).addPathPrefix(path, basePath));
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=add-base-path.js.map

/***/ }),

/***/ "../../node_modules/next/dist/client/add-locale.js":
/*!*********************************************************!*\
  !*** ../../node_modules/next/dist/client/add-locale.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.addLocale = void 0;
var _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ "../../node_modules/next/dist/client/normalize-trailing-slash.js");
const addLocale = (path, ...args)=>{
    if (({}).__NEXT_I18N_SUPPORT) {
        return (0, _normalizeTrailingSlash).normalizePathTrailingSlash((__webpack_require__(/*! ../shared/lib/router/utils/add-locale */ "../../node_modules/next/dist/shared/lib/router/utils/add-locale.js").addLocale)(path, ...args));
    }
    return path;
};
exports.addLocale = addLocale;

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=add-locale.js.map

/***/ }),

/***/ "../../node_modules/next/dist/client/detect-domain-locale.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/next/dist/client/detect-domain-locale.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.detectDomainLocale = void 0;
const detectDomainLocale = (...args)=>{
    if (({}).__NEXT_I18N_SUPPORT) {
        return (__webpack_require__(/*! ../shared/lib/i18n/detect-domain-locale */ "../../node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js").detectDomainLocale)(...args);
    }
};
exports.detectDomainLocale = detectDomainLocale;

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=detect-domain-locale.js.map

/***/ }),

/***/ "../../node_modules/next/dist/client/get-domain-locale.js":
/*!****************************************************************!*\
  !*** ../../node_modules/next/dist/client/get-domain-locale.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getDomainLocale = getDomainLocale;
const basePath = ({}).__NEXT_ROUTER_BASEPATH || '';
function getDomainLocale(path, locale, locales, domainLocales) {
    if (({}).__NEXT_I18N_SUPPORT) {
        const normalizeLocalePath = (__webpack_require__(/*! ./normalize-locale-path */ "../../node_modules/next/dist/client/normalize-locale-path.js").normalizeLocalePath);
        const detectDomainLocale = (__webpack_require__(/*! ./detect-domain-locale */ "../../node_modules/next/dist/client/detect-domain-locale.js").detectDomainLocale);
        const target = locale || normalizeLocalePath(path, locales).detectedLocale;
        const domain = detectDomainLocale(domainLocales, undefined, target);
        if (domain) {
            const proto = `http${domain.http ? '' : 's'}://`;
            const finalLocale = target === domain.defaultLocale ? '' : `/${target}`;
            return `${proto}${domain.domain}${basePath}${finalLocale}${path}`;
        }
        return false;
    } else {
        return false;
    }
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=get-domain-locale.js.map

/***/ }),

/***/ "../../node_modules/next/dist/client/has-base-path.js":
/*!************************************************************!*\
  !*** ../../node_modules/next/dist/client/has-base-path.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.hasBasePath = hasBasePath;
var _pathHasPrefix = __webpack_require__(/*! ../shared/lib/router/utils/path-has-prefix */ "../../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js");
const basePath = ({}).__NEXT_ROUTER_BASEPATH || '';
function hasBasePath(path) {
    return (0, _pathHasPrefix).pathHasPrefix(path, basePath);
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=has-base-path.js.map

/***/ }),

/***/ "../../node_modules/next/dist/client/link.js":
/*!***************************************************!*\
  !*** ../../node_modules/next/dist/client/link.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use client";
"use strict";
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ "../../node_modules/@swc/helpers/lib/_interop_require_default.js")["default"]);
var _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ "../../node_modules/@swc/helpers/lib/_object_without_properties_loose.js")["default"]);
var _react = _interop_require_default(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var _resolveHref = __webpack_require__(/*! ../shared/lib/router/utils/resolve-href */ "../../node_modules/next/dist/shared/lib/router/utils/resolve-href.js");
var _isLocalUrl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ "../../node_modules/next/dist/shared/lib/router/utils/is-local-url.js");
var _formatUrl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ "../../node_modules/next/dist/shared/lib/router/utils/format-url.js");
var _utils = __webpack_require__(/*! ../shared/lib/utils */ "../../node_modules/next/dist/shared/lib/utils.js");
var _addLocale = __webpack_require__(/*! ./add-locale */ "../../node_modules/next/dist/client/add-locale.js");
var _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ "../../node_modules/next/dist/shared/lib/router-context.js");
var _appRouterContext = __webpack_require__(/*! ../shared/lib/app-router-context */ "../../node_modules/next/dist/shared/lib/app-router-context.js");
var _useIntersection = __webpack_require__(/*! ./use-intersection */ "../../node_modules/next/dist/client/use-intersection.js");
var _getDomainLocale = __webpack_require__(/*! ./get-domain-locale */ "../../node_modules/next/dist/client/get-domain-locale.js");
var _addBasePath = __webpack_require__(/*! ./add-base-path */ "../../node_modules/next/dist/client/add-base-path.js");

const prefetched = new Set();
function prefetch(router, href, as, options, isAppRouter) {
    if (typeof window === 'undefined') {
        return;
    }
    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.
    if (!isAppRouter && !(0, _isLocalUrl).isLocalURL(href)) {
        return;
    }
    // We should only dedupe requests when experimental.optimisticClientCache is
    // disabled.
    if (!options.bypassPrefetchedCheck) {
        const locale = // Let the link's locale prop override the default router locale.
        typeof options.locale !== 'undefined' ? options.locale : 'locale' in router ? router.locale : undefined;
        const prefetchedKey = href + '%' + as + '%' + locale;
        // If we've already fetched the key, then don't prefetch it again!
        if (prefetched.has(prefetchedKey)) {
            return;
        }
        // Mark this URL as prefetched.
        prefetched.add(prefetchedKey);
    }
    // Prefetch the JSON page if asked (only in the client)
    // We need to handle a prefetch error here since we may be
    // loading with priority which can reject but we don't
    // want to force navigation since this is only a prefetch
    Promise.resolve(router.prefetch(href, as, options)).catch((err)=>{
        if (true) {
            // rethrow to show invalid URL errors
            throw err;
        }
    });
}
function isModifiedEvent(event) {
    const eventTarget = event.currentTarget;
    const target = eventTarget.getAttribute('target');
    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || event.nativeEvent && event.nativeEvent.which === 2;
}
function linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled) {
    const { nodeName  } = e.currentTarget;
    // anchors inside an svg have a lowercase nodeName
    const isAnchorNodeName = nodeName.toUpperCase() === 'A';
    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.
    (!isAppRouter && !(0, _isLocalUrl).isLocalURL(href)))) {
        // ignore click for browser’s default behavior
        return;
    }
    e.preventDefault();
    const navigate = ()=>{
        // If the router is an NextRouter instance it will have `beforePopState`
        if ('beforePopState' in router) {
            router[replace ? 'replace' : 'push'](href, as, {
                shallow,
                locale,
                scroll
            });
        } else {
            router[replace ? 'replace' : 'push'](as || href, {
                forceOptimisticNavigation: !prefetchEnabled
            });
        }
    };
    if (isAppRouter) {
        // @ts-expect-error startTransition exists.
        _react.default.startTransition(navigate);
    } else {
        navigate();
    }
}
function formatStringOrUrl(urlObjOrString) {
    if (typeof urlObjOrString === 'string') {
        return urlObjOrString;
    }
    return (0, _formatUrl).formatUrl(urlObjOrString);
}
/**
 * React Component that enables client-side transitions between routes.
 */ const Link = /*#__PURE__*/ _react.default.forwardRef(function LinkComponent(props, forwardedRef) {
    if (true) {
        function createPropError(args) {
            return new Error(`Failed prop type: The prop \`${args.key}\` expects a ${args.expected} in \`<Link>\`, but got \`${args.actual}\` instead.` + (typeof window !== 'undefined' ? "\nOpen your browser's console to view the Component stack trace." : ''));
        }
        // TypeScript trick for type-guarding:
        const requiredPropsGuard = {
            href: true
        };
        const requiredProps = Object.keys(requiredPropsGuard);
        requiredProps.forEach((key)=>{
            if (key === 'href') {
                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: props[key] === null ? 'null' : typeof props[key]
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const _ = key;
            }
        });
        // TypeScript trick for type-guarding:
        const optionalPropsGuard = {
            as: true,
            replace: true,
            scroll: true,
            shallow: true,
            passHref: true,
            prefetch: true,
            locale: true,
            onClick: true,
            onMouseEnter: true,
            onTouchStart: true,
            legacyBehavior: true
        };
        const optionalProps = Object.keys(optionalPropsGuard);
        optionalProps.forEach((key)=>{
            const valType = typeof props[key];
            if (key === 'as') {
                if (props[key] && valType !== 'string' && valType !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: valType
                    });
                }
            } else if (key === 'locale') {
                if (props[key] && valType !== 'string') {
                    throw createPropError({
                        key,
                        expected: '`string`',
                        actual: valType
                    });
                }
            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart') {
                if (props[key] && valType !== 'function') {
                    throw createPropError({
                        key,
                        expected: '`function`',
                        actual: valType
                    });
                }
            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch' || key === 'legacyBehavior') {
                if (props[key] != null && valType !== 'boolean') {
                    throw createPropError({
                        key,
                        expected: '`boolean`',
                        actual: valType
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const _ = key;
            }
        });
        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const hasWarned = _react.default.useRef(false);
        if (props.prefetch && !hasWarned.current) {
            hasWarned.current = true;
            console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated');
        }
    }
    let children;
    const { href: hrefProp , as: asProp , children: childrenProp , prefetch: prefetchProp , passHref , replace , shallow , scroll , locale , onClick , onMouseEnter: onMouseEnterProp , onTouchStart: onTouchStartProp , // @ts-expect-error this is inlined as a literal boolean not a string
    legacyBehavior =undefined === false  } = props, restProps = _object_without_properties_loose(props, [
        "href",
        "as",
        "children",
        "prefetch",
        "passHref",
        "replace",
        "shallow",
        "scroll",
        "locale",
        "onClick",
        "onMouseEnter",
        "onTouchStart",
        "legacyBehavior"
    ]);
    children = childrenProp;
    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {
        children = /*#__PURE__*/ _react.default.createElement("a", null, children);
    }
    const prefetchEnabled = prefetchProp !== false;
    const pagesRouter = _react.default.useContext(_routerContext.RouterContext);
    const appRouter = _react.default.useContext(_appRouterContext.AppRouterContext);
    const router = pagesRouter != null ? pagesRouter : appRouter;
    // We're in the app directory if there is no pages router.
    const isAppRouter = !pagesRouter;
    if (true) {
        if (isAppRouter && !asProp) {
            let href;
            if (typeof hrefProp === 'string') {
                href = hrefProp;
            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {
                href = hrefProp.pathname;
            }
            if (href) {
                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));
                if (hasDynamicSegment) {
                    throw new Error(`Dynamic href \`${href}\` found in <Link> while using the \`/app\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`);
                }
            }
        }
    }
    const { href , as  } = _react.default.useMemo(()=>{
        if (!pagesRouter) {
            const resolvedHref = formatStringOrUrl(hrefProp);
            return {
                href: resolvedHref,
                as: asProp ? formatStringOrUrl(asProp) : resolvedHref
            };
        }
        const [resolvedHref, resolvedAs] = (0, _resolveHref).resolveHref(pagesRouter, hrefProp, true);
        return {
            href: resolvedHref,
            as: asProp ? (0, _resolveHref).resolveHref(pagesRouter, asProp) : resolvedAs || resolvedHref
        };
    }, [
        pagesRouter,
        hrefProp,
        asProp
    ]);
    const previousHref = _react.default.useRef(href);
    const previousAs = _react.default.useRef(as);
    // This will return the first child, if multiple are provided it will throw an error
    let child;
    if (legacyBehavior) {
        if (true) {
            if (onClick) {
                console.warn(`"onClick" was passed to <Link> with \`href\` of \`${hrefProp}\` but "legacyBehavior" was set. The legacy behavior requires onClick be set on the child of next/link`);
            }
            if (onMouseEnterProp) {
                console.warn(`"onMouseEnter" was passed to <Link> with \`href\` of \`${hrefProp}\` but "legacyBehavior" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`);
            }
            try {
                child = _react.default.Children.only(children);
            } catch (err) {
                if (!children) {
                    throw new Error(`No children were passed to <Link> with \`href\` of \`${hrefProp}\` but one child is required https://nextjs.org/docs/messages/link-no-children`);
                }
                throw new Error(`Multiple children were passed to <Link> with \`href\` of \`${hrefProp}\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` + (typeof window !== 'undefined' ? " \nOpen your browser's console to view the Component stack trace." : ''));
            }
        } else {}
    } else {
        if (true) {
            var ref;
            if (((ref = children) == null ? void 0 : ref.type) === 'a') {
                throw new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor');
            }
        }
    }
    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;
    const [setIntersectionRef, isVisible, resetVisible] = (0, _useIntersection).useIntersection({
        rootMargin: '200px'
    });
    const setRef = _react.default.useCallback((el)=>{
        // Before the link getting observed, check if visible state need to be reset
        if (previousAs.current !== as || previousHref.current !== href) {
            resetVisible();
            previousAs.current = as;
            previousHref.current = href;
        }
        setIntersectionRef(el);
        if (childRef) {
            if (typeof childRef === 'function') childRef(el);
            else if (typeof childRef === 'object') {
                childRef.current = el;
            }
        }
    }, [
        as,
        childRef,
        href,
        resetVisible,
        setIntersectionRef
    ]);
    // Prefetch the URL if we haven't already and it's visible.
    _react.default.useEffect(()=>{
        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.
        if (true) {
            return;
        }
        if (!router) {
            return;
        }
        // If we don't need to prefetch the URL, don't do prefetch.
        if (!isVisible || !prefetchEnabled) {
            return;
        }
        // Prefetch the URL.
        prefetch(router, href, as, {
            locale
        }, isAppRouter);
    }, [
        as,
        href,
        isVisible,
        locale,
        prefetchEnabled,
        pagesRouter == null ? void 0 : pagesRouter.locale,
        router,
        isAppRouter, 
    ]);
    const childProps = {
        ref: setRef,
        onClick (e) {
            if (true) {
                if (!e) {
                    throw new Error(`Component rendered inside next/link has to pass click event to "onClick" prop.`);
                }
            }
            if (!legacyBehavior && typeof onClick === 'function') {
                onClick(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {
                child.props.onClick(e);
            }
            if (!router) {
                return;
            }
            if (e.defaultPrevented) {
                return;
            }
            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled);
        },
        onMouseEnter (e) {
            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {
                onMouseEnterProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {
                child.props.onMouseEnter(e);
            }
            if (!router) {
                return;
            }
            if (!prefetchEnabled && isAppRouter) {
                return;
            }
            prefetch(router, href, as, {
                locale,
                priority: true,
                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}
                bypassPrefetchedCheck: true
            }, isAppRouter);
        },
        onTouchStart (e) {
            if (!legacyBehavior && typeof onTouchStartProp === 'function') {
                onTouchStartProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {
                child.props.onTouchStart(e);
            }
            if (!router) {
                return;
            }
            if (!prefetchEnabled && isAppRouter) {
                return;
            }
            prefetch(router, href, as, {
                locale,
                priority: true,
                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}
                bypassPrefetchedCheck: true
            }, isAppRouter);
        }
    };
    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
    // defined, we specify the current 'href', so that repetition is not needed by the user.
    // If the url is absolute, we can bypass the logic to prepend the domain and locale.
    if ((0, _utils).isAbsoluteUrl(as)) {
        childProps.href = as;
    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {
        const curLocale = typeof locale !== 'undefined' ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;
        // we only render domain locales if we are currently on a domain locale
        // so that locale links are still visitable in development/preview envs
        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getDomainLocale).getDomainLocale(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);
        childProps.href = localeDomain || (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));
    }
    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ _react.default.createElement("a", Object.assign({}, restProps, childProps), children);
});
var _default = Link;
exports["default"] = _default;

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=link.js.map

/***/ }),

/***/ "../../node_modules/next/dist/client/normalize-locale-path.js":
/*!********************************************************************!*\
  !*** ../../node_modules/next/dist/client/normalize-locale-path.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.normalizeLocalePath = void 0;
const normalizeLocalePath = (pathname, locales)=>{
    if (({}).__NEXT_I18N_SUPPORT) {
        return (__webpack_require__(/*! ../shared/lib/i18n/normalize-locale-path */ "../../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js").normalizeLocalePath)(pathname, locales);
    }
    return {
        pathname,
        detectedLocale: undefined
    };
};
exports.normalizeLocalePath = normalizeLocalePath;

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=normalize-locale-path.js.map

/***/ }),

/***/ "../../node_modules/next/dist/client/remove-base-path.js":
/*!***************************************************************!*\
  !*** ../../node_modules/next/dist/client/remove-base-path.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.removeBasePath = removeBasePath;
var _hasBasePath = __webpack_require__(/*! ./has-base-path */ "../../node_modules/next/dist/client/has-base-path.js");
const basePath = ({}).__NEXT_ROUTER_BASEPATH || '';
function removeBasePath(path) {
    if (({}).__NEXT_MANUAL_CLIENT_BASE_PATH) {
        if (!(0, _hasBasePath).hasBasePath(path)) {
            return path;
        }
    }
    path = path.slice(basePath.length);
    if (!path.startsWith('/')) path = `/${path}`;
    return path;
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=remove-base-path.js.map

/***/ }),

/***/ "../../node_modules/next/dist/client/remove-locale.js":
/*!************************************************************!*\
  !*** ../../node_modules/next/dist/client/remove-locale.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.removeLocale = removeLocale;
var _parsePath = __webpack_require__(/*! ../shared/lib/router/utils/parse-path */ "../../node_modules/next/dist/shared/lib/router/utils/parse-path.js");
function removeLocale(path, locale) {
    if (({}).__NEXT_I18N_SUPPORT) {
        const { pathname  } = (0, _parsePath).parsePath(path);
        const pathLower = pathname.toLowerCase();
        const localeLower = locale == null ? void 0 : locale.toLowerCase();
        return locale && (pathLower.startsWith(`/${localeLower}/`) || pathLower === `/${localeLower}`) ? `${pathname.length === locale.length + 1 ? `/` : ``}${path.slice(locale.length + 1)}` : path;
    }
    return path;
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=remove-locale.js.map

/***/ }),

/***/ "../../node_modules/next/dist/client/route-loader.js":
/*!***********************************************************!*\
  !*** ../../node_modules/next/dist/client/route-loader.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.markAssetError = markAssetError;
exports.isAssetError = isAssetError;
exports.getClientBuildManifest = getClientBuildManifest;
exports.createRouteLoader = createRouteLoader;
var _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ "../../node_modules/@swc/helpers/lib/_interop_require_default.js")["default"]);
var _getAssetPathFromRoute = _interop_require_default(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ "../../node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js"));
var _trustedTypes = __webpack_require__(/*! ./trusted-types */ "../../node_modules/next/dist/client/trusted-types.js");
var _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ "../../node_modules/next/dist/client/request-idle-callback.js");
// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive
// considers as "Good" time-to-interactive. We must assume something went
// wrong beyond this point, and then fall-back to a full page transition to
// show the user something of value.
const MS_MAX_IDLE_DELAY = 3800;
function withFuture(key, map, generator) {
    let entry = map.get(key);
    if (entry) {
        if ('future' in entry) {
            return entry.future;
        }
        return Promise.resolve(entry);
    }
    let resolver;
    const prom = new Promise((resolve)=>{
        resolver = resolve;
    });
    map.set(key, entry = {
        resolve: resolver,
        future: prom
    });
    return generator ? generator()// eslint-disable-next-line no-sequences
    .then((value)=>(resolver(value), value)).catch((err)=>{
        map.delete(key);
        throw err;
    }) : prom;
}
const ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');
function markAssetError(err) {
    return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
}
function isAssetError(err) {
    return err && ASSET_LOAD_ERROR in err;
}
function hasPrefetch(link) {
    try {
        link = document.createElement('link');
        return(// detect IE11 since it supports prefetch but isn't detected
        // with relList.support
        (!!window.MSInputMethodContext && !!document.documentMode) || link.relList.supports('prefetch'));
    } catch (e) {
        return false;
    }
}
const canPrefetch = hasPrefetch();
function prefetchViaDom(href, as, link) {
    return new Promise((resolve, reject)=>{
        const selector = `
      link[rel="prefetch"][href^="${href}"],
      link[rel="preload"][href^="${href}"],
      script[src^="${href}"]`;
        if (document.querySelector(selector)) {
            return resolve();
        }
        link = document.createElement('link');
        // The order of property assignment here is intentional:
        if (as) link.as = as;
        link.rel = `prefetch`;
        link.crossOrigin = ({}).__NEXT_CROSS_ORIGIN;
        link.onload = resolve;
        link.onerror = ()=>reject(markAssetError(new Error(`Failed to prefetch: ${href}`)));
        // `href` should always be last:
        link.href = href;
        document.head.appendChild(link);
    });
}
function appendScript(src, script) {
    return new Promise((resolve, reject)=>{
        script = document.createElement('script');
        // The order of property assignment here is intentional.
        // 1. Setup success/failure hooks in case the browser synchronously
        //    executes when `src` is set.
        script.onload = resolve;
        script.onerror = ()=>reject(markAssetError(new Error(`Failed to load script: ${src}`)));
        // 2. Configure the cross-origin attribute before setting `src` in case the
        //    browser begins to fetch.
        script.crossOrigin = ({}).__NEXT_CROSS_ORIGIN;
        // 3. Finally, set the source and inject into the DOM in case the child
        //    must be appended for fetching to start.
        script.src = src;
        document.body.appendChild(script);
    });
}
// We wait for pages to be built in dev before we start the route transition
// timeout to prevent an un-necessary hard navigation in development.
let devBuildPromise;
// Resolve a promise that times out after given amount of milliseconds.
function resolvePromiseWithTimeout(p, ms, err) {
    return new Promise((resolve, reject)=>{
        let cancelled = false;
        p.then((r)=>{
            // Resolved, cancel the timeout
            cancelled = true;
            resolve(r);
        }).catch(reject);
        // We wrap these checks separately for better dead-code elimination in
        // production bundles.
        if (true) {
            (devBuildPromise || Promise.resolve()).then(()=>{
                (0, _requestIdleCallback).requestIdleCallback(()=>setTimeout(()=>{
                        if (!cancelled) {
                            reject(err);
                        }
                    }, ms));
            });
        }
        if (false) {}
    });
}
function getClientBuildManifest() {
    if (self.__BUILD_MANIFEST) {
        return Promise.resolve(self.__BUILD_MANIFEST);
    }
    const onBuildManifest = new Promise((resolve)=>{
        // Mandatory because this is not concurrent safe:
        const cb = self.__BUILD_MANIFEST_CB;
        self.__BUILD_MANIFEST_CB = ()=>{
            resolve(self.__BUILD_MANIFEST);
            cb && cb();
        };
    });
    return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));
}
function getFilesForRoute(assetPrefix, route) {
    if (true) {
        const scriptUrl = assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute).default(route, '.js'));
        return Promise.resolve({
            scripts: [
                (0, _trustedTypes).__unsafeCreateTrustedScriptURL(scriptUrl)
            ],
            // Styles are handled by `style-loader` in development:
            css: []
        });
    }
    return getClientBuildManifest().then((manifest)=>{
        if (!(route in manifest)) {
            throw markAssetError(new Error(`Failed to lookup route: ${route}`));
        }
        const allFiles = manifest[route].map((entry)=>assetPrefix + '/_next/' + encodeURI(entry));
        return {
            scripts: allFiles.filter((v)=>v.endsWith('.js')).map((v)=>(0, _trustedTypes).__unsafeCreateTrustedScriptURL(v)),
            css: allFiles.filter((v)=>v.endsWith('.css'))
        };
    });
}
function createRouteLoader(assetPrefix) {
    const entrypoints = new Map();
    const loadedScripts = new Map();
    const styleSheets = new Map();
    const routes = new Map();
    function maybeExecuteScript(src) {
        // With HMR we might need to "reload" scripts when they are
        // disposed and readded. Executing scripts twice has no functional
        // differences
        if (false) {} else {
            return appendScript(src);
        }
    }
    function fetchStyleSheet(href) {
        let prom = styleSheets.get(href);
        if (prom) {
            return prom;
        }
        styleSheets.set(href, prom = fetch(href).then((res)=>{
            if (!res.ok) {
                throw new Error(`Failed to load stylesheet: ${href}`);
            }
            return res.text().then((text)=>({
                    href: href,
                    content: text
                }));
        }).catch((err)=>{
            throw markAssetError(err);
        }));
        return prom;
    }
    return {
        whenEntrypoint (route) {
            return withFuture(route, entrypoints);
        },
        onEntrypoint (route, execute) {
            (execute ? Promise.resolve().then(()=>execute()).then((exports)=>({
                    component: exports && exports.default || exports,
                    exports: exports
                }), (err)=>({
                    error: err
                })) : Promise.resolve(undefined)).then((input)=>{
                const old = entrypoints.get(route);
                if (old && 'resolve' in old) {
                    if (input) {
                        entrypoints.set(route, input);
                        old.resolve(input);
                    }
                } else {
                    if (input) {
                        entrypoints.set(route, input);
                    } else {
                        entrypoints.delete(route);
                    }
                    // when this entrypoint has been resolved before
                    // the route is outdated and we want to invalidate
                    // this cache entry
                    routes.delete(route);
                }
            });
        },
        loadRoute (route, prefetch) {
            return withFuture(route, routes, ()=>{
                let devBuildPromiseResolve;
                if (true) {
                    devBuildPromise = new Promise((resolve)=>{
                        devBuildPromiseResolve = resolve;
                    });
                }
                return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(({ scripts , css  })=>{
                    return Promise.all([
                        entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),
                        Promise.all(css.map(fetchStyleSheet)), 
                    ]);
                }).then((res)=>{
                    return this.whenEntrypoint(route).then((entrypoint)=>({
                            entrypoint,
                            styles: res[1]
                        }));
                }), MS_MAX_IDLE_DELAY, markAssetError(new Error(`Route did not complete loading: ${route}`))).then(({ entrypoint , styles  })=>{
                    const res = Object.assign({
                        styles: styles
                    }, entrypoint);
                    return 'error' in entrypoint ? entrypoint : res;
                }).catch((err)=>{
                    if (prefetch) {
                        // we don't want to cache errors during prefetch
                        throw err;
                    }
                    return {
                        error: err
                    };
                }).finally(()=>{
                    return devBuildPromiseResolve == null ? void 0 : devBuildPromiseResolve();
                });
            });
        },
        prefetch (route) {
            // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
            // License: Apache 2.0
            let cn;
            if (cn = navigator.connection) {
                // Don't prefetch if using 2G or if Save-Data is enabled.
                if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
            }
            return getFilesForRoute(assetPrefix, route).then((output)=>Promise.all(canPrefetch ? output.scripts.map((script)=>prefetchViaDom(script.toString(), 'script')) : [])).then(()=>{
                (0, _requestIdleCallback).requestIdleCallback(()=>this.loadRoute(route, true).catch(()=>{}));
            }).catch(// swallow prefetch errors
            ()=>{});
        }
    };
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=route-loader.js.map

/***/ }),

/***/ "../../node_modules/next/dist/client/router.js":
/*!*****************************************************!*\
  !*** ../../node_modules/next/dist/client/router.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "Router", ({
    enumerable: true,
    get: function() {
        return _router.default;
    }
}));
Object.defineProperty(exports, "withRouter", ({
    enumerable: true,
    get: function() {
        return _withRouter.default;
    }
}));
exports.useRouter = useRouter;
exports.createRouter = createRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports["default"] = void 0;
var _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ "../../node_modules/@swc/helpers/lib/_interop_require_default.js")["default"]);
var _react = _interop_require_default(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var _router = _interop_require_default(__webpack_require__(/*! ../shared/lib/router/router */ "../../node_modules/next/dist/shared/lib/router/router.js"));
var _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ "../../node_modules/next/dist/shared/lib/router-context.js");
var _isError = _interop_require_default(__webpack_require__(/*! ../lib/is-error */ "../../node_modules/next/dist/lib/is-error.js"));
var _withRouter = _interop_require_default(__webpack_require__(/*! ./with-router */ "../../node_modules/next/dist/client/with-router.js"));
const singletonRouter = {
    router: null,
    readyCallbacks: [],
    ready (cb) {
        if (this.router) return cb();
        if (typeof window !== 'undefined') {
            this.readyCallbacks.push(cb);
        }
    }
};
// Create public properties and methods of the router in the singletonRouter
const urlPropertyFields = [
    'pathname',
    'route',
    'query',
    'asPath',
    'components',
    'isFallback',
    'basePath',
    'locale',
    'locales',
    'defaultLocale',
    'isReady',
    'isPreview',
    'isLocaleDomain',
    'domainLocales', 
];
const routerEvents = [
    'routeChangeStart',
    'beforeHistoryChange',
    'routeChangeComplete',
    'routeChangeError',
    'hashChangeStart',
    'hashChangeComplete', 
];
const coreMethodFields = [
    'push',
    'replace',
    'reload',
    'back',
    'prefetch',
    'beforePopState', 
];
// Events is a static property on the router, the router doesn't have to be initialized to use it
Object.defineProperty(singletonRouter, 'events', {
    get () {
        return _router.default.events;
    }
});
function getRouter() {
    if (!singletonRouter.router) {
        const message = 'No router instance found.\n' + 'You should only use "next/router" on the client side of your app.\n';
        throw new Error(message);
    }
    return singletonRouter.router;
}
urlPropertyFields.forEach((field)=>{
    // Here we need to use Object.defineProperty because we need to return
    // the property assigned to the actual router
    // The value might get changed as we change routes and this is the
    // proper way to access it
    Object.defineProperty(singletonRouter, field, {
        get () {
            const router = getRouter();
            return router[field];
        }
    });
});
coreMethodFields.forEach((field)=>{
    singletonRouter[field] = (...args)=>{
        const router = getRouter();
        return router[field](...args);
    };
});
routerEvents.forEach((event)=>{
    singletonRouter.ready(()=>{
        _router.default.events.on(event, (...args)=>{
            const eventField = `on${event.charAt(0).toUpperCase()}${event.substring(1)}`;
            const _singletonRouter = singletonRouter;
            if (_singletonRouter[eventField]) {
                try {
                    _singletonRouter[eventField](...args);
                } catch (err) {
                    console.error(`Error when running the Router event: ${eventField}`);
                    console.error((0, _isError).default(err) ? `${err.message}\n${err.stack}` : err + '');
                }
            }
        });
    });
});
var _default = singletonRouter;
exports["default"] = _default;
function useRouter() {
    const router = _react.default.useContext(_routerContext.RouterContext);
    if (!router) {
        throw new Error('NextRouter was not mounted. https://nextjs.org/docs/messages/next-router-not-mounted');
    }
    return router;
}
function createRouter(...args) {
    singletonRouter.router = new _router.default(...args);
    singletonRouter.readyCallbacks.forEach((cb)=>cb());
    singletonRouter.readyCallbacks = [];
    return singletonRouter.router;
}
function makePublicRouterInstance(router) {
    const scopedRouter = router;
    const instance = {};
    for (const property of urlPropertyFields){
        if (typeof scopedRouter[property] === 'object') {
            instance[property] = Object.assign(Array.isArray(scopedRouter[property]) ? [] : {}, scopedRouter[property]) // makes sure query is not stateful
            ;
            continue;
        }
        instance[property] = scopedRouter[property];
    }
    // Events is a static property on the router, the router doesn't have to be initialized to use it
    instance.events = _router.default.events;
    coreMethodFields.forEach((field)=>{
        instance[field] = (...args)=>{
            return scopedRouter[field](...args);
        };
    });
    return instance;
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=router.js.map

/***/ }),

/***/ "../../node_modules/next/dist/client/script.js":
/*!*****************************************************!*\
  !*** ../../node_modules/next/dist/client/script.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use client";
"use strict";
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.handleClientScriptLoad = handleClientScriptLoad;
exports.initScriptLoader = initScriptLoader;
exports["default"] = void 0;
var _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ "../../node_modules/@swc/helpers/lib/_extends.js")["default"]);
var _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ "../../node_modules/@swc/helpers/lib/_interop_require_default.js")["default"]);
var _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ "../../node_modules/@swc/helpers/lib/_interop_require_wildcard.js")["default"]);
var _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ "../../node_modules/@swc/helpers/lib/_object_without_properties_loose.js")["default"]);
var _reactDom = _interop_require_default(__webpack_require__(/*! react-dom */ "../../node_modules/react-dom/index.js"));
var _react = _interop_require_wildcard(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var _headManagerContext = __webpack_require__(/*! ../shared/lib/head-manager-context */ "../../node_modules/next/dist/shared/lib/head-manager-context.js");
var _headManager = __webpack_require__(/*! ./head-manager */ "../../node_modules/next/dist/client/head-manager.js");
var _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ "../../node_modules/next/dist/client/request-idle-callback.js");

const ScriptCache = new Map();
const LoadCache = new Set();
const ignoreProps = [
    'onLoad',
    'onReady',
    'dangerouslySetInnerHTML',
    'children',
    'onError',
    'strategy', 
];
const loadScript = (props)=>{
    const { src , id , onLoad =()=>{} , onReady =null , dangerouslySetInnerHTML , children ='' , strategy ='afterInteractive' , onError ,  } = props;
    const cacheKey = id || src;
    // Script has already loaded
    if (cacheKey && LoadCache.has(cacheKey)) {
        return;
    }
    // Contents of this script are already loading/loaded
    if (ScriptCache.has(src)) {
        LoadCache.add(cacheKey);
        // It is possible that multiple `next/script` components all have same "src", but has different "onLoad"
        // This is to make sure the same remote script will only load once, but "onLoad" are executed in order
        ScriptCache.get(src).then(onLoad, onError);
        return;
    }
    /** Execute after the script first loaded */ const afterLoad = ()=>{
        // Run onReady for the first time after load event
        if (onReady) {
            onReady();
        }
        // add cacheKey to LoadCache when load successfully
        LoadCache.add(cacheKey);
    };
    const el = document.createElement('script');
    const loadPromise = new Promise((resolve, reject)=>{
        el.addEventListener('load', function(e) {
            resolve();
            if (onLoad) {
                onLoad.call(this, e);
            }
            afterLoad();
        });
        el.addEventListener('error', function(e) {
            reject(e);
        });
    }).catch(function(e) {
        if (onError) {
            onError(e);
        }
    });
    if (dangerouslySetInnerHTML) {
        el.innerHTML = dangerouslySetInnerHTML.__html || '';
        afterLoad();
    } else if (children) {
        el.textContent = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';
        afterLoad();
    } else if (src) {
        el.src = src;
        // do not add cacheKey into LoadCache for remote script here
        // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)
        ScriptCache.set(src, loadPromise);
    }
    for (const [k, value] of Object.entries(props)){
        if (value === undefined || ignoreProps.includes(k)) {
            continue;
        }
        const attr = _headManager.DOMAttributeNames[k] || k.toLowerCase();
        el.setAttribute(attr, value);
    }
    if (strategy === 'worker') {
        el.setAttribute('type', 'text/partytown');
    }
    el.setAttribute('data-nscript', strategy);
    document.body.appendChild(el);
};
function handleClientScriptLoad(props) {
    const { strategy ='afterInteractive'  } = props;
    if (strategy === 'lazyOnload') {
        window.addEventListener('load', ()=>{
            (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));
        });
    } else {
        loadScript(props);
    }
}
function loadLazyScript(props) {
    if (document.readyState === 'complete') {
        (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));
    } else {
        window.addEventListener('load', ()=>{
            (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));
        });
    }
}
function addBeforeInteractiveToCache() {
    const scripts = [
        ...document.querySelectorAll('[data-nscript="beforeInteractive"]'),
        ...document.querySelectorAll('[data-nscript="beforePageRender"]'), 
    ];
    scripts.forEach((script)=>{
        const cacheKey = script.id || script.getAttribute('src');
        LoadCache.add(cacheKey);
    });
}
function initScriptLoader(scriptLoaderItems) {
    scriptLoaderItems.forEach(handleClientScriptLoad);
    addBeforeInteractiveToCache();
}
function Script(props) {
    const { id , src ='' , onLoad =()=>{} , onReady =null , strategy ='afterInteractive' , onError  } = props, restProps = _object_without_properties_loose(props, [
        "id",
        "src",
        "onLoad",
        "onReady",
        "strategy",
        "onError"
    ]);
    // Context is available only during SSR
    const { updateScripts , scripts , getIsSsr , appDir , nonce  } = (0, _react).useContext(_headManagerContext.HeadManagerContext);
    /**
   * - First mount:
   *   1. The useEffect for onReady executes
   *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)
   *      onReady is skipped, set hasOnReadyEffectCalled.current to true
   *   3. The useEffect for loadScript executes
   *   4. hasLoadScriptEffectCalled.current is false, loadScript executes
   *      Once the script is loaded, the onLoad and onReady will be called by then
   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]
   *   5. The useEffect for onReady executes again
   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped
   *   7. The useEffect for loadScript executes again
   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped
   *
   * - Second mount:
   *   1. The useEffect for onReady executes
   *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)
   *      onReady is called, set hasOnReadyEffectCalled.current to true
   *   3. The useEffect for loadScript executes
   *   4. The script is already loaded, loadScript bails out
   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]
   *   5. The useEffect for onReady executes again
   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped
   *   7. The useEffect for loadScript executes again
   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped
   */ const hasOnReadyEffectCalled = (0, _react).useRef(false);
    (0, _react).useEffect(()=>{
        const cacheKey = id || src;
        if (!hasOnReadyEffectCalled.current) {
            // Run onReady if script has loaded before but component is re-mounted
            if (onReady && cacheKey && LoadCache.has(cacheKey)) {
                onReady();
            }
            hasOnReadyEffectCalled.current = true;
        }
    }, [
        onReady,
        id,
        src
    ]);
    const hasLoadScriptEffectCalled = (0, _react).useRef(false);
    (0, _react).useEffect(()=>{
        if (!hasLoadScriptEffectCalled.current) {
            if (strategy === 'afterInteractive') {
                loadScript(props);
            } else if (strategy === 'lazyOnload') {
                loadLazyScript(props);
            }
            hasLoadScriptEffectCalled.current = true;
        }
    }, [
        props,
        strategy
    ]);
    if (strategy === 'beforeInteractive' || strategy === 'worker') {
        if (updateScripts) {
            scripts[strategy] = (scripts[strategy] || []).concat([
                _extends({
                    id,
                    src,
                    onLoad,
                    onReady,
                    onError
                }, restProps), 
            ]);
            updateScripts(scripts);
        } else if (getIsSsr && getIsSsr()) {
            // Script has already loaded during SSR
            LoadCache.add(id || src);
        } else if (getIsSsr && !getIsSsr()) {
            loadScript(props);
        }
    }
    // For the app directory, we need React Float to preload these scripts.
    if (appDir) {
        // Before interactive scripts need to be loaded by Next.js' runtime instead
        // of native <script> tags, because they no longer have `defer`.
        if (strategy === 'beforeInteractive') {
            if (!src) {
                // For inlined scripts, we put the content in `children`.
                if (restProps.dangerouslySetInnerHTML) {
                    restProps.children = restProps.dangerouslySetInnerHTML.__html;
                    delete restProps.dangerouslySetInnerHTML;
                }
                return /*#__PURE__*/ _react.default.createElement("script", {
                    nonce: nonce,
                    dangerouslySetInnerHTML: {
                        __html: `(self.__next_s=self.__next_s||[]).push(${JSON.stringify([
                            0,
                            _extends({}, restProps), 
                        ])})`
                    }
                });
            }
            // @ts-ignore
            _reactDom.default.preload(src, restProps.integrity ? {
                as: 'script',
                integrity: restProps.integrity
            } : {
                as: 'script'
            });
            return /*#__PURE__*/ _react.default.createElement("script", {
                nonce: nonce,
                dangerouslySetInnerHTML: {
                    __html: `(self.__next_s=self.__next_s||[]).push(${JSON.stringify([
                        src, 
                    ])})`
                }
            });
        } else if (strategy === 'afterInteractive') {
            if (src) {
                // @ts-ignore
                _reactDom.default.preload(src, restProps.integrity ? {
                    as: 'script',
                    integrity: restProps.integrity
                } : {
                    as: 'script'
                });
            }
        }
    }
    return null;
}
Object.defineProperty(Script, '__nextScript', {
    value: true
});
var _default = Script;
exports["default"] = _default;

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=script.js.map

/***/ }),

/***/ "../../node_modules/next/dist/client/trusted-types.js":
/*!************************************************************!*\
  !*** ../../node_modules/next/dist/client/trusted-types.js ***!
  \************************************************************/
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.__unsafeCreateTrustedScriptURL = __unsafeCreateTrustedScriptURL;
/**
 * Stores the Trusted Types Policy. Starts as undefined and can be set to null
 * if Trusted Types is not supported in the browser.
 */ let policy;
/**
 * Getter for the Trusted Types Policy. If it is undefined, it is instantiated
 * here or set to null if Trusted Types is not supported in the browser.
 */ function getPolicy() {
    if (typeof policy === 'undefined' && typeof window !== 'undefined') {
        var ref;
        policy = ((ref = window.trustedTypes) == null ? void 0 : ref.createPolicy('nextjs', {
            createHTML: (input)=>input,
            createScript: (input)=>input,
            createScriptURL: (input)=>input
        })) || null;
    }
    return policy;
}
function __unsafeCreateTrustedScriptURL(url) {
    var ref;
    return ((ref = getPolicy()) == null ? void 0 : ref.createScriptURL(url)) || url;
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=trusted-types.js.map

/***/ }),

/***/ "../../node_modules/next/dist/client/with-router.js":
/*!**********************************************************!*\
  !*** ../../node_modules/next/dist/client/with-router.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = withRouter;
var _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ "../../node_modules/@swc/helpers/lib/_interop_require_default.js")["default"]);
var _react = _interop_require_default(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var _router = __webpack_require__(/*! ./router */ "../../node_modules/next/dist/client/router.js");
function withRouter(ComposedComponent) {
    function WithRouterWrapper(props) {
        return /*#__PURE__*/ _react.default.createElement(ComposedComponent, Object.assign({
            router: (0, _router).useRouter()
        }, props));
    }
    WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps;
    WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;
    if (true) {
        const name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
        WithRouterWrapper.displayName = `withRouter(${name})`;
    }
    return WithRouterWrapper;
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=with-router.js.map

/***/ }),

/***/ "../../node_modules/next/dist/compiled/path-to-regexp/index.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/next/dist/compiled/path-to-regexp/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at " + i);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at " + j);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at " + j);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at " + i);
            if (!pattern)
                throw new TypeError("Missing pattern at " + i);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
    };
    var consumeText = function () {
        var result = "";
        var value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
exports.parse = parse;
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
exports.compile = compile;
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
        }
        return path;
    };
}
exports.tokensToFunction = tokensToFunction;
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
exports.match = match;
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            // tslint:disable-next-line
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
exports.regexpToFunction = regexpToFunction;
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
        for (var i = 0; i < groups.length; i++) {
            keys.push({
                name: i,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
        }
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
    var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
    var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                    }
                    else {
                        route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                    }
                }
                else {
                    route += "(" + token.pattern + ")" + token.modifier;
                }
            }
            else {
                route += "(?:" + prefix + suffix + ")" + token.modifier;
            }
        }
    }
    if (end) {
        if (!strict)
            route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
            route += "(?=" + delimiter + "|" + endsWith + ")";
        }
    }
    return new RegExp(route, flags(options));
}
exports.tokensToRegexp = tokensToRegexp;
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
exports.pathToRegexp = pathToRegexp;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/next/dist/compiled/react-is/cjs/react-is.development.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/next/dist/compiled/react-is/cjs/react-is.development.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
var REACT_ELEMENT_TYPE = Symbol.for('react.element');
var REACT_PORTAL_TYPE = Symbol.for('react.portal');
var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
var REACT_CONTEXT_TYPE = Symbol.for('react.context');
var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
var REACT_MEMO_TYPE = Symbol.for('react.memo');
var REACT_LAZY_TYPE = Symbol.for('react.lazy');
var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');

// -----------------------------------------------------------------------------

var enableScopeAPI = false; // Experimental Create Event Handle API.
var enableCacheElement = false;
var enableTransitionTracing = false; // No known bugs, but needs performance testing

var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
// stuff. Intended to enable React core members to more easily debug scheduling
// issues in DEV builds.

var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

var REACT_MODULE_REFERENCE;

{
  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
}

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
    // types supported by any Flight configuration anywhere since
    // we don't know which Flight build this will end up being used
    // with.
    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
      return true;
    }
  }

  return false;
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
          case REACT_SUSPENSE_LIST_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_SERVER_CONTEXT_TYPE:
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
}
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false;
var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
    }
  }

  return false;
}
function isConcurrentMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
    }
  }

  return false;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}
function isSuspenseList(object) {
  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
}

exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.SuspenseList = SuspenseList;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isSuspenseList = isSuspenseList;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "../../node_modules/next/dist/compiled/react-is/index.js":
/*!***************************************************************!*\
  !*** ../../node_modules/next/dist/compiled/react-is/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "../../node_modules/next/dist/compiled/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "../../node_modules/next/dist/lib/is-api-route.js":
/*!********************************************************!*\
  !*** ../../node_modules/next/dist/lib/is-api-route.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isAPIRoute = isAPIRoute;
function isAPIRoute(value) {
    return value === "/api" || Boolean(value == null ? void 0 : value.startsWith("/api/"));
}

//# sourceMappingURL=is-api-route.js.map

/***/ }),

/***/ "../../node_modules/next/dist/lib/is-error.js":
/*!****************************************************!*\
  !*** ../../node_modules/next/dist/lib/is-error.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = isError;
exports.getProperError = getProperError;
var _isPlainObject = __webpack_require__(/*! ../shared/lib/is-plain-object */ "../../node_modules/next/dist/shared/lib/is-plain-object.js");
function isError(err) {
    return typeof err === "object" && err !== null && "name" in err && "message" in err;
}
function getProperError(err) {
    if (isError(err)) {
        return err;
    }
    if (true) {
        // provide better error for case where `throw undefined`
        // is called in development
        if (typeof err === "undefined") {
            return new Error("An undefined error was thrown, " + "see here for more info: https://nextjs.org/docs/messages/threw-undefined");
        }
        if (err === null) {
            return new Error("A null error was thrown, " + "see here for more info: https://nextjs.org/docs/messages/threw-undefined");
        }
    }
    return new Error((0, _isPlainObject).isPlainObject(err) ? JSON.stringify(err) : err + "");
}

//# sourceMappingURL=is-error.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/bloom-filter/base-filter.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/bloom-filter/base-filter.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ "../../node_modules/@swc/helpers/lib/_interop_require_default.js")["default"]);
var _hashing = _interop_require_default(__webpack_require__(/*! ./hashing */ "../../node_modules/next/dist/shared/lib/bloom-filter/hashing.js"));
var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/next/dist/shared/lib/bloom-filter/utils.js");
function randomInt32() {
    if (typeof window === 'undefined' && ({}).NEXT_RUNTIME === 'nodejs') {
        return (__webpack_require__(/*! crypto */ "?2d50").randomBytes)(4).readUInt32BE(0);
    }
    return crypto.getRandomValues(new Uint32Array(1))[0];
}
function seedrandom() {
    return {
        int32: randomInt32,
        quick: randomInt32
    };
}
class BaseFilter {
    /**
   * Get the seed used in this structure
   */ get seed() {
        return this._seed;
    }
    /**
   * Set the seed for this structure
   * @param  seed the new seed that will be used in this structure
   */ set seed(seed) {
        this._seed = seed;
        this._rng = seedrandom();
    }
    /**
   * Get a function used to draw random number
   * @return A factory function used to draw random integer
   */ get random() {
        return this._rng;
    }
    /**
   * Return a next random seeded int32 integer
   * @returns
   */ nextInt32() {
        return this._rng.int32();
    }
    /**
   * Save the current structure as a JSON
   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
    saveAsJSON() {
        throw new Error('not-implemented');
    }
    /**
   * Load an Object from a provided JSON object
   * @param json the JSON object to load
   * @return Return the Object loaded from the provided JSON object
   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars
    static fromJSON(json) {
        throw new Error(`not-implemented`);
    }
    constructor(){
        this._seed = (0, _utils).getDefaultSeed();
        this._rng = seedrandom();
        this._hashing = new _hashing.default();
    }
}
exports["default"] = BaseFilter;

//# sourceMappingURL=base-filter.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/bloom-filter/base64-arraybuffer.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/bloom-filter/base64-arraybuffer.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.decode = exports.encode = void 0;
// original source: https://github.com/niklasvh/base64-arraybuffer/blob/master/src/index.ts
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
const lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for(let i = 0; i < chars.length; i++){
    lookup[chars.charCodeAt(i)] = i;
}
const encode = (arraybuffer)=>{
    let bytes = new Uint8Array(arraybuffer), i1, len = bytes.length, base64 = '';
    for(i1 = 0; i1 < len; i1 += 3){
        base64 += chars[bytes[i1] >> 2];
        base64 += chars[(bytes[i1] & 3) << 4 | bytes[i1 + 1] >> 4];
        base64 += chars[(bytes[i1 + 1] & 15) << 2 | bytes[i1 + 2] >> 6];
        base64 += chars[bytes[i1 + 2] & 63];
    }
    if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + '=';
    } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + '==';
    }
    return base64;
};
exports.encode = encode;
const decode = (base64)=>{
    let bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for(i2 = 0; i2 < len; i2 += 4){
        encoded1 = lookup[base64.charCodeAt(i2)];
        encoded2 = lookup[base64.charCodeAt(i2 + 1)];
        encoded3 = lookup[base64.charCodeAt(i2 + 2)];
        encoded4 = lookup[base64.charCodeAt(i2 + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return arraybuffer;
};
exports.decode = decode;

//# sourceMappingURL=base64-arraybuffer.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/bloom-filter/bit-set.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/bloom-filter/bit-set.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _base64Arraybuffer = __webpack_require__(/*! ./base64-arraybuffer */ "../../node_modules/next/dist/shared/lib/bloom-filter/base64-arraybuffer.js");
const bitsPerWord = 8;
class BitSet {
    /**
   * Returns the value of the bit at the given index
   * @param index position of the bit, zero-indexed
   */ has(index) {
        const wordIndex = Math.floor(index / bitsPerWord);
        const mask = 1 << index % bitsPerWord;
        return (this.array[wordIndex] & mask) !== 0;
    }
    /**
   * Set the bit to true
   * @param index position of the bit, zero-indexed
   */ add(index) {
        const wordIndex = Math.floor(index / bitsPerWord);
        const mask = 1 << index % bitsPerWord;
        this.array[wordIndex] = this.array[wordIndex] | mask;
    }
    /**
   * Returns the maximum true bit.
   */ max() {
        for(let i = this.array.length - 1; i >= 0; i--){
            const bits = this.array[i];
            if (bits) {
                return BitSet.highBit(bits) + i * bitsPerWord;
            }
        }
        return 0;
    }
    /**
   * Returns the number of true bits.
   */ bitCount() {
        let result = 0;
        for(let i = 0; i < this.array.length; i++){
            result += BitSet.countBits(this.array[i]) // Assumes we never have bits set beyond the end
            ;
        }
        return result;
    }
    /**
   * Returns true if the size and contents are identical.
   * @param other another BitSet
   */ equals(other) {
        if (other.size !== this.size) {
            return false;
        }
        for(let i = 0; i < this.array.length; i++){
            if (this.array[i] !== other.array[i]) {
                return false;
            }
        }
        return true;
    }
    /**
   * Returns a JSON-encodable object readable by {@link import}.
   */ export() {
        return {
            size: this.size,
            content: (0, _base64Arraybuffer).encode(this.array)
        };
    }
    /**
   * Returns an object written by {@link export}.
   * @param data an object written by {@link export}
   */ static import(data) {
        if (typeof data.size !== 'number') {
            throw Error('BitSet missing size');
        }
        if (typeof data.content !== 'string') {
            throw Error('BitSet: missing content');
        }
        const result = new BitSet(data.size);
        const buffer = (0, _base64Arraybuffer).decode(data.content);
        result.array = new Uint8Array(buffer);
        return result;
    }
    /**
   * Returns the index of the maximum bit in the number, or -1 for 0
   * @bits an unsigned 8-bit number
   * ```js
   * @example
   * BitSet.highBit(0) // returns -1
   * BitSet.highBit(5) // returns 2
   * ```
   */ static highBit(bits) {
        let result = bitsPerWord - 1;
        let mask = 1 << result;
        while(result >= 0 && (mask & bits) !== mask){
            mask >>>= 1;
            result--;
        }
        return result;
    }
    /**
   * Returns the number of true bits in the number
   * @bits an unsigned 8-bit number
   * @example
   * ```js
   * BitSet.countBits(0) // returns 0
   * BitSet.countBits(3) // returns 2
   * ```
   */ static countBits(bits) {
        let result = bits & 1;
        while(bits !== 0){
            bits = bits >>> 1;
            result += bits & 1;
        }
        return result;
    }
    /**
   * Constructor. All bits are initially set to false.
   * @param size the number of bits that can be stored. (This is NOT required to be a multiple of 8.)
   */ constructor(size){
        const diff = bitsPerWord - size % bitsPerWord;
        this.size = size + ([
            0,
            8
        ].includes(diff) ? 0 : diff);
        this.array = new Uint8Array(Math.ceil(this.size / bitsPerWord));
    }
}
exports["default"] = BitSet;

//# sourceMappingURL=bit-set.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/bloom-filter/formulas.js":
/*!************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/bloom-filter/formulas.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.optimalFilterSize = optimalFilterSize;
exports.optimalHashes = optimalHashes;
function optimalFilterSize(length, errorRate) {
    return Math.ceil(-(length * Math.log(errorRate) / Math.pow(Math.log(2), 2)));
}
function optimalHashes(size, length) {
    return Math.ceil(size / length * Math.log(2));
}

//# sourceMappingURL=formulas.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/bloom-filter/hashing.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/bloom-filter/hashing.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ "../../node_modules/@swc/helpers/lib/_interop_require_default.js")["default"]);
var _fnv1A = _interop_require_default(__webpack_require__(/*! ../fnv1a */ "../../node_modules/next/dist/shared/lib/fnv1a.js"));
var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/next/dist/shared/lib/bloom-filter/utils.js");
class Hashing {
    /**
   * Apply enhanced Double Hashing to produce a n-hash
   * @see {@link http://peterd.org/pcd-diss.pdf} s6.5.4
   * @param  n - The indice of the hash function we want to produce
   * @param  hashA - The result of the first hash function applied to a value.
   * @param  hashB - The result of the second hash function applied to a value.
   * @param  size - The size of the datastructures associated to the hash context (ex: the size of a Bloom Filter)
   * @return The result of hash_n applied to a value.
   * @memberof Hashing
   * @author Thomas Minier
   * @author Arnaud Grall
   */ doubleHashing(n, hashA, hashB, size) {
        return Math.abs((hashA + n * hashB + Math.floor((n ** 3 - n) / 6)) % size);
    }
    /**
   * Generate a set of distinct indexes on interval [0, size) using the double hashing technique
   * For generating efficiently distinct indexes we re-hash after detecting a cycle by changing slightly the seed.
   * It has the effect of generating faster distinct indexes without loosing entirely the utility of the double hashing.
   * For small number of indexes it will work perfectly. For a number close to the size, and size very large
   * Advise: do not generate `size` indexes for a large interval. In practice, size should be equal
   * to the number of hash functions used and is often low.
   *
   * @param  element  - The element to hash
   * @param  size     - the range on which we can generate an index [0, size) = size
   * @param  number   - The number of indexes desired
   * @param  seed     - The seed used
   * @return Array<number>
   * @author Arnaud Grall
   * @author Simon Woolf (SimonWoolf)
   */ getDistinctIndexes(element, size, number, seed) {
        if (seed === undefined) {
            seed = (0, _utils).getDefaultSeed();
        }
        let n = 0;
        const indexes = new Set();
        let hashes = this.hashTwice(element, seed);
        // let cycle = 0
        while(indexes.size < number){
            const ind = hashes.first % size;
            if (!indexes.has(ind)) {
                indexes.add(ind);
            }
            hashes.first = (hashes.first + hashes.second) % size;
            hashes.second = (hashes.second + n) % size;
            n++;
            if (n > size) {
                // Enhanced double hashing stops cycles of length less than `size` in the case where
                // size is coprime with the second hash. But you still get cycles of length `size`.
                // So if we reach there and haven't finished, append a prime to the input and
                // rehash.
                seed++;
                hashes = this.hashTwice(element, seed);
            }
        }
        return [
            ...indexes.values()
        ];
    }
    /**
   * Generate N indexes on range [0, size)
   * It uses the double hashing technique to generate the indexes.
   * It hash twice the value only once before generating the indexes.
   * Warning: you can have a lot of modulo collisions.
   * @param  element    - The element to hash
   * @param  size       - The range on which we can generate the index, exclusive
   * @param  hashCount  - The number of indexes we want
   * @return An array of indexes on range [0, size)
   */ getIndexes(element, size, hashCount, seed) {
        if (seed === undefined) {
            seed = (0, _utils).getDefaultSeed();
        }
        const arr = [];
        const hashes = this.hashTwice(element, seed);
        for(let i = 0; i < hashCount; i++){
            arr.push(this.doubleHashing(i, hashes.first, hashes.second, size));
        }
        return arr;
    }
    /**
   * @internal
   * Hash an element of type {@link HashableInput} into {@link Number}
   * Can be overrided as long as you return a value of type {@link Number}
   * Don't forget to use the seed when hashing, otherwise if some kind of randomness is in the process
   * you may have inconsistent behaviors between 2 runs.
   * @param element
   * @param seed
   * @returns A 64bits floating point {@link Number}
   */ serialize(element, seed) {
        if (!seed) {
            seed = (0, _utils).getDefaultSeed();
        }
        return Number((0, _fnv1A).default(element, {
            seed
        }));
    }
    /**
   * (64-bits only) Hash a value into two values (in hex or integer format)
   * @param  value - The value to hash
   * @param  asInt - (optional) If True, the values will be returned as an integer. Otherwise, as hexadecimal values.
   * @param seed the seed used for hashing
   * @return The results of the hash functions applied to the value (in hex or integer)
   * @author Arnaud Grall & Thomas Minier
   */ hashTwice(value, seed) {
        if (seed === undefined) {
            seed = (0, _utils).getDefaultSeed();
        }
        return {
            first: this.serialize(value, seed + 1),
            second: this.serialize(value, seed + 2)
        };
    }
    /**
   * Hash twice an element into their HEX string representations
   * @param value
   * @param seed
   * @returns TwoHashesTemplated<string>
   */ hashTwiceAsString(value, seed) {
        const { first , second  } = this.hashTwice(value, seed);
        return {
            first: (0, _utils).numberToHex(first),
            second: (0, _utils).numberToHex(second)
        };
    }
    /**
   * (64-bits only) Same as hashTwice but return Numbers and String equivalent
   * @param  val the value to hash
   * @param  seed the seed to change when hashing
   * @return TwoHashesIntAndString
   * @author Arnaud Grall
   */ hashTwiceIntAndString(val, seed) {
        if (seed === undefined) {
            seed = (0, _utils).getDefaultSeed();
        }
        const one = this.hashIntAndString(val, seed + 1);
        const two = this.hashIntAndString(val, seed + 2);
        return {
            int: {
                first: one.int,
                second: two.int
            },
            string: {
                first: one.string,
                second: two.string
            }
        };
    }
    /**
   * Hash an item as an unsigned int
   * @param  elem - Element to hash
   * @param  seed - The hash seed. If its is UINT32 make sure to set the length to 32
   * @param  length - The length of hashes (defaults to 32 bits)
   * @return The hash value as an unsigned int
   * @author Arnaud Grall
   */ hashAsInt(elem, seed) {
        if (seed === undefined) {
            seed = (0, _utils).getDefaultSeed();
        }
        return this.serialize(elem, seed);
    }
    /**
   * Hash an item and return its number and HEX string representation
   * @param  elem - Element to hash
   * @param  seed - The hash seed. If its is UINT32 make sure to set the length to 32
   * @param  base - The base in which the string will be returned, default: 16
   * @param  length - The length of hashes (defaults to 32 bits)
   * @return The item hased as an int and a string
   * @author Arnaud Grall
   */ hashIntAndString(elem, seed) {
        const hash = this.hashAsInt(elem, seed);
        return {
            int: hash,
            string: (0, _utils).numberToHex(hash)
        };
    }
}
exports["default"] = Hashing;

//# sourceMappingURL=hashing.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/bloom-filter/index.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/bloom-filter/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ "../../node_modules/@swc/helpers/lib/_interop_require_default.js")["default"]);
var _baseFilter = _interop_require_default(__webpack_require__(/*! ./base-filter */ "../../node_modules/next/dist/shared/lib/bloom-filter/base-filter.js"));
var _bitSet = _interop_require_default(__webpack_require__(/*! ./bit-set */ "../../node_modules/next/dist/shared/lib/bloom-filter/bit-set.js"));
var _formulas = __webpack_require__(/*! ./formulas */ "../../node_modules/next/dist/shared/lib/bloom-filter/formulas.js");
class BloomFilter extends _baseFilter.default {
    /**
   * Create an optimal bloom filter providing the maximum of elements stored and the error rate desired
   * @param  nbItems      - The maximum number of item to store
   * @param  errorRate  - The error rate desired for a maximum of items inserted
   * @return A new {@link BloomFilter}
   */ static create(nbItems, errorRate) {
        const size = (0, _formulas).optimalFilterSize(nbItems, errorRate);
        const hashes = (0, _formulas).optimalHashes(size, nbItems);
        return new this(size, hashes);
    }
    /**
   * Build a new Bloom Filter from an existing iterable with a fixed error rate
   * @param items - The iterable used to populate the filter
   * @param errorRate - The error rate, i.e. 'false positive' rate, targeted by the filter
   * @param seed - The random number seed (optional)
   * @return A new Bloom Filter filled with the iterable's elements
   * @example
   * ```js
   * // create a filter with a false positive rate of 0.1
   * const filter = BloomFilter.from(['alice', 'bob', 'carl'], 0.1);
   * ```
   */ static from(items, errorRate, seed) {
        const array = Array.from(items);
        const filter = BloomFilter.create(array.length, errorRate);
        if (typeof seed === 'number') {
            filter.seed = seed;
        }
        array.forEach((element)=>filter.add(element));
        return filter;
    }
    /**
   * Get the optimal size of the filter
   * @return The size of the filter
   */ get size() {
        return this._size;
    }
    /**
   * Get the number of bits currently set in the filter
   * @return The filter length
   */ get length() {
        return this._filter.bitCount();
    }
    /**
   * Add an element to the filter
   * @param element - The element to add
   * @example
   * ```js
   * const filter = new BloomFilter(15, 0.1);
   * filter.add('foo');
   * ```
   */ add(element) {
        const indexes = this._hashing.getIndexes(element, this._size, this._nbHashes, this.seed);
        for(let i = 0; i < indexes.length; i++){
            this._filter.add(indexes[i]);
        }
    }
    /**
   * Test an element for membership
   * @param element - The element to look for in the filter
   * @return False if the element is definitively not in the filter, True is the element might be in the filter
   * @example
   * ```js
   * const filter = new BloomFilter(15, 0.1);
   * filter.add('foo');
   * console.log(filter.has('foo')); // output: true
   * console.log(filter.has('bar')); // output: false
   * ```
   */ has(element) {
        const indexes = this._hashing.getIndexes(element, this._size, this._nbHashes, this.seed);
        for(let i = 0; i < indexes.length; i++){
            if (!this._filter.has(indexes[i])) {
                return false;
            }
        }
        return true;
    }
    /**
   * Get the current false positive rate (or error rate) of the filter
   * @return The current false positive rate of the filter
   * @example
   * ```js
   * const filter = new BloomFilter(15, 0.1);
   * console.log(filter.rate()); // output: something around 0.1
   * ```
   */ rate() {
        return Math.pow(1 - Math.exp(-this.length / this._size), this._nbHashes);
    }
    /**
   * Check if another Bloom Filter is equal to this one
   * @param  other - The filter to compare to this one
   * @return True if they are equal, false otherwise
   */ equals(other) {
        if (this._size !== other._size || this._nbHashes !== other._nbHashes) {
            return false;
        }
        return this._filter.equals(other._filter);
    }
    export() {
        return {
            bitset: this._filter.export(),
            hashes: this._nbHashes,
            size: this._size
        };
    }
    import(data) {
        this._filter = _bitSet.default.import(data.bitset);
    }
    /**
   * Constructor
   * @param size - The number of cells
   * @param nbHashes - The number of hash functions used
   */ constructor(size, nbHashes){
        super();
        if (nbHashes < 1) {
            throw new Error(`A BloomFilter cannot uses less than one hash function, while you tried to use ${nbHashes}.`);
        }
        this._size = size;
        this._nbHashes = nbHashes;
        this._filter = new _bitSet.default(size);
    }
}
exports.BloomFilter = BloomFilter;

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/bloom-filter/utils.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/bloom-filter/utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.numberToHex = numberToHex;
exports.randomInt = randomInt;
exports.getDefaultSeed = getDefaultSeed;
function numberToHex(elem) {
    let e = Number(elem).toString(16);
    if (e.length % 4 !== 0) {
        e = '0'.repeat(4 - e.length % 4) + e;
    }
    return e;
}
function randomInt(min, max, random) {
    if (random === undefined) {
        random = Math.random;
    }
    min = Math.ceil(min);
    max = Math.floor(max);
    const rn = random();
    return Math.floor(rn * (max - min + 1)) + min;
}
function getDefaultSeed() {
    return 0x1234567890;
}

//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/escape-regexp.js":
/*!****************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.escapeStringRegexp = escapeStringRegexp;
// regexp is based on https://github.com/sindresorhus/escape-string-regexp
const reHasRegExp = /[|\\{}()[\]^$+*?.-]/;
const reReplaceRegExp = /[|\\{}()[\]^$+*?.-]/g;
function escapeStringRegexp(str) {
    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23
    if (reHasRegExp.test(str)) {
        return str.replace(reReplaceRegExp, '\\$&');
    }
    return str;
}

//# sourceMappingURL=escape-regexp.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/fnv1a.js":
/*!********************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/fnv1a.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = fnv1a;
function fnv1a(inputString, { size =32 , seed =0  } = {}) {
    if (!FNV_PRIMES[size]) {
        throw new Error('The `size` option must be one of 32, 64, 128, 256, 512, or 1024');
    }
    let hash = FNV_OFFSETS[size] ^ BigInt(seed);
    const fnvPrime = FNV_PRIMES[size];
    // Handle Unicode code points > 0x7f
    let isUnicoded = false;
    for(let index = 0; index < inputString.length; index++){
        let characterCode = inputString.charCodeAt(index);
        // Non-ASCII characters trigger the Unicode escape logic
        if (characterCode > 0x7f && !isUnicoded) {
            inputString = unescape(encodeURIComponent(inputString));
            characterCode = inputString.charCodeAt(index);
            isUnicoded = true;
        }
        hash ^= BigInt(characterCode);
        hash = BigInt.asUintN(size, hash * fnvPrime);
    }
    return hash;
}
// source: https://github.com/sindresorhus/fnv1a
// FNV_PRIMES and FNV_OFFSETS from
// http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param
const FNV_PRIMES = {
    32: BigInt(16777619),
    64: BigInt(1099511628211),
    128: BigInt(309485009821345068724781371),
    256: BigInt(374144419156711147060143317175368453031918731002211),
    512: BigInt(35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759),
    1024: BigInt(5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573)
};
const FNV_OFFSETS = {
    32: BigInt(2166136261),
    64: BigInt(14695981039346656037),
    128: BigInt(144066263297769815596495629667062367629),
    256: BigInt(100029257958052580907070968620625704837092796014241193945225284501741471925557),
    512: BigInt(9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785),
    1024: BigInt(14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915)
};

//# sourceMappingURL=fnv1a.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.detectDomainLocale = detectDomainLocale;
function detectDomainLocale(domainItems, hostname, detectedLocale) {
    let domainItem;
    if (domainItems) {
        if (detectedLocale) {
            detectedLocale = detectedLocale.toLowerCase();
        }
        for (const item of domainItems){
            var ref, ref1;
            // remove port if present
            const domainHostname = (ref = item.domain) == null ? void 0 : ref.split(':')[0].toLowerCase();
            if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || ((ref1 = item.locales) == null ? void 0 : ref1.some((locale)=>locale.toLowerCase() === detectedLocale))) {
                domainItem = item;
                break;
            }
        }
    }
    return domainItem;
}

//# sourceMappingURL=detect-domain-locale.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.normalizeLocalePath = normalizeLocalePath;
function normalizeLocalePath(pathname, locales) {
    let detectedLocale;
    // first item will be empty string from splitting at first char
    const pathnameParts = pathname.split('/');
    (locales || []).some((locale)=>{
        if (pathnameParts[1] && pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
            detectedLocale = locale;
            pathnameParts.splice(1, 1);
            pathname = pathnameParts.join('/') || '/';
            return true;
        }
        return false;
    });
    return {
        pathname,
        detectedLocale
    };
}

//# sourceMappingURL=normalize-locale-path.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/is-plain-object.js":
/*!******************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/is-plain-object.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getObjectClassLabel = getObjectClassLabel;
exports.isPlainObject = isPlainObject;
function getObjectClassLabel(value) {
    return Object.prototype.toString.call(value);
}
function isPlainObject(value) {
    if (getObjectClassLabel(value) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    /**
   * this used to be previously:
   *
   * `return prototype === null || prototype === Object.prototype`
   *
   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.
   *
   * It was changed to the current implementation since it's resilient to serialization.
   */ return prototype === null || prototype.hasOwnProperty('isPrototypeOf');
}

//# sourceMappingURL=is-plain-object.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/mitt.js":
/*!*******************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/mitt.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = mitt;
function mitt() {
    const all = Object.create(null);
    return {
        on (type, handler) {
            (all[type] || (all[type] = [])).push(handler);
        },
        off (type, handler) {
            if (all[type]) {
                all[type].splice(all[type].indexOf(handler) >>> 0, 1);
            }
        },
        emit (type, ...evts) {
            (all[type] || []).slice().map((handler)=>{
                handler(...evts);
            });
        }
    };
}

//# sourceMappingURL=mitt.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.denormalizePagePath = denormalizePagePath;
var _utils = __webpack_require__(/*! ../router/utils */ "../../node_modules/next/dist/shared/lib/router/utils/index.js");
var _normalizePathSep = __webpack_require__(/*! ./normalize-path-sep */ "../../node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js");
function denormalizePagePath(page) {
    let _page = (0, _normalizePathSep).normalizePathSep(page);
    return _page.startsWith('/index/') && !(0, _utils).isDynamicRoute(_page) ? _page.slice(6) : _page !== '/index' ? _page : '/';
}

//# sourceMappingURL=denormalize-page-path.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.normalizePathSep = normalizePathSep;
function normalizePathSep(path) {
    return path.replace(/\\/g, '/');
}

//# sourceMappingURL=normalize-path-sep.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/router.js":
/*!****************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/router.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.matchesMiddleware = matchesMiddleware;
exports.createKey = createKey;
exports["default"] = void 0;
var _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ "../../node_modules/@swc/helpers/lib/_async_to_generator.js")["default"]);
var _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ "../../node_modules/@swc/helpers/lib/_extends.js")["default"]);
var _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ "../../node_modules/@swc/helpers/lib/_interop_require_default.js")["default"]);
var _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ "../../node_modules/@swc/helpers/lib/_interop_require_wildcard.js")["default"]);
var _removeTrailingSlash = __webpack_require__(/*! ./utils/remove-trailing-slash */ "../../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js");
var _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ "../../node_modules/next/dist/client/route-loader.js");
var _script = __webpack_require__(/*! ../../../client/script */ "../../node_modules/next/dist/client/script.js");
var _isError = _interop_require_wildcard(__webpack_require__(/*! ../../../lib/is-error */ "../../node_modules/next/dist/lib/is-error.js"));
var _denormalizePagePath = __webpack_require__(/*! ../page-path/denormalize-page-path */ "../../node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js");
var _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ "../../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js");
var _mitt = _interop_require_default(__webpack_require__(/*! ../mitt */ "../../node_modules/next/dist/shared/lib/mitt.js"));
var _utils = __webpack_require__(/*! ../utils */ "../../node_modules/next/dist/shared/lib/utils.js");
var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "../../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js");
var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "../../node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js");
var _resolveRewrites = _interop_require_default(__webpack_require__(/*! ./utils/resolve-rewrites */ "../../node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js"));
var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "../../node_modules/next/dist/shared/lib/router/utils/route-matcher.js");
var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "../../node_modules/next/dist/shared/lib/router/utils/route-regex.js");
var _formatUrl = __webpack_require__(/*! ./utils/format-url */ "../../node_modules/next/dist/shared/lib/router/utils/format-url.js");
var _detectDomainLocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ "../../node_modules/next/dist/client/detect-domain-locale.js");
var _parsePath = __webpack_require__(/*! ./utils/parse-path */ "../../node_modules/next/dist/shared/lib/router/utils/parse-path.js");
var _addLocale = __webpack_require__(/*! ../../../client/add-locale */ "../../node_modules/next/dist/client/add-locale.js");
var _removeLocale = __webpack_require__(/*! ../../../client/remove-locale */ "../../node_modules/next/dist/client/remove-locale.js");
var _removeBasePath = __webpack_require__(/*! ../../../client/remove-base-path */ "../../node_modules/next/dist/client/remove-base-path.js");
var _addBasePath = __webpack_require__(/*! ../../../client/add-base-path */ "../../node_modules/next/dist/client/add-base-path.js");
var _hasBasePath = __webpack_require__(/*! ../../../client/has-base-path */ "../../node_modules/next/dist/client/has-base-path.js");
var _isApiRoute = __webpack_require__(/*! ../../../lib/is-api-route */ "../../node_modules/next/dist/lib/is-api-route.js");
var _getNextPathnameInfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ "../../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js");
var _formatNextPathnameInfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ "../../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js");
var _compareStates = __webpack_require__(/*! ./utils/compare-states */ "../../node_modules/next/dist/shared/lib/router/utils/compare-states.js");
var _isLocalUrl = __webpack_require__(/*! ./utils/is-local-url */ "../../node_modules/next/dist/shared/lib/router/utils/is-local-url.js");
var _isBot = __webpack_require__(/*! ./utils/is-bot */ "../../node_modules/next/dist/shared/lib/router/utils/is-bot.js");
var _omit = __webpack_require__(/*! ./utils/omit */ "../../node_modules/next/dist/shared/lib/router/utils/omit.js");
var _resolveHref = __webpack_require__(/*! ./utils/resolve-href */ "../../node_modules/next/dist/shared/lib/router/utils/resolve-href.js");
var _interpolateAs = __webpack_require__(/*! ./utils/interpolate-as */ "../../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js");
var _handleSmoothScroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ "../../node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js");
function buildCancellationError() {
    return Object.assign(new Error('Route Cancelled'), {
        cancelled: true
    });
}
function matchesMiddleware(options) {
    return _matchesMiddleware.apply(this, arguments);
}
function _matchesMiddleware() {
    _matchesMiddleware = _async_to_generator(function*(options) {
        const matchers = yield Promise.resolve(options.router.pageLoader.getMiddleware());
        if (!matchers) return false;
        const { pathname: asPathname  } = (0, _parsePath).parsePath(options.asPath);
        // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`
        const cleanedAs = (0, _hasBasePath).hasBasePath(asPathname) ? (0, _removeBasePath).removeBasePath(asPathname) : asPathname;
        const asWithBasePathAndLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, options.locale));
        // Check only path match on client. Matching "has" should be done on server
        // where we can access more info such as headers, HttpOnly cookie, etc.
        return matchers.some((m)=>new RegExp(m.regexp).test(asWithBasePathAndLocale));
    });
    return _matchesMiddleware.apply(this, arguments);
}
function stripOrigin(url) {
    const origin = (0, _utils).getLocationOrigin();
    return url.startsWith(origin) ? url.substring(origin.length) : url;
}
function prepareUrlAs(router, url, as) {
    // If url and as provided as an object representation,
    // we'll format them into the string version here.
    let [resolvedHref, resolvedAs] = (0, _resolveHref).resolveHref(router, url, true);
    const origin = (0, _utils).getLocationOrigin();
    const hrefWasAbsolute = resolvedHref.startsWith(origin);
    const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);
    resolvedHref = stripOrigin(resolvedHref);
    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;
    const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addBasePath).addBasePath(resolvedHref);
    const preparedAs = as ? stripOrigin((0, _resolveHref).resolveHref(router, as)) : resolvedAs || resolvedHref;
    return {
        url: preparedUrl,
        as: asWasAbsolute ? preparedAs : (0, _addBasePath).addBasePath(preparedAs)
    };
}
function resolveDynamicRoute(pathname, pages) {
    const cleanPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));
    if (cleanPathname === '/404' || cleanPathname === '/_error') {
        return pathname;
    }
    // handle resolving href for dynamic routes
    if (!pages.includes(cleanPathname)) {
        // eslint-disable-next-line array-callback-return
        pages.some((page)=>{
            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {
                pathname = page;
                return true;
            }
        });
    }
    return (0, _removeTrailingSlash).removeTrailingSlash(pathname);
}
function getMiddlewareData(source, response, options) {
    const nextConfig = {
        basePath: options.router.basePath,
        i18n: {
            locales: options.router.locales
        },
        trailingSlash: Boolean(({}).__NEXT_TRAILING_SLASH)
    };
    const rewriteHeader = response.headers.get('x-nextjs-rewrite');
    let rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');
    const matchedPath = response.headers.get('x-matched-path');
    if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {
        // leverage x-matched-path to detect next.config.js rewrites
        rewriteTarget = matchedPath;
    }
    if (rewriteTarget) {
        if (rewriteTarget.startsWith('/') || ({}).__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE) {
            const parsedRewriteTarget = (0, _parseRelativeUrl).parseRelativeUrl(rewriteTarget);
            const pathnameInfo = (0, _getNextPathnameInfo).getNextPathnameInfo(parsedRewriteTarget.pathname, {
                nextConfig,
                parseData: true
            });
            let fsPathname = (0, _removeTrailingSlash).removeTrailingSlash(pathnameInfo.pathname);
            return Promise.all([
                options.router.pageLoader.getPageList(),
                (0, _routeLoader).getClientBuildManifest(), 
            ]).then(([pages, { __rewrites: rewrites  }])=>{
                let as = (0, _addLocale).addLocale(pathnameInfo.pathname, pathnameInfo.locale);
                if ((0, _isDynamic).isDynamicRoute(as) || !rewriteHeader && pages.includes((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(as), options.router.locales).pathname)) {
                    const parsedSource = (0, _getNextPathnameInfo).getNextPathnameInfo((0, _parseRelativeUrl).parseRelativeUrl(source).pathname, {
                        parseData: true
                    });
                    as = (0, _addBasePath).addBasePath(parsedSource.pathname);
                    parsedRewriteTarget.pathname = as;
                }
                if (({}).__NEXT_HAS_REWRITES) {
                    const result = (0, _resolveRewrites).default(as, pages, rewrites, parsedRewriteTarget.query, (path)=>resolveDynamicRoute(path, pages), options.router.locales);
                    if (result.matchedPage) {
                        parsedRewriteTarget.pathname = result.parsedAs.pathname;
                        as = parsedRewriteTarget.pathname;
                        Object.assign(parsedRewriteTarget.query, result.parsedAs.query);
                    }
                } else if (!pages.includes(fsPathname)) {
                    const resolvedPathname = resolveDynamicRoute(fsPathname, pages);
                    if (resolvedPathname !== fsPathname) {
                        fsPathname = resolvedPathname;
                    }
                }
                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;
                if ((0, _isDynamic).isDynamicRoute(resolvedHref)) {
                    const matches = (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(resolvedHref))(as);
                    Object.assign(parsedRewriteTarget.query, matches || {});
                }
                return {
                    type: 'rewrite',
                    parsedAs: parsedRewriteTarget,
                    resolvedHref
                };
            });
        }
        const src = (0, _parsePath).parsePath(source);
        const pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {
            nextConfig,
            parseData: true
        }), {
            defaultLocale: options.router.defaultLocale,
            buildId: ''
        }));
        return Promise.resolve({
            type: 'redirect-external',
            destination: `${pathname}${src.query}${src.hash}`
        });
    }
    const redirectTarget = response.headers.get('x-nextjs-redirect');
    if (redirectTarget) {
        if (redirectTarget.startsWith('/')) {
            const src = (0, _parsePath).parsePath(redirectTarget);
            const pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {
                nextConfig,
                parseData: true
            }), {
                defaultLocale: options.router.defaultLocale,
                buildId: ''
            }));
            return Promise.resolve({
                type: 'redirect-internal',
                newAs: `${pathname}${src.query}${src.hash}`,
                newUrl: `${pathname}${src.query}${src.hash}`
            });
        }
        return Promise.resolve({
            type: 'redirect-external',
            destination: redirectTarget
        });
    }
    return Promise.resolve({
        type: 'next'
    });
}
function withMiddlewareEffects(options) {
    return _withMiddlewareEffects.apply(this, arguments);
}
function _withMiddlewareEffects() {
    _withMiddlewareEffects = _async_to_generator(function*(options) {
        const matches = yield matchesMiddleware(options);
        if (!matches || !options.fetchData) {
            return null;
        }
        try {
            const data = yield options.fetchData();
            const effect = yield getMiddlewareData(data.dataHref, data.response, options);
            return {
                dataHref: data.dataHref,
                json: data.json,
                response: data.response,
                text: data.text,
                cacheKey: data.cacheKey,
                effect
            };
        } catch (e) {
            /**
     * TODO: Revisit this in the future.
     * For now we will not consider middleware data errors to be fatal.
     * maybe we should revisit in the future.
     */ return null;
        }
    });
    return _withMiddlewareEffects.apply(this, arguments);
}
const manualScrollRestoration = ({}).__NEXT_SCROLL_RESTORATION && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function() {
    try {
        let v = '__next';
        // eslint-disable-next-line no-sequences
        return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;
    } catch (n) {}
}();
const SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');
function fetchRetry(url, attempts, options) {
    return fetch(url, {
        // Cookies are required to be present for Next.js' SSG "Preview Mode".
        // Cookies may also be required for `getServerSideProps`.
        //
        // > `fetch` won’t send cookies, unless you set the credentials init
        // > option.
        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
        //
        // > For maximum browser compatibility when it comes to sending &
        // > receiving cookies, always supply the `credentials: 'same-origin'`
        // > option instead of relying on the default.
        // https://github.com/github/fetch#caveats
        credentials: 'same-origin',
        method: options.method || 'GET',
        headers: Object.assign({}, options.headers, {
            'x-nextjs-data': '1'
        })
    }).then((response)=>{
        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;
    });
}
function tryToParseAsJSON(text) {
    try {
        return JSON.parse(text);
    } catch (error) {
        return null;
    }
}
function fetchNextData({ dataHref , inflightCache , isPrefetch , hasMiddleware , isServerRender , parseJSON , persistCache , isBackground , unstable_skipClientCache  }) {
    const { href: cacheKey  } = new URL(dataHref, window.location.href);
    var ref1;
    const getData = (params)=>{
        return fetchRetry(dataHref, isServerRender ? 3 : 1, {
            headers: Object.assign({}, isPrefetch ? {
                purpose: 'prefetch'
            } : {}, isPrefetch && hasMiddleware ? {
                'x-middleware-prefetch': '1'
            } : {}),
            method: (ref1 = params == null ? void 0 : params.method) != null ? ref1 : 'GET'
        }).then((response)=>{
            if (response.ok && (params == null ? void 0 : params.method) === 'HEAD') {
                return {
                    dataHref,
                    response,
                    text: '',
                    json: {},
                    cacheKey
                };
            }
            return response.text().then((text)=>{
                if (!response.ok) {
                    /**
             * When the data response is a redirect because of a middleware
             * we do not consider it an error. The headers must bring the
             * mapped location.
             * TODO: Change the status code in the handler.
             */ if (hasMiddleware && [
                        301,
                        302,
                        307,
                        308
                    ].includes(response.status)) {
                        return {
                            dataHref,
                            response,
                            text,
                            json: {},
                            cacheKey
                        };
                    }
                    if (response.status === 404) {
                        var ref;
                        if ((ref = tryToParseAsJSON(text)) == null ? void 0 : ref.notFound) {
                            return {
                                dataHref,
                                json: {
                                    notFound: SSG_DATA_NOT_FOUND
                                },
                                response,
                                text,
                                cacheKey
                            };
                        }
                    }
                    const error = new Error(`Failed to load static props`);
                    /**
             * We should only trigger a server-side transition if this was
             * caused on a client-side transition. Otherwise, we'd get into
             * an infinite loop.
             */ if (!isServerRender) {
                        (0, _routeLoader).markAssetError(error);
                    }
                    throw error;
                }
                return {
                    dataHref,
                    json: parseJSON ? tryToParseAsJSON(text) : null,
                    response,
                    text,
                    cacheKey
                };
            });
        }).then((data)=>{
            if (!persistCache || "development" !== 'production' || 0) {
                delete inflightCache[cacheKey];
            }
            return data;
        }).catch((err)=>{
            if (!unstable_skipClientCache) {
                delete inflightCache[cacheKey];
            }
            if (// chrome
            err.message === 'Failed to fetch' || // firefox
            err.message === 'NetworkError when attempting to fetch resource.' || // safari
            err.message === 'Load failed') {
                (0, _routeLoader).markAssetError(err);
            }
            throw err;
        });
    };
    // when skipping client cache we wait to update
    // inflight cache until successful data response
    // this allows racing click event with fetching newer data
    // without blocking navigation when stale data is available
    if (unstable_skipClientCache && persistCache) {
        return getData({}).then((data)=>{
            inflightCache[cacheKey] = Promise.resolve(data);
            return data;
        });
    }
    if (inflightCache[cacheKey] !== undefined) {
        return inflightCache[cacheKey];
    }
    return inflightCache[cacheKey] = getData(isBackground ? {
        method: 'HEAD'
    } : {});
}
function createKey() {
    return Math.random().toString(36).slice(2, 10);
}
function handleHardNavigation({ url , router  }) {
    // ensure we don't trigger a hard navigation to the same
    // URL as this can end up with an infinite refresh
    if (url === (0, _addBasePath).addBasePath((0, _addLocale).addLocale(router.asPath, router.locale))) {
        throw new Error(`Invariant: attempted to hard navigate to the same URL ${url} ${location.href}`);
    }
    window.location.href = url;
}
const getCancelledHandler = ({ route , router  })=>{
    let cancelled = false;
    const cancel = router.clc = ()=>{
        cancelled = true;
    };
    const handleCancelled = ()=>{
        if (cancelled) {
            const error = new Error(`Abort fetching component for route: "${route}"`);
            error.cancelled = true;
            throw error;
        }
        if (cancel === router.clc) {
            router.clc = null;
        }
    };
    return handleCancelled;
};
class Router {
    reload() {
        window.location.reload();
    }
    /**
   * Go back in history
   */ back() {
        window.history.back();
    }
    /**
   * Go forward in history
   */ forward() {
        window.history.forward();
    }
    /**
   * Performs a `pushState` with arguments
   * @param url of the route
   * @param as masks `url` for the browser
   * @param options object you can define `shallow` and other options
   */ push(url, as, options = {}) {
        if (({}).__NEXT_SCROLL_RESTORATION) {
            // TODO: remove in the future when we update history before route change
            // is complete, as the popstate event should handle this capture.
            if (manualScrollRestoration) {
                try {
                    // Snapshot scroll position right before navigating to a new page:
                    sessionStorage.setItem('__next_scroll_' + this._key, JSON.stringify({
                        x: self.pageXOffset,
                        y: self.pageYOffset
                    }));
                } catch (e) {}
            }
        }
        ({ url , as  } = prepareUrlAs(this, url, as));
        return this.change('pushState', url, as, options);
    }
    /**
   * Performs a `replaceState` with arguments
   * @param url of the route
   * @param as masks `url` for the browser
   * @param options object you can define `shallow` and other options
   */ replace(url, as, options = {}) {
        ({ url , as  } = prepareUrlAs(this, url, as));
        return this.change('replaceState', url, as, options);
    }
    _bfl(as, resolvedAs, locale) {
        var _this = this;
        return _async_to_generator(function*() {
            if (({}).__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {
                let matchesBflStatic = false;
                let matchesBflDynamic = false;
                for (const curAs of [
                    as,
                    resolvedAs
                ]){
                    if (curAs) {
                        const asNoSlash = (0, _removeTrailingSlash).removeTrailingSlash(new URL(curAs, 'http://n').pathname);
                        const asNoSlashLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(asNoSlash, locale || _this.locale));
                        if (asNoSlash !== (0, _removeTrailingSlash).removeTrailingSlash(new URL(_this.asPath, 'http://n').pathname)) {
                            var ref, ref2;
                            matchesBflStatic = matchesBflStatic || !!((ref = _this._bfl_s) == null ? void 0 : ref.has(asNoSlash)) || !!((ref2 = _this._bfl_s) == null ? void 0 : ref2.has(asNoSlashLocale));
                            for (const normalizedAS of [
                                asNoSlash,
                                asNoSlashLocale
                            ]){
                                // if any sub-path of as matches a dynamic filter path
                                // it should be hard navigated
                                const curAsParts = normalizedAS.split('/');
                                for(let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){
                                    var ref3;
                                    const currentPart = curAsParts.slice(0, i).join('/');
                                    if (currentPart && ((ref3 = _this._bfl_d) == null ? void 0 : ref3.has(currentPart))) {
                                        matchesBflDynamic = true;
                                        break;
                                    }
                                }
                            }
                            // if the client router filter is matched then we trigger
                            // a hard navigation
                            if (matchesBflStatic || matchesBflDynamic) {
                                handleHardNavigation({
                                    url: (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, locale || _this.locale)),
                                    router: _this
                                });
                                return new Promise(()=>{});
                            }
                        }
                    }
                }
            }
        })();
    }
    change(method, url, as, options, forcedScroll) {
        var _this = this;
        return _async_to_generator(function*() {
            if (!(0, _isLocalUrl).isLocalURL(url)) {
                handleHardNavigation({
                    url,
                    router: _this
                });
                return false;
            }
            // WARNING: `_h` is an internal option for handing Next.js client-side
            // hydration. Your app should _never_ use this property. It may change at
            // any time without notice.
            const isQueryUpdating = options._h === 1;
            if (!isQueryUpdating && !options.shallow) {
                yield _this._bfl(as, undefined, options.locale);
            }
            let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsePath).parsePath(url).pathname === (0, _parsePath).parsePath(as).pathname;
            const nextState = _extends({}, _this.state);
            // for static pages with query params in the URL we delay
            // marking the router ready until after the query is updated
            // or a navigation has occurred
            const readyStateChange = _this.isReady !== true;
            _this.isReady = true;
            const isSsr = _this.isSsr;
            if (!isQueryUpdating) {
                _this.isSsr = false;
            }
            // if a route transition is already in progress before
            // the query updating is triggered ignore query updating
            if (isQueryUpdating && _this.clc) {
                return false;
            }
            const prevLocale = nextState.locale;
            if (({}).__NEXT_I18N_SUPPORT) {
                nextState.locale = options.locale === false ? _this.defaultLocale : options.locale || nextState.locale;
                if (typeof options.locale === 'undefined') {
                    options.locale = nextState.locale;
                }
                const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as);
                const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);
                if (localePathResult.detectedLocale) {
                    nextState.locale = localePathResult.detectedLocale;
                    parsedAs.pathname = (0, _addBasePath).addBasePath(parsedAs.pathname);
                    as = (0, _formatUrl).formatWithValidation(parsedAs);
                    url = (0, _addBasePath).addBasePath((0, _normalizeLocalePath).normalizeLocalePath((0, _hasBasePath).hasBasePath(url) ? (0, _removeBasePath).removeBasePath(url) : url, _this.locales).pathname);
                }
                let didNavigate = false;
                // we need to wrap this in the env check again since regenerator runtime
                // moves this on its own due to the return
                if (({}).__NEXT_I18N_SUPPORT) {
                    var ref;
                    // if the locale isn't configured hard navigate to show 404 page
                    if (!((ref = _this.locales) == null ? void 0 : ref.includes(nextState.locale))) {
                        parsedAs.pathname = (0, _addLocale).addLocale(parsedAs.pathname, nextState.locale);
                        handleHardNavigation({
                            url: (0, _formatUrl).formatWithValidation(parsedAs),
                            router: _this
                        });
                        // this was previously a return but was removed in favor
                        // of better dead code elimination with regenerator runtime
                        didNavigate = true;
                    }
                }
                const detectedDomain = (0, _detectDomainLocale).detectDomainLocale(_this.domainLocales, undefined, nextState.locale);
                // we need to wrap this in the env check again since regenerator runtime
                // moves this on its own due to the return
                if (({}).__NEXT_I18N_SUPPORT) {
                    // if we are navigating to a domain locale ensure we redirect to the
                    // correct domain
                    if (!didNavigate && detectedDomain && _this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {
                        const asNoBasePath = (0, _removeBasePath).removeBasePath(as);
                        handleHardNavigation({
                            url: `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${(0, _addBasePath).addBasePath(`${nextState.locale === detectedDomain.defaultLocale ? '' : `/${nextState.locale}`}${asNoBasePath === '/' ? '' : asNoBasePath}` || '/')}`,
                            router: _this
                        });
                        // this was previously a return but was removed in favor
                        // of better dead code elimination with regenerator runtime
                        didNavigate = true;
                    }
                }
                if (didNavigate) {
                    return new Promise(()=>{});
                }
            }
            // marking route changes as a navigation start entry
            if (_utils.ST) {
                performance.mark('routeChange');
            }
            const { shallow =false , scroll =true  } = options;
            const routeProps = {
                shallow
            };
            if (_this._inFlightRoute && _this.clc) {
                if (!isSsr) {
                    Router.events.emit('routeChangeError', buildCancellationError(), _this._inFlightRoute, routeProps);
                }
                _this.clc();
                _this.clc = null;
            }
            as = (0, _addBasePath).addBasePath((0, _addLocale).addLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, options.locale, _this.defaultLocale));
            const cleanedAs = (0, _removeLocale).removeLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, nextState.locale);
            _this._inFlightRoute = as;
            const localeChange = prevLocale !== nextState.locale;
            // If the url change is only related to a hash change
            // We should not proceed. We should only change the state.
            if (!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange) {
                nextState.asPath = cleanedAs;
                Router.events.emit('hashChangeStart', as, routeProps);
                // TODO: do we need the resolved href when only a hash change?
                _this.changeState(method, url, as, _extends({}, options, {
                    scroll: false
                }));
                if (scroll) {
                    _this.scrollToHash(cleanedAs);
                }
                try {
                    yield _this.set(nextState, _this.components[nextState.route], null);
                } catch (err) {
                    if ((0, _isError).default(err) && err.cancelled) {
                        Router.events.emit('routeChangeError', err, cleanedAs, routeProps);
                    }
                    throw err;
                }
                Router.events.emit('hashChangeComplete', as, routeProps);
                return true;
            }
            let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);
            let { pathname , query  } = parsed;
            // The build manifest needs to be loaded before auto-static dynamic pages
            // get their query parameters to allow ensuring they can be parsed properly
            // when rewritten to
            let pages, rewrites;
            try {
                [pages, { __rewrites: rewrites  }] = yield Promise.all([
                    _this.pageLoader.getPageList(),
                    (0, _routeLoader).getClientBuildManifest(),
                    _this.pageLoader.getMiddleware(), 
                ]);
            } catch (err) {
                // If we fail to resolve the page list or client-build manifest, we must
                // do a server-side transition:
                handleHardNavigation({
                    url: as,
                    router: _this
                });
                return false;
            }
            // If asked to change the current URL we should reload the current page
            // (not location.reload() but reload getInitialProps and other Next.js stuffs)
            // We also need to set the method = replaceState always
            // as this should not go into the history (That's how browsers work)
            // We should compare the new asPath to the current asPath, not the url
            if (!_this.urlIsNew(cleanedAs) && !localeChange) {
                method = 'replaceState';
            }
            // we need to resolve the as value using rewrites for dynamic SSG
            // pages to allow building the data URL correctly
            let resolvedAs = as;
            // url and as should always be prefixed with basePath by this
            // point by either next/link or router.push/replace so strip the
            // basePath from the pathname to match the pages dir 1-to-1
            pathname = pathname ? (0, _removeTrailingSlash).removeTrailingSlash((0, _removeBasePath).removeBasePath(pathname)) : pathname;
            let route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);
            const parsedAsPathname = as.startsWith('/') && (0, _parseRelativeUrl).parseRelativeUrl(as).pathname;
            const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isDynamic).isDynamicRoute(route) || !(0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(route))(parsedAsPathname)));
            // we don't attempt resolve asPath when we need to execute
            // middleware as the resolving will occur server-side
            const isMiddlewareMatch = !options.shallow && (yield matchesMiddleware({
                asPath: as,
                locale: nextState.locale,
                router: _this
            }));
            if (isQueryUpdating && isMiddlewareMatch) {
                shouldResolveHref = false;
            }
            if (shouldResolveHref && pathname !== '/_error') {
                options._shouldResolveHref = true;
                if (({}).__NEXT_HAS_REWRITES && as.startsWith('/')) {
                    const rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, nextState.locale), true), pages, rewrites, query, (p)=>resolveDynamicRoute(p, pages), _this.locales);
                    if (rewritesResult.externalDest) {
                        handleHardNavigation({
                            url: as,
                            router: _this
                        });
                        return true;
                    }
                    if (!isMiddlewareMatch) {
                        resolvedAs = rewritesResult.asPath;
                    }
                    if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {
                        // if this directly matches a page we need to update the href to
                        // allow the correct page chunk to be loaded
                        pathname = rewritesResult.resolvedHref;
                        parsed.pathname = (0, _addBasePath).addBasePath(pathname);
                        if (!isMiddlewareMatch) {
                            url = (0, _formatUrl).formatWithValidation(parsed);
                        }
                    }
                } else {
                    parsed.pathname = resolveDynamicRoute(pathname, pages);
                    if (parsed.pathname !== pathname) {
                        pathname = parsed.pathname;
                        parsed.pathname = (0, _addBasePath).addBasePath(pathname);
                        if (!isMiddlewareMatch) {
                            url = (0, _formatUrl).formatWithValidation(parsed);
                        }
                    }
                }
            }
            if (!(0, _isLocalUrl).isLocalURL(as)) {
                if (true) {
                    throw new Error(`Invalid href: "${url}" and as: "${as}", received relative href and external as` + `\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`);
                }
                handleHardNavigation({
                    url: as,
                    router: _this
                });
                return false;
            }
            resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(resolvedAs), nextState.locale);
            route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);
            let routeMatch = false;
            if ((0, _isDynamic).isDynamicRoute(route)) {
                const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);
                const asPathname = parsedAs.pathname;
                const routeRegex = (0, _routeRegex).getRouteRegex(route);
                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);
                const shouldInterpolate = route === asPathname;
                const interpolatedAs = shouldInterpolate ? (0, _interpolateAs).interpolateAs(route, asPathname, query) : {};
                if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {
                    const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param] && !routeRegex.groups[param].optional);
                    if (missingParams.length > 0 && !isMiddlewareMatch) {
                        if (true) {
                            console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \`as\` and \`href\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \`href\`'s \`query\``);
                        }
                        throw new Error((shouldInterpolate ? `The provided \`href\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \`as\` value (${asPathname}) is incompatible with the \`href\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);
                    }
                } else if (shouldInterpolate) {
                    as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs, {
                        pathname: interpolatedAs.result,
                        query: (0, _omit).omit(query, interpolatedAs.params)
                    }));
                } else {
                    // Merge params into `query`, overwriting any specified in search
                    Object.assign(query, routeMatch);
                }
            }
            if (!isQueryUpdating) {
                Router.events.emit('routeChangeStart', as, routeProps);
            }
            const isErrorRoute = _this.pathname === '/404' || _this.pathname === '/_error';
            try {
                var ref4, ref5, ref6;
                let routeInfo = yield _this.getRouteInfo({
                    route,
                    pathname,
                    query,
                    as,
                    resolvedAs,
                    routeProps,
                    locale: nextState.locale,
                    isPreview: nextState.isPreview,
                    hasMiddleware: isMiddlewareMatch,
                    unstable_skipClientCache: options.unstable_skipClientCache,
                    isQueryUpdating: isQueryUpdating && !_this.isFallback,
                    isMiddlewareRewrite
                });
                if (!isQueryUpdating && !options.shallow) {
                    yield _this._bfl(as, 'resolvedAs' in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);
                }
                if ('route' in routeInfo && isMiddlewareMatch) {
                    pathname = routeInfo.route || route;
                    route = pathname;
                    if (!routeProps.shallow) {
                        query = Object.assign({}, routeInfo.query || {}, query);
                    }
                    const cleanedParsedPathname = (0, _hasBasePath).hasBasePath(parsed.pathname) ? (0, _removeBasePath).removeBasePath(parsed.pathname) : parsed.pathname;
                    if (routeMatch && pathname !== cleanedParsedPathname) {
                        Object.keys(routeMatch).forEach((key)=>{
                            if (routeMatch && query[key] === routeMatch[key]) {
                                delete query[key];
                            }
                        });
                    }
                    if ((0, _isDynamic).isDynamicRoute(pathname)) {
                        const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addBasePath).addBasePath((0, _addLocale).addLocale(new URL(as, location.href).pathname, nextState.locale), true);
                        let rewriteAs = prefixedAs;
                        if ((0, _hasBasePath).hasBasePath(rewriteAs)) {
                            rewriteAs = (0, _removeBasePath).removeBasePath(rewriteAs);
                        }
                        if (({}).__NEXT_I18N_SUPPORT) {
                            const localeResult = (0, _normalizeLocalePath).normalizeLocalePath(rewriteAs, _this.locales);
                            nextState.locale = localeResult.detectedLocale || nextState.locale;
                            rewriteAs = localeResult.pathname;
                        }
                        const routeRegex = (0, _routeRegex).getRouteRegex(pathname);
                        const curRouteMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(new URL(rewriteAs, location.href).pathname);
                        if (curRouteMatch) {
                            Object.assign(query, curRouteMatch);
                        }
                    }
                }
                // If the routeInfo brings a redirect we simply apply it.
                if ('type' in routeInfo) {
                    if (routeInfo.type === 'redirect-internal') {
                        return _this.change(method, routeInfo.newUrl, routeInfo.newAs, options);
                    } else {
                        handleHardNavigation({
                            url: routeInfo.destination,
                            router: _this
                        });
                        return new Promise(()=>{});
                    }
                }
                const component = routeInfo.Component;
                if (component && component.unstable_scriptLoader) {
                    const scripts = [].concat(component.unstable_scriptLoader());
                    scripts.forEach((script)=>{
                        (0, _script).handleClientScriptLoad(script.props);
                    });
                }
                // handle redirect on client-transition
                if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {
                    if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {
                        // Use the destination from redirect without adding locale
                        options.locale = false;
                        const destination = routeInfo.props.pageProps.__N_REDIRECT;
                        // check if destination is internal (resolves to a page) and attempt
                        // client-navigation if it is falling back to hard navigation if
                        // it's not
                        if (destination.startsWith('/') && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {
                            const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);
                            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);
                            const { url: newUrl , as: newAs  } = prepareUrlAs(_this, destination, destination);
                            return _this.change(method, newUrl, newAs, options);
                        }
                        handleHardNavigation({
                            url: destination,
                            router: _this
                        });
                        return new Promise(()=>{});
                    }
                    nextState.isPreview = !!routeInfo.props.__N_PREVIEW;
                    // handle SSG data 404
                    if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {
                        let notFoundRoute;
                        try {
                            yield _this.fetchComponent('/404');
                            notFoundRoute = '/404';
                        } catch (_) {
                            notFoundRoute = '/_error';
                        }
                        routeInfo = yield _this.getRouteInfo({
                            route: notFoundRoute,
                            pathname: notFoundRoute,
                            query,
                            as,
                            resolvedAs,
                            routeProps: {
                                shallow: false
                            },
                            locale: nextState.locale,
                            isPreview: nextState.isPreview,
                            isNotFound: true
                        });
                        if ('type' in routeInfo) {
                            throw new Error(`Unexpected middleware effect on /404`);
                        }
                    }
                }
                if (isQueryUpdating && _this.pathname === '/_error' && ((ref4 = self.__NEXT_DATA__.props) == null ? void 0 : (ref5 = ref4.pageProps) == null ? void 0 : ref5.statusCode) === 500 && ((ref6 = routeInfo.props) == null ? void 0 : ref6.pageProps)) {
                    // ensure statusCode is still correct for static 500 page
                    // when updating query information
                    routeInfo.props.pageProps.statusCode = 500;
                }
                var _route;
                // shallow routing is only allowed for same page URL changes.
                const isValidShallowRoute = options.shallow && nextState.route === ((_route = routeInfo.route) != null ? _route : route);
                var _scroll;
                const shouldScroll = (_scroll = options.scroll) != null ? _scroll : !isQueryUpdating && !isValidShallowRoute;
                const resetScroll = shouldScroll ? {
                    x: 0,
                    y: 0
                } : null;
                const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;
                // the new state that the router gonna set
                const upcomingRouterState = _extends({}, nextState, {
                    route,
                    pathname,
                    query,
                    asPath: cleanedAs,
                    isFallback: false
                });
                // When the page being rendered is the 404 page, we should only update the
                // query parameters. Route changes here might add the basePath when it
                // wasn't originally present. This is also why this block is before the
                // below `changeState` call which updates the browser's history (changing
                // the URL).
                if (isQueryUpdating && isErrorRoute) {
                    var ref7, ref8, ref9;
                    routeInfo = yield _this.getRouteInfo({
                        route: _this.pathname,
                        pathname: _this.pathname,
                        query,
                        as,
                        resolvedAs,
                        routeProps: {
                            shallow: false
                        },
                        locale: nextState.locale,
                        isPreview: nextState.isPreview,
                        isQueryUpdating: isQueryUpdating && !_this.isFallback
                    });
                    if ('type' in routeInfo) {
                        throw new Error(`Unexpected middleware effect on ${_this.pathname}`);
                    }
                    if (_this.pathname === '/_error' && ((ref7 = self.__NEXT_DATA__.props) == null ? void 0 : (ref8 = ref7.pageProps) == null ? void 0 : ref8.statusCode) === 500 && ((ref9 = routeInfo.props) == null ? void 0 : ref9.pageProps)) {
                        // ensure statusCode is still correct for static 500 page
                        // when updating query information
                        routeInfo.props.pageProps.statusCode = 500;
                    }
                    try {
                        yield _this.set(upcomingRouterState, routeInfo, upcomingScrollState);
                    } catch (err) {
                        if ((0, _isError).default(err) && err.cancelled) {
                            Router.events.emit('routeChangeError', err, cleanedAs, routeProps);
                        }
                        throw err;
                    }
                    return true;
                }
                Router.events.emit('beforeHistoryChange', as, routeProps);
                _this.changeState(method, url, as, options);
                // for query updates we can skip it if the state is unchanged and we don't
                // need to scroll
                // https://github.com/vercel/next.js/issues/37139
                const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _compareStates).compareRouterStates(upcomingRouterState, _this.state);
                if (!canSkipUpdating) {
                    try {
                        yield _this.set(upcomingRouterState, routeInfo, upcomingScrollState);
                    } catch (e) {
                        if (e.cancelled) routeInfo.error = routeInfo.error || e;
                        else throw e;
                    }
                    if (routeInfo.error) {
                        if (!isQueryUpdating) {
                            Router.events.emit('routeChangeError', routeInfo.error, cleanedAs, routeProps);
                        }
                        throw routeInfo.error;
                    }
                    if (({}).__NEXT_I18N_SUPPORT) {
                        if (nextState.locale) {
                            document.documentElement.lang = nextState.locale;
                        }
                    }
                    if (!isQueryUpdating) {
                        Router.events.emit('routeChangeComplete', as, routeProps);
                    }
                    // A hash mark # is the optional last part of a URL
                    const hashRegex = /#.+$/;
                    if (shouldScroll && hashRegex.test(as)) {
                        _this.scrollToHash(as);
                    }
                }
                return true;
            } catch (err1) {
                if ((0, _isError).default(err1) && err1.cancelled) {
                    return false;
                }
                throw err1;
            }
        })();
    }
    changeState(method, url, as, options = {}) {
        if (true) {
            if (typeof window.history === 'undefined') {
                console.error(`Warning: window.history is not available.`);
                return;
            }
            if (typeof window.history[method] === 'undefined') {
                console.error(`Warning: window.history.${method} is not available`);
                return;
            }
        }
        if (method !== 'pushState' || (0, _utils).getURL() !== as) {
            this._shallow = options.shallow;
            window.history[method]({
                url,
                as,
                options,
                __N: true,
                key: this._key = method !== 'pushState' ? this._key : createKey()
            }, // Most browsers currently ignores this parameter, although they may use it in the future.
            // Passing the empty string here should be safe against future changes to the method.
            // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
            '', as);
        }
    }
    handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {
        var _this = this;
        return _async_to_generator(function*() {
            console.error(err);
            if (err.cancelled) {
                // bubble up cancellation errors
                throw err;
            }
            if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {
                Router.events.emit('routeChangeError', err, as, routeProps);
                // If we can't load the page it could be one of following reasons
                //  1. Page doesn't exists
                //  2. Page does exist in a different zone
                //  3. Internal error while loading the page
                // So, doing a hard reload is the proper way to deal with this.
                handleHardNavigation({
                    url: as,
                    router: _this
                });
                // Changing the URL doesn't block executing the current code path.
                // So let's throw a cancellation error stop the routing logic.
                throw buildCancellationError();
            }
            try {
                let props;
                const { page: Component , styleSheets  } = yield _this.fetchComponent('/_error');
                const routeInfo = {
                    props,
                    Component,
                    styleSheets,
                    err,
                    error: err
                };
                if (!routeInfo.props) {
                    try {
                        routeInfo.props = yield _this.getInitialProps(Component, {
                            err,
                            pathname,
                            query
                        });
                    } catch (gipErr) {
                        console.error('Error in error page `getInitialProps`: ', gipErr);
                        routeInfo.props = {};
                    }
                }
                return routeInfo;
            } catch (routeInfoErr) {
                return _this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ''), pathname, query, as, routeProps, true);
            }
        })();
    }
    getRouteInfo({ route: requestedRoute , pathname , query , as , resolvedAs , routeProps , locale , hasMiddleware , isPreview , unstable_skipClientCache , isQueryUpdating , isMiddlewareRewrite , isNotFound  }) {
        var _this = this;
        return _async_to_generator(function*() {
            /**
     * This `route` binding can change if there's a rewrite
     * so we keep a reference to the original requested route
     * so we can store the cache for it and avoid re-requesting every time
     * for shallow routing purposes.
     */ let route = requestedRoute;
            try {
                var ref, ref10, ref11, ref12;
                const handleCancelled = getCancelledHandler({
                    route,
                    router: _this
                });
                let existingInfo = _this.components[route];
                if (routeProps.shallow && existingInfo && _this.route === route) {
                    return existingInfo;
                }
                if (hasMiddleware) {
                    existingInfo = undefined;
                }
                let cachedRouteInfo = existingInfo && !('initial' in existingInfo) && "development" !== 'development' ? 0 : undefined;
                const isBackground = isQueryUpdating;
                const fetchNextDataParams = {
                    dataHref: _this.pageLoader.getDataHref({
                        href: (0, _formatUrl).formatWithValidation({
                            pathname,
                            query
                        }),
                        skipInterpolation: true,
                        asPath: isNotFound ? '/404' : resolvedAs,
                        locale
                    }),
                    hasMiddleware: true,
                    isServerRender: _this.isSsr,
                    parseJSON: true,
                    inflightCache: isBackground ? _this.sbc : _this.sdc,
                    persistCache: !isPreview,
                    isPrefetch: false,
                    unstable_skipClientCache,
                    isBackground
                };
                let data = isQueryUpdating && !isMiddlewareRewrite ? null : yield withMiddlewareEffects({
                    fetchData: ()=>fetchNextData(fetchNextDataParams),
                    asPath: isNotFound ? '/404' : resolvedAs,
                    locale: locale,
                    router: _this
                }).catch((err)=>{
                    // we don't hard error during query updating
                    // as it's un-necessary and doesn't need to be fatal
                    // unless it is a fallback route and the props can't
                    // be loaded
                    if (isQueryUpdating) {
                        return null;
                    }
                    throw err;
                });
                // when rendering error routes we don't apply middleware
                // effects
                if (data && (pathname === '/_error' || pathname === '/404')) {
                    data.effect = undefined;
                }
                if (isQueryUpdating) {
                    if (!data) {
                        data = {
                            json: self.__NEXT_DATA__.props
                        };
                    } else {
                        data.json = self.__NEXT_DATA__.props;
                    }
                }
                handleCancelled();
                if ((data == null ? void 0 : (ref = data.effect) == null ? void 0 : ref.type) === 'redirect-internal' || (data == null ? void 0 : (ref10 = data.effect) == null ? void 0 : ref10.type) === 'redirect-external') {
                    return data.effect;
                }
                if ((data == null ? void 0 : (ref11 = data.effect) == null ? void 0 : ref11.type) === 'rewrite') {
                    const resolvedRoute = (0, _removeTrailingSlash).removeTrailingSlash(data.effect.resolvedHref);
                    const pages = yield _this.pageLoader.getPageList();
                    // during query updating the page must match although during
                    // client-transition a redirect that doesn't match a page
                    // can be returned and this should trigger a hard navigation
                    // which is valid for incremental migration
                    if (!isQueryUpdating || pages.includes(resolvedRoute)) {
                        route = resolvedRoute;
                        pathname = data.effect.resolvedHref;
                        query = _extends({}, query, data.effect.parsedAs.query);
                        resolvedAs = (0, _removeBasePath).removeBasePath((0, _normalizeLocalePath).normalizeLocalePath(data.effect.parsedAs.pathname, _this.locales).pathname);
                        // Check again the cache with the new destination.
                        existingInfo = _this.components[route];
                        if (routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware) {
                            // If we have a match with the current route due to rewrite,
                            // we can copy the existing information to the rewritten one.
                            // Then, we return the information along with the matched route.
                            return _extends({}, existingInfo, {
                                route
                            });
                        }
                    }
                }
                if ((0, _isApiRoute).isAPIRoute(route)) {
                    handleHardNavigation({
                        url: as,
                        router: _this
                    });
                    return new Promise(()=>{});
                }
                const routeInfo = cachedRouteInfo || (yield _this.fetchComponent(route).then((res)=>({
                        Component: res.page,
                        styleSheets: res.styleSheets,
                        __N_SSG: res.mod.__N_SSG,
                        __N_SSP: res.mod.__N_SSP
                    })));
                if (true) {
                    const { isValidElementType  } = __webpack_require__(/*! next/dist/compiled/react-is */ "../../node_modules/next/dist/compiled/react-is/index.js");
                    if (!isValidElementType(routeInfo.Component)) {
                        throw new Error(`The default export is not a React Component in page: "${pathname}"`);
                    }
                }
                const wasBailedPrefetch = data == null ? void 0 : (ref12 = data.response) == null ? void 0 : ref12.headers.get('x-middleware-skip');
                const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;
                // For non-SSG prefetches that bailed before sending data
                // we clear the cache to fetch full response
                if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {
                    delete _this.sdc[data.dataHref];
                }
                const { props , cacheKey  } = yield _this._getData(_async_to_generator(function*() {
                    if (shouldFetchData) {
                        if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {
                            return {
                                cacheKey: data.cacheKey,
                                props: data.json
                            };
                        }
                        const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this.pageLoader.getDataHref({
                            href: (0, _formatUrl).formatWithValidation({
                                pathname,
                                query
                            }),
                            asPath: resolvedAs,
                            locale
                        });
                        const fetched = yield fetchNextData({
                            dataHref,
                            isServerRender: _this.isSsr,
                            parseJSON: true,
                            inflightCache: wasBailedPrefetch ? {} : _this.sdc,
                            persistCache: !isPreview,
                            isPrefetch: false,
                            unstable_skipClientCache
                        });
                        return {
                            cacheKey: fetched.cacheKey,
                            props: fetched.json || {}
                        };
                    }
                    return {
                        headers: {},
                        props: yield _this.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`
                        {
                            pathname,
                            query,
                            asPath: as,
                            locale,
                            locales: _this.locales,
                            defaultLocale: _this.defaultLocale
                        })
                    };
                }));
                // Only bust the data cache for SSP routes although
                // middleware can skip cache per request with
                // x-middleware-cache: no-cache as well
                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {
                    delete _this.sdc[cacheKey];
                }
                // we kick off a HEAD request in the background
                // when a non-prefetch request is made to signal revalidation
                if (!_this.isPreview && routeInfo.__N_SSG && "development" !== 'development' && 0) {}
                props.pageProps = Object.assign({}, props.pageProps);
                routeInfo.props = props;
                routeInfo.route = route;
                routeInfo.query = query;
                routeInfo.resolvedAs = resolvedAs;
                _this.components[route] = routeInfo;
                return routeInfo;
            } catch (err) {
                return _this.handleRouteInfoError((0, _isError).getProperError(err), pathname, query, as, routeProps);
            }
        })();
    }
    set(state, data, resetScroll) {
        this.state = state;
        return this.sub(data, this.components['/_app'].Component, resetScroll);
    }
    /**
   * Callback to execute before replacing router state
   * @param cb callback to be executed
   */ beforePopState(cb) {
        this._bps = cb;
    }
    onlyAHashChange(as) {
        if (!this.asPath) return false;
        const [oldUrlNoHash, oldHash] = this.asPath.split('#');
        const [newUrlNoHash, newHash] = as.split('#');
        // Makes sure we scroll to the provided hash if the url/hash are the same
        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
            return true;
        }
        // If the urls are change, there's more than a hash change
        if (oldUrlNoHash !== newUrlNoHash) {
            return false;
        }
        // If the hash has changed, then it's a hash only change.
        // This check is necessary to handle both the enter and
        // leave hash === '' cases. The identity case falls through
        // and is treated as a next reload.
        return oldHash !== newHash;
    }
    scrollToHash(as) {
        const [, hash = ''] = as.split('#');
        // Scroll to top if the hash is just `#` with no value or `#top`
        // To mirror browsers
        if (hash === '' || hash === 'top') {
            (0, _handleSmoothScroll).handleSmoothScroll(()=>window.scrollTo(0, 0));
            return;
        }
        // Decode hash to make non-latin anchor works.
        const rawHash = decodeURIComponent(hash);
        // First we check if the element by id is found
        const idEl = document.getElementById(rawHash);
        if (idEl) {
            (0, _handleSmoothScroll).handleSmoothScroll(()=>idEl.scrollIntoView());
            return;
        }
        // If there's no element with the id, we check the `name` property
        // To mirror browsers
        const nameEl = document.getElementsByName(rawHash)[0];
        if (nameEl) {
            (0, _handleSmoothScroll).handleSmoothScroll(()=>nameEl.scrollIntoView());
        }
    }
    urlIsNew(asPath) {
        return this.asPath !== asPath;
    }
    /**
   * Prefetch page code, you may wait for the data during page rendering.
   * This feature only works in production!
   * @param url the href of prefetched page
   * @param asPath the as path of the prefetched page
   */ prefetch(url, asPath = url, options = {}) {
        var _this = this;
        return _async_to_generator(function*() {
            // Prefetch is not supported in development mode because it would trigger on-demand-entries
            if (true) {
                return;
            }
            if (typeof window !== 'undefined' && (0, _isBot).isBot(window.navigator.userAgent)) {
                // No prefetches for bots that render the link since they are typically navigating
                // links via the equivalent of a hard navigation and hence never utilize these
                // prefetches.
                return;
            }
            let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);
            let { pathname , query  } = parsed;
            const originalPathname = pathname;
            if (({}).__NEXT_I18N_SUPPORT) {
                if (options.locale === false) {
                    pathname = (0, _normalizeLocalePath).normalizeLocalePath(pathname, _this.locales).pathname;
                    parsed.pathname = pathname;
                    url = (0, _formatUrl).formatWithValidation(parsed);
                    let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);
                    const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);
                    parsedAs.pathname = localePathResult.pathname;
                    options.locale = localePathResult.detectedLocale || _this.defaultLocale;
                    asPath = (0, _formatUrl).formatWithValidation(parsedAs);
                }
            }
            const pages = yield _this.pageLoader.getPageList();
            let resolvedAs = asPath;
            const locale = typeof options.locale !== 'undefined' ? options.locale || undefined : _this.locale;
            const isMiddlewareMatch = yield matchesMiddleware({
                asPath: asPath,
                locale: locale,
                router: _this
            });
            if (({}).__NEXT_HAS_REWRITES && asPath.startsWith('/')) {
                let rewrites;
                ({ __rewrites: rewrites  } = yield (0, _routeLoader).getClientBuildManifest());
                const rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(asPath, _this.locale), true), pages, rewrites, parsed.query, (p)=>resolveDynamicRoute(p, pages), _this.locales);
                if (rewritesResult.externalDest) {
                    return;
                }
                if (!isMiddlewareMatch) {
                    resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(rewritesResult.asPath), _this.locale);
                }
                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {
                    // if this directly matches a page we need to update the href to
                    // allow the correct page chunk to be loaded
                    pathname = rewritesResult.resolvedHref;
                    parsed.pathname = pathname;
                    if (!isMiddlewareMatch) {
                        url = (0, _formatUrl).formatWithValidation(parsed);
                    }
                }
            }
            parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);
            if ((0, _isDynamic).isDynamicRoute(parsed.pathname)) {
                pathname = parsed.pathname;
                parsed.pathname = pathname;
                Object.assign(query, (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(parsed.pathname))((0, _parsePath).parsePath(asPath).pathname) || {});
                if (!isMiddlewareMatch) {
                    url = (0, _formatUrl).formatWithValidation(parsed);
                }
            }
            const data = ({}).__NEXT_MIDDLEWARE_PREFETCH === 'strict' ? null : yield withMiddlewareEffects({
                fetchData: ()=>fetchNextData({
                        dataHref: _this.pageLoader.getDataHref({
                            href: (0, _formatUrl).formatWithValidation({
                                pathname: originalPathname,
                                query
                            }),
                            skipInterpolation: true,
                            asPath: resolvedAs,
                            locale
                        }),
                        hasMiddleware: true,
                        isServerRender: _this.isSsr,
                        parseJSON: true,
                        inflightCache: _this.sdc,
                        persistCache: !_this.isPreview,
                        isPrefetch: true
                    }),
                asPath: asPath,
                locale: locale,
                router: _this
            });
            /**
     * If there was a rewrite we apply the effects of the rewrite on the
     * current parameters for the prefetch.
     */ if ((data == null ? void 0 : data.effect.type) === 'rewrite') {
                parsed.pathname = data.effect.resolvedHref;
                pathname = data.effect.resolvedHref;
                query = _extends({}, query, data.effect.parsedAs.query);
                resolvedAs = data.effect.parsedAs.pathname;
                url = (0, _formatUrl).formatWithValidation(parsed);
            }
            /**
     * If there is a redirect to an external destination then we don't have
     * to prefetch content as it will be unused.
     */ if ((data == null ? void 0 : data.effect.type) === 'redirect-external') {
                return;
            }
            const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);
            yield Promise.all([
                _this.pageLoader._isSsg(route).then((isSsg)=>{
                    return isSsg ? fetchNextData({
                        dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this.pageLoader.getDataHref({
                            href: url,
                            asPath: resolvedAs,
                            locale: locale
                        }),
                        isServerRender: false,
                        parseJSON: true,
                        inflightCache: _this.sdc,
                        persistCache: !_this.isPreview,
                        isPrefetch: true,
                        unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!({}).__NEXT_OPTIMISTIC_CLIENT_CACHE
                    }).then(()=>false) : false;
                }),
                _this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route), 
            ]);
        })();
    }
    fetchComponent(route) {
        var _this = this;
        return _async_to_generator(function*() {
            const handleCancelled = getCancelledHandler({
                route,
                router: _this
            });
            try {
                const componentResult = yield _this.pageLoader.loadPage(route);
                handleCancelled();
                return componentResult;
            } catch (err) {
                handleCancelled();
                throw err;
            }
        })();
    }
    _getData(fn) {
        let cancelled = false;
        const cancel = ()=>{
            cancelled = true;
        };
        this.clc = cancel;
        return fn().then((data)=>{
            if (cancel === this.clc) {
                this.clc = null;
            }
            if (cancelled) {
                const err = new Error('Loading initial props cancelled');
                err.cancelled = true;
                throw err;
            }
            return data;
        });
    }
    _getFlightData(dataHref) {
        // Do not cache RSC flight response since it's not a static resource
        return fetchNextData({
            dataHref,
            isServerRender: true,
            parseJSON: false,
            inflightCache: this.sdc,
            persistCache: false,
            isPrefetch: false
        }).then(({ text  })=>({
                data: text
            }));
    }
    getInitialProps(Component, ctx) {
        const { Component: App  } = this.components['/_app'];
        const AppTree = this._wrapApp(App);
        ctx.AppTree = AppTree;
        return (0, _utils).loadGetInitialProps(App, {
            AppTree,
            Component,
            router: this,
            ctx
        });
    }
    get route() {
        return this.state.route;
    }
    get pathname() {
        return this.state.pathname;
    }
    get query() {
        return this.state.query;
    }
    get asPath() {
        return this.state.asPath;
    }
    get locale() {
        return this.state.locale;
    }
    get isFallback() {
        return this.state.isFallback;
    }
    get isPreview() {
        return this.state.isPreview;
    }
    constructor(pathname1, query1, as1, { initialProps , pageLoader , App , wrapApp , Component , err , subscription , isFallback , locale , locales , defaultLocale , domainLocales , isPreview  }){
        // Server Data Cache (full data requests)
        this.sdc = {};
        // Server Background Cache (HEAD requests)
        this.sbc = {};
        this.isFirstPopStateEvent = true;
        this._key = createKey();
        this.onPopState = (e)=>{
            const { isFirstPopStateEvent  } = this;
            this.isFirstPopStateEvent = false;
            const state = e.state;
            if (!state) {
                // We get state as undefined for two reasons.
                //  1. With older safari (< 8) and older chrome (< 34)
                //  2. When the URL changed with #
                //
                // In the both cases, we don't need to proceed and change the route.
                // (as it's already changed)
                // But we can simply replace the state with the new changes.
                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
                // So, doing the following for (1) does no harm.
                const { pathname , query  } = this;
                this.changeState('replaceState', (0, _formatUrl).formatWithValidation({
                    pathname: (0, _addBasePath).addBasePath(pathname),
                    query
                }), (0, _utils).getURL());
                return;
            }
            // __NA is used to identify if the history entry can be handled by the app-router.
            if (state.__NA) {
                window.location.reload();
                return;
            }
            if (!state.__N) {
                return;
            }
            // Safari fires popstateevent when reopening the browser.
            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {
                return;
            }
            let forcedScroll;
            const { url , as , options , key  } = state;
            if (({}).__NEXT_SCROLL_RESTORATION) {
                if (manualScrollRestoration) {
                    if (this._key !== key) {
                        // Snapshot current scroll position:
                        try {
                            sessionStorage.setItem('__next_scroll_' + this._key, JSON.stringify({
                                x: self.pageXOffset,
                                y: self.pageYOffset
                            }));
                        } catch (e) {}
                        // Restore old scroll position:
                        try {
                            const v = sessionStorage.getItem('__next_scroll_' + key);
                            forcedScroll = JSON.parse(v);
                        } catch (e1) {
                            forcedScroll = {
                                x: 0,
                                y: 0
                            };
                        }
                    }
                }
            }
            this._key = key;
            const { pathname  } = (0, _parseRelativeUrl).parseRelativeUrl(url);
            // Make sure we don't re-render on initial load,
            // can be caused by navigating back from an external site
            if (this.isSsr && as === (0, _addBasePath).addBasePath(this.asPath) && pathname === (0, _addBasePath).addBasePath(this.pathname)) {
                return;
            }
            // If the downstream application returns falsy, return.
            // They will then be responsible for handling the event.
            if (this._bps && !this._bps(state)) {
                return;
            }
            this.change('replaceState', url, as, Object.assign({}, options, {
                shallow: options.shallow && this._shallow,
                locale: options.locale || this.defaultLocale,
                // @ts-ignore internal value not exposed on types
                _h: 0
            }), forcedScroll);
        };
        // represents the current component key
        const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname1);
        // set up the component cache (by route keys)
        this.components = {};
        // We should not keep the cache, if there's an error
        // Otherwise, this cause issues when when going back and
        // come again to the errored page.
        if (pathname1 !== '/_error') {
            this.components[route] = {
                Component,
                initial: true,
                props: initialProps,
                err,
                __N_SSG: initialProps && initialProps.__N_SSG,
                __N_SSP: initialProps && initialProps.__N_SSP
            };
        }
        this.components['/_app'] = {
            Component: App,
            styleSheets: []
        };
        if (({}).__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {
            const { BloomFilter  } = __webpack_require__(/*! ../../lib/bloom-filter */ "../../node_modules/next/dist/shared/lib/bloom-filter/index.js");
            const staticFilterData = ({}).__NEXT_CLIENT_ROUTER_S_FILTER;
            const dynamicFilterData = ({}).__NEXT_CLIENT_ROUTER_D_FILTER;
            if (staticFilterData == null ? void 0 : staticFilterData.hashes) {
                this._bfl_s = new BloomFilter(staticFilterData.size, staticFilterData.hashes);
                this._bfl_s.import(staticFilterData);
            }
            if (dynamicFilterData == null ? void 0 : dynamicFilterData.hashes) {
                this._bfl_d = new BloomFilter(dynamicFilterData.size, dynamicFilterData.hashes);
                this._bfl_d.import(dynamicFilterData);
            }
        }
        // Backwards compat for Router.router.events
        // TODO: Should be remove the following major version as it was never documented
        this.events = Router.events;
        this.pageLoader = pageLoader;
        // if auto prerendered and dynamic route wait to update asPath
        // until after mount to prevent hydration mismatch
        const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;
        this.basePath = ({}).__NEXT_ROUTER_BASEPATH || '';
        this.sub = subscription;
        this.clc = null;
        this._wrapApp = wrapApp;
        // make sure to ignore extra popState in safari on navigating
        // back from external site
        this.isSsr = true;
        this.isLocaleDomain = false;
        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !({}).__NEXT_HAS_REWRITES);
        if (({}).__NEXT_I18N_SUPPORT) {
            this.locales = locales;
            this.defaultLocale = defaultLocale;
            this.domainLocales = domainLocales;
            this.isLocaleDomain = !!(0, _detectDomainLocale).detectDomainLocale(domainLocales, self.location.hostname);
        }
        this.state = {
            route,
            pathname: pathname1,
            query: query1,
            asPath: autoExportDynamic ? pathname1 : as1,
            isPreview: !!isPreview,
            locale: ({}).__NEXT_I18N_SUPPORT ? locale : undefined,
            isFallback
        };
        this._initialMatchesMiddlewarePromise = Promise.resolve(false);
        if (typeof window !== 'undefined') {
            // make sure "as" doesn't start with double slashes or else it can
            // throw an error as it's considered invalid
            if (!as1.startsWith('//')) {
                // in order for `e.state` to work on the `onpopstate` event
                // we have to register the initial route upon initialization
                const options = {
                    locale
                };
                const asPath = (0, _utils).getURL();
                this._initialMatchesMiddlewarePromise = matchesMiddleware({
                    router: this,
                    locale,
                    asPath
                }).then((matches)=>{
                    options._shouldResolveHref = as1 !== pathname1;
                    this.changeState('replaceState', matches ? asPath : (0, _formatUrl).formatWithValidation({
                        pathname: (0, _addBasePath).addBasePath(pathname1),
                        query: query1
                    }), asPath, options);
                    return matches;
                });
            }
            window.addEventListener('popstate', this.onPopState);
            // enable custom scroll restoration handling when available
            // otherwise fallback to browser's default handling
            if (({}).__NEXT_SCROLL_RESTORATION) {
                if (manualScrollRestoration) {
                    window.history.scrollRestoration = 'manual';
                }
            }
        }
    }
}
Router.events = (0, _mitt).default();
exports["default"] = Router;

//# sourceMappingURL=router.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/add-locale.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/add-locale.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.addLocale = addLocale;
var _addPathPrefix = __webpack_require__(/*! ./add-path-prefix */ "../../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js");
var _pathHasPrefix = __webpack_require__(/*! ./path-has-prefix */ "../../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js");
function addLocale(path, locale, defaultLocale, ignorePrefix) {
    if (locale && locale !== defaultLocale && (ignorePrefix || !(0, _pathHasPrefix).pathHasPrefix(path.toLowerCase(), `/${locale.toLowerCase()}`) && !(0, _pathHasPrefix).pathHasPrefix(path.toLowerCase(), '/api'))) {
        return (0, _addPathPrefix).addPathPrefix(path, `/${locale}`);
    }
    return path;
}

//# sourceMappingURL=add-locale.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.addPathPrefix = addPathPrefix;
var _parsePath = __webpack_require__(/*! ./parse-path */ "../../node_modules/next/dist/shared/lib/router/utils/parse-path.js");
function addPathPrefix(path, prefix) {
    if (!path.startsWith('/') || !prefix) {
        return path;
    }
    const { pathname , query , hash  } = (0, _parsePath).parsePath(path);
    return `${prefix}${pathname}${query}${hash}`;
}

//# sourceMappingURL=add-path-prefix.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.addPathSuffix = addPathSuffix;
var _parsePath = __webpack_require__(/*! ./parse-path */ "../../node_modules/next/dist/shared/lib/router/utils/parse-path.js");
function addPathSuffix(path, suffix) {
    if (!path.startsWith('/') || !suffix) {
        return path;
    }
    const { pathname , query , hash  } = (0, _parsePath).parsePath(path);
    return `${pathname}${suffix}${query}${hash}`;
}

//# sourceMappingURL=add-path-suffix.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/compare-states.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/compare-states.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.compareRouterStates = compareRouterStates;
function compareRouterStates(a, b) {
    const stateKeys = Object.keys(a);
    if (stateKeys.length !== Object.keys(b).length) return false;
    for(let i = stateKeys.length; i--;){
        const key = stateKeys[i];
        if (key === 'query') {
            const queryKeys = Object.keys(a.query);
            if (queryKeys.length !== Object.keys(b.query).length) {
                return false;
            }
            for(let j = queryKeys.length; j--;){
                const queryKey = queryKeys[j];
                if (!b.query.hasOwnProperty(queryKey) || a.query[queryKey] !== b.query[queryKey]) {
                    return false;
                }
            }
        } else if (!b.hasOwnProperty(key) || a[key] !== b[key]) {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=compare-states.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.formatNextPathnameInfo = formatNextPathnameInfo;
var _removeTrailingSlash = __webpack_require__(/*! ./remove-trailing-slash */ "../../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js");
var _addPathPrefix = __webpack_require__(/*! ./add-path-prefix */ "../../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js");
var _addPathSuffix = __webpack_require__(/*! ./add-path-suffix */ "../../node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js");
var _addLocale = __webpack_require__(/*! ./add-locale */ "../../node_modules/next/dist/shared/lib/router/utils/add-locale.js");
function formatNextPathnameInfo(info) {
    let pathname = (0, _addLocale).addLocale(info.pathname, info.locale, info.buildId ? undefined : info.defaultLocale, info.ignorePrefix);
    if (info.buildId || !info.trailingSlash) {
        pathname = (0, _removeTrailingSlash).removeTrailingSlash(pathname);
    }
    if (info.buildId) {
        pathname = (0, _addPathSuffix).addPathSuffix((0, _addPathPrefix).addPathPrefix(pathname, `/_next/data/${info.buildId}`), info.pathname === '/' ? 'index.json' : '.json');
    }
    pathname = (0, _addPathPrefix).addPathPrefix(pathname, info.basePath);
    return !info.buildId && info.trailingSlash ? !pathname.endsWith('/') ? (0, _addPathSuffix).addPathSuffix(pathname, '/') : pathname : (0, _removeTrailingSlash).removeTrailingSlash(pathname);
}

//# sourceMappingURL=format-next-pathname-info.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.formatUrl = formatUrl;
exports.formatWithValidation = formatWithValidation;
exports.urlObjectKeys = void 0;
var _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ "../../node_modules/@swc/helpers/lib/_interop_require_wildcard.js")["default"]);
var querystring = _interop_require_wildcard(__webpack_require__(/*! ./querystring */ "../../node_modules/next/dist/shared/lib/router/utils/querystring.js"));
const slashedProtocols = /https?|ftp|gopher|file/;
function formatUrl(urlObj) {
    let { auth , hostname  } = urlObj;
    let protocol = urlObj.protocol || '';
    let pathname = urlObj.pathname || '';
    let hash = urlObj.hash || '';
    let query = urlObj.query || '';
    let host = false;
    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';
    if (urlObj.host) {
        host = auth + urlObj.host;
    } else if (hostname) {
        host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname);
        if (urlObj.port) {
            host += ':' + urlObj.port;
        }
    }
    if (query && typeof query === 'object') {
        query = String(querystring.urlQueryToSearchParams(query));
    }
    let search = urlObj.search || query && `?${query}` || '';
    if (protocol && !protocol.endsWith(':')) protocol += ':';
    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
    } else if (!host) {
        host = '';
    }
    if (hash && hash[0] !== '#') hash = '#' + hash;
    if (search && search[0] !== '?') search = '?' + search;
    pathname = pathname.replace(/[?#]/g, encodeURIComponent);
    search = search.replace('#', '%23');
    return `${protocol}${host}${pathname}${search}${hash}`;
}
const urlObjectKeys = [
    'auth',
    'hash',
    'host',
    'hostname',
    'href',
    'path',
    'pathname',
    'port',
    'protocol',
    'query',
    'search',
    'slashes', 
];
exports.urlObjectKeys = urlObjectKeys;
function formatWithValidation(url) {
    if (true) {
        if (url !== null && typeof url === 'object') {
            Object.keys(url).forEach((key)=>{
                if (urlObjectKeys.indexOf(key) === -1) {
                    console.warn(`Unknown key passed via urlObject into url.format: ${key}`);
                }
            });
        }
    }
    return formatUrl(url);
}

//# sourceMappingURL=format-url.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = getAssetPathFromRoute;
function getAssetPathFromRoute(route, ext = '') {
    const path = route === '/' ? '/index' : /^\/index(\/|$)/.test(route) ? `/index${route}` : `${route}`;
    return path + ext;
}

//# sourceMappingURL=get-asset-path-from-route.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getNextPathnameInfo = getNextPathnameInfo;
var _normalizeLocalePath = __webpack_require__(/*! ../../i18n/normalize-locale-path */ "../../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js");
var _removePathPrefix = __webpack_require__(/*! ./remove-path-prefix */ "../../node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js");
var _pathHasPrefix = __webpack_require__(/*! ./path-has-prefix */ "../../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js");
function getNextPathnameInfo(pathname, options) {
    var _nextConfig;
    const { basePath , i18n , trailingSlash  } = (_nextConfig = options.nextConfig) != null ? _nextConfig : {};
    const info = {
        pathname: pathname,
        trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash
    };
    if (basePath && (0, _pathHasPrefix).pathHasPrefix(info.pathname, basePath)) {
        info.pathname = (0, _removePathPrefix).removePathPrefix(info.pathname, basePath);
        info.basePath = basePath;
    }
    if (options.parseData === true && info.pathname.startsWith('/_next/data/') && info.pathname.endsWith('.json')) {
        const paths = info.pathname.replace(/^\/_next\/data\//, '').replace(/\.json$/, '').split('/');
        const buildId = paths[0];
        info.pathname = paths[1] !== 'index' ? `/${paths.slice(1).join('/')}` : '/';
        info.buildId = buildId;
    }
    if (i18n) {
        const pathLocale = (0, _normalizeLocalePath).normalizeLocalePath(info.pathname, i18n.locales);
        info.locale = pathLocale == null ? void 0 : pathLocale.detectedLocale;
        info.pathname = (pathLocale == null ? void 0 : pathLocale.pathname) || info.pathname;
    }
    return info;
}

//# sourceMappingURL=get-next-pathname-info.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.handleSmoothScroll = handleSmoothScroll;
function handleSmoothScroll(fn, options = {}) {
    const htmlElement = document.documentElement;
    const existing = htmlElement.style.scrollBehavior;
    htmlElement.style.scrollBehavior = 'auto';
    if (!options.dontForceLayout) {
        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.
        // Otherwise it will not pickup the change in scrollBehavior
        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042
        htmlElement.getClientRects();
    }
    fn();
    htmlElement.style.scrollBehavior = existing;
}

//# sourceMappingURL=handle-smooth-scroll.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/index.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getSortedRoutes", ({
    enumerable: true,
    get: function() {
        return _sortedRoutes.getSortedRoutes;
    }
}));
Object.defineProperty(exports, "isDynamicRoute", ({
    enumerable: true,
    get: function() {
        return _isDynamic.isDynamicRoute;
    }
}));
var _sortedRoutes = __webpack_require__(/*! ./sorted-routes */ "../../node_modules/next/dist/shared/lib/router/utils/sorted-routes.js");
var _isDynamic = __webpack_require__(/*! ./is-dynamic */ "../../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js");

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.interpolateAs = interpolateAs;
var _routeMatcher = __webpack_require__(/*! ./route-matcher */ "../../node_modules/next/dist/shared/lib/router/utils/route-matcher.js");
var _routeRegex = __webpack_require__(/*! ./route-regex */ "../../node_modules/next/dist/shared/lib/router/utils/route-regex.js");
function interpolateAs(route, asPathname, query) {
    let interpolatedRoute = '';
    const dynamicRegex = (0, _routeRegex).getRouteRegex(route);
    const dynamicGroups = dynamicRegex.groups;
    const dynamicMatches = // Try to match the dynamic route against the asPath
    (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
    // TODO: should this take priority; also need to change in the router.
    query;
    interpolatedRoute = route;
    const params = Object.keys(dynamicGroups);
    if (!params.every((param)=>{
        let value = dynamicMatches[param] || '';
        const { repeat , optional  } = dynamicGroups[param];
        // support single-level catch-all
        // TODO: more robust handling for user-error (passing `/`)
        let replaced = `[${repeat ? '...' : ''}${param}]`;
        if (optional) {
            replaced = `${!value ? '/' : ''}[${replaced}]`;
        }
        if (repeat && !Array.isArray(value)) value = [
            value
        ];
        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present
        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// these values should be fully encoded instead of just
        // path delimiter escaped since they are being inserted
        // into the URL and we expect URL encoded segments
        // when parsing dynamic route params
        (segment)=>encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');
    })) {
        interpolatedRoute = '' // did not satisfy all requirements
        ;
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
    }
    return {
        params,
        result: interpolatedRoute
    };
}

//# sourceMappingURL=interpolate-as.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/is-bot.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/is-bot.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isBot = isBot;
function isBot(userAgent) {
    return /Googlebot|Mediapartners-Google|AdsBot-Google|googleweblight|Storebot-Google|Google-PageRenderer|Bingbot|BingPreview|Slurp|DuckDuckBot|baiduspider|yandex|sogou|LinkedInBot|bitlybot|tumblr|vkShare|quora link preview|facebookexternalhit|facebookcatalog|Twitterbot|applebot|redditbot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|ia_archiver/i.test(userAgent);
}

//# sourceMappingURL=is-bot.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isDynamicRoute = isDynamicRoute;
// Identify /[param]/ in route string
const TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;
function isDynamicRoute(route) {
    return TEST_ROUTE.test(route);
}

//# sourceMappingURL=is-dynamic.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isLocalURL = isLocalURL;
var _utils = __webpack_require__(/*! ../../utils */ "../../node_modules/next/dist/shared/lib/utils.js");
var _hasBasePath = __webpack_require__(/*! ../../../../client/has-base-path */ "../../node_modules/next/dist/client/has-base-path.js");
function isLocalURL(url) {
    // prevent a hydration mismatch on href for url with anchor refs
    if (!(0, _utils).isAbsoluteUrl(url)) return true;
    try {
        // absolute urls can be local if they are on the same origin
        const locationOrigin = (0, _utils).getLocationOrigin();
        const resolved = new URL(url, locationOrigin);
        return resolved.origin === locationOrigin && (0, _hasBasePath).hasBasePath(resolved.pathname);
    } catch (_) {
        return false;
    }
}

//# sourceMappingURL=is-local-url.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/omit.js":
/*!********************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/omit.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.omit = omit;
function omit(object, keys) {
    const omitted = {};
    Object.keys(object).forEach((key)=>{
        if (!keys.includes(key)) {
            omitted[key] = object[key];
        }
    });
    return omitted;
}

//# sourceMappingURL=omit.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseRelativeUrl = parseRelativeUrl;
var _utils = __webpack_require__(/*! ../../utils */ "../../node_modules/next/dist/shared/lib/utils.js");
var _querystring = __webpack_require__(/*! ./querystring */ "../../node_modules/next/dist/shared/lib/router/utils/querystring.js");
function parseRelativeUrl(url, base) {
    const globalBase = new URL(typeof window === 'undefined' ? 'http://n' : (0, _utils).getLocationOrigin());
    const resolvedBase = base ? new URL(base, globalBase) : url.startsWith('.') ? new URL(typeof window === 'undefined' ? 'http://n' : window.location.href) : globalBase;
    const { pathname , searchParams , search , hash , href , origin  } = new URL(url, resolvedBase);
    if (origin !== globalBase.origin) {
        throw new Error(`invariant: invalid relative URL, router received ${url}`);
    }
    return {
        pathname,
        query: (0, _querystring).searchParamsToUrlQuery(searchParams),
        search,
        hash,
        href: href.slice(globalBase.origin.length)
    };
}

//# sourceMappingURL=parse-relative-url.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/parse-url.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/parse-url.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseUrl = parseUrl;
var _querystring = __webpack_require__(/*! ./querystring */ "../../node_modules/next/dist/shared/lib/router/utils/querystring.js");
var _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ "../../node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js");
function parseUrl(url) {
    if (url.startsWith('/')) {
        return (0, _parseRelativeUrl).parseRelativeUrl(url);
    }
    const parsedURL = new URL(url);
    return {
        hash: parsedURL.hash,
        hostname: parsedURL.hostname,
        href: parsedURL.href,
        pathname: parsedURL.pathname,
        port: parsedURL.port,
        protocol: parsedURL.protocol,
        query: (0, _querystring).searchParamsToUrlQuery(parsedURL.searchParams),
        search: parsedURL.search
    };
}

//# sourceMappingURL=parse-url.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.pathHasPrefix = pathHasPrefix;
var _parsePath = __webpack_require__(/*! ./parse-path */ "../../node_modules/next/dist/shared/lib/router/utils/parse-path.js");
function pathHasPrefix(path, prefix) {
    if (typeof path !== 'string') {
        return false;
    }
    const { pathname  } = (0, _parsePath).parsePath(path);
    return pathname === prefix || pathname.startsWith(prefix + '/');
}

//# sourceMappingURL=path-has-prefix.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/path-match.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/path-match.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getPathMatch = getPathMatch;
var _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ "../../node_modules/@swc/helpers/lib/_extends.js")["default"]);
var _pathToRegexp = __webpack_require__(/*! next/dist/compiled/path-to-regexp */ "../../node_modules/next/dist/compiled/path-to-regexp/index.js");
function getPathMatch(path, options) {
    const keys = [];
    const regexp = (0, _pathToRegexp).pathToRegexp(path, keys, {
        delimiter: '/',
        sensitive: false,
        strict: options == null ? void 0 : options.strict
    });
    const matcher = (0, _pathToRegexp).regexpToFunction((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);
    /**
   * A matcher function that will check if a given pathname matches the path
   * given in the builder function. When the path does not match it will return
   * `false` but if it does it will return an object with the matched params
   * merged with the params provided in the second argument.
   */ return (pathname, params)=>{
        const res = pathname == null ? false : matcher(pathname);
        if (!res) {
            return false;
        }
        /**
     * If unnamed params are not allowed they must be removed from
     * the matched parameters. path-to-regexp uses "string" for named and
     * "number" for unnamed parameters.
     */ if (options == null ? void 0 : options.removeUnnamedParams) {
            for (const key of keys){
                if (typeof key.name === 'number') {
                    delete res.params[key.name];
                }
            }
        }
        return _extends({}, params, res.params);
    };
}

//# sourceMappingURL=path-match.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/prepare-destination.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/prepare-destination.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.matchHas = matchHas;
exports.compileNonPath = compileNonPath;
exports.prepareDestination = prepareDestination;
var _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ "../../node_modules/@swc/helpers/lib/_extends.js")["default"]);
var _pathToRegexp = __webpack_require__(/*! next/dist/compiled/path-to-regexp */ "../../node_modules/next/dist/compiled/path-to-regexp/index.js");
var _escapeRegexp = __webpack_require__(/*! ../../escape-regexp */ "../../node_modules/next/dist/shared/lib/escape-regexp.js");
var _parseUrl = __webpack_require__(/*! ./parse-url */ "../../node_modules/next/dist/shared/lib/router/utils/parse-url.js");
/**
 * Ensure only a-zA-Z are used for param names for proper interpolating
 * with path-to-regexp
 */ function getSafeParamName(paramName) {
    let newParamName = '';
    for(let i = 0; i < paramName.length; i++){
        const charCode = paramName.charCodeAt(i);
        if (charCode > 64 && charCode < 91 || charCode > 96 && charCode < 123 // a-z
        ) {
            newParamName += paramName[i];
        }
    }
    return newParamName;
}
function escapeSegment(str, segmentName) {
    return str.replace(new RegExp(`:${(0, _escapeRegexp).escapeStringRegexp(segmentName)}`, 'g'), `__ESC_COLON_${segmentName}`);
}
function unescapeSegments(str) {
    return str.replace(/__ESC_COLON_/gi, ':');
}
function matchHas(req, query, has = [], missing = []) {
    const params = {};
    const hasMatch = (hasItem)=>{
        let value;
        let key = hasItem.key;
        switch(hasItem.type){
            case 'header':
                {
                    key = key.toLowerCase();
                    value = req.headers[key];
                    break;
                }
            case 'cookie':
                {
                    value = req.cookies[hasItem.key];
                    break;
                }
            case 'query':
                {
                    value = query[key];
                    break;
                }
            case 'host':
                {
                    const { host  } = (req == null ? void 0 : req.headers) || {};
                    // remove port from host if present
                    const hostname = host == null ? void 0 : host.split(':')[0].toLowerCase();
                    value = hostname;
                    break;
                }
            default:
                {
                    break;
                }
        }
        if (!hasItem.value && value) {
            params[getSafeParamName(key)] = value;
            return true;
        } else if (value) {
            const matcher = new RegExp(`^${hasItem.value}$`);
            const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);
            if (matches) {
                if (Array.isArray(matches)) {
                    if (matches.groups) {
                        Object.keys(matches.groups).forEach((groupKey)=>{
                            params[groupKey] = matches.groups[groupKey];
                        });
                    } else if (hasItem.type === 'host' && matches[0]) {
                        params.host = matches[0];
                    }
                }
                return true;
            }
        }
        return false;
    };
    const allMatch = has.every((item)=>hasMatch(item)) && !missing.some((item)=>hasMatch(item));
    if (allMatch) {
        return params;
    }
    return false;
}
function compileNonPath(value, params) {
    if (!value.includes(':')) {
        return value;
    }
    for (const key of Object.keys(params)){
        if (value.includes(`:${key}`)) {
            value = value.replace(new RegExp(`:${key}\\*`, 'g'), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\?`, 'g'), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\w)`, 'g'), `--ESCAPED_PARAM_COLON${key}`);
        }
    }
    value = value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, '\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*');
    // the value needs to start with a forward-slash to be compiled
    // correctly
    return (0, _pathToRegexp).compile(`/${value}`, {
        validate: false
    })(params).slice(1);
}
function prepareDestination(args) {
    const query = Object.assign({}, args.query);
    delete query.__nextLocale;
    delete query.__nextDefaultLocale;
    delete query.__nextDataReq;
    let escapedDestination = args.destination;
    for (const param of Object.keys(_extends({}, args.params, query))){
        escapedDestination = escapeSegment(escapedDestination, param);
    }
    const parsedDestination = (0, _parseUrl).parseUrl(escapedDestination);
    const destQuery = parsedDestination.query;
    const destPath = unescapeSegments(`${parsedDestination.pathname}${parsedDestination.hash || ''}`);
    const destHostname = unescapeSegments(parsedDestination.hostname || '');
    const destPathParamKeys = [];
    const destHostnameParamKeys = [];
    (0, _pathToRegexp).pathToRegexp(destPath, destPathParamKeys);
    (0, _pathToRegexp).pathToRegexp(destHostname, destHostnameParamKeys);
    const destParams = [];
    destPathParamKeys.forEach((key)=>destParams.push(key.name));
    destHostnameParamKeys.forEach((key)=>destParams.push(key.name));
    const destPathCompiler = (0, _pathToRegexp).compile(destPath, // we don't validate while compiling the destination since we should
    // have already validated before we got to this point and validating
    // breaks compiling destinations with named pattern params from the source
    // e.g. /something:hello(.*) -> /another/:hello is broken with validation
    // since compile validation is meant for reversing and not for inserting
    // params from a separate path-regex into another
    {
        validate: false
    });
    const destHostnameCompiler = (0, _pathToRegexp).compile(destHostname, {
        validate: false
    });
    // update any params in query values
    for (const [key1, strOrArray] of Object.entries(destQuery)){
        // the value needs to start with a forward-slash to be compiled
        // correctly
        if (Array.isArray(strOrArray)) {
            destQuery[key1] = strOrArray.map((value)=>compileNonPath(unescapeSegments(value), args.params));
        } else if (typeof strOrArray === 'string') {
            destQuery[key1] = compileNonPath(unescapeSegments(strOrArray), args.params);
        }
    }
    // add path params to query if it's not a redirect and not
    // already defined in destination query or path
    let paramKeys = Object.keys(args.params).filter((name)=>name !== 'nextInternalLocale');
    if (args.appendParamsToQuery && !paramKeys.some((key)=>destParams.includes(key))) {
        for (const key of paramKeys){
            if (!(key in destQuery)) {
                destQuery[key] = args.params[key];
            }
        }
    }
    let newUrl;
    try {
        newUrl = destPathCompiler(args.params);
        const [pathname, hash] = newUrl.split('#');
        parsedDestination.hostname = destHostnameCompiler(args.params);
        parsedDestination.pathname = pathname;
        parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;
        delete parsedDestination.search;
    } catch (err) {
        if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
            throw new Error(`To use a multi-match in the destination you must add \`*\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`);
        }
        throw err;
    }
    // Query merge order lowest priority to highest
    // 1. initial URL query values
    // 2. path segment values
    // 3. destination specified query values
    parsedDestination.query = _extends({}, query, parsedDestination.query);
    return {
        newUrl,
        destQuery,
        parsedDestination
    };
}

//# sourceMappingURL=prepare-destination.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;
function searchParamsToUrlQuery(searchParams) {
    const query = {};
    searchParams.forEach((value, key)=>{
        if (typeof query[key] === 'undefined') {
            query[key] = value;
        } else if (Array.isArray(query[key])) {
            query[key].push(value);
        } else {
            query[key] = [
                query[key],
                value
            ];
        }
    });
    return query;
}
function stringifyUrlQueryParam(param) {
    if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
        return String(param);
    } else {
        return '';
    }
}
function urlQueryToSearchParams(urlQuery) {
    const result = new URLSearchParams();
    Object.entries(urlQuery).forEach(([key, value])=>{
        if (Array.isArray(value)) {
            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));
        } else {
            result.set(key, stringifyUrlQueryParam(value));
        }
    });
    return result;
}
function assign(target, ...searchParamsList) {
    searchParamsList.forEach((searchParams)=>{
        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));
        searchParams.forEach((value, key)=>target.append(key, value));
    });
    return target;
}

//# sourceMappingURL=querystring.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.removePathPrefix = removePathPrefix;
var _pathHasPrefix = __webpack_require__(/*! ./path-has-prefix */ "../../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js");
function removePathPrefix(path, prefix) {
    if ((0, _pathHasPrefix).pathHasPrefix(path, prefix)) {
        const withoutPrefix = path.slice(prefix.length);
        return withoutPrefix.startsWith('/') ? withoutPrefix : `/${withoutPrefix}`;
    }
    return path;
}

//# sourceMappingURL=remove-path-prefix.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/resolve-href.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/resolve-href.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveHref = resolveHref;
var _querystring = __webpack_require__(/*! ./querystring */ "../../node_modules/next/dist/shared/lib/router/utils/querystring.js");
var _formatUrl = __webpack_require__(/*! ./format-url */ "../../node_modules/next/dist/shared/lib/router/utils/format-url.js");
var _omit = __webpack_require__(/*! ./omit */ "../../node_modules/next/dist/shared/lib/router/utils/omit.js");
var _utils = __webpack_require__(/*! ../../utils */ "../../node_modules/next/dist/shared/lib/utils.js");
var _normalizeTrailingSlash = __webpack_require__(/*! ../../../../client/normalize-trailing-slash */ "../../node_modules/next/dist/client/normalize-trailing-slash.js");
var _isLocalUrl = __webpack_require__(/*! ./is-local-url */ "../../node_modules/next/dist/shared/lib/router/utils/is-local-url.js");
var _isDynamic = __webpack_require__(/*! ./is-dynamic */ "../../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js");
var _interpolateAs = __webpack_require__(/*! ./interpolate-as */ "../../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js");
function resolveHref(router, href, resolveAs) {
    // we use a dummy base url for relative urls
    let base;
    let urlAsString = typeof href === 'string' ? href : (0, _formatUrl).formatWithValidation(href);
    // repeated slashes and backslashes in the URL are considered
    // invalid and will never match a Next.js page/file
    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\/\//);
    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;
    const urlParts = urlAsStringNoProto.split('?');
    if ((urlParts[0] || '').match(/(\/\/|\\)/)) {
        console.error(`Invalid href '${urlAsString}' passed to next/router in page: '${router.pathname}'. Repeated forward-slashes (//) or backslashes \\ are not valid in the href.`);
        const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);
        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;
    }
    // Return because it cannot be routed by the Next.js router
    if (!(0, _isLocalUrl).isLocalURL(urlAsString)) {
        return resolveAs ? [
            urlAsString
        ] : urlAsString;
    }
    try {
        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');
    } catch (_) {
        // fallback to / for invalid asPath values e.g. //
        base = new URL('/', 'http://n');
    }
    try {
        const finalUrl = new URL(urlAsString, base);
        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);
        let interpolatedAs = '';
        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
            const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);
            const { result , params  } = (0, _interpolateAs).interpolateAs(finalUrl.pathname, finalUrl.pathname, query);
            if (result) {
                interpolatedAs = (0, _formatUrl).formatWithValidation({
                    pathname: result,
                    hash: finalUrl.hash,
                    query: (0, _omit).omit(query, params)
                });
            }
        }
        // if the origin didn't change, it means we received a relative href
        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
        return resolveAs ? [
            resolvedHref,
            interpolatedAs || resolvedHref
        ] : resolvedHref;
    } catch (_1) {
        return resolveAs ? [
            urlAsString
        ] : urlAsString;
    }
}

//# sourceMappingURL=resolve-href.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = resolveRewrites;
var _pathMatch = __webpack_require__(/*! ./path-match */ "../../node_modules/next/dist/shared/lib/router/utils/path-match.js");
var _prepareDestination = __webpack_require__(/*! ./prepare-destination */ "../../node_modules/next/dist/shared/lib/router/utils/prepare-destination.js");
var _removeTrailingSlash = __webpack_require__(/*! ./remove-trailing-slash */ "../../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js");
var _normalizeLocalePath = __webpack_require__(/*! ../../i18n/normalize-locale-path */ "../../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js");
var _removeBasePath = __webpack_require__(/*! ../../../../client/remove-base-path */ "../../node_modules/next/dist/client/remove-base-path.js");
var _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ "../../node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js");
function resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {
    let matchedPage = false;
    let externalDest = false;
    let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);
    let fsPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedAs.pathname), locales).pathname);
    let resolvedHref;
    const handleRewrite = (rewrite)=>{
        const matcher = (0, _pathMatch).getPathMatch(rewrite.source + (({}).__NEXT_TRAILING_SLASH ? '(/)?' : ''), {
            removeUnnamedParams: true,
            strict: true
        });
        let params = matcher(parsedAs.pathname);
        if ((rewrite.has || rewrite.missing) && params) {
            const hasParams = (0, _prepareDestination).matchHas({
                headers: {
                    host: document.location.hostname
                },
                cookies: document.cookie.split('; ').reduce((acc, item)=>{
                    const [key, ...value] = item.split('=');
                    acc[key] = value.join('=');
                    return acc;
                }, {})
            }, parsedAs.query, rewrite.has, rewrite.missing);
            if (hasParams) {
                Object.assign(params, hasParams);
            } else {
                params = false;
            }
        }
        if (params) {
            if (!rewrite.destination) {
                // this is a proxied rewrite which isn't handled on the client
                externalDest = true;
                return true;
            }
            const destRes = (0, _prepareDestination).prepareDestination({
                appendParamsToQuery: true,
                destination: rewrite.destination,
                params: params,
                query: query
            });
            parsedAs = destRes.parsedDestination;
            asPath = destRes.newUrl;
            Object.assign(query, destRes.parsedDestination.query);
            fsPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(asPath), locales).pathname);
            if (pages.includes(fsPathname)) {
                // check if we now match a page as this means we are done
                // resolving the rewrites
                matchedPage = true;
                resolvedHref = fsPathname;
                return true;
            }
            // check if we match a dynamic-route, if so we break the rewrites chain
            resolvedHref = resolveHref(fsPathname);
            if (resolvedHref !== asPath && pages.includes(resolvedHref)) {
                matchedPage = true;
                return true;
            }
        }
    };
    let finished = false;
    for(let i = 0; i < rewrites.beforeFiles.length; i++){
        // we don't end after match in beforeFiles to allow
        // continuing through all beforeFiles rewrites
        handleRewrite(rewrites.beforeFiles[i]);
    }
    matchedPage = pages.includes(fsPathname);
    if (!matchedPage) {
        if (!finished) {
            for(let i = 0; i < rewrites.afterFiles.length; i++){
                if (handleRewrite(rewrites.afterFiles[i])) {
                    finished = true;
                    break;
                }
            }
        }
        // check dynamic route before processing fallback rewrites
        if (!finished) {
            resolvedHref = resolveHref(fsPathname);
            matchedPage = pages.includes(resolvedHref);
            finished = matchedPage;
        }
        if (!finished) {
            for(let i = 0; i < rewrites.fallback.length; i++){
                if (handleRewrite(rewrites.fallback[i])) {
                    finished = true;
                    break;
                }
            }
        }
    }
    return {
        asPath,
        parsedAs,
        matchedPage,
        resolvedHref,
        externalDest
    };
}

//# sourceMappingURL=resolve-rewrites.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getRouteMatcher = getRouteMatcher;
var _utils = __webpack_require__(/*! ../../utils */ "../../node_modules/next/dist/shared/lib/utils.js");
function getRouteMatcher({ re , groups  }) {
    return (pathname)=>{
        const routeMatch = re.exec(pathname);
        if (!routeMatch) {
            return false;
        }
        const decode = (param)=>{
            try {
                return decodeURIComponent(param);
            } catch (_) {
                throw new _utils.DecodeError('failed to decode param');
            }
        };
        const params = {};
        Object.keys(groups).forEach((slugName)=>{
            const g = groups[slugName];
            const m = routeMatch[g.pos];
            if (m !== undefined) {
                params[slugName] = ~m.indexOf('/') ? m.split('/').map((entry)=>decode(entry)) : g.repeat ? [
                    decode(m)
                ] : decode(m);
            }
        });
        return params;
    };
}

//# sourceMappingURL=route-matcher.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getRouteRegex = getRouteRegex;
exports.getNamedRouteRegex = getNamedRouteRegex;
exports.getNamedMiddlewareRegex = getNamedMiddlewareRegex;
var _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ "../../node_modules/@swc/helpers/lib/_extends.js")["default"]);
var _escapeRegexp = __webpack_require__(/*! ../../escape-regexp */ "../../node_modules/next/dist/shared/lib/escape-regexp.js");
var _removeTrailingSlash = __webpack_require__(/*! ./remove-trailing-slash */ "../../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js");
/**
 * Parses a given parameter from a route to a data structure that can be used
 * to generate the parametrized route. Examples:
 *   - `[...slug]` -> `{ name: 'slug', repeat: true, optional: true }`
 *   - `[foo]` -> `{ name: 'foo', repeat: false, optional: true }`
 *   - `bar` -> `{ name: 'bar', repeat: false, optional: false }`
 */ function parseParameter(param) {
    const optional = param.startsWith('[') && param.endsWith(']');
    if (optional) {
        param = param.slice(1, -1);
    }
    const repeat = param.startsWith('...');
    if (repeat) {
        param = param.slice(3);
    }
    return {
        key: param,
        repeat,
        optional
    };
}
function getParametrizedRoute(route) {
    const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');
    const groups = {};
    let groupIndex = 1;
    return {
        parameterizedRoute: segments.map((segment)=>{
            if (segment.startsWith('[') && segment.endsWith(']')) {
                const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));
                groups[key] = {
                    pos: groupIndex++,
                    repeat,
                    optional
                };
                return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
            } else {
                return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;
            }
        }).join(''),
        groups
    };
}
function getRouteRegex(normalizedRoute) {
    const { parameterizedRoute , groups  } = getParametrizedRoute(normalizedRoute);
    return {
        re: new RegExp(`^${parameterizedRoute}(?:/)?$`),
        groups: groups
    };
}
/**
 * Builds a function to generate a minimal routeKey using only a-z and minimal
 * number of characters.
 */ function buildGetSafeRouteKey() {
    let routeKeyCharCode = 97;
    let routeKeyCharLength = 1;
    return ()=>{
        let routeKey = '';
        for(let i = 0; i < routeKeyCharLength; i++){
            routeKey += String.fromCharCode(routeKeyCharCode);
            routeKeyCharCode++;
            if (routeKeyCharCode > 122) {
                routeKeyCharLength++;
                routeKeyCharCode = 97;
            }
        }
        return routeKey;
    };
}
function getNamedParametrizedRoute(route) {
    const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split('/');
    const getSafeRouteKey = buildGetSafeRouteKey();
    const routeKeys = {};
    return {
        namedParameterizedRoute: segments.map((segment)=>{
            if (segment.startsWith('[') && segment.endsWith(']')) {
                const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));
                // replace any non-word characters since they can break
                // the named regex
                let cleanedKey = key.replace(/\W/g, '');
                let invalidKey = false;
                // check if the key is still invalid and fallback to using a known
                // safe key
                if (cleanedKey.length === 0 || cleanedKey.length > 30) {
                    invalidKey = true;
                }
                if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {
                    invalidKey = true;
                }
                if (invalidKey) {
                    cleanedKey = getSafeRouteKey();
                }
                routeKeys[cleanedKey] = key;
                return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;
            } else {
                return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;
            }
        }).join(''),
        routeKeys
    };
}
function getNamedRouteRegex(normalizedRoute) {
    const result = getNamedParametrizedRoute(normalizedRoute);
    return _extends({}, getRouteRegex(normalizedRoute), {
        namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`,
        routeKeys: result.routeKeys
    });
}
function getNamedMiddlewareRegex(normalizedRoute, options) {
    const { parameterizedRoute  } = getParametrizedRoute(normalizedRoute);
    const { catchAll =true  } = options;
    if (parameterizedRoute === '/') {
        let catchAllRegex = catchAll ? '.*' : '';
        return {
            namedRegex: `^/${catchAllRegex}$`
        };
    }
    const { namedParameterizedRoute  } = getNamedParametrizedRoute(normalizedRoute);
    let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';
    return {
        namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`
    };
}

//# sourceMappingURL=route-regex.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getSortedRoutes = getSortedRoutes;
class UrlNode {
    insert(urlPath) {
        this._insert(urlPath.split('/').filter(Boolean), [], false);
    }
    smoosh() {
        return this._smoosh();
    }
    _smoosh(prefix = '/') {
        const childrenPaths = [
            ...this.children.keys()
        ].sort();
        if (this.slugName !== null) {
            childrenPaths.splice(childrenPaths.indexOf('[]'), 1);
        }
        if (this.restSlugName !== null) {
            childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);
        }
        if (this.optionalRestSlugName !== null) {
            childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1);
        }
        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(`${prefix}${c}/`)).reduce((prev, curr)=>[
                ...prev,
                ...curr
            ], []);
        if (this.slugName !== null) {
            routes.push(...this.children.get('[]')._smoosh(`${prefix}[${this.slugName}]/`));
        }
        if (!this.placeholder) {
            const r = prefix === '/' ? '/' : prefix.slice(0, -1);
            if (this.optionalRestSlugName != null) {
                throw new Error(`You cannot define a route with the same specificity as a optional catch-all route ("${r}" and "${r}[[...${this.optionalRestSlugName}]]").`);
            }
            routes.unshift(r);
        }
        if (this.restSlugName !== null) {
            routes.push(...this.children.get('[...]')._smoosh(`${prefix}[...${this.restSlugName}]/`));
        }
        if (this.optionalRestSlugName !== null) {
            routes.push(...this.children.get('[[...]]')._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`));
        }
        return routes;
    }
    _insert(urlPaths, slugNames, isCatchAll) {
        if (urlPaths.length === 0) {
            this.placeholder = false;
            return;
        }
        if (isCatchAll) {
            throw new Error(`Catch-all must be the last part of the URL.`);
        }
        // The next segment in the urlPaths list
        let nextSegment = urlPaths[0];
        // Check if the segment matches `[something]`
        if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {
            // Strip `[` and `]`, leaving only `something`
            let segmentName = nextSegment.slice(1, -1);
            let isOptional = false;
            if (segmentName.startsWith('[') && segmentName.endsWith(']')) {
                // Strip optional `[` and `]`, leaving only `something`
                segmentName = segmentName.slice(1, -1);
                isOptional = true;
            }
            if (segmentName.startsWith('...')) {
                // Strip `...`, leaving only `something`
                segmentName = segmentName.substring(3);
                isCatchAll = true;
            }
            if (segmentName.startsWith('[') || segmentName.endsWith(']')) {
                throw new Error(`Segment names may not start or end with extra brackets ('${segmentName}').`);
            }
            if (segmentName.startsWith('.')) {
                throw new Error(`Segment names may not start with erroneous periods ('${segmentName}').`);
            }
            function handleSlug(previousSlug, nextSlug) {
                if (previousSlug !== null) {
                    // If the specific segment already has a slug but the slug is not `something`
                    // This prevents collisions like:
                    // pages/[post]/index.js
                    // pages/[id]/index.js
                    // Because currently multiple dynamic params on the same segment level are not supported
                    if (previousSlug !== nextSlug) {
                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.
                        throw new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`);
                    }
                }
                slugNames.forEach((slug)=>{
                    if (slug === nextSlug) {
                        throw new Error(`You cannot have the same slug name "${nextSlug}" repeat within a single dynamic path`);
                    }
                    if (slug.replace(/\W/g, '') === nextSegment.replace(/\W/g, '')) {
                        throw new Error(`You cannot have the slug names "${slug}" and "${nextSlug}" differ only by non-word symbols within a single dynamic path`);
                    }
                });
                slugNames.push(nextSlug);
            }
            if (isCatchAll) {
                if (isOptional) {
                    if (this.restSlugName != null) {
                        throw new Error(`You cannot use both an required and optional catch-all route at the same level ("[...${this.restSlugName}]" and "${urlPaths[0]}" ).`);
                    }
                    handleSlug(this.optionalRestSlugName, segmentName);
                    // slugName is kept as it can only be one particular slugName
                    this.optionalRestSlugName = segmentName;
                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically
                    nextSegment = '[[...]]';
                } else {
                    if (this.optionalRestSlugName != null) {
                        throw new Error(`You cannot use both an optional and required catch-all route at the same level ("[[...${this.optionalRestSlugName}]]" and "${urlPaths[0]}").`);
                    }
                    handleSlug(this.restSlugName, segmentName);
                    // slugName is kept as it can only be one particular slugName
                    this.restSlugName = segmentName;
                    // nextSegment is overwritten to [...] so that it can later be sorted specifically
                    nextSegment = '[...]';
                }
            } else {
                if (isOptional) {
                    throw new Error(`Optional route parameters are not yet supported ("${urlPaths[0]}").`);
                }
                handleSlug(this.slugName, segmentName);
                // slugName is kept as it can only be one particular slugName
                this.slugName = segmentName;
                // nextSegment is overwritten to [] so that it can later be sorted specifically
                nextSegment = '[]';
            }
        }
        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode
        if (!this.children.has(nextSegment)) {
            this.children.set(nextSegment, new UrlNode());
        }
        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);
    }
    constructor(){
        this.placeholder = true;
        this.children = new Map();
        this.slugName = null;
        this.restSlugName = null;
        this.optionalRestSlugName = null;
    }
}
function getSortedRoutes(normalizedPages) {
    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment
    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js
    // Only 1 dynamic segment per nesting level
    // So in the case that is test/integration/dynamic-routing it'll be this:
    // pages/[post]/comments.js
    // pages/blog/[post]/comment/[id].js
    // Both are fine because `pages/[post]` and `pages/blog` are on the same level
    // So in this case `UrlNode` created here has `this.slugName === 'post'`
    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities
    // Instead what has to be passed through is the upwards path's dynamic names
    const root = new UrlNode();
    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels
    normalizedPages.forEach((pagePath)=>root.insert(pagePath));
    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority
    return root.smoosh();
}

//# sourceMappingURL=sorted-routes.js.map

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/utils.js":
/*!********************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.normalizeRepeatedSlashes = normalizeRepeatedSlashes;
exports.loadGetInitialProps = loadGetInitialProps;
exports.ST = exports.SP = exports.isAbsoluteUrl = exports.WEB_VITALS = void 0;
var _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ "../../node_modules/@swc/helpers/lib/_async_to_generator.js")["default"]);
const WEB_VITALS = [
    'CLS',
    'FCP',
    'FID',
    'INP',
    'LCP',
    'TTFB'
];
exports.WEB_VITALS = WEB_VITALS;
function execOnce(fn) {
    let used = false;
    let result;
    return (...args)=>{
        if (!used) {
            used = true;
            result = fn(...args);
        }
        return result;
    };
}
// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);
exports.isAbsoluteUrl = isAbsoluteUrl;
function getLocationOrigin() {
    const { protocol , hostname , port  } = window.location;
    return `${protocol}//${hostname}${port ? ':' + port : ''}`;
}
function getURL() {
    const { href  } = window.location;
    const origin = getLocationOrigin();
    return href.substring(origin.length);
}
function getDisplayName(Component) {
    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}
function isResSent(res) {
    return res.finished || res.headersSent;
}
function normalizeRepeatedSlashes(url) {
    const urlParts = url.split('?');
    const urlNoQuery = urlParts[0];
    return urlNoQuery// first we replace any non-encoded backslashes with forward
    // then normalize repeated forward slashes
    .replace(/\\/g, '/').replace(/\/\/+/g, '/') + (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '');
}
function loadGetInitialProps(App, ctx) {
    return _loadGetInitialProps.apply(this, arguments);
}
function _loadGetInitialProps() {
    _loadGetInitialProps = _async_to_generator(function*(App, ctx) {
        if (true) {
            var ref;
            if ((ref = App.prototype) == null ? void 0 : ref.getInitialProps) {
                const message = `"${getDisplayName(App)}.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`;
                throw new Error(message);
            }
        }
        // when called from _app `ctx` is nested in `ctx`
        const res = ctx.res || ctx.ctx && ctx.ctx.res;
        if (!App.getInitialProps) {
            if (ctx.ctx && ctx.Component) {
                // @ts-ignore pageProps default
                return {
                    pageProps: yield loadGetInitialProps(ctx.Component, ctx.ctx)
                };
            }
            return {};
        }
        const props = yield App.getInitialProps(ctx);
        if (res && isResSent(res)) {
            return props;
        }
        if (!props) {
            const message = `"${getDisplayName(App)}.getInitialProps()" should resolve to an object. But found "${props}" instead.`;
            throw new Error(message);
        }
        if (true) {
            if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn(`${getDisplayName(App)} returned an empty object from \`getInitialProps\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`);
            }
        }
        return props;
    });
    return _loadGetInitialProps.apply(this, arguments);
}
const SP = typeof performance !== 'undefined';
exports.SP = SP;
const ST = SP && [
    'mark',
    'measure',
    'getEntriesByName'
].every((method)=>typeof performance[method] === 'function');
exports.ST = ST;
class DecodeError extends Error {
}
exports.DecodeError = DecodeError;
class NormalizeError extends Error {
}
exports.NormalizeError = NormalizeError;
class PageNotFoundError extends Error {
    constructor(page){
        super();
        this.code = 'ENOENT';
        this.message = `Cannot find module for page: ${page}`;
    }
}
exports.PageNotFoundError = PageNotFoundError;
class MissingStaticPage extends Error {
    constructor(page, message){
        super();
        this.message = `Failed to load static file for page: ${page} ${message}`;
    }
}
exports.MissingStaticPage = MissingStaticPage;
class MiddlewareNotFoundError extends Error {
    constructor(){
        super();
        this.code = 'ENOENT';
        this.message = `Cannot find the middleware module`;
    }
}
exports.MiddlewareNotFoundError = MiddlewareNotFoundError;

//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../../node_modules/next/link.js":
/*!***************************************!*\
  !*** ../../node_modules/next/link.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./dist/client/link */ "../../node_modules/next/dist/client/link.js")


/***/ }),

/***/ "../../node_modules/next/router.js":
/*!*****************************************!*\
  !*** ../../node_modules/next/router.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./dist/client/router */ "../../node_modules/next/dist/client/router.js")


/***/ }),

/***/ "../../node_modules/performant-array-to-tree/build/arrayToTree.min.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/performant-array-to-tree/build/arrayToTree.min.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
var __assign=this&&this.__assign||function(){return(__assign=Object.assign||function(e){for(var r,t=1,n=arguments.length;t<n;t++)for(var o in r=arguments[t])Object.prototype.hasOwnProperty.call(r,o)&&(e[o]=r[o]);return e}).apply(this,arguments)},defaultConfig=(Object.defineProperty(exports,"__esModule",{value:!0}),{id:"id",parentId:"parentId",dataField:"data",childrenField:"children",throwIfOrphans:!1,rootParentIds:{"":!(exports.countNodes=exports.arrayToTree=void 0)},nestedIds:!0,assign:!1});function arrayToTree(c,e){void 0===e&&(e={});for(var r,t=__assign(__assign({},defaultConfig),e),n=[],o={},a=t.throwIfOrphans?new Set:null,s=0,h=c;s<h.length;s++){var i=h[s],d=t.nestedIds?getNestedProperty(i,t.id):i[t.id],l=t.nestedIds?getNestedProperty(i,t.parentId):i[t.parentId];if(t.rootParentIds[d])throw new Error("The item array contains a node whose parentId both exists in another node and is in "+'`rootParentIds` (`itemId`: "'.concat(d,'", `rootParentIds`: ').concat(Object.keys(t.rootParentIds).map(function(e){return'"'.concat(e,'"')}).join(", "),")."));Object.prototype.hasOwnProperty.call(o,d)||(o[d]=((r={})[t.childrenField]=[],r)),a&&a.delete(d),t.dataField?o[d][t.dataField]=i:t.assign?o[d]=Object.assign(i,((r={})[t.childrenField]=o[d][t.childrenField],r)):o[d]=__assign(__assign({},i),((i={})[t.childrenField]=o[d][t.childrenField],i));i=o[d];null==l||t.rootParentIds[l]?n.push(i):(Object.prototype.hasOwnProperty.call(o,l)||(o[l]=((d={})[t.childrenField]=[],d),a&&a.add(l)),o[l][t.childrenField].push(i))}if(null!=a&&a.size)throw new Error("The items array contains orphans that point to the following parentIds: "+"[".concat(Array.from(a),"]. These parentIds do not exist in the items array. Hint: prevent orphans to result ")+"in an error by passing the following option: { throwIfOrphans: false }");if(t.throwIfOrphans&&countNodes(n,t.childrenField)<Object.keys(o).length)throw new Error("The items array contains nodes with a circular parent/child relationship.");return n}function countNodes(e,t){return e.reduce(function(e,r){return e+1+(r[t]&&countNodes(r[t],t))},0)}function getNestedProperty(e,r){return r.split(".").reduce(function(e,r){return e&&e[r]},e)}exports.arrayToTree=arrayToTree,exports.countNodes=countNodes;

/***/ }),

/***/ "../../node_modules/react-remove-scroll-bar/dist/es2015/component.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemoveScrollBar": () => (/* binding */ RemoveScrollBar)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_style_singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-style-singleton */ "../../node_modules/react-style-singleton/dist/es2015/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ "../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js");




var Style = (0,react_style_singleton__WEBPACK_IMPORTED_MODULE_1__.styleSingleton)();
// important tip - once we measure scrollBar width and remove them
// we could not repeat this operation
// thus we are using style-singleton - only the first "yet correct" style will be applied.
var getStyles = function (_a, allowRelative, gapMode, important) {
    var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
    if (gapMode === void 0) { gapMode = 'margin'; }
    return "\n  .".concat(_constants__WEBPACK_IMPORTED_MODULE_3__.noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
        allowRelative && "position: relative ".concat(important, ";"),
        gapMode === 'margin' &&
            "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
        gapMode === 'padding' && "padding-right: ".concat(gap, "px ").concat(important, ";"),
    ]
        .filter(Boolean)
        .join(''), "\n  }\n  \n  .").concat(_constants__WEBPACK_IMPORTED_MODULE_3__.zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(_constants__WEBPACK_IMPORTED_MODULE_3__.fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(_constants__WEBPACK_IMPORTED_MODULE_3__.zeroRightClassName, " .").concat(_constants__WEBPACK_IMPORTED_MODULE_3__.zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(_constants__WEBPACK_IMPORTED_MODULE_3__.fullWidthClassName, " .").concat(_constants__WEBPACK_IMPORTED_MODULE_3__.fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(_constants__WEBPACK_IMPORTED_MODULE_3__.removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
/**
 * Removes page scrollbar and blocks page scroll when mounted
 */
var RemoveScrollBar = function (props) {
    var noRelative = props.noRelative, noImportant = props.noImportant, _a = props.gapMode, gapMode = _a === void 0 ? 'margin' : _a;
    /*
     gap will be measured on every component mount
     however it will be used only by the "first" invocation
     due to singleton nature of <Style
     */
    var gap = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () { return (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getGapWidth)(gapMode); }, [gapMode]);
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? '!important' : '') });
};


/***/ }),

/***/ "../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fullWidthClassName": () => (/* binding */ fullWidthClassName),
/* harmony export */   "noScrollbarsClassName": () => (/* binding */ noScrollbarsClassName),
/* harmony export */   "removedBarSizeVariable": () => (/* binding */ removedBarSizeVariable),
/* harmony export */   "zeroRightClassName": () => (/* binding */ zeroRightClassName)
/* harmony export */ });
var zeroRightClassName = 'right-scroll-bar-position';
var fullWidthClassName = 'width-before-scroll-bar';
var noScrollbarsClassName = 'with-scroll-bars-hidden';
/**
 * Name of a CSS variable containing the amount of "hidden" scrollbar
 * ! might be undefined ! use will fallback!
 */
var removedBarSizeVariable = '--removed-body-scroll-bar-size';


/***/ }),

/***/ "../../node_modules/react-remove-scroll-bar/dist/es2015/index.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/react-remove-scroll-bar/dist/es2015/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemoveScrollBar": () => (/* reexport safe */ _component__WEBPACK_IMPORTED_MODULE_0__.RemoveScrollBar),
/* harmony export */   "fullWidthClassName": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_2__.fullWidthClassName),
/* harmony export */   "getGapWidth": () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.getGapWidth),
/* harmony export */   "noScrollbarsClassName": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_2__.noScrollbarsClassName),
/* harmony export */   "removedBarSizeVariable": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_2__.removedBarSizeVariable),
/* harmony export */   "zeroRightClassName": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_2__.zeroRightClassName)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "../../node_modules/react-remove-scroll-bar/dist/es2015/component.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js");






/***/ }),

/***/ "../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getGapWidth": () => (/* binding */ getGapWidth),
/* harmony export */   "zeroGap": () => (/* binding */ zeroGap)
/* harmony export */ });
var zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0,
};
var parse = function (x) { return parseInt(x || '', 10) || 0; };
var getOffset = function (gapMode) {
    var cs = window.getComputedStyle(document.body);
    var left = cs[gapMode === 'padding' ? 'paddingLeft' : 'marginLeft'];
    var top = cs[gapMode === 'padding' ? 'paddingTop' : 'marginTop'];
    var right = cs[gapMode === 'padding' ? 'paddingRight' : 'marginRight'];
    return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function (gapMode) {
    if (gapMode === void 0) { gapMode = 'margin'; }
    if (typeof window === 'undefined') {
        return zeroGap;
    }
    var offsets = getOffset(gapMode);
    var documentWidth = document.documentElement.clientWidth;
    var windowWidth = window.innerWidth;
    return {
        left: offsets[0],
        top: offsets[1],
        right: offsets[2],
        gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0]),
    };
};


/***/ }),

/***/ "../../node_modules/react-remove-scroll/dist/es2015/Combination.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/react-remove-scroll/dist/es2015/Combination.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UI */ "../../node_modules/react-remove-scroll/dist/es2015/UI.js");
/* harmony import */ var _sidecar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sidecar */ "../../node_modules/react-remove-scroll/dist/es2015/sidecar.js");




var ReactRemoveScroll = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) { return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_UI__WEBPACK_IMPORTED_MODULE_2__.RemoveScroll, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, props, { ref: ref, sideCar: _sidecar__WEBPACK_IMPORTED_MODULE_1__["default"] }))); });
ReactRemoveScroll.classNames = _UI__WEBPACK_IMPORTED_MODULE_2__.RemoveScroll.classNames;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReactRemoveScroll);


/***/ }),

/***/ "../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js":
/*!************************************************************************!*\
  !*** ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemoveScrollSideCar": () => (/* binding */ RemoveScrollSideCar),
/* harmony export */   "getDeltaXY": () => (/* binding */ getDeltaXY),
/* harmony export */   "getTouchXY": () => (/* binding */ getTouchXY)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_remove_scroll_bar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-remove-scroll-bar */ "../../node_modules/react-remove-scroll-bar/dist/es2015/index.js");
/* harmony import */ var react_style_singleton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-style-singleton */ "../../node_modules/react-style-singleton/dist/es2015/index.js");
/* harmony import */ var _aggresiveCapture__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./aggresiveCapture */ "../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js");
/* harmony import */ var _handleScroll__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./handleScroll */ "../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js");






var getTouchXY = function (event) {
    return 'changedTouches' in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function (event) { return [event.deltaX, event.deltaY]; };
var extractRef = function (ref) {
    return ref && 'current' in ref ? ref.current : ref;
};
var deltaCompare = function (x, y) { return x[0] === y[0] && x[1] === y[1]; };
var generateStyle = function (id) { return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n"); };
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
    var shouldPreventQueue = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);
    var touchStartRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([0, 0]);
    var activeAxis = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
    var id = react__WEBPACK_IMPORTED_MODULE_0__.useState(idCounter++)[0];
    var Style = react__WEBPACK_IMPORTED_MODULE_0__.useState(function () { return (0,react_style_singleton__WEBPACK_IMPORTED_MODULE_2__.styleSingleton)(); })[0];
    var lastProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(props);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
        lastProps.current = props;
    }, [props]);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
        if (props.inert) {
            document.body.classList.add("block-interactivity-".concat(id));
            var allow_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__spreadArray)([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
            allow_1.forEach(function (el) { return el.classList.add("allow-interactivity-".concat(id)); });
            return function () {
                document.body.classList.remove("block-interactivity-".concat(id));
                allow_1.forEach(function (el) { return el.classList.remove("allow-interactivity-".concat(id)); });
            };
        }
        return;
    }, [props.inert, props.lockRef.current, props.shards]);
    var shouldCancelEvent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event, parent) {
        if ('touches' in event && event.touches.length === 2) {
            return !lastProps.current.allowPinchZoom;
        }
        var touch = getTouchXY(event);
        var touchStart = touchStartRef.current;
        var deltaX = 'deltaX' in event ? event.deltaX : touchStart[0] - touch[0];
        var deltaY = 'deltaY' in event ? event.deltaY : touchStart[1] - touch[1];
        var currentAxis;
        var target = event.target;
        var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'h' : 'v';
        // allow horizontal touch move on Range inputs. They will not cause any scroll
        if ('touches' in event && moveDirection === 'h' && target.type === 'range') {
            return false;
        }
        var canBeScrolledInMainDirection = (0,_handleScroll__WEBPACK_IMPORTED_MODULE_4__.locationCouldBeScrolled)(moveDirection, target);
        if (!canBeScrolledInMainDirection) {
            return true;
        }
        if (canBeScrolledInMainDirection) {
            currentAxis = moveDirection;
        }
        else {
            currentAxis = moveDirection === 'v' ? 'h' : 'v';
            canBeScrolledInMainDirection = (0,_handleScroll__WEBPACK_IMPORTED_MODULE_4__.locationCouldBeScrolled)(moveDirection, target);
            // other axis might be not scrollable
        }
        if (!canBeScrolledInMainDirection) {
            return false;
        }
        if (!activeAxis.current && 'changedTouches' in event && (deltaX || deltaY)) {
            activeAxis.current = currentAxis;
        }
        if (!currentAxis) {
            return true;
        }
        var cancelingAxis = activeAxis.current || currentAxis;
        return (0,_handleScroll__WEBPACK_IMPORTED_MODULE_4__.handleScroll)(cancelingAxis, parent, event, cancelingAxis === 'h' ? deltaX : deltaY, true);
    }, []);
    var shouldPrevent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (_event) {
        var event = _event;
        if (!lockStack.length || lockStack[lockStack.length - 1] !== Style) {
            // not the last active
            return;
        }
        var delta = 'deltaY' in event ? getDeltaXY(event) : getTouchXY(event);
        var sourceEvent = shouldPreventQueue.current.filter(function (e) { return e.name === event.type && e.target === event.target && deltaCompare(e.delta, delta); })[0];
        // self event, and should be canceled
        if (sourceEvent && sourceEvent.should) {
            if (event.cancelable) {
                event.preventDefault();
            }
            return;
        }
        // outside or shard event
        if (!sourceEvent) {
            var shardNodes = (lastProps.current.shards || [])
                .map(extractRef)
                .filter(Boolean)
                .filter(function (node) { return node.contains(event.target); });
            var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
            if (shouldStop) {
                if (event.cancelable) {
                    event.preventDefault();
                }
            }
        }
    }, []);
    var shouldCancel = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (name, delta, target, should) {
        var event = { name: name, delta: delta, target: target, should: should };
        shouldPreventQueue.current.push(event);
        setTimeout(function () {
            shouldPreventQueue.current = shouldPreventQueue.current.filter(function (e) { return e !== event; });
        }, 1);
    }, []);
    var scrollTouchStart = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event) {
        touchStartRef.current = getTouchXY(event);
        activeAxis.current = undefined;
    }, []);
    var scrollWheel = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event) {
        shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    var scrollTouchMove = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event) {
        shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
        lockStack.push(Style);
        props.setCallbacks({
            onScrollCapture: scrollWheel,
            onWheelCapture: scrollWheel,
            onTouchMoveCapture: scrollTouchMove,
        });
        document.addEventListener('wheel', shouldPrevent, _aggresiveCapture__WEBPACK_IMPORTED_MODULE_5__.nonPassive);
        document.addEventListener('touchmove', shouldPrevent, _aggresiveCapture__WEBPACK_IMPORTED_MODULE_5__.nonPassive);
        document.addEventListener('touchstart', scrollTouchStart, _aggresiveCapture__WEBPACK_IMPORTED_MODULE_5__.nonPassive);
        return function () {
            lockStack = lockStack.filter(function (inst) { return inst !== Style; });
            document.removeEventListener('wheel', shouldPrevent, _aggresiveCapture__WEBPACK_IMPORTED_MODULE_5__.nonPassive);
            document.removeEventListener('touchmove', shouldPrevent, _aggresiveCapture__WEBPACK_IMPORTED_MODULE_5__.nonPassive);
            document.removeEventListener('touchstart', scrollTouchStart, _aggresiveCapture__WEBPACK_IMPORTED_MODULE_5__.nonPassive);
        };
    }, []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        inert ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(Style, { styles: generateStyle(id) }) : null,
        removeScrollBar ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_remove_scroll_bar__WEBPACK_IMPORTED_MODULE_1__.RemoveScrollBar, { gapMode: "margin" }) : null));
}


/***/ }),

/***/ "../../node_modules/react-remove-scroll/dist/es2015/UI.js":
/*!****************************************************************!*\
  !*** ../../node_modules/react-remove-scroll/dist/es2015/UI.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemoveScroll": () => (/* binding */ RemoveScroll)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_remove_scroll_bar_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-remove-scroll-bar/constants */ "../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js");
/* harmony import */ var use_callback_ref__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-callback-ref */ "../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js");
/* harmony import */ var _medium__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./medium */ "../../node_modules/react-remove-scroll/dist/es2015/medium.js");





var nothing = function () {
    return;
};
/**
 * Removes scrollbar from the page and contain the scroll within the Lock
 */
var RemoveScroll = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, parentRef) {
    var ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
    var _a = react__WEBPACK_IMPORTED_MODULE_0__.useState({
        onScrollCapture: nothing,
        onWheelCapture: nothing,
        onTouchMoveCapture: nothing,
    }), callbacks = _a[0], setCallbacks = _a[1];
    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? 'div' : _b, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__rest)(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
    var SideCar = sideCar;
    var containerRef = (0,use_callback_ref__WEBPACK_IMPORTED_MODULE_2__.useMergeRefs)([ref, parentRef]);
    var containerProps = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, rest), callbacks);
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,
        enabled && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(SideCar, { sideCar: _medium__WEBPACK_IMPORTED_MODULE_3__.effectCar, removeScrollBar: removeScrollBar, shards: shards, noIsolation: noIsolation, inert: inert, setCallbacks: setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref })),
        forwardProps ? (react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(react__WEBPACK_IMPORTED_MODULE_0__.Children.only(children), (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, containerProps), { ref: containerRef }))) : (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Container, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, containerProps, { className: className, ref: containerRef }), children))));
});
RemoveScroll.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false,
};
RemoveScroll.classNames = {
    fullWidth: react_remove_scroll_bar_constants__WEBPACK_IMPORTED_MODULE_4__.fullWidthClassName,
    zeroRight: react_remove_scroll_bar_constants__WEBPACK_IMPORTED_MODULE_4__.zeroRightClassName,
};



/***/ }),

/***/ "../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "nonPassive": () => (/* binding */ nonPassive)
/* harmony export */ });
var passiveSupported = false;
if (typeof window !== 'undefined') {
    try {
        var options = Object.defineProperty({}, 'passive', {
            get: function () {
                passiveSupported = true;
                return true;
            },
        });
        // @ts-ignore
        window.addEventListener('test', options, options);
        // @ts-ignore
        window.removeEventListener('test', options, options);
    }
    catch (err) {
        passiveSupported = false;
    }
}
var nonPassive = passiveSupported ? { passive: false } : false;


/***/ }),

/***/ "../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "handleScroll": () => (/* binding */ handleScroll),
/* harmony export */   "locationCouldBeScrolled": () => (/* binding */ locationCouldBeScrolled)
/* harmony export */ });
var alwaysContainsScroll = function (node) {
    // textarea will always _contain_ scroll inside self. It only can be hidden
    return node.tagName === 'TEXTAREA';
};
var elementCanBeScrolled = function (node, overflow) {
    var styles = window.getComputedStyle(node);
    return (
    // not-not-scrollable
    styles[overflow] !== 'hidden' &&
        // contains scroll inside self
        !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible'));
};
var elementCouldBeVScrolled = function (node) { return elementCanBeScrolled(node, 'overflowY'); };
var elementCouldBeHScrolled = function (node) { return elementCanBeScrolled(node, 'overflowX'); };
var locationCouldBeScrolled = function (axis, node) {
    var current = node;
    do {
        // Skip over shadow root
        if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {
            current = current.host;
        }
        var isScrollable = elementCouldBeScrolled(axis, current);
        if (isScrollable) {
            var _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];
            if (s > d) {
                return true;
            }
        }
        current = current.parentNode;
    } while (current && current !== document.body);
    return false;
};
var getVScrollVariables = function (_a) {
    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
    return [
        scrollTop,
        scrollHeight,
        clientHeight,
    ];
};
var getHScrollVariables = function (_a) {
    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
    return [
        scrollLeft,
        scrollWidth,
        clientWidth,
    ];
};
var elementCouldBeScrolled = function (axis, node) {
    return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function (axis, node) {
    return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function (axis, direction) {
    /**
     * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,
     * and then increasingly negative as you scroll towards the end of the content.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft
     */
    return axis === 'h' && direction === 'rtl' ? -1 : 1;
};
var handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
    var delta = directionFactor * sourceDelta;
    // find scrollable target
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
        var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
        var elementScroll = scroll_1 - capacity - directionFactor * position;
        if (position || elementScroll) {
            if (elementCouldBeScrolled(axis, target)) {
                availableScroll += elementScroll;
                availableScrollTop += position;
            }
        }
        target = target.parentNode;
    } while (
    // portaled content
    (!targetInLock && target !== document.body) ||
        // self content
        (targetInLock && (endTarget.contains(target) || endTarget === target)));
    if (isDeltaPositive && ((noOverscroll && availableScroll === 0) || (!noOverscroll && delta > availableScroll))) {
        shouldCancelScroll = true;
    }
    else if (!isDeltaPositive &&
        ((noOverscroll && availableScrollTop === 0) || (!noOverscroll && -delta > availableScrollTop))) {
        shouldCancelScroll = true;
    }
    return shouldCancelScroll;
};


/***/ }),

/***/ "../../node_modules/react-remove-scroll/dist/es2015/medium.js":
/*!********************************************************************!*\
  !*** ../../node_modules/react-remove-scroll/dist/es2015/medium.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "effectCar": () => (/* binding */ effectCar)
/* harmony export */ });
/* harmony import */ var use_sidecar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! use-sidecar */ "../../node_modules/use-sidecar/dist/es2015/medium.js");

var effectCar = (0,use_sidecar__WEBPACK_IMPORTED_MODULE_0__.createSidecarMedium)();


/***/ }),

/***/ "../../node_modules/react-remove-scroll/dist/es2015/sidecar.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/react-remove-scroll/dist/es2015/sidecar.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var use_sidecar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! use-sidecar */ "../../node_modules/use-sidecar/dist/es2015/exports.js");
/* harmony import */ var _SideEffect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SideEffect */ "../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js");
/* harmony import */ var _medium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./medium */ "../../node_modules/react-remove-scroll/dist/es2015/medium.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,use_sidecar__WEBPACK_IMPORTED_MODULE_0__.exportSidecar)(_medium__WEBPACK_IMPORTED_MODULE_1__.effectCar, _SideEffect__WEBPACK_IMPORTED_MODULE_2__.RemoveScrollSideCar));


/***/ }),

/***/ "../../node_modules/react-style-singleton/dist/es2015/component.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/react-style-singleton/dist/es2015/component.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "styleSingleton": () => (/* binding */ styleSingleton)
/* harmony export */ });
/* harmony import */ var _hook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hook */ "../../node_modules/react-style-singleton/dist/es2015/hook.js");

/**
 * create a Component to add styles on demand
 * - styles are added when first instance is mounted
 * - styles are removed when the last instance is unmounted
 * - changing styles in runtime does nothing unless dynamic is set. But with multiple components that can lead to the undefined behavior
 */
var styleSingleton = function () {
    var useStyle = (0,_hook__WEBPACK_IMPORTED_MODULE_0__.styleHookSingleton)();
    var Sheet = function (_a) {
        var styles = _a.styles, dynamic = _a.dynamic;
        useStyle(styles, dynamic);
        return null;
    };
    return Sheet;
};


/***/ }),

/***/ "../../node_modules/react-style-singleton/dist/es2015/hook.js":
/*!********************************************************************!*\
  !*** ../../node_modules/react-style-singleton/dist/es2015/hook.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "styleHookSingleton": () => (/* binding */ styleHookSingleton)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./singleton */ "../../node_modules/react-style-singleton/dist/es2015/singleton.js");


/**
 * creates a hook to control style singleton
 * @see {@link styleSingleton} for a safer component version
 * @example
 * ```tsx
 * const useStyle = styleHookSingleton();
 * ///
 * useStyle('body { overflow: hidden}');
 */
var styleHookSingleton = function () {
    var sheet = (0,_singleton__WEBPACK_IMPORTED_MODULE_1__.stylesheetSingleton)();
    return function (styles, isDynamic) {
        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {
            sheet.add(styles);
            return function () {
                sheet.remove();
            };
        }, [styles && isDynamic]);
    };
};


/***/ }),

/***/ "../../node_modules/react-style-singleton/dist/es2015/index.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/react-style-singleton/dist/es2015/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "styleHookSingleton": () => (/* reexport safe */ _hook__WEBPACK_IMPORTED_MODULE_2__.styleHookSingleton),
/* harmony export */   "styleSingleton": () => (/* reexport safe */ _component__WEBPACK_IMPORTED_MODULE_0__.styleSingleton),
/* harmony export */   "stylesheetSingleton": () => (/* reexport safe */ _singleton__WEBPACK_IMPORTED_MODULE_1__.stylesheetSingleton)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "../../node_modules/react-style-singleton/dist/es2015/component.js");
/* harmony import */ var _singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./singleton */ "../../node_modules/react-style-singleton/dist/es2015/singleton.js");
/* harmony import */ var _hook__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hook */ "../../node_modules/react-style-singleton/dist/es2015/hook.js");





/***/ }),

/***/ "../../node_modules/react-style-singleton/dist/es2015/singleton.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/react-style-singleton/dist/es2015/singleton.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stylesheetSingleton": () => (/* binding */ stylesheetSingleton)
/* harmony export */ });
/* harmony import */ var get_nonce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! get-nonce */ "../../node_modules/get-nonce/dist/es2015/index.js");

function makeStyleTag() {
    if (!document)
        return null;
    var tag = document.createElement('style');
    tag.type = 'text/css';
    var nonce = (0,get_nonce__WEBPACK_IMPORTED_MODULE_0__.getNonce)();
    if (nonce) {
        tag.setAttribute('nonce', nonce);
    }
    return tag;
}
function injectStyles(tag, css) {
    // @ts-ignore
    if (tag.styleSheet) {
        // @ts-ignore
        tag.styleSheet.cssText = css;
    }
    else {
        tag.appendChild(document.createTextNode(css));
    }
}
function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName('head')[0];
    head.appendChild(tag);
}
var stylesheetSingleton = function () {
    var counter = 0;
    var stylesheet = null;
    return {
        add: function (style) {
            if (counter == 0) {
                if ((stylesheet = makeStyleTag())) {
                    injectStyles(stylesheet, style);
                    insertStyleTag(stylesheet);
                }
            }
            counter++;
        },
        remove: function () {
            counter--;
            if (!counter && stylesheet) {
                stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
                stylesheet = null;
            }
        },
    };
};


/***/ }),

/***/ "../../node_modules/reforest/dist/esm/index.js":
/*!*****************************************************!*\
  !*** ../../node_modules/reforest/dist/esm/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cleanAndSortTree": () => (/* binding */ cleanAndSortTree),
/* harmony export */   "compareIndexPaths": () => (/* binding */ compareIndexPaths),
/* harmony export */   "flattenChildren": () => (/* binding */ flattenChildren),
/* harmony export */   "mapToChildren": () => (/* binding */ mapToChildren),
/* harmony export */   "parseIndexPath": () => (/* binding */ parseIndexPath),
/* harmony export */   "sortMapByIndexPath": () => (/* binding */ sortMapByIndexPath),
/* harmony export */   "useIndex": () => (/* binding */ useIndex),
/* harmony export */   "useIndexedChildren": () => (/* binding */ useIndexedChildren),
/* harmony export */   "useRovingIndex": () => (/* binding */ useRovingIndex),
/* harmony export */   "useTree": () => (/* binding */ useTree),
/* harmony export */   "useTreeNode": () => (/* binding */ useTreeNode),
/* harmony export */   "useTreeState": () => (/* binding */ useTreeState)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var performant_array_to_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! performant-array-to-tree */ "../../node_modules/performant-array-to-tree/build/arrayToTree.min.js");
/* harmony import */ var performant_array_to_tree__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(performant_array_to_tree__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand */ "../../node_modules/zustand/esm/index.mjs");
// src/use-indexed-children.tsx


// src/contexts.ts

var PrerenderContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(false);
PrerenderContext.displayName = "PrerenderContext";
var MaxIndexContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext([]);
MaxIndexContext.displayName = "MaxIndexContext";
var IndexContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
IndexContext.displayName = "IndexContext";
var TreeStateContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
TreeStateContext.displayName = "TreeStateContext";

// src/utils.ts


var isServer = typeof window === "undefined";
var useIsomorphicLayoutEffect = isServer ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;
function parseIndexPath(indexPathString) {
  return indexPathString.split(".").map((index) => parseInt(index, 10));
}
function compareIndexPaths(a = "", b = "") {
  var _a, _b;
  let aArray = a.split(".").map(Number);
  let bArray = b.split(".").map(Number);
  if (aArray.includes(NaN) || bArray.includes(NaN)) {
    throw new Error("Version contains parts that are not numbers");
  }
  const maxLength = Math.max(a.length, b.length);
  for (let index = 0; index < maxLength; index++) {
    const difference = ((_a = aArray[index]) != null ? _a : 0) - ((_b = bArray[index]) != null ? _b : 0);
    if (difference === 0) {
      continue;
    }
    return difference > 0 ? 1 : -1;
  }
  return 0;
}
function cleanAndSortTree(tree) {
  var _a;
  if (((_a = tree.children) == null ? void 0 : _a.length) > 0) {
    tree.children.sort((a, b) => compareIndexPaths(a.indexPathString, b.indexPathString));
    return {
      ...tree.data,
      children: tree.children.map(cleanAndSortTree)
    };
  }
  return tree.data;
}
function mapToChildren(dataMap) {
  const parsedValues = Array.from(dataMap.entries()).map(([indexPathString, data]) => {
    const parentIndexPathString = parseIndexPath(indexPathString).slice(0, -1).join(".");
    return {
      data,
      parentId: parentIndexPathString,
      id: indexPathString
    };
  });
  const tree = (0,performant_array_to_tree__WEBPACK_IMPORTED_MODULE_1__.arrayToTree)(parsedValues, { dataField: null });
  const cleanedTree = cleanAndSortTree({ children: tree });
  return cleanedTree ? cleanedTree.children : [];
}
function sortMapByIndexPath(treeMap) {
  const sortedEntries = Array.from(treeMap.entries()).sort((a, b) => compareIndexPaths(a[0], b[0]));
  return new Map(sortedEntries);
}
function flattenChildren(children) {
  const flatChildren = children.flatMap(
    (child) => child.children ? flattenChildren(child.children) : [child]
  );
  return flatChildren;
}

// src/use-indexed-children.tsx
function useIndex() {
  const maxIndexPath = react__WEBPACK_IMPORTED_MODULE_0__.useContext(MaxIndexContext);
  const indexPathString = react__WEBPACK_IMPORTED_MODULE_0__.useContext(IndexContext);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (indexPathString === null) {
      return null;
    }
    const indexPath = parseIndexPath(indexPathString);
    const maxIndex = maxIndexPath[maxIndexPath.length - 1];
    const index = indexPath[indexPath.length - 1];
    return {
      maxIndex,
      maxIndexPath,
      index,
      indexPath,
      indexPathString,
      isFirst: index === 0,
      isLast: index === maxIndex,
      isEven: index % 2 === 0,
      isOdd: Math.abs(index % 2) === 1
    };
  }, [maxIndexPath, indexPathString]);
}
function useIndexedChildren(children) {
  const parentMaxIndexPath = react__WEBPACK_IMPORTED_MODULE_0__.useContext(MaxIndexContext);
  const indexPathString = react__WEBPACK_IMPORTED_MODULE_0__.useContext(IndexContext);
  const childrenCount = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children);
  const maxIndexPath = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => parentMaxIndexPath.concat(childrenCount - 1),
    [childrenCount]
  );
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MaxIndexContext.Provider, { value: maxIndexPath }, react__WEBPACK_IMPORTED_MODULE_0__.Children.map(
    children,
    (child, index) => react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(child) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      IndexContext.Provider,
      {
        key: child.key,
        value: indexPathString ? `${indexPathString}.${index.toString()}` : index.toString()
      },
      child
    ) : child
  ));
}

// src/use-roving-index.ts

function useRovingIndex({
  contain = true,
  defaultIndex = 0,
  maxIndex = Infinity,
  wrap = false
}) {
  const [activeIndex, setLocalActiveIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(defaultIndex);
  const getNextIndex = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (nextIndex) => {
      if (wrap) {
        return (nextIndex % maxIndex + maxIndex) % maxIndex;
      }
      if (contain) {
        return nextIndex > maxIndex ? maxIndex : nextIndex < 0 ? 0 : nextIndex;
      }
      return nextIndex;
    },
    [maxIndex, wrap]
  );
  const moveActiveIndex = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (amountToMove) => {
      setLocalActiveIndex((currentIndex) => getNextIndex(currentIndex + amountToMove));
    },
    [getNextIndex]
  );
  const setActiveIndex = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (nextIndex) => {
      setLocalActiveIndex(getNextIndex(nextIndex));
    },
    [getNextIndex]
  );
  const moveBackward = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => moveActiveIndex(-1), [moveActiveIndex]);
  const moveForward = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => moveActiveIndex(1), [moveActiveIndex]);
  return {
    activeIndex,
    moveActiveIndex,
    setActiveIndex,
    moveBackward,
    moveForward,
    moveBackwardDisabled: activeIndex <= 0,
    moveForwardDisabled: activeIndex >= maxIndex
  };
}

// src/use-tree.tsx


function useTreeState(selector) {
  const treeStateContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(TreeStateContext);
  const [treeState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(
    () => treeStateContext || (0,zustand__WEBPACK_IMPORTED_MODULE_2__.create)((set, get) => ({
      treeMap: /* @__PURE__ */ new Map(),
      prerenderedTreeIds: /* @__PURE__ */ new Map(),
      shouldPrerender: true,
      setTreeData: (id, data) => {
        const { treeMap } = get();
        treeMap.set(id, data);
        set({ treeMap: sortMapByIndexPath(treeMap) });
      },
      deleteTreeData: (id) => {
        const { treeMap } = get();
        treeMap.delete(id);
        set({ treeMap: sortMapByIndexPath(treeMap) });
      }
    }))
  );
  return selector ? treeState(selector) : treeState;
}
function PrerenderTree({ children }) {
  const treeState = useTreeState();
  const shouldPrerender = treeState((state) => state.shouldPrerender);
  useIsomorphicLayoutEffect(() => {
    treeState.setState({
      prerenderedTreeIds: /* @__PURE__ */ new Map(),
      shouldPrerender: false
    });
  }, []);
  return shouldPrerender ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrerenderContext.Provider, { value: true }, children) : null;
}
function useTree(children, treeState) {
  const treeStateContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(TreeStateContext);
  const treeStateLocal = useTreeState();
  const parsedTreeState = treeStateContext || treeState || treeStateLocal;
  const isPrerender = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PrerenderContext);
  const isRoot = treeStateContext === null;
  const indexedChildren = useIndexedChildren(children);
  const childrenToRender = isRoot ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TreeStateContext.Provider, { value: parsedTreeState }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrerenderTree, null, indexedChildren), indexedChildren) : indexedChildren;
  return {
    children: childrenToRender,
    useStore: parsedTreeState,
    isPrerender,
    isRoot
  };
}
function useTreeNode(getData, dependencies = []) {
  const isPrerender = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PrerenderContext);
  const treeStateContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(TreeStateContext);
  if (treeStateContext === null) {
    throw new Error("useTreeNode must be used in a descendant component of useTree.");
  }
  const { deleteTreeData, prerenderedTreeIds, setTreeData, treeMap } = treeStateContext.getState();
  const { indexPathString } = useIndex();
  const generatedId = react__WEBPACK_IMPORTED_MODULE_0__.useId().slice(1, -1);
  const treeId = prerenderedTreeIds.get(indexPathString) || generatedId;
  const treeData = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
    () => Object.assign({ treeId }, getData()),
    dependencies.concat(treeId)
  );
  if (isPrerender) {
    treeMap.set(indexPathString, treeData);
    prerenderedTreeIds.set(indexPathString, treeId);
  } else {
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
      setTreeData(indexPathString, treeData);
      return () => {
        deleteTreeData(indexPathString);
      };
    }, [indexPathString, treeData]);
  }
  return {
    id: treeId,
    data: treeData,
    indexPathString,
    isPrerender
  };
}



/***/ }),

/***/ "../../node_modules/tabbable/dist/index.esm.js":
/*!*****************************************************!*\
  !*** ../../node_modules/tabbable/dist/index.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "focusable": () => (/* binding */ focusable),
/* harmony export */   "isFocusable": () => (/* binding */ isFocusable),
/* harmony export */   "isTabbable": () => (/* binding */ isTabbable),
/* harmony export */   "tabbable": () => (/* binding */ tabbable)
/* harmony export */ });
/*!
* tabbable 6.0.1
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
var candidateSelector = /* #__PURE__ */candidateSelectors.join(',');
var NoElement = typeof Element === 'undefined';
var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
  return element.getRootNode();
} : function (element) {
  return element.ownerDocument;
};

/**
 * @param {Element} el container to check in
 * @param {boolean} includeContainer add container to check
 * @param {(node: Element) => boolean} filter filter candidates
 * @returns {Element[]}
 */
var getCandidates = function getCandidates(el, includeContainer, filter) {
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};

/**
 * @callback GetShadowRoot
 * @param {Element} element to check for shadow root
 * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.
 */

/**
 * @callback ShadowRootFilter
 * @param {Element} shadowHostNode the element which contains shadow content
 * @returns {boolean} true if a shadow root could potentially contain valid candidates.
 */

/**
 * @typedef {Object} CandidateScope
 * @property {Element} scopeParent contains inner candidates
 * @property {Element[]} candidates list of candidates found in the scope parent
 */

/**
 * @typedef {Object} IterativeOptions
 * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;
 *  if a function, implies shadow support is enabled and either returns the shadow root of an element
 *  or a boolean stating if it has an undisclosed shadow root
 * @property {(node: Element) => boolean} filter filter candidates
 * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list
 * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;
 */

/**
 * @param {Element[]} elements list of element containers to match candidates from
 * @param {boolean} includeContainer add container list to check
 * @param {IterativeOptions} options
 * @returns {Array.<Element|CandidateScope>}
 */
var getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (element.tagName === 'SLOT') {
      // add shadow dom slot scope (slot itself cannot be focusable)
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      // check candidate element
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }

      // iterate over shadow content if possible
      var shadowRoot = element.shadowRoot ||
      // check for an undisclosed shadow
      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);
      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
      if (shadowRoot && validShadowRoot) {
        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed
        //  shadow exists, so look at light dom children as fallback BUT create a scope for any
        //  child candidates found because they're likely slotted elements (elements that are
        //  children of the web component element (which has the shadow), in the light dom, but
        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,
        //  _after_ we return from this recursive call
        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        // there's not shadow so just dig into the element's (light dom) children
        //  __without__ giving the element special scope treatment
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex(node, isScope) {
  if (node.tabIndex < 0) {
    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
    // yet they are still part of the regular tab order; in FF, they get a default
    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab
    // order, consider their tab index to be 0.
    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.
    //
    // isScope is positive for custom element with shadow root or slot that by default
    // have tabIndex -1, but need to be sorted by document order in order for their
    // content to be inserted in the correct position
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput(node) {
  return node.tagName === 'INPUT';
};
var isHiddenInput = function isHiddenInput(node) {
  return isInput(node) && node.type === 'hidden';
};
var isDetailsWithSummary = function isDetailsWithSummary(node) {
  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
    return child.tagName === 'SUMMARY';
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio(node) {
  return isInput(node) && node.type === 'radio';
};
var isNonTabbableRadio = function isNonTabbableRadio(node) {
  return isRadio(node) && !isTabbableRadio(node);
};

// determines if a node is ultimately attached to the window's document
var isNodeAttached = function isNodeAttached(node) {
  var _nodeRootHost;
  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
  //  (but NOT _the_ document; see second 'If' comment below for more).
  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
  //  is attached, and the one we need to check if it's in the document or not (because the
  //  shadow, and all nodes it contains, is never considered in the document since shadows
  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
  //  visibility, including all the nodes it contains). The host could be any normal node,
  //  or a custom element (i.e. web component). Either way, that's the one that is considered
  //  part of the document, not the shadow root, nor any of its children (i.e. the node being
  //  tested).
  // To further complicate things, we have to look all the way up until we find a shadow HOST
  //  that is attached (or find none) because the node might be in nested shadows...
  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
  //  document (per the docs) and while it's a Document-type object, that document does not
  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
  //  node is actually detached.
  var nodeRootHost = getRootNode(node).host;
  var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));
  while (!attached && nodeRootHost) {
    var _nodeRootHost2;
    // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
    //  which means we need to get the host's host and check if that parent host is contained
    //  in (i.e. attached to) the document
    nodeRootHost = getRootNode(nodeRootHost).host;
    attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));
  }
  return attached;
};
var isZeroArea = function isZeroArea(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(),
    width = _node$getBoundingClie.width,
    height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden(node, _ref) {
  var displayCheck = _ref.displayCheck,
    getShadowRoot = _ref.getShadowRoot;
  // NOTE: visibility will be `undefined` if node is detached from the document
  //  (see notes about this further down), which means we will consider it visible
  //  (this is legacy behavior from a very long way back)
  // NOTE: we check this regardless of `displayCheck="none"` because this is a
  //  _visibility_ check, not a _display_ check
  if (getComputedStyle(node).visibility === 'hidden') {
    return true;
  }
  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
    return true;
  }
  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
    if (typeof getShadowRoot === 'function') {
      // figure out if we should consider the node to be in an undisclosed shadow and use the
      //  'non-zero-area' fallback
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
        ) {
          // node has an undisclosed shadow which means we can only treat it as a black box, so we
          //  fall back to a non-zero-area test
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          // iterate up slot
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          // cross shadow boundary
          node = rootNode.host;
        } else {
          // iterate up normal dom
          node = parentElement;
        }
      }
      node = originalNode;
    }
    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
    //  it might be a falsy value, which means shadow DOM support is disabled

    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
    //  now we can just test to see if it would normally be visible or not, provided it's
    //  attached to the main document.
    // NOTE: We must consider case where node is inside a shadow DOM and given directly to
    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.

    if (isNodeAttached(node)) {
      // this works wherever the node is: if there's at least one client rect, it's
      //  somehow displayed; it also covers the CSS 'display: contents' case where the
      //  node itself is hidden in place of its contents; and there's no need to search
      //  up the hierarchy either
      return !node.getClientRects().length;
    }

    // Else, the node isn't attached to the document, which means the `getClientRects()`
    //  API will __always__ return zero rects (this can happen, for example, if React
    //  is used to render nodes onto a detached tree, as confirmed in this thread:
    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
    //
    // It also means that even window.getComputedStyle(node).display will return `undefined`
    //  because styles are only computed for nodes that are in the document.
    //
    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
    //  somehow. Though it was never stated officially, anyone who has ever used tabbable
    //  APIs on nodes in detached containers has actually implicitly used tabbable in what
    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
    //  considering __everything__ to be visible because of the innability to determine styles.
    //
    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
    //  nodes as visible with the 'none' fallback.__
    if (displayCheck !== 'legacy-full') {
      return true; // hidden
    }
    // else, fallback to 'none' mode and consider the node visible
  } else if (displayCheck === 'non-zero-area') {
    // NOTE: Even though this tests that the node's client rect is non-zero to determine
    //  whether it's displayed, and that a detached node will __always__ have a zero-area
    //  client rect, we don't special-case for whether the node is attached or not. In
    //  this mode, we do want to consider nodes that have a zero area to be hidden at all
    //  times, and that includes attached or not.
    return isZeroArea(node);
  }

  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
  //  it's visible
  return false;
};

// form fields (nested) inside a disabled fieldset are not focusable/tabbable
//  unless they are in the _first_ <legend> element of the top-most disabled
//  fieldset
var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    // check if `node` is contained in a disabled <fieldset>
    while (parentNode) {
      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
        // look for the first <legend> among the children of the disabled <fieldset>
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          // when the first <legend> (in document order) is found
          if (child.tagName === 'LEGEND') {
            // if its parent <fieldset> is not nested in another disabled <fieldset>,
            // return whether `node` is a descendant of its first <legend>
            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
          }
        }
        // the disabled <fieldset> containing `node` has no <legend>
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }

  // else, node's tabbable/focusable state should not be affected by a fieldset's
  //  enabled/disabled state
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options) ||
  // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  // If a custom element has an explicit negative tabindex,
  // browsers will not allow tab targeting said element's children.
  return false;
};

/**
 * @param {Array.<Element|CandidateScope>} candidates
 * @returns Element[]
 */
var sortByOrder = function sortByOrder(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function (item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item: item,
        isScope: isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');
var isFocusable = function isFocusable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};


//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ "../../node_modules/tamagui/dist/esm/helpers/inputHelpers.mjs":
/*!********************************************************************!*\
  !*** ../../node_modules/tamagui/dist/esm/helpers/inputHelpers.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "inputSizeVariant": () => (/* binding */ inputSizeVariant),
/* harmony export */   "textAreaSizeVariant": () => (/* binding */ textAreaSizeVariant)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_get_button_sized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/get-button-sized */ "../../node_modules/@tamagui/get-button-sized/dist/esm/index.mjs");
/* harmony import */ var _tamagui_get_font_sized__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/get-font-sized */ "../../node_modules/@tamagui/get-font-sized/dist/esm/index.mjs");
/* harmony import */ var _tamagui_get_size__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/get-size */ "../../node_modules/@tamagui/get-size/dist/esm/index.mjs");




const inputSizeVariant = (val = "$true", extras) => {
  if (extras.props.multiline || extras.props.numberOfLines > 1) {
    return textAreaSizeVariant(val, extras);
  }
  const buttonStyles = (0,_tamagui_get_button_sized__WEBPACK_IMPORTED_MODULE_1__.getButtonSized)(val, extras);
  const paddingHorizontal = (0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_2__.stepTokenUpOrDown)("space", val, -1, [2]);
  const fontStyle = (0,_tamagui_get_font_sized__WEBPACK_IMPORTED_MODULE_0__.getFontSized)(val, extras);
  if (!_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.isWeb && fontStyle) {
    delete fontStyle["lineHeight"];
  }
  return {
    ...fontStyle,
    ...buttonStyles,
    paddingHorizontal
  };
};
const textAreaSizeVariant = (val = "$true", extras) => {
  const { props } = extras;
  const buttonStyles = (0,_tamagui_get_button_sized__WEBPACK_IMPORTED_MODULE_1__.getButtonSized)(val, extras);
  const fontStyle = (0,_tamagui_get_font_sized__WEBPACK_IMPORTED_MODULE_0__.getFontSized)(val, extras);
  const height = props.numberOfLines ? (props.numberOfLines || 1) * (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.getVariableValue)(fontStyle.lineHeight) : "auto";
  const paddingVertical = (0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_2__.stepTokenUpOrDown)("space", val, -2, [2]);
  const paddingHorizontal = (0,_tamagui_get_size__WEBPACK_IMPORTED_MODULE_2__.stepTokenUpOrDown)("space", val, -1, [2]);
  return {
    ...buttonStyles,
    ...fontStyle,
    paddingVertical,
    paddingHorizontal,
    height
  };
};

//# sourceMappingURL=inputHelpers.mjs.map


/***/ }),

/***/ "../../node_modules/tamagui/dist/esm/index.mjs":
/*!*****************************************************!*\
  !*** ../../node_modules/tamagui/dist/esm/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Adapt": () => (/* reexport safe */ _tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__.Adapt),
/* harmony export */   "AdaptContents": () => (/* reexport safe */ _tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__.AdaptContents),
/* harmony export */   "AdaptParentContext": () => (/* reexport safe */ _tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__.AdaptParentContext),
/* harmony export */   "AlertDialog": () => (/* reexport safe */ _tamagui_alert_dialog__WEBPACK_IMPORTED_MODULE_2__.AlertDialog),
/* harmony export */   "AlertDialogAction": () => (/* reexport safe */ _tamagui_alert_dialog__WEBPACK_IMPORTED_MODULE_2__.AlertDialogAction),
/* harmony export */   "AlertDialogCancel": () => (/* reexport safe */ _tamagui_alert_dialog__WEBPACK_IMPORTED_MODULE_2__.AlertDialogCancel),
/* harmony export */   "AlertDialogContent": () => (/* reexport safe */ _tamagui_alert_dialog__WEBPACK_IMPORTED_MODULE_2__.AlertDialogContent),
/* harmony export */   "AlertDialogDescription": () => (/* reexport safe */ _tamagui_alert_dialog__WEBPACK_IMPORTED_MODULE_2__.AlertDialogDescription),
/* harmony export */   "AlertDialogOverlay": () => (/* reexport safe */ _tamagui_alert_dialog__WEBPACK_IMPORTED_MODULE_2__.AlertDialogOverlay),
/* harmony export */   "AlertDialogPortal": () => (/* reexport safe */ _tamagui_alert_dialog__WEBPACK_IMPORTED_MODULE_2__.AlertDialogPortal),
/* harmony export */   "AlertDialogTitle": () => (/* reexport safe */ _tamagui_alert_dialog__WEBPACK_IMPORTED_MODULE_2__.AlertDialogTitle),
/* harmony export */   "AlertDialogTrigger": () => (/* reexport safe */ _tamagui_alert_dialog__WEBPACK_IMPORTED_MODULE_2__.AlertDialogTrigger),
/* harmony export */   "Anchor": () => (/* reexport safe */ _views_Anchor__WEBPACK_IMPORTED_MODULE_44__.Anchor),
/* harmony export */   "AnimatePresence": () => (/* reexport safe */ _tamagui_animate_presence__WEBPACK_IMPORTED_MODULE_3__.AnimatePresence),
/* harmony export */   "AnimationDriverProvider": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_52__.AnimationDriverProvider),
/* harmony export */   "Article": () => (/* reexport safe */ _views_Layouts__WEBPACK_IMPORTED_MODULE_49__.Article),
/* harmony export */   "Aside": () => (/* reexport safe */ _views_Layouts__WEBPACK_IMPORTED_MODULE_49__.Aside),
/* harmony export */   "Avatar": () => (/* reexport safe */ _tamagui_avatar__WEBPACK_IMPORTED_MODULE_4__.Avatar),
/* harmony export */   "AvatarFallback": () => (/* reexport safe */ _tamagui_avatar__WEBPACK_IMPORTED_MODULE_4__.AvatarFallback),
/* harmony export */   "AvatarFallbackFrame": () => (/* reexport safe */ _tamagui_avatar__WEBPACK_IMPORTED_MODULE_4__.AvatarFallbackFrame),
/* harmony export */   "AvatarFrame": () => (/* reexport safe */ _tamagui_avatar__WEBPACK_IMPORTED_MODULE_4__.AvatarFrame),
/* harmony export */   "AvatarImage": () => (/* reexport safe */ _tamagui_avatar__WEBPACK_IMPORTED_MODULE_4__.AvatarImage),
/* harmony export */   "BubbleInput": () => (/* reexport safe */ _tamagui_checkbox__WEBPACK_IMPORTED_MODULE_7__.BubbleInput),
/* harmony export */   "Button": () => (/* reexport safe */ _tamagui_button__WEBPACK_IMPORTED_MODULE_5__.Button),
/* harmony export */   "ButtonFrame": () => (/* reexport safe */ _tamagui_button__WEBPACK_IMPORTED_MODULE_5__.ButtonFrame),
/* harmony export */   "ButtonText": () => (/* reexport safe */ _tamagui_button__WEBPACK_IMPORTED_MODULE_5__.ButtonText),
/* harmony export */   "Card": () => (/* reexport safe */ _tamagui_card__WEBPACK_IMPORTED_MODULE_6__.Card),
/* harmony export */   "CardBackground": () => (/* reexport safe */ _tamagui_card__WEBPACK_IMPORTED_MODULE_6__.CardBackground),
/* harmony export */   "CardFooter": () => (/* reexport safe */ _tamagui_card__WEBPACK_IMPORTED_MODULE_6__.CardFooter),
/* harmony export */   "CardFrame": () => (/* reexport safe */ _tamagui_card__WEBPACK_IMPORTED_MODULE_6__.CardFrame),
/* harmony export */   "CardHeader": () => (/* reexport safe */ _tamagui_card__WEBPACK_IMPORTED_MODULE_6__.CardHeader),
/* harmony export */   "Checkbox": () => (/* reexport safe */ _tamagui_checkbox__WEBPACK_IMPORTED_MODULE_7__.Checkbox),
/* harmony export */   "CheckboxFrame": () => (/* reexport safe */ _tamagui_checkbox__WEBPACK_IMPORTED_MODULE_7__.CheckboxFrame),
/* harmony export */   "Circle": () => (/* reexport safe */ _tamagui_shapes__WEBPACK_IMPORTED_MODULE_26__.Circle),
/* harmony export */   "ControlledSheet": () => (/* reexport safe */ _tamagui_sheet__WEBPACK_IMPORTED_MODULE_27__.ControlledSheet),
/* harmony export */   "Dialog": () => (/* reexport safe */ _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__.Dialog),
/* harmony export */   "DialogClose": () => (/* reexport safe */ _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__.DialogClose),
/* harmony export */   "DialogContent": () => (/* reexport safe */ _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__.DialogContent),
/* harmony export */   "DialogDescription": () => (/* reexport safe */ _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__.DialogDescription),
/* harmony export */   "DialogOverlay": () => (/* reexport safe */ _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__.DialogOverlay),
/* harmony export */   "DialogOverlayFrame": () => (/* reexport safe */ _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__.DialogOverlayFrame),
/* harmony export */   "DialogPortal": () => (/* reexport safe */ _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__.DialogPortal),
/* harmony export */   "DialogPortalFrame": () => (/* reexport safe */ _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__.DialogPortalFrame),
/* harmony export */   "DialogSheetContents": () => (/* reexport safe */ _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__.DialogSheetContents),
/* harmony export */   "DialogTitle": () => (/* reexport safe */ _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__.DialogTitle),
/* harmony export */   "DialogTrigger": () => (/* reexport safe */ _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__.DialogTrigger),
/* harmony export */   "DialogWarningProvider": () => (/* reexport safe */ _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__.DialogWarningProvider),
/* harmony export */   "DirectionalYStack": () => (/* reexport safe */ _tamagui_slider__WEBPACK_IMPORTED_MODULE_28__.DirectionalYStack),
/* harmony export */   "EnsureFlexed": () => (/* reexport safe */ _views_EnsureFlexed__WEBPACK_IMPORTED_MODULE_45__.EnsureFlexed),
/* harmony export */   "Fieldset": () => (/* reexport safe */ _views_Fieldset__WEBPACK_IMPORTED_MODULE_46__.Fieldset),
/* harmony export */   "FontLanguage": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_53__.FontLanguage),
/* harmony export */   "Footer": () => (/* reexport safe */ _views_Layouts__WEBPACK_IMPORTED_MODULE_49__.Footer),
/* harmony export */   "Form": () => (/* reexport safe */ _tamagui_form__WEBPACK_IMPORTED_MODULE_12__.Form),
/* harmony export */   "FormFrame": () => (/* reexport safe */ _tamagui_form__WEBPACK_IMPORTED_MODULE_12__.FormFrame),
/* harmony export */   "FormProvider": () => (/* reexport safe */ _tamagui_form__WEBPACK_IMPORTED_MODULE_12__.FormProvider),
/* harmony export */   "FormTrigger": () => (/* reexport safe */ _tamagui_form__WEBPACK_IMPORTED_MODULE_12__.FormTrigger),
/* harmony export */   "ForwardSelectContext": () => (/* reexport safe */ _tamagui_select__WEBPACK_IMPORTED_MODULE_24__.ForwardSelectContext),
/* harmony export */   "Grid": () => (/* reexport safe */ _views_Grid__WEBPACK_IMPORTED_MODULE_47__.Grid),
/* harmony export */   "Group": () => (/* reexport safe */ _tamagui_group__WEBPACK_IMPORTED_MODULE_13__.Group),
/* harmony export */   "GroupFrame": () => (/* reexport safe */ _tamagui_group__WEBPACK_IMPORTED_MODULE_13__.GroupFrame),
/* harmony export */   "Header": () => (/* reexport safe */ _views_Layouts__WEBPACK_IMPORTED_MODULE_49__.Header),
/* harmony export */   "Image": () => (/* reexport safe */ _tamagui_image__WEBPACK_IMPORTED_MODULE_15__.Image),
/* harmony export */   "Input": () => (/* reexport safe */ _views_Input__WEBPACK_IMPORTED_MODULE_48__.Input),
/* harmony export */   "InputFrame": () => (/* reexport safe */ _views_Input__WEBPACK_IMPORTED_MODULE_48__.InputFrame),
/* harmony export */   "Label": () => (/* reexport safe */ _tamagui_label__WEBPACK_IMPORTED_MODULE_16__.Label),
/* harmony export */   "LabelFrame": () => (/* reexport safe */ _tamagui_label__WEBPACK_IMPORTED_MODULE_16__.LabelFrame),
/* harmony export */   "LinearGradient": () => (/* binding */ LinearGradient),
/* harmony export */   "ListItem": () => (/* reexport safe */ _tamagui_list_item__WEBPACK_IMPORTED_MODULE_17__.ListItem),
/* harmony export */   "ListItemFrame": () => (/* reexport safe */ _tamagui_list_item__WEBPACK_IMPORTED_MODULE_17__.ListItemFrame),
/* harmony export */   "ListItemSubtitle": () => (/* reexport safe */ _tamagui_list_item__WEBPACK_IMPORTED_MODULE_17__.ListItemSubtitle),
/* harmony export */   "ListItemText": () => (/* reexport safe */ _tamagui_list_item__WEBPACK_IMPORTED_MODULE_17__.ListItemText),
/* harmony export */   "ListItemTitle": () => (/* reexport safe */ _tamagui_list_item__WEBPACK_IMPORTED_MODULE_17__.ListItemTitle),
/* harmony export */   "Main": () => (/* reexport safe */ _views_Layouts__WEBPACK_IMPORTED_MODULE_49__.Main),
/* harmony export */   "Nav": () => (/* reexport safe */ _views_Layouts__WEBPACK_IMPORTED_MODULE_49__.Nav),
/* harmony export */   "Popover": () => (/* reexport safe */ _tamagui_popover__WEBPACK_IMPORTED_MODULE_18__.Popover),
/* harmony export */   "PopoverAnchor": () => (/* reexport safe */ _tamagui_popover__WEBPACK_IMPORTED_MODULE_18__.PopoverAnchor),
/* harmony export */   "PopoverArrow": () => (/* reexport safe */ _tamagui_popover__WEBPACK_IMPORTED_MODULE_18__.PopoverArrow),
/* harmony export */   "PopoverClose": () => (/* reexport safe */ _tamagui_popover__WEBPACK_IMPORTED_MODULE_18__.PopoverClose),
/* harmony export */   "PopoverContent": () => (/* reexport safe */ _tamagui_popover__WEBPACK_IMPORTED_MODULE_18__.PopoverContent),
/* harmony export */   "PopoverTrigger": () => (/* reexport safe */ _tamagui_popover__WEBPACK_IMPORTED_MODULE_18__.PopoverTrigger),
/* harmony export */   "Popper": () => (/* reexport safe */ _tamagui_popper__WEBPACK_IMPORTED_MODULE_19__.Popper),
/* harmony export */   "PopperAnchor": () => (/* reexport safe */ _tamagui_popper__WEBPACK_IMPORTED_MODULE_19__.PopperAnchor),
/* harmony export */   "PopperArrow": () => (/* reexport safe */ _tamagui_popper__WEBPACK_IMPORTED_MODULE_19__.PopperArrow),
/* harmony export */   "PopperContent": () => (/* reexport safe */ _tamagui_popper__WEBPACK_IMPORTED_MODULE_19__.PopperContent),
/* harmony export */   "PopperContentFrame": () => (/* reexport safe */ _tamagui_popper__WEBPACK_IMPORTED_MODULE_19__.PopperContentFrame),
/* harmony export */   "PopperProvider": () => (/* reexport safe */ _tamagui_popper__WEBPACK_IMPORTED_MODULE_19__.PopperProvider),
/* harmony export */   "PresenceContext": () => (/* reexport safe */ _tamagui_animate_presence__WEBPACK_IMPORTED_MODULE_3__.PresenceContext),
/* harmony export */   "Progress": () => (/* reexport safe */ _tamagui_progress__WEBPACK_IMPORTED_MODULE_21__.Progress),
/* harmony export */   "ProgressFrame": () => (/* reexport safe */ _tamagui_progress__WEBPACK_IMPORTED_MODULE_21__.ProgressFrame),
/* harmony export */   "ProgressIndicator": () => (/* reexport safe */ _tamagui_progress__WEBPACK_IMPORTED_MODULE_21__.ProgressIndicator),
/* harmony export */   "ProgressIndicatorFrame": () => (/* reexport safe */ _tamagui_progress__WEBPACK_IMPORTED_MODULE_21__.ProgressIndicatorFrame),
/* harmony export */   "RadioGroup": () => (/* reexport safe */ _tamagui_radio_group__WEBPACK_IMPORTED_MODULE_22__.RadioGroup),
/* harmony export */   "Range": () => (/* reexport safe */ _tamagui_slider__WEBPACK_IMPORTED_MODULE_28__.Range),
/* harmony export */   "ScrollView": () => (/* reexport safe */ _tamagui_scroll_view__WEBPACK_IMPORTED_MODULE_23__.ScrollView),
/* harmony export */   "Section": () => (/* reexport safe */ _views_Layouts__WEBPACK_IMPORTED_MODULE_49__.Section),
/* harmony export */   "Select": () => (/* reexport safe */ _tamagui_select__WEBPACK_IMPORTED_MODULE_24__.Select),
/* harmony export */   "SelectGroupFrame": () => (/* reexport safe */ _tamagui_select__WEBPACK_IMPORTED_MODULE_24__.SelectGroupFrame),
/* harmony export */   "SelectIcon": () => (/* reexport safe */ _tamagui_select__WEBPACK_IMPORTED_MODULE_24__.SelectIcon),
/* harmony export */   "SelectItem": () => (/* reexport safe */ _tamagui_select__WEBPACK_IMPORTED_MODULE_24__.SelectItem),
/* harmony export */   "SelectItemTextFrame": () => (/* reexport safe */ _tamagui_select__WEBPACK_IMPORTED_MODULE_24__.SelectItemTextFrame),
/* harmony export */   "SelectProvider": () => (/* reexport safe */ _tamagui_select__WEBPACK_IMPORTED_MODULE_24__.SelectProvider),
/* harmony export */   "SelectSeparator": () => (/* reexport safe */ _tamagui_select__WEBPACK_IMPORTED_MODULE_24__.SelectSeparator),
/* harmony export */   "SelectTrigger": () => (/* reexport safe */ _tamagui_select__WEBPACK_IMPORTED_MODULE_24__.SelectTrigger),
/* harmony export */   "Separator": () => (/* reexport safe */ _tamagui_separator__WEBPACK_IMPORTED_MODULE_25__.Separator),
/* harmony export */   "Sheet": () => (/* reexport safe */ _tamagui_sheet__WEBPACK_IMPORTED_MODULE_27__.Sheet),
/* harmony export */   "SheetController": () => (/* reexport safe */ _tamagui_sheet__WEBPACK_IMPORTED_MODULE_27__.SheetController),
/* harmony export */   "SheetFrame": () => (/* reexport safe */ _tamagui_sheet__WEBPACK_IMPORTED_MODULE_27__.SheetFrame),
/* harmony export */   "SheetFrameFrame": () => (/* reexport safe */ _tamagui_sheet__WEBPACK_IMPORTED_MODULE_27__.SheetFrameFrame),
/* harmony export */   "SheetHandle": () => (/* reexport safe */ _tamagui_sheet__WEBPACK_IMPORTED_MODULE_27__.SheetHandle),
/* harmony export */   "SheetHandleFrame": () => (/* reexport safe */ _tamagui_sheet__WEBPACK_IMPORTED_MODULE_27__.SheetHandleFrame),
/* harmony export */   "SheetOverlay": () => (/* reexport safe */ _tamagui_sheet__WEBPACK_IMPORTED_MODULE_27__.SheetOverlay),
/* harmony export */   "SheetOverlayFrame": () => (/* reexport safe */ _tamagui_sheet__WEBPACK_IMPORTED_MODULE_27__.SheetOverlayFrame),
/* harmony export */   "SizableStack": () => (/* reexport safe */ _tamagui_stacks__WEBPACK_IMPORTED_MODULE_29__.SizableStack),
/* harmony export */   "Slider": () => (/* reexport safe */ _tamagui_slider__WEBPACK_IMPORTED_MODULE_28__.Slider),
/* harmony export */   "SliderFrame": () => (/* reexport safe */ _tamagui_slider__WEBPACK_IMPORTED_MODULE_28__.SliderFrame),
/* harmony export */   "SliderThumb": () => (/* reexport safe */ _tamagui_slider__WEBPACK_IMPORTED_MODULE_28__.SliderThumb),
/* harmony export */   "SliderThumbFrame": () => (/* reexport safe */ _tamagui_slider__WEBPACK_IMPORTED_MODULE_28__.SliderThumbFrame),
/* harmony export */   "SliderTrack": () => (/* reexport safe */ _tamagui_slider__WEBPACK_IMPORTED_MODULE_28__.SliderTrack),
/* harmony export */   "SliderTrackActive": () => (/* reexport safe */ _tamagui_slider__WEBPACK_IMPORTED_MODULE_28__.SliderTrackActive),
/* harmony export */   "SliderTrackActiveFrame": () => (/* reexport safe */ _tamagui_slider__WEBPACK_IMPORTED_MODULE_28__.SliderTrackActiveFrame),
/* harmony export */   "SliderTrackFrame": () => (/* reexport safe */ _tamagui_slider__WEBPACK_IMPORTED_MODULE_28__.SliderTrackFrame),
/* harmony export */   "Spacer": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_54__.Spacer),
/* harmony export */   "Spinner": () => (/* reexport safe */ _views_Spinner__WEBPACK_IMPORTED_MODULE_50__.Spinner),
/* harmony export */   "Square": () => (/* reexport safe */ _tamagui_shapes__WEBPACK_IMPORTED_MODULE_26__.Square),
/* harmony export */   "Stack": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_55__.Stack),
/* harmony export */   "Switch": () => (/* reexport safe */ _tamagui_switch__WEBPACK_IMPORTED_MODULE_30__.Switch),
/* harmony export */   "SwitchFrame": () => (/* reexport safe */ _tamagui_switch__WEBPACK_IMPORTED_MODULE_30__.SwitchFrame),
/* harmony export */   "SwitchThumb": () => (/* reexport safe */ _tamagui_switch__WEBPACK_IMPORTED_MODULE_30__.SwitchThumb),
/* harmony export */   "SwitchThumbFrame": () => (/* reexport safe */ _tamagui_switch__WEBPACK_IMPORTED_MODULE_30__.SwitchThumbFrame),
/* harmony export */   "Tabs": () => (/* reexport safe */ _tamagui_tabs__WEBPACK_IMPORTED_MODULE_31__.Tabs),
/* harmony export */   "TamaguiProvider": () => (/* reexport safe */ _views_TamaguiProvider__WEBPACK_IMPORTED_MODULE_42__.TamaguiProvider),
/* harmony export */   "Text": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_55__.Text),
/* harmony export */   "TextAncestorContext": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_56__.TextAncestorContext),
/* harmony export */   "TextArea": () => (/* reexport safe */ _views_TextArea__WEBPACK_IMPORTED_MODULE_51__.TextArea),
/* harmony export */   "TextAreaFrame": () => (/* reexport safe */ _views_TextArea__WEBPACK_IMPORTED_MODULE_51__.TextAreaFrame),
/* harmony export */   "Theme": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_57__.Theme),
/* harmony export */   "ThemeableStack": () => (/* reexport safe */ _tamagui_stacks__WEBPACK_IMPORTED_MODULE_29__.ThemeableStack),
/* harmony export */   "Thumb": () => (/* reexport safe */ _tamagui_slider__WEBPACK_IMPORTED_MODULE_28__.Thumb),
/* harmony export */   "ToggleGroup": () => (/* reexport safe */ _tamagui_toggle_group__WEBPACK_IMPORTED_MODULE_34__.ToggleGroup),
/* harmony export */   "Tooltip": () => (/* reexport safe */ _tamagui_tooltip__WEBPACK_IMPORTED_MODULE_35__.Tooltip),
/* harmony export */   "TooltipGroup": () => (/* reexport safe */ _tamagui_tooltip__WEBPACK_IMPORTED_MODULE_35__.TooltipGroup),
/* harmony export */   "TooltipSimple": () => (/* reexport safe */ _tamagui_tooltip__WEBPACK_IMPORTED_MODULE_35__.TooltipSimple),
/* harmony export */   "Track": () => (/* reexport safe */ _tamagui_slider__WEBPACK_IMPORTED_MODULE_28__.Track),
/* harmony export */   "Unspaced": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_54__.Unspaced),
/* harmony export */   "VisuallyHidden": () => (/* reexport safe */ _tamagui_visually_hidden__WEBPACK_IMPORTED_MODULE_40__.VisuallyHidden),
/* harmony export */   "XGroup": () => (/* reexport safe */ _tamagui_group__WEBPACK_IMPORTED_MODULE_13__.XGroup),
/* harmony export */   "XStack": () => (/* reexport safe */ _tamagui_stacks__WEBPACK_IMPORTED_MODULE_29__.XStack),
/* harmony export */   "YGroup": () => (/* reexport safe */ _tamagui_group__WEBPACK_IMPORTED_MODULE_13__.YGroup),
/* harmony export */   "YStack": () => (/* reexport safe */ _tamagui_stacks__WEBPACK_IMPORTED_MODULE_29__.YStack),
/* harmony export */   "ZStack": () => (/* reexport safe */ _tamagui_stacks__WEBPACK_IMPORTED_MODULE_29__.ZStack),
/* harmony export */   "__PopoverProviderInternal": () => (/* reexport safe */ _tamagui_popover__WEBPACK_IMPORTED_MODULE_18__.__PopoverProviderInternal),
/* harmony export */   "addTheme": () => (/* reexport safe */ _tamagui_theme__WEBPACK_IMPORTED_MODULE_33__.addTheme),
/* harmony export */   "buttonStaticConfig": () => (/* reexport safe */ _tamagui_button__WEBPACK_IMPORTED_MODULE_5__.buttonStaticConfig),
/* harmony export */   "composeRefs": () => (/* reexport safe */ _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_8__.composeRefs),
/* harmony export */   "createAlertDialogScope": () => (/* reexport safe */ _tamagui_alert_dialog__WEBPACK_IMPORTED_MODULE_2__.createAlertDialogScope),
/* harmony export */   "createAvatarScope": () => (/* reexport safe */ _tamagui_avatar__WEBPACK_IMPORTED_MODULE_4__.createAvatarScope),
/* harmony export */   "createButtonScope": () => (/* reexport safe */ _tamagui_button__WEBPACK_IMPORTED_MODULE_5__.createButtonScope),
/* harmony export */   "createCheckboxScope": () => (/* reexport safe */ _tamagui_checkbox__WEBPACK_IMPORTED_MODULE_7__.createCheckboxScope),
/* harmony export */   "createComponent": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_54__.createComponent),
/* harmony export */   "createContext": () => (/* reexport safe */ _tamagui_create_context__WEBPACK_IMPORTED_MODULE_9__.createContext),
/* harmony export */   "createContextScope": () => (/* reexport safe */ _tamagui_create_context__WEBPACK_IMPORTED_MODULE_9__.createContextScope),
/* harmony export */   "createDialogScope": () => (/* reexport safe */ _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__.createDialogScope),
/* harmony export */   "createFont": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_58__.createFont),
/* harmony export */   "createPopoverScope": () => (/* reexport safe */ _tamagui_popover__WEBPACK_IMPORTED_MODULE_18__.createPopoverScope),
/* harmony export */   "createPopperScope": () => (/* reexport safe */ _tamagui_popper__WEBPACK_IMPORTED_MODULE_19__.createPopperScope),
/* harmony export */   "createProgressScope": () => (/* reexport safe */ _tamagui_progress__WEBPACK_IMPORTED_MODULE_21__.createProgressScope),
/* harmony export */   "createRadioGroupScope": () => (/* reexport safe */ _tamagui_radio_group__WEBPACK_IMPORTED_MODULE_22__.createRadioGroupScope),
/* harmony export */   "createSelectContext": () => (/* reexport safe */ _tamagui_select__WEBPACK_IMPORTED_MODULE_24__.createSelectContext),
/* harmony export */   "createSelectScope": () => (/* reexport safe */ _tamagui_select__WEBPACK_IMPORTED_MODULE_24__.createSelectScope),
/* harmony export */   "createSheetScope": () => (/* reexport safe */ _tamagui_sheet__WEBPACK_IMPORTED_MODULE_27__.createSheetScope),
/* harmony export */   "createShorthands": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_59__.createShorthands),
/* harmony export */   "createSwitchScope": () => (/* reexport safe */ _tamagui_switch__WEBPACK_IMPORTED_MODULE_30__.createSwitchScope),
/* harmony export */   "createTamagui": () => (/* reexport safe */ _createTamagui__WEBPACK_IMPORTED_MODULE_41__.createTamagui),
/* harmony export */   "createTheme": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_60__.createTheme),
/* harmony export */   "createToggleGroupScope": () => (/* reexport safe */ _tamagui_toggle_group__WEBPACK_IMPORTED_MODULE_34__.createToggleGroupScope),
/* harmony export */   "createTokens": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_61__.createTokens),
/* harmony export */   "createVariable": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_62__.createVariable),
/* harmony export */   "debounce": () => (/* reexport safe */ _tamagui_use_debounce__WEBPACK_IMPORTED_MODULE_37__.debounce),
/* harmony export */   "defaultStyles": () => (/* reexport safe */ _views_Input__WEBPACK_IMPORTED_MODULE_48__.defaultStyles),
/* harmony export */   "fullscreenStyle": () => (/* reexport safe */ _tamagui_stacks__WEBPACK_IMPORTED_MODULE_29__.fullscreenStyle),
/* harmony export */   "getAnimationDriver": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_63__.getAnimationDriver),
/* harmony export */   "getConfig": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_64__.getConfig),
/* harmony export */   "getFontSize": () => (/* reexport safe */ _tamagui_font_size__WEBPACK_IMPORTED_MODULE_11__.getFontSize),
/* harmony export */   "getFontSizeToken": () => (/* reexport safe */ _tamagui_font_size__WEBPACK_IMPORTED_MODULE_11__.getFontSizeToken),
/* harmony export */   "getFontSizeVariable": () => (/* reexport safe */ _tamagui_font_size__WEBPACK_IMPORTED_MODULE_11__.getFontSizeVariable),
/* harmony export */   "getMedia": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_65__.getMedia),
/* harmony export */   "getShapeSize": () => (/* reexport safe */ _tamagui_shapes__WEBPACK_IMPORTED_MODULE_26__.getShapeSize),
/* harmony export */   "getState": () => (/* reexport safe */ _tamagui_checkbox__WEBPACK_IMPORTED_MODULE_7__.getState),
/* harmony export */   "getStylesAtomic": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_66__.getStylesAtomic),
/* harmony export */   "getThemes": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_64__.getThemes),
/* harmony export */   "getTokens": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_64__.getTokens),
/* harmony export */   "getVariable": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_62__.getVariable),
/* harmony export */   "getVariableName": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_62__.getVariableName),
/* harmony export */   "getVariableValue": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_62__.getVariableValue),
/* harmony export */   "idFn": () => (/* reexport safe */ _setup__WEBPACK_IMPORTED_MODULE_0__.idFn),
/* harmony export */   "insertFont": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_67__.insertFont),
/* harmony export */   "isChrome": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_68__.isChrome),
/* harmony export */   "isClient": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_68__.isClient),
/* harmony export */   "isIndeterminate": () => (/* reexport safe */ _tamagui_checkbox__WEBPACK_IMPORTED_MODULE_7__.isIndeterminate),
/* harmony export */   "isPresent": () => (/* reexport safe */ _tamagui_animate_presence__WEBPACK_IMPORTED_MODULE_3__.isPresent),
/* harmony export */   "isServer": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_68__.isServer),
/* harmony export */   "isServerSide": () => (/* reexport safe */ _tamagui_use_force_update__WEBPACK_IMPORTED_MODULE_38__.isServerSide),
/* harmony export */   "isTamaguiComponent": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_69__.isTamaguiComponent),
/* harmony export */   "isTamaguiElement": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_70__.isTamaguiElement),
/* harmony export */   "isTouchable": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_68__.isTouchable),
/* harmony export */   "isVariable": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_62__.isVariable),
/* harmony export */   "isWeb": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_68__.isWeb),
/* harmony export */   "isWebTouchable": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_68__.isWebTouchable),
/* harmony export */   "listItemStaticConfig": () => (/* reexport safe */ _tamagui_list_item__WEBPACK_IMPORTED_MODULE_17__.listItemStaticConfig),
/* harmony export */   "matchMedia": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_71__.matchMedia),
/* harmony export */   "mediaObjectToString": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_65__.mediaObjectToString),
/* harmony export */   "mediaQueryConfig": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_65__.mediaQueryConfig),
/* harmony export */   "mediaState": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_65__.mediaState),
/* harmony export */   "spacedChildren": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_54__.spacedChildren),
/* harmony export */   "styled": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_72__.styled),
/* harmony export */   "themeable": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_73__.themeable),
/* harmony export */   "updateTheme": () => (/* reexport safe */ _tamagui_theme__WEBPACK_IMPORTED_MODULE_33__.updateTheme),
/* harmony export */   "useAdaptParent": () => (/* reexport safe */ _tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__.useAdaptParent),
/* harmony export */   "useButton": () => (/* reexport safe */ _tamagui_button__WEBPACK_IMPORTED_MODULE_5__.useButton),
/* harmony export */   "useComposedRefs": () => (/* reexport safe */ _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_8__.useComposedRefs),
/* harmony export */   "useControllableState": () => (/* reexport safe */ _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_36__.useControllableState),
/* harmony export */   "useDebounce": () => (/* reexport safe */ _tamagui_use_debounce__WEBPACK_IMPORTED_MODULE_37__.useDebounce),
/* harmony export */   "useDebounceValue": () => (/* reexport safe */ _tamagui_use_debounce__WEBPACK_IMPORTED_MODULE_37__.useDebounceValue),
/* harmony export */   "useDidFinishSSR": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_74__.useDidFinishSSR),
/* harmony export */   "useEvent": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_75__.useEvent),
/* harmony export */   "useFloatingContext": () => (/* reexport safe */ _tamagui_popover__WEBPACK_IMPORTED_MODULE_18__.useFloatingContext),
/* harmony export */   "useForceUpdate": () => (/* reexport safe */ _tamagui_use_force_update__WEBPACK_IMPORTED_MODULE_38__.useForceUpdate),
/* harmony export */   "useFormContext": () => (/* reexport safe */ _tamagui_form__WEBPACK_IMPORTED_MODULE_12__.useFormContext),
/* harmony export */   "useGet": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_75__.useGet),
/* harmony export */   "useGroupItem": () => (/* reexport safe */ _tamagui_group__WEBPACK_IMPORTED_MODULE_13__.useGroupItem),
/* harmony export */   "useIsPresent": () => (/* reexport safe */ _tamagui_animate_presence__WEBPACK_IMPORTED_MODULE_3__.useIsPresent),
/* harmony export */   "useIsTouchDevice": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_76__.useIsTouchDevice),
/* harmony export */   "useIsomorphicLayoutEffect": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_68__.useIsomorphicLayoutEffect),
/* harmony export */   "useLabelContext": () => (/* reexport safe */ _tamagui_label__WEBPACK_IMPORTED_MODULE_16__.useLabelContext),
/* harmony export */   "useListItem": () => (/* reexport safe */ _tamagui_list_item__WEBPACK_IMPORTED_MODULE_17__.useListItem),
/* harmony export */   "useMedia": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_65__.useMedia),
/* harmony export */   "usePopoverScope": () => (/* reexport safe */ _tamagui_popover__WEBPACK_IMPORTED_MODULE_18__.usePopoverScope),
/* harmony export */   "usePopperContext": () => (/* reexport safe */ _tamagui_popper__WEBPACK_IMPORTED_MODULE_19__.usePopperContext),
/* harmony export */   "usePresence": () => (/* reexport safe */ _tamagui_animate_presence__WEBPACK_IMPORTED_MODULE_3__.usePresence),
/* harmony export */   "useSafeRef": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_77__.useSafeRef),
/* harmony export */   "useSelectContext": () => (/* reexport safe */ _tamagui_select__WEBPACK_IMPORTED_MODULE_24__.useSelectContext),
/* harmony export */   "useStyle": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_78__.useStyle),
/* harmony export */   "useTheme": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_79__.useTheme),
/* harmony export */   "useThemeName": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_80__.useThemeName),
/* harmony export */   "useWindowDimensions": () => (/* reexport safe */ _tamagui_use_window_dimensions__WEBPACK_IMPORTED_MODULE_39__.useWindowDimensions),
/* harmony export */   "variableToString": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_62__.variableToString),
/* harmony export */   "withStaticProperties": () => (/* reexport safe */ _tamagui_core__WEBPACK_IMPORTED_MODULE_81__.withStaticProperties)
/* harmony export */ });
/* harmony import */ var _setup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setup */ "../../node_modules/tamagui/dist/esm/setup.mjs");
/* harmony import */ var _tamagui_adapt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/adapt */ "../../node_modules/@tamagui/adapt/dist/esm/index.mjs");
/* harmony import */ var _tamagui_alert_dialog__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/alert-dialog */ "../../node_modules/@tamagui/alert-dialog/dist/esm/index.mjs");
/* harmony import */ var _tamagui_animate_presence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/animate-presence */ "../../node_modules/@tamagui/animate-presence/dist/esm/index.mjs");
/* harmony import */ var _tamagui_avatar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/avatar */ "../../node_modules/@tamagui/avatar/dist/esm/index.mjs");
/* harmony import */ var _tamagui_button__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/button */ "../../node_modules/@tamagui/button/dist/esm/index.mjs");
/* harmony import */ var _tamagui_card__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tamagui/card */ "../../node_modules/@tamagui/card/dist/esm/index.mjs");
/* harmony import */ var _tamagui_checkbox__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tamagui/checkbox */ "../../node_modules/@tamagui/checkbox/dist/esm/index.mjs");
/* harmony import */ var _tamagui_compose_refs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tamagui/compose-refs */ "../../node_modules/@tamagui/compose-refs/dist/esm/index.mjs");
/* harmony import */ var _tamagui_create_context__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tamagui/create-context */ "../../node_modules/@tamagui/create-context/dist/esm/index.mjs");
/* harmony import */ var _tamagui_dialog__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tamagui/dialog */ "../../node_modules/@tamagui/dialog/dist/esm/index.mjs");
/* harmony import */ var _tamagui_font_size__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tamagui/font-size */ "../../node_modules/@tamagui/font-size/dist/esm/index.mjs");
/* harmony import */ var _tamagui_form__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tamagui/form */ "../../node_modules/@tamagui/form/dist/esm/index.js");
/* harmony import */ var _tamagui_group__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tamagui/group */ "../../node_modules/@tamagui/group/dist/esm/index.mjs");
/* harmony import */ var _tamagui_helpers_tamagui__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tamagui/helpers-tamagui */ "../../node_modules/@tamagui/helpers-tamagui/dist/esm/index.mjs");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _tamagui_helpers_tamagui__WEBPACK_IMPORTED_MODULE_14__) if(["default","AnimationDriverProvider","FontLanguage","LinearGradient","Spacer","Stack","Text","TextAncestorContext","Theme","Unspaced","createComponent","createFont","createShorthands","createTheme","createTokens","createVariable","getAnimationDriver","getConfig","getMedia","getStylesAtomic","getThemes","getTokens","getVariable","getVariableName","getVariableValue","insertFont","isChrome","isClient","isServer","isTamaguiComponent","isTamaguiElement","isTouchable","isVariable","isWeb","isWebTouchable","matchMedia","mediaObjectToString","mediaQueryConfig","mediaState","spacedChildren","styled","themeable","useDidFinishSSR","useEvent","useGet","useIsTouchDevice","useIsomorphicLayoutEffect","useMedia","useSafeRef","useStyle","useTheme","useThemeName","variableToString","withStaticProperties","idFn","Adapt","AdaptContents","AdaptParentContext","useAdaptParent","AlertDialog","AlertDialogAction","AlertDialogCancel","AlertDialogContent","AlertDialogDescription","AlertDialogOverlay","AlertDialogPortal","AlertDialogTitle","AlertDialogTrigger","createAlertDialogScope","AnimatePresence","PresenceContext","isPresent","useIsPresent","usePresence","Avatar","AvatarFallback","AvatarFallbackFrame","AvatarFrame","AvatarImage","createAvatarScope","Button","ButtonFrame","ButtonText","buttonStaticConfig","createButtonScope","useButton","Card","CardBackground","CardFooter","CardFrame","CardHeader","BubbleInput","Checkbox","CheckboxFrame","createCheckboxScope","getState","isIndeterminate","composeRefs","useComposedRefs","createContext","createContextScope","Dialog","DialogClose","DialogContent","DialogDescription","DialogOverlay","DialogOverlayFrame","DialogPortal","DialogPortalFrame","DialogSheetContents","DialogTitle","DialogTrigger","DialogWarningProvider","createDialogScope","getFontSize","getFontSizeToken","getFontSizeVariable","Form","FormFrame","FormProvider","FormTrigger","useFormContext","Group","GroupFrame","XGroup","YGroup","useGroupItem"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _tamagui_helpers_tamagui__WEBPACK_IMPORTED_MODULE_14__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _tamagui_image__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tamagui/image */ "../../node_modules/@tamagui/image/dist/esm/index.mjs");
/* harmony import */ var _tamagui_label__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tamagui/label */ "../../node_modules/@tamagui/label/dist/esm/index.mjs");
/* harmony import */ var _tamagui_list_item__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tamagui/list-item */ "../../node_modules/@tamagui/list-item/dist/esm/index.mjs");
/* harmony import */ var _tamagui_popover__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @tamagui/popover */ "../../node_modules/@tamagui/popover/dist/esm/index.mjs");
/* harmony import */ var _tamagui_popper__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @tamagui/popper */ "../../node_modules/@tamagui/popper/dist/esm/index.mjs");
/* harmony import */ var _tamagui_portal__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @tamagui/portal */ "../../node_modules/@tamagui/portal/dist/esm/index.mjs");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _tamagui_portal__WEBPACK_IMPORTED_MODULE_20__) if(["default","AnimationDriverProvider","FontLanguage","LinearGradient","Spacer","Stack","Text","TextAncestorContext","Theme","Unspaced","createComponent","createFont","createShorthands","createTheme","createTokens","createVariable","getAnimationDriver","getConfig","getMedia","getStylesAtomic","getThemes","getTokens","getVariable","getVariableName","getVariableValue","insertFont","isChrome","isClient","isServer","isTamaguiComponent","isTamaguiElement","isTouchable","isVariable","isWeb","isWebTouchable","matchMedia","mediaObjectToString","mediaQueryConfig","mediaState","spacedChildren","styled","themeable","useDidFinishSSR","useEvent","useGet","useIsTouchDevice","useIsomorphicLayoutEffect","useMedia","useSafeRef","useStyle","useTheme","useThemeName","variableToString","withStaticProperties","idFn","Adapt","AdaptContents","AdaptParentContext","useAdaptParent","AlertDialog","AlertDialogAction","AlertDialogCancel","AlertDialogContent","AlertDialogDescription","AlertDialogOverlay","AlertDialogPortal","AlertDialogTitle","AlertDialogTrigger","createAlertDialogScope","AnimatePresence","PresenceContext","isPresent","useIsPresent","usePresence","Avatar","AvatarFallback","AvatarFallbackFrame","AvatarFrame","AvatarImage","createAvatarScope","Button","ButtonFrame","ButtonText","buttonStaticConfig","createButtonScope","useButton","Card","CardBackground","CardFooter","CardFrame","CardHeader","BubbleInput","Checkbox","CheckboxFrame","createCheckboxScope","getState","isIndeterminate","composeRefs","useComposedRefs","createContext","createContextScope","Dialog","DialogClose","DialogContent","DialogDescription","DialogOverlay","DialogOverlayFrame","DialogPortal","DialogPortalFrame","DialogSheetContents","DialogTitle","DialogTrigger","DialogWarningProvider","createDialogScope","getFontSize","getFontSizeToken","getFontSizeVariable","Form","FormFrame","FormProvider","FormTrigger","useFormContext","Group","GroupFrame","XGroup","YGroup","useGroupItem","getSpace","prevent","useCurrentColor","useGetThemedIcon","Image","Label","LabelFrame","useLabelContext","ListItem","ListItemFrame","ListItemSubtitle","ListItemText","ListItemTitle","listItemStaticConfig","useListItem","Popover","PopoverAnchor","PopoverArrow","PopoverClose","PopoverContent","PopoverTrigger","__PopoverProviderInternal","createPopoverScope","useFloatingContext","usePopoverScope","Popper","PopperAnchor","PopperArrow","PopperContent","PopperContentFrame","PopperProvider","createPopperScope","usePopperContext"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _tamagui_portal__WEBPACK_IMPORTED_MODULE_20__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _tamagui_progress__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @tamagui/progress */ "../../node_modules/@tamagui/progress/dist/esm/index.mjs");
/* harmony import */ var _tamagui_radio_group__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @tamagui/radio-group */ "../../node_modules/@tamagui/radio-group/dist/esm/index.mjs");
/* harmony import */ var _tamagui_scroll_view__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @tamagui/scroll-view */ "../../node_modules/@tamagui/scroll-view/dist/esm/index.mjs");
/* harmony import */ var _tamagui_select__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @tamagui/select */ "../../node_modules/@tamagui/select/dist/esm/index.mjs");
/* harmony import */ var _tamagui_separator__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @tamagui/separator */ "../../node_modules/@tamagui/separator/dist/esm/index.mjs");
/* harmony import */ var _tamagui_shapes__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @tamagui/shapes */ "../../node_modules/@tamagui/shapes/dist/esm/index.mjs");
/* harmony import */ var _tamagui_sheet__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @tamagui/sheet */ "../../node_modules/@tamagui/sheet/dist/esm/index.mjs");
/* harmony import */ var _tamagui_slider__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @tamagui/slider */ "../../node_modules/@tamagui/slider/dist/esm/index.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/index.mjs");
/* harmony import */ var _tamagui_switch__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @tamagui/switch */ "../../node_modules/@tamagui/switch/dist/esm/index.mjs");
/* harmony import */ var _tamagui_tabs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @tamagui/tabs */ "../../node_modules/@tamagui/tabs/dist/esm/index.mjs");
/* harmony import */ var _tamagui_text__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! @tamagui/text */ "../../node_modules/@tamagui/text/dist/esm/index.mjs");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _tamagui_text__WEBPACK_IMPORTED_MODULE_32__) if(["default","AnimationDriverProvider","FontLanguage","LinearGradient","Spacer","Stack","Text","TextAncestorContext","Theme","Unspaced","createComponent","createFont","createShorthands","createTheme","createTokens","createVariable","getAnimationDriver","getConfig","getMedia","getStylesAtomic","getThemes","getTokens","getVariable","getVariableName","getVariableValue","insertFont","isChrome","isClient","isServer","isTamaguiComponent","isTamaguiElement","isTouchable","isVariable","isWeb","isWebTouchable","matchMedia","mediaObjectToString","mediaQueryConfig","mediaState","spacedChildren","styled","themeable","useDidFinishSSR","useEvent","useGet","useIsTouchDevice","useIsomorphicLayoutEffect","useMedia","useSafeRef","useStyle","useTheme","useThemeName","variableToString","withStaticProperties","idFn","Adapt","AdaptContents","AdaptParentContext","useAdaptParent","AlertDialog","AlertDialogAction","AlertDialogCancel","AlertDialogContent","AlertDialogDescription","AlertDialogOverlay","AlertDialogPortal","AlertDialogTitle","AlertDialogTrigger","createAlertDialogScope","AnimatePresence","PresenceContext","isPresent","useIsPresent","usePresence","Avatar","AvatarFallback","AvatarFallbackFrame","AvatarFrame","AvatarImage","createAvatarScope","Button","ButtonFrame","ButtonText","buttonStaticConfig","createButtonScope","useButton","Card","CardBackground","CardFooter","CardFrame","CardHeader","BubbleInput","Checkbox","CheckboxFrame","createCheckboxScope","getState","isIndeterminate","composeRefs","useComposedRefs","createContext","createContextScope","Dialog","DialogClose","DialogContent","DialogDescription","DialogOverlay","DialogOverlayFrame","DialogPortal","DialogPortalFrame","DialogSheetContents","DialogTitle","DialogTrigger","DialogWarningProvider","createDialogScope","getFontSize","getFontSizeToken","getFontSizeVariable","Form","FormFrame","FormProvider","FormTrigger","useFormContext","Group","GroupFrame","XGroup","YGroup","useGroupItem","getSpace","prevent","useCurrentColor","useGetThemedIcon","Image","Label","LabelFrame","useLabelContext","ListItem","ListItemFrame","ListItemSubtitle","ListItemText","ListItemTitle","listItemStaticConfig","useListItem","Popover","PopoverAnchor","PopoverArrow","PopoverClose","PopoverContent","PopoverTrigger","__PopoverProviderInternal","createPopoverScope","useFloatingContext","usePopoverScope","Popper","PopperAnchor","PopperArrow","PopperContent","PopperContentFrame","PopperProvider","createPopperScope","usePopperContext","ACTIONS","INITIAL_STATE","Portal","PortalHost","PortalItem","PortalProvider","usePortal","Progress","ProgressFrame","ProgressIndicator","ProgressIndicatorFrame","createProgressScope","RadioGroup","createRadioGroupScope","ScrollView","ForwardSelectContext","Select","SelectGroupFrame","SelectIcon","SelectItem","SelectItemTextFrame","SelectProvider","SelectSeparator","SelectTrigger","createSelectContext","createSelectScope","useSelectContext","Separator","Circle","Square","getShapeSize","ControlledSheet","Sheet","SheetController","SheetFrame","SheetFrameFrame","SheetHandle","SheetHandleFrame","SheetOverlay","SheetOverlayFrame","createSheetScope","DirectionalYStack","Range","Slider","SliderFrame","SliderThumb","SliderThumbFrame","SliderTrack","SliderTrackActive","SliderTrackActiveFrame","SliderTrackFrame","Thumb","Track","SizableStack","ThemeableStack","XStack","YStack","ZStack","fullscreenStyle","Switch","SwitchFrame","SwitchThumb","SwitchThumbFrame","createSwitchScope","Tabs"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _tamagui_text__WEBPACK_IMPORTED_MODULE_32__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _tamagui_theme__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! @tamagui/theme */ "../../node_modules/@tamagui/theme/dist/esm/index.mjs");
/* harmony import */ var _tamagui_toggle_group__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! @tamagui/toggle-group */ "../../node_modules/@tamagui/toggle-group/dist/esm/index.js");
/* harmony import */ var _tamagui_tooltip__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! @tamagui/tooltip */ "../../node_modules/@tamagui/tooltip/dist/esm/index.mjs");
/* harmony import */ var _tamagui_use_controllable_state__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! @tamagui/use-controllable-state */ "../../node_modules/@tamagui/use-controllable-state/dist/esm/index.mjs");
/* harmony import */ var _tamagui_use_debounce__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! @tamagui/use-debounce */ "../../node_modules/@tamagui/use-debounce/dist/esm/index.mjs");
/* harmony import */ var _tamagui_use_force_update__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! @tamagui/use-force-update */ "../../node_modules/@tamagui/use-force-update/dist/esm/index.mjs");
/* harmony import */ var _tamagui_use_window_dimensions__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! @tamagui/use-window-dimensions */ "../../node_modules/@tamagui/use-window-dimensions/dist/esm/index.mjs");
/* harmony import */ var _tamagui_visually_hidden__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! @tamagui/visually-hidden */ "../../node_modules/@tamagui/visually-hidden/dist/esm/index.mjs");
/* harmony import */ var _createTamagui__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./createTamagui */ "../../node_modules/tamagui/dist/esm/createTamagui.mjs");
/* harmony import */ var _views_TamaguiProvider__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./views/TamaguiProvider */ "../../node_modules/tamagui/dist/esm/views/TamaguiProvider.mjs");
/* harmony import */ var _viewTypes__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./viewTypes */ "../../node_modules/tamagui/dist/esm/viewTypes.mjs");
/* harmony import */ var _viewTypes__WEBPACK_IMPORTED_MODULE_43___default = /*#__PURE__*/__webpack_require__.n(_viewTypes__WEBPACK_IMPORTED_MODULE_43__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _viewTypes__WEBPACK_IMPORTED_MODULE_43__) if(["default","AnimationDriverProvider","FontLanguage","LinearGradient","Spacer","Stack","Text","TextAncestorContext","Theme","Unspaced","createComponent","createFont","createShorthands","createTheme","createTokens","createVariable","getAnimationDriver","getConfig","getMedia","getStylesAtomic","getThemes","getTokens","getVariable","getVariableName","getVariableValue","insertFont","isChrome","isClient","isServer","isTamaguiComponent","isTamaguiElement","isTouchable","isVariable","isWeb","isWebTouchable","matchMedia","mediaObjectToString","mediaQueryConfig","mediaState","spacedChildren","styled","themeable","useDidFinishSSR","useEvent","useGet","useIsTouchDevice","useIsomorphicLayoutEffect","useMedia","useSafeRef","useStyle","useTheme","useThemeName","variableToString","withStaticProperties","idFn","Adapt","AdaptContents","AdaptParentContext","useAdaptParent","AlertDialog","AlertDialogAction","AlertDialogCancel","AlertDialogContent","AlertDialogDescription","AlertDialogOverlay","AlertDialogPortal","AlertDialogTitle","AlertDialogTrigger","createAlertDialogScope","AnimatePresence","PresenceContext","isPresent","useIsPresent","usePresence","Avatar","AvatarFallback","AvatarFallbackFrame","AvatarFrame","AvatarImage","createAvatarScope","Button","ButtonFrame","ButtonText","buttonStaticConfig","createButtonScope","useButton","Card","CardBackground","CardFooter","CardFrame","CardHeader","BubbleInput","Checkbox","CheckboxFrame","createCheckboxScope","getState","isIndeterminate","composeRefs","useComposedRefs","createContext","createContextScope","Dialog","DialogClose","DialogContent","DialogDescription","DialogOverlay","DialogOverlayFrame","DialogPortal","DialogPortalFrame","DialogSheetContents","DialogTitle","DialogTrigger","DialogWarningProvider","createDialogScope","getFontSize","getFontSizeToken","getFontSizeVariable","Form","FormFrame","FormProvider","FormTrigger","useFormContext","Group","GroupFrame","XGroup","YGroup","useGroupItem","getSpace","prevent","useCurrentColor","useGetThemedIcon","Image","Label","LabelFrame","useLabelContext","ListItem","ListItemFrame","ListItemSubtitle","ListItemText","ListItemTitle","listItemStaticConfig","useListItem","Popover","PopoverAnchor","PopoverArrow","PopoverClose","PopoverContent","PopoverTrigger","__PopoverProviderInternal","createPopoverScope","useFloatingContext","usePopoverScope","Popper","PopperAnchor","PopperArrow","PopperContent","PopperContentFrame","PopperProvider","createPopperScope","usePopperContext","ACTIONS","INITIAL_STATE","Portal","PortalHost","PortalItem","PortalProvider","usePortal","Progress","ProgressFrame","ProgressIndicator","ProgressIndicatorFrame","createProgressScope","RadioGroup","createRadioGroupScope","ScrollView","ForwardSelectContext","Select","SelectGroupFrame","SelectIcon","SelectItem","SelectItemTextFrame","SelectProvider","SelectSeparator","SelectTrigger","createSelectContext","createSelectScope","useSelectContext","Separator","Circle","Square","getShapeSize","ControlledSheet","Sheet","SheetController","SheetFrame","SheetFrameFrame","SheetHandle","SheetHandleFrame","SheetOverlay","SheetOverlayFrame","createSheetScope","DirectionalYStack","Range","Slider","SliderFrame","SliderThumb","SliderThumbFrame","SliderTrack","SliderTrackActive","SliderTrackActiveFrame","SliderTrackFrame","Thumb","Track","SizableStack","ThemeableStack","XStack","YStack","ZStack","fullscreenStyle","Switch","SwitchFrame","SwitchThumb","SwitchThumbFrame","createSwitchScope","Tabs","H1","H2","H3","H4","H5","H6","Heading","Paragraph","SizableText","wrapChildrenInText","addTheme","updateTheme","ToggleGroup","createToggleGroupScope","Tooltip","TooltipGroup","TooltipSimple","useControllableState","debounce","useDebounce","useDebounceValue","isServerSide","useForceUpdate","useWindowDimensions","VisuallyHidden","createTamagui","TamaguiProvider"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _viewTypes__WEBPACK_IMPORTED_MODULE_43__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _views_Anchor__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./views/Anchor */ "../../node_modules/tamagui/dist/esm/views/Anchor.mjs");
/* harmony import */ var _views_EnsureFlexed__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./views/EnsureFlexed */ "../../node_modules/tamagui/dist/esm/views/EnsureFlexed.mjs");
/* harmony import */ var _views_Fieldset__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./views/Fieldset */ "../../node_modules/tamagui/dist/esm/views/Fieldset.mjs");
/* harmony import */ var _views_Grid__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./views/Grid */ "../../node_modules/tamagui/dist/esm/views/Grid.mjs");
/* harmony import */ var _views_Input__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./views/Input */ "../../node_modules/tamagui/dist/esm/views/Input.mjs");
/* harmony import */ var _views_Layouts__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./views/Layouts */ "../../node_modules/tamagui/dist/esm/views/Layouts.mjs");
/* harmony import */ var _views_Spinner__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./views/Spinner */ "../../node_modules/tamagui/dist/esm/views/Spinner.mjs");
/* harmony import */ var _views_TextArea__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./views/TextArea */ "../../node_modules/tamagui/dist/esm/views/TextArea.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/views/AnimationDriverProvider.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/views/FontLanguage.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createComponent.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/core/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/contexts/TextAncestorContext.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/views/Theme.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createFont.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createShorthands.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createTheme.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createTokens.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/getAnimationDriver.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/config.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useMedia.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/getStylesAtomic.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/insertFont.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/isTamaguiComponent.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/isTamaguiElement.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/matchMedia.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/themeable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/use-did-finish-ssr/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/use-event/dist/esm/index.mjs");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useIsTouchDevice.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useSafeRef.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useStyle.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useTheme.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useThemeName.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/withStaticProperties.js");





















































function LinearGradient(props) {
  if (true) {
    console.warn(`LinearGradient has been moved to tamagui/linear-gradient as of 1.1`);
  }
  return null;
}

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "../../node_modules/tamagui/dist/esm/setup.mjs":
/*!*****************************************************!*\
  !*** ../../node_modules/tamagui/dist/esm/setup.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "idFn": () => (/* binding */ idFn)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/setupReactNative.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-native */ "../../node_modules/react-native-web/dist/index.js");



globalThis.React = react__WEBPACK_IMPORTED_MODULE_0__;
(0,_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.setupReactNative)({
  View: react_native__WEBPACK_IMPORTED_MODULE_2__.View,
  Text: react_native__WEBPACK_IMPORTED_MODULE_2__.Text
});
if (typeof requestAnimationFrame === "undefined") {
  globalThis["requestAnimationFrame"] = setImmediate;
}
const cancelAnimationFrame = globalThis.cancelAnimationFrame;
__webpack_require__.g.cancelAnimationFrame = (x) => {
  try {
    cancelAnimationFrame(x);
  } catch {
  }
};
const idFn = () => {
};

//# sourceMappingURL=setup.mjs.map


/***/ }),

/***/ "../../node_modules/tamagui/dist/esm/viewTypes.mjs":
/*!*********************************************************!*\
  !*** ../../node_modules/tamagui/dist/esm/viewTypes.mjs ***!
  \*********************************************************/
/***/ (() => {

//# sourceMappingURL=viewTypes.mjs.map


/***/ }),

/***/ "../../node_modules/tamagui/dist/esm/views/Anchor.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/tamagui/dist/esm/views/Anchor.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Anchor": () => (/* binding */ Anchor)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/text */ "../../node_modules/@tamagui/text/dist/esm/SizableText.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-native */ "../../node_modules/react-native-web/dist/index.js");





const AnchorFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.styled)(_tamagui_text__WEBPACK_IMPORTED_MODULE_3__.SizableText, {
  name: "Anchor",
  tag: "a",
  accessibilityRole: "link"
});
const Anchor = AnchorFrame.extractable(
  (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ href, target, ...props }, ref) => {
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      AnchorFrame,
      {
        ...props,
        ..._tamagui_core__WEBPACK_IMPORTED_MODULE_4__.isWeb ? {
          href,
          target
        } : {
          onPress: (event) => {
            var _a;
            (_a = props.onPress) == null ? void 0 : _a.call(props, event);
            if (href !== void 0) {
              react_native__WEBPACK_IMPORTED_MODULE_5__.Linking.openURL(href);
            }
          }
        },
        ref
      }
    );
  })
);

//# sourceMappingURL=Anchor.mjs.map


/***/ }),

/***/ "../../node_modules/tamagui/dist/esm/views/EnsureFlexed.mjs":
/*!******************************************************************!*\
  !*** ../../node_modules/tamagui/dist/esm/views/EnsureFlexed.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EnsureFlexed": () => (/* binding */ EnsureFlexed)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/core/dist/esm/index.mjs");

const EnsureFlexed = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.Text, {
  opacity: 0,
  lineHeight: 0,
  height: 0,
  display: "flex",
  fontSize: 200,
  children: "wwwwwwwwwwwwwwwwwww",
  hoverStyle: {
    backgroundColor: "red"
  },
  pointerEvents: "none"
});
EnsureFlexed["isVisuallyHidden"] = true;

//# sourceMappingURL=EnsureFlexed.mjs.map


/***/ }),

/***/ "../../node_modules/tamagui/dist/esm/views/Fieldset.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/tamagui/dist/esm/views/Fieldset.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Fieldset": () => (/* binding */ Fieldset)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");


const Fieldset = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.styled)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_1__.YStack, {
  name: "Fieldset",
  tag: "fieldset",
  variants: {
    horizontal: {
      true: {
        flexDirection: "row",
        alignItems: "center"
      }
    }
  }
});

//# sourceMappingURL=Fieldset.mjs.map


/***/ }),

/***/ "../../node_modules/tamagui/dist/esm/views/Grid.mjs":
/*!**********************************************************!*\
  !*** ../../node_modules/tamagui/dist/esm/views/Grid.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Grid": () => (/* binding */ Grid)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/constants/dist/esm/index.mjs");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);




function Grid({ children, columns, itemMinWidth = 200, gap }) {
  if (_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.isWeb) {
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      "div",
      {
        style: {
          gap,
          display: "grid",
          justifyContent: "stretch",
          // gridTemplateRows: 'repeat(4, 1fr)',
          gridTemplateColumns: `repeat( auto-fit, minmax(${itemMinWidth}px, 1fr) )`
          // gridTemplateColumns: '1fr 1fr',
        },
        children
      }
    );
  }
  const childrenList = react__WEBPACK_IMPORTED_MODULE_1___default().Children.toArray(children);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_3__.XStack, { alignItems: "center", justifyContent: "center", flexWrap: "wrap", children: childrenList.map((child, i) => {
    if (!child) {
      return null;
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(
      _tamagui_stacks__WEBPACK_IMPORTED_MODULE_3__.XStack,
      {
        flex: 1,
        minWidth: itemMinWidth,
        marginRight: gap,
        marginBottom: gap,
        children: child
      },
      i
    );
  }) });
}

//# sourceMappingURL=Grid.mjs.map


/***/ }),

/***/ "../../node_modules/tamagui/dist/esm/views/Input.mjs":
/*!***********************************************************!*\
  !*** ../../node_modules/tamagui/dist/esm/views/Input.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Input": () => (/* binding */ Input),
/* harmony export */   "InputFrame": () => (/* binding */ InputFrame),
/* harmony export */   "defaultStyles": () => (/* binding */ defaultStyles)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/setupReactNative.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_focusable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/focusable */ "../../node_modules/@tamagui/focusable/dist/esm/focusableInputHOC.mjs");
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-native */ "../../node_modules/react-native-web/dist/index.js");
/* harmony import */ var _helpers_inputHelpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/inputHelpers */ "../../node_modules/tamagui/dist/esm/helpers/inputHelpers.mjs");




(0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.setupReactNative)({
  TextInput: react_native__WEBPACK_IMPORTED_MODULE_1__.TextInput
});
const defaultStyles = {
  size: "$true",
  fontFamily: "$body",
  borderWidth: 1,
  outlineWidth: 0,
  color: "$color",
  focusable: true,
  borderColor: "$borderColor",
  backgroundColor: "$background",
  placeholderTextColor: "$placeholderColor",
  // this fixes a flex bug where it overflows container
  minWidth: 0,
  hoverStyle: {
    borderColor: "$borderColorHover"
  },
  focusStyle: {
    outlineColor: "$borderColorFocus",
    outlineWidth: 2,
    outlineStyle: "solid",
    borderColor: "$borderColorFocus"
  }
};
const InputFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_2__.styled)(
  react_native__WEBPACK_IMPORTED_MODULE_1__.TextInput,
  {
    name: "Input",
    variants: {
      unstyled: {
        false: defaultStyles
      },
      size: {
        "...size": _helpers_inputHelpers__WEBPACK_IMPORTED_MODULE_3__.inputSizeVariant
      }
    },
    defaultVariants: {
      unstyled: false
    }
  },
  {
    isInput: true
  }
);
const Input = (0,_tamagui_focusable__WEBPACK_IMPORTED_MODULE_4__.focusableInputHOC)(InputFrame);

//# sourceMappingURL=Input.mjs.map


/***/ }),

/***/ "../../node_modules/tamagui/dist/esm/views/Layouts.mjs":
/*!*************************************************************!*\
  !*** ../../node_modules/tamagui/dist/esm/views/Layouts.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Article": () => (/* binding */ Article),
/* harmony export */   "Aside": () => (/* binding */ Aside),
/* harmony export */   "Footer": () => (/* binding */ Footer),
/* harmony export */   "Header": () => (/* binding */ Header),
/* harmony export */   "Main": () => (/* binding */ Main),
/* harmony export */   "Nav": () => (/* binding */ Nav),
/* harmony export */   "Section": () => (/* binding */ Section)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/core/dist/esm/index.mjs");

const Section = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.Stack, {
  name: "Section",
  tag: "section",
  flexDirection: "column",
  accessibilityRole: "summary"
});
const Article = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.Stack, {
  name: "Article",
  tag: "article",
  flexDirection: "column"
});
const Main = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.Stack, {
  name: "Main",
  tag: "main",
  flexDirection: "column"
});
const Header = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.Stack, {
  name: "Header",
  tag: "header",
  accessibilityRole: "header",
  flexDirection: "column"
});
const Aside = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.Stack, {
  name: "Aside",
  tag: "aside",
  flexDirection: "column"
  // accessibilityRole: 'complementary',
});
const Footer = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.Stack, {
  name: "Footer",
  tag: "footer",
  flexDirection: "column"
  // accessibilityRole: 'contentinfo',
});
const Nav = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.styled)(_tamagui_core__WEBPACK_IMPORTED_MODULE_1__.Stack, {
  name: "Nav",
  tag: "nav",
  flexDirection: "column"
  // accessibilityRole: 'navigation',
});

//# sourceMappingURL=Layouts.mjs.map


/***/ }),

/***/ "../../node_modules/tamagui/dist/esm/views/Spinner.mjs":
/*!*************************************************************!*\
  !*** ../../node_modules/tamagui/dist/esm/views/Spinner.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Spinner": () => (/* binding */ Spinner)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/helpers/themeable.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/hooks/useTheme.js");
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/createVariable.js");
/* harmony import */ var _tamagui_stacks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tamagui/stacks */ "../../node_modules/@tamagui/stacks/dist/esm/Stacks.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-native */ "../../node_modules/react-native-web/dist/index.js");





const Spinner = _tamagui_stacks__WEBPACK_IMPORTED_MODULE_2__.YStack.extractable(
  (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_3__.themeable)(
    react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, ref) => {
      const { size, color: colorProp, ...stackProps } = props;
      const theme = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_4__.useTheme)();
      let color = colorProp;
      if (color && color[0] === "$") {
        color = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_5__.variableToString)(theme[color]);
      }
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tamagui_stacks__WEBPACK_IMPORTED_MODULE_2__.YStack, { ref, ...stackProps, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_native__WEBPACK_IMPORTED_MODULE_6__.ActivityIndicator, { size, color }) });
    }),
    {
      componentName: "Spinner"
    }
  )
);

//# sourceMappingURL=Spinner.mjs.map


/***/ }),

/***/ "../../node_modules/tamagui/dist/esm/views/TextArea.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/tamagui/dist/esm/views/TextArea.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextArea": () => (/* binding */ TextArea),
/* harmony export */   "TextAreaFrame": () => (/* binding */ TextAreaFrame)
/* harmony export */ });
/* harmony import */ var _tamagui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tamagui/core */ "../../node_modules/@tamagui/web/dist/esm/styled.js");
/* harmony import */ var _tamagui_focusable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tamagui/focusable */ "../../node_modules/@tamagui/focusable/dist/esm/focusableInputHOC.mjs");
/* harmony import */ var _helpers_inputHelpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/inputHelpers */ "../../node_modules/tamagui/dist/esm/helpers/inputHelpers.mjs");
/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Input */ "../../node_modules/tamagui/dist/esm/views/Input.mjs");




const TextAreaFrame = (0,_tamagui_core__WEBPACK_IMPORTED_MODULE_0__.styled)(_Input__WEBPACK_IMPORTED_MODULE_1__.InputFrame, {
  name: "TextArea",
  multiline: true,
  variants: {
    unstyled: {
      false: {
        ..._Input__WEBPACK_IMPORTED_MODULE_1__.defaultStyles,
        height: "auto",
        numberOfLines: 4
      }
    },
    size: {
      "...size": _helpers_inputHelpers__WEBPACK_IMPORTED_MODULE_2__.textAreaSizeVariant
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const TextArea = (0,_tamagui_focusable__WEBPACK_IMPORTED_MODULE_3__.focusableInputHOC)(TextAreaFrame);

//# sourceMappingURL=TextArea.mjs.map


/***/ }),

/***/ "../../node_modules/tslib/tslib.es6.js":
/*!*********************************************!*\
  !*** ../../node_modules/tslib/tslib.es6.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   "__classPrivateFieldIn": () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArray": () => (/* binding */ __spreadArray),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__values": () => (/* binding */ __values)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}


/***/ }),

/***/ "../../node_modules/use-callback-ref/dist/es2015/assignRef.js":
/*!********************************************************************!*\
  !*** ../../node_modules/use-callback-ref/dist/es2015/assignRef.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assignRef": () => (/* binding */ assignRef)
/* harmony export */ });
/**
 * Assigns a value for a given ref, no matter of the ref format
 * @param {RefObject} ref - a callback function or ref object
 * @param value - a new value
 *
 * @see https://github.com/theKashey/use-callback-ref#assignref
 * @example
 * const refObject = useRef();
 * const refFn = (ref) => {....}
 *
 * assignRef(refObject, "refValue");
 * assignRef(refFn, "refValue");
 */
function assignRef(ref, value) {
    if (typeof ref === 'function') {
        ref(value);
    }
    else if (ref) {
        ref.current = value;
    }
    return ref;
}


/***/ }),

/***/ "../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useMergeRefs": () => (/* binding */ useMergeRefs)
/* harmony export */ });
/* harmony import */ var _assignRef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assignRef */ "../../node_modules/use-callback-ref/dist/es2015/assignRef.js");
/* harmony import */ var _useRef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useRef */ "../../node_modules/use-callback-ref/dist/es2015/useRef.js");


/**
 * Merges two or more refs together providing a single interface to set their value
 * @param {RefObject|Ref} refs
 * @returns {MutableRefObject} - a new ref, which translates all changes to {refs}
 *
 * @see {@link mergeRefs} a version without buit-in memoization
 * @see https://github.com/theKashey/use-callback-ref#usemergerefs
 * @example
 * const Component = React.forwardRef((props, ref) => {
 *   const ownRef = useRef();
 *   const domRef = useMergeRefs([ref, ownRef]); // 👈 merge together
 *   return <div ref={domRef}>...</div>
 * }
 */
function useMergeRefs(refs, defaultValue) {
    return (0,_useRef__WEBPACK_IMPORTED_MODULE_0__.useCallbackRef)(defaultValue || null, function (newValue) { return refs.forEach(function (ref) { return (0,_assignRef__WEBPACK_IMPORTED_MODULE_1__.assignRef)(ref, newValue); }); });
}


/***/ }),

/***/ "../../node_modules/use-callback-ref/dist/es2015/useRef.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/use-callback-ref/dist/es2015/useRef.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useCallbackRef": () => (/* binding */ useCallbackRef)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

/**
 * creates a MutableRef with ref change callback
 * @param initialValue - initial ref value
 * @param {Function} callback - a callback to run when value changes
 *
 * @example
 * const ref = useCallbackRef(0, (newValue, oldValue) => console.log(oldValue, '->', newValue);
 * ref.current = 1;
 * // prints 0 -> 1
 *
 * @see https://reactjs.org/docs/hooks-reference.html#useref
 * @see https://github.com/theKashey/use-callback-ref#usecallbackref---to-replace-reactuseref
 * @returns {MutableRefObject}
 */
function useCallbackRef(initialValue, callback) {
    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () { return ({
        // value
        value: initialValue,
        // last callback
        callback: callback,
        // "memoized" public interface
        facade: {
            get current() {
                return ref.value;
            },
            set current(value) {
                var last = ref.value;
                if (last !== value) {
                    ref.value = value;
                    ref.callback(value, last);
                }
            },
        },
    }); })[0];
    // update callback
    ref.callback = callback;
    return ref.facade;
}


/***/ }),

/***/ "../../node_modules/use-sidecar/dist/es2015/exports.js":
/*!*************************************************************!*\
  !*** ../../node_modules/use-sidecar/dist/es2015/exports.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "exportSidecar": () => (/* binding */ exportSidecar)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


var SideCar = function (_a) {
    var sideCar = _a.sideCar, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__rest)(_a, ["sideCar"]);
    if (!sideCar) {
        throw new Error('Sidecar: please provide `sideCar` property to import the right car');
    }
    var Target = sideCar.read();
    if (!Target) {
        throw new Error('Sidecar medium not found');
    }
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Target, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
    medium.useMedium(exported);
    return SideCar;
}


/***/ }),

/***/ "../../node_modules/use-sidecar/dist/es2015/medium.js":
/*!************************************************************!*\
  !*** ../../node_modules/use-sidecar/dist/es2015/medium.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createMedium": () => (/* binding */ createMedium),
/* harmony export */   "createSidecarMedium": () => (/* binding */ createSidecarMedium)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.js");

function ItoI(a) {
    return a;
}
function innerCreateMedium(defaults, middleware) {
    if (middleware === void 0) { middleware = ItoI; }
    var buffer = [];
    var assigned = false;
    var medium = {
        read: function () {
            if (assigned) {
                throw new Error('Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.');
            }
            if (buffer.length) {
                return buffer[buffer.length - 1];
            }
            return defaults;
        },
        useMedium: function (data) {
            var item = middleware(data, assigned);
            buffer.push(item);
            return function () {
                buffer = buffer.filter(function (x) { return x !== item; });
            };
        },
        assignSyncMedium: function (cb) {
            assigned = true;
            while (buffer.length) {
                var cbs = buffer;
                buffer = [];
                cbs.forEach(cb);
            }
            buffer = {
                push: function (x) { return cb(x); },
                filter: function () { return buffer; },
            };
        },
        assignMedium: function (cb) {
            assigned = true;
            var pendingQueue = [];
            if (buffer.length) {
                var cbs = buffer;
                buffer = [];
                cbs.forEach(cb);
                pendingQueue = buffer;
            }
            var executeQueue = function () {
                var cbs = pendingQueue;
                pendingQueue = [];
                cbs.forEach(cb);
            };
            var cycle = function () { return Promise.resolve().then(executeQueue); };
            cycle();
            buffer = {
                push: function (x) {
                    pendingQueue.push(x);
                    cycle();
                },
                filter: function (filter) {
                    pendingQueue = pendingQueue.filter(filter);
                    return buffer;
                },
            };
        },
    };
    return medium;
}
function createMedium(defaults, middleware) {
    if (middleware === void 0) { middleware = ItoI; }
    return innerCreateMedium(defaults, middleware);
}
// eslint-disable-next-line @typescript-eslint/ban-types
function createSidecarMedium(options) {
    if (options === void 0) { options = {}; }
    var medium = innerCreateMedium(null);
    medium.options = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({ async: true, ssr: false }, options);
    return medium;
}


/***/ }),

/***/ "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {

          'use strict';

/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
if (
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===
    'function'
) {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
}
          var React = __webpack_require__(/*! react */ "../../node_modules/react/index.js");

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      printWarning('error', format, args);
    }
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    } // eslint-disable-next-line react-internal/safe-string-coercion


    var argsWithFormat = args.map(function (item) {
      return String(item);
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

var objectIs = typeof Object.is === 'function' ? Object.is : is;

// dispatch for CommonJS interop named imports.

var useState = React.useState,
    useEffect = React.useEffect,
    useLayoutEffect = React.useLayoutEffect,
    useDebugValue = React.useDebugValue;
var didWarnOld18Alpha = false;
var didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works
// because of a very particular set of implementation details and assumptions
// -- change any one of them and it will break. The most important assumption
// is that updates are always synchronous, because concurrent rendering is
// only available in versions of React that also have a built-in
// useSyncExternalStore API. And we only use this shim when the built-in API
// does not exist.
//
// Do not assume that the clever hacks used by this hook also work in general.
// The point of this shim is to replace the need for hacks by other libraries.

function useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of
// React do not expose a way to check if we're hydrating. So users of the shim
// will need to track that themselves and return the correct value
// from `getSnapshot`.
getServerSnapshot) {
  {
    if (!didWarnOld18Alpha) {
      if (React.startTransition !== undefined) {
        didWarnOld18Alpha = true;

        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');
      }
    }
  } // Read the current snapshot from the store on every render. Again, this
  // breaks the rules of React, and only works here because of specific
  // implementation details, most importantly that updates are
  // always synchronous.


  var value = getSnapshot();

  {
    if (!didWarnUncachedGetSnapshot) {
      var cachedValue = getSnapshot();

      if (!objectIs(value, cachedValue)) {
        error('The result of getSnapshot should be cached to avoid an infinite loop');

        didWarnUncachedGetSnapshot = true;
      }
    }
  } // Because updates are synchronous, we don't queue them. Instead we force a
  // re-render whenever the subscribed state changes by updating an some
  // arbitrary useState hook. Then, during render, we call getSnapshot to read
  // the current value.
  //
  // Because we don't actually use the state returned by the useState hook, we
  // can save a bit of memory by storing other stuff in that slot.
  //
  // To implement the early bailout, we need to track some things on a mutable
  // object. Usually, we would put that in a useRef hook, but we can stash it in
  // our useState hook instead.
  //
  // To force a re-render, we call forceUpdate({inst}). That works because the
  // new object always fails an equality check.


  var _useState = useState({
    inst: {
      value: value,
      getSnapshot: getSnapshot
    }
  }),
      inst = _useState[0].inst,
      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated
  // in the layout phase so we can access it during the tearing check that
  // happens on subscribe.


  useLayoutEffect(function () {
    inst.value = value;
    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the
    // commit phase if there was an interleaved mutation. In concurrent mode
    // this can happen all the time, but even in synchronous mode, an earlier
    // effect may have mutated the store.

    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({
        inst: inst
      });
    }
  }, [subscribe, value, getSnapshot]);
  useEffect(function () {
    // Check for changes right before subscribing. Subsequent changes will be
    // detected in the subscription handler.
    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({
        inst: inst
      });
    }

    var handleStoreChange = function () {
      // TODO: Because there is no cross-renderer API for batching updates, it's
      // up to the consumer of this library to wrap their subscription event
      // with unstable_batchedUpdates. Should we try to detect when this isn't
      // the case and print a warning in development?
      // The store changed. Check if the snapshot changed since the last time we
      // read from the store.
      if (checkIfSnapshotChanged(inst)) {
        // Force a re-render.
        forceUpdate({
          inst: inst
        });
      }
    }; // Subscribe to the store and return a clean-up function.


    return subscribe(handleStoreChange);
  }, [subscribe]);
  useDebugValue(value);
  return value;
}

function checkIfSnapshotChanged(inst) {
  var latestGetSnapshot = inst.getSnapshot;
  var prevValue = inst.value;

  try {
    var nextValue = latestGetSnapshot();
    return !objectIs(prevValue, nextValue);
  } catch (error) {
    return true;
  }
}

function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
  // Note: The shim does not use getServerSnapshot, because pre-18 versions of
  // React do not expose a way to check if we're hydrating. So users of the shim
  // will need to track that themselves and return the correct value
  // from `getSnapshot`.
  return getSnapshot();
}

var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');

var isServerEnvironment = !canUseDOM;

var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
var useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;

exports.useSyncExternalStore = useSyncExternalStore$2;
          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
if (
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===
    'function'
) {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
}
        
  })();
}


/***/ }),

/***/ "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {

          'use strict';

/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
if (
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===
    'function'
) {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
}
          var React = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
var shim = __webpack_require__(/*! use-sync-external-store/shim */ "../../node_modules/use-sync-external-store/shim/index.js");

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

var objectIs = typeof Object.is === 'function' ? Object.is : is;

var useSyncExternalStore = shim.useSyncExternalStore;

// for CommonJS interop.

var useRef = React.useRef,
    useEffect = React.useEffect,
    useMemo = React.useMemo,
    useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.

function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
  // Use this to track the rendered snapshot.
  var instRef = useRef(null);
  var inst;

  if (instRef.current === null) {
    inst = {
      hasValue: false,
      value: null
    };
    instRef.current = inst;
  } else {
    inst = instRef.current;
  }

  var _useMemo = useMemo(function () {
    // Track the memoized state using closure variables that are local to this
    // memoized instance of a getSnapshot function. Intentionally not using a
    // useRef hook, because that state would be shared across all concurrent
    // copies of the hook/component.
    var hasMemo = false;
    var memoizedSnapshot;
    var memoizedSelection;

    var memoizedSelector = function (nextSnapshot) {
      if (!hasMemo) {
        // The first time the hook is called, there is no memoized result.
        hasMemo = true;
        memoizedSnapshot = nextSnapshot;

        var _nextSelection = selector(nextSnapshot);

        if (isEqual !== undefined) {
          // Even if the selector has changed, the currently rendered selection
          // may be equal to the new selection. We should attempt to reuse the
          // current value if possible, to preserve downstream memoizations.
          if (inst.hasValue) {
            var currentSelection = inst.value;

            if (isEqual(currentSelection, _nextSelection)) {
              memoizedSelection = currentSelection;
              return currentSelection;
            }
          }
        }

        memoizedSelection = _nextSelection;
        return _nextSelection;
      } // We may be able to reuse the previous invocation's result.


      // We may be able to reuse the previous invocation's result.
      var prevSnapshot = memoizedSnapshot;
      var prevSelection = memoizedSelection;

      if (objectIs(prevSnapshot, nextSnapshot)) {
        // The snapshot is the same as last time. Reuse the previous selection.
        return prevSelection;
      } // The snapshot has changed, so we need to compute a new selection.


      // The snapshot has changed, so we need to compute a new selection.
      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data
      // has changed. If it hasn't, return the previous selection. That signals
      // to React that the selections are conceptually equal, and we can bail
      // out of rendering.

      // If a custom isEqual function is provided, use that to check if the data
      // has changed. If it hasn't, return the previous selection. That signals
      // to React that the selections are conceptually equal, and we can bail
      // out of rendering.
      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {
        return prevSelection;
      }

      memoizedSnapshot = nextSnapshot;
      memoizedSelection = nextSelection;
      return nextSelection;
    }; // Assigning this to a constant so that Flow knows it can't change.


    // Assigning this to a constant so that Flow knows it can't change.
    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;

    var getSnapshotWithSelector = function () {
      return memoizedSelector(getSnapshot());
    };

    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {
      return memoizedSelector(maybeGetServerSnapshot());
    };
    return [getSnapshotWithSelector, getServerSnapshotWithSelector];
  }, [getSnapshot, getServerSnapshot, selector, isEqual]),
      getSelection = _useMemo[0],
      getServerSelection = _useMemo[1];

  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
  useEffect(function () {
    inst.hasValue = true;
    inst.value = value;
  }, [value]);
  useDebugValue(value);
  return value;
}

exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
if (
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===
    'function'
) {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
}
        
  })();
}


/***/ }),

/***/ "../../node_modules/use-sync-external-store/shim/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/use-sync-external-store/shim/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js");
}


/***/ }),

/***/ "../../node_modules/use-sync-external-store/shim/with-selector.js":
/*!************************************************************************!*\
  !*** ../../node_modules/use-sync-external-store/shim/with-selector.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim/with-selector.development.js */ "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js");
}


/***/ }),

/***/ "../../node_modules/zustand/esm/index.mjs":
/*!************************************************!*\
  !*** ../../node_modules/zustand/esm/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "createStore": () => (/* reexport safe */ zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__.createStore),
/* harmony export */   "default": () => (/* binding */ react),
/* harmony export */   "useStore": () => (/* binding */ useStore)
/* harmony export */ });
/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand/vanilla */ "../../node_modules/zustand/esm/vanilla.mjs");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ "../../node_modules/use-sync-external-store/shim/with-selector.js");





const { useSyncExternalStoreWithSelector } = use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__;
function useStore(api, selector = api.getState, equalityFn) {
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getState,
    selector,
    equalityFn
  );
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue)(slice);
  return slice;
}
const createImpl = (createState) => {
  if ( true && typeof createState !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api = typeof createState === "function" ? (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__.createStore)(createState) : createState;
  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = (createState) => createState ? createImpl(createState) : createImpl;
var react = (createState) => {
  if (true) {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`."
    );
  }
  return create(createState);
};




/***/ }),

/***/ "../../node_modules/zustand/esm/vanilla.mjs":
/*!**************************************************!*\
  !*** ../../node_modules/zustand/esm/vanilla.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStore": () => (/* binding */ createStore),
/* harmony export */   "default": () => (/* binding */ vanilla)
/* harmony export */ });
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if (true) {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, subscribe, destroy };
  state = createState(setState, getState, api);
  return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
var vanilla = (createState) => {
  if (true) {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'."
    );
  }
  return createStore(createState);
};




/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_tamagui_lucide-icons_dist_esm_themed_mjs-node_modules_react-native-svg_l-609481.iframe.bundle.js.map